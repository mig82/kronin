//app.js file
//FP Appended KAnnotationsPopup.js-----------------------------------------------------------

	var project_params = null;
	var annotationDataPREVIEW = null;
	var doEdit = false;
	var editSelectedItem = null;
	var currIndices = {};
	var coords = [];
	var rowreset = false;
	var swipedIndices = {};
	var animationObj;
	/*
	* project details params [project_guid, channel etc.].
	*/	
	var __projectDetailsParams = function(ann_id){
		
		var proj_details = kony.ds.read("kv_project");
		var params = {};
		if(proj_details != null && proj_details.length > 0)
		{
			params.proj_guid = proj_details[0]["project_guid"];
            params.acc_guid = proj_details[0]["account_guid"];
			params.annotation_id = ann_id;
            params.widget_id = ann_id;
			params.channel = proj_details[0]["channel"];
		}
		kony.print("@@@project_params: "+JSON.stringify(params));
		
		return params;
	}

	/*
	* active comments data for segment.
	*/
	var segmentData = function(annotationData){
		
		kony.print("Inside segmentData method");
		var seg_data = [];
        var widgetId = project_params.widget_id;
		if(annotationData == null || annotationData["comments"][widgetId] == null) return seg_data;
        
		for(var key in annotationData["comments"][widgetId])
		{
            var comments = annotationData["comments"][widgetId];
			kony.print("Inside for loop:"+JSON.stringify(comments));

		if(comments[key]['active'] == 1)
			{
                var lmt = comments[key].lastModifiedTime;
                lmt = new Date(lmt);
               // var days = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];
                var months = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
                var dn = "AM";
                var hour = lmt.getHours();
                var minutes = lmt.getMinutes();
                if(hour > 12){
                    hour = hour - 12;
                    dn = "PM";
                }
                if(hour == 0){
                    hour = 12;
                }
                if(minutes <= 9){
                    minutes = "0"+minutes;
                }
                var dateString = months[lmt.getMonth()] + " " + lmt.getDate() + ", " + hour + ":"+ minutes + " " + dn;
                comments[key].formattedlmt = dateString;
				seg_data.push(comments[key]);
			}
		}
		function compare(a,b) {
          if (a.lastModifiedTime < b.lastModifiedTime)
             return -1;
          if (a.lastModifiedTime > b.lastModifiedTime)
            return 1;
          return 0;
        }
		
		kony.print("Inside segment method before sorting:"+JSON.stringify(seg_data));
		seg_data.sort(function(a,b){return new Date(b.lastModifiedTime) - new Date(a.lastModifiedTime)});
		kony.print("Inside segment method after sorting:"+JSON.stringify(seg_data));
        //seg_data.sort(compare);
		return seg_data;
	}
	
	/*
	*  set segment data for popupBottomPreview.
	*/
	var setSegmentData_popupBottomPreview = function(data){
		
		annotationDataPREVIEW = data;
		var annLength = data.length;
		currentfrmFP = kony.application.getCurrentForm();
		
        var kvsession = kony.ds.read("kvsession")[0];
        var userDetails = kvsession['userDetails'];
		var key;
        
		if((data == null) || data.length == 0) {
			
			if(currentfrmFP.segPopupPreview) {
				currentfrmFP.segPopupPreview.isVisible = false;
			}
			if(currentfrmFP.lblNoNotes) {
				currentfrmFP.lblNoNotes.setVisibility(true);
			}
			
		}
		else {
			if(currentfrmFP.lblNoNotes) {
				currentfrmFP.lblNoNotes.setVisibility(false);
			}
			if(currentfrmFP.segPopupPreview){
				currentfrmFP.segPopupPreview.setData(data);
				currentfrmFP.segPopupPreview.setVisibility(true);
			}
		}		
	}
    
	/*
	*  read annotation from DataStore
	*/	
	var __annotationData = function(){
        
		var annotations = fpas.readAnnotationFromDataStore(project_params);
		kony.print("@@@@annotationData: "+JSON.stringify(annotations));
		
		return segmentData(annotations);
	}

	var __showPopupWidBottomContext = function(){
            var segment_data = __annotationData();
			setSegmentData_popupBottomPreview(segment_data);
	}
    
    var __refreshSegmentData = function(){
            var segment_data = __annotationData();
			setSegmentData_popupBottomPreview(segment_data);
	}
	
	
	function txtAreaCallback() {
	}
		
	/*
	* Add & appends new notes in popup [call addOrAppendAnnotation function] 
	*/
	var __addAppendCommentFP = function(){
		
		kony.print("Inside text area done");
		var currentfrmFP = kony.application.getCurrentForm();
		var platformName = (kony.os.deviceInfo().name).toLowerCase();		
			
		if(platformName == "Android") {
			currentfrmFP.windowSoftInputMode = constants.FORM_ADJUST_PAN;
		}
		
		doEdit = false;
		var annotation = {};
		var comment = currentfrmFP.txtAreaNotesAV.text && currentfrmFP.txtAreaNotesAV.text.trim();
		if(comment == null || comment == "") return;
		annotation.comment = comment;
		fpas.addOrAppendAnnotationTODS(project_params, annotation, function(result){
						if(result['status'] == 400)
						{
							kony.print("@@@@@@result['data']: "+JSON.stringify(result['data']));
							var seg_data = segmentData(result['data']);
							
							 kony.print("SEG DATA :" + JSON.stringify(seg_data));
							setSegmentData_popupBottomPreview(seg_data);
							currentfrmFP.txtAreaNotesAV.text = "";
                           // setSegmentData_popupTopPreview(seg_data);
							syncWithCloudDBUtil(function(res){
                                             if(res.status == 200){
                                                 kony.print("Successfully synced with DB.");
                                                __refreshSegmentData();
                                             }
                                            });
                            //currentfrmFP.txtAreaNotesAV.text = null;
						}else 
						kony.print("Error: "+result['err']);
					});
				
	}
	
	function getTransAnimDefinition(leftVal) {
	try{
     	var transAnimDef1 = {
        	"100": {
            	"left": leftVal
        	}
    	};
    	var transAnimDefObject = kony.ui.createAnimation(transAnimDef1);

    	return {
        	definition: transAnimDefObject,
        	config: {
            	"duration": 1,
            	"iterationCount": 1,
            	"delay": 0,
            	"fillMode": kony.anim.FILL_MODE_FORWARDS
        	}
    	};
	} 
  	catch(err){
      	kony.print("CATCH: getTransAnimDefinition "+err);
    }
}

function panGestureHandler(commonWidget, gestureInfo, context) {
	try{
      	var secIndex = context["sectionIndex"];
       	var rowIndex = context["rowIndex"];
       	var panRowList = [{ sectionIndex: secIndex, rowIndex: rowIndex }];
       	var segInfo = context["widgetInfo"];
       	var segName = context["widgetInfo"]["id"];
       	currIndices["secIndex"] = context["sectionIndex"];
       	currIndices["rowIndex"] = context["rowIndex"];
       	var diff = 0;
       	var leftVal1 = 0;
       	var diffConst,animConst;
		var platformName = (kony.os.deviceInfo().name).toLowerCase();
       	leftVal1 = (parseInt(gestureInfo.translationX));
        coords.push(leftVal1);       
        if (gestureInfo.gestureState == 3) {
            kony.print("coords" + JSON.stringify(coords));
            diff = ((coords.length == 1) ? coords[0] : coords[coords.length - 1] - coords[0]);
            if(segName == "segPopupPreview" ){
              diffConst = -256
              if(/^(androidtab||windows)$/.test(platformName)){
                 animConst = "-21%"
               }
              else
             	animConst = "-10%"
            }
            else{
              diffConst = -140
              animConst = "-18.5%"
            }
            if (diff > diffConst ) {
                animationObj = getTransAnimDefinition("0%");
                coords = [];
                segInfo.animateRows({
                    rows: [{
                        sectionIndex: context["sectionIndex"],
                        rowIndex: context["rowIndex"]
                    }],
                    widgets: ["flxMainTemplate"],
                    animation: animationObj
                });
            } else {
				if( swipedIndices["rowIndex"] == context["rowIndex"]&& swipedIndices["secIndex"] == context["sectionIndex"]){
				 swipedIndices={};
				}
				else{
                swipedIndices["rowIndex"] = context["rowIndex"];
                swipedIndices["secIndex"] = context["sectionIndex"];
				}
                animationObj = getTransAnimDefinition(animConst);
                segInfo.animateRows({
                    rows: [{
                        sectionIndex: context["sectionIndex"],
                        rowIndex: context["rowIndex"]
                    }],
                    widgets: ["flxMainTemplate"],
                    animation: animationObj
                });
				
            }

        } else if (gestureInfo.gestureState == 2) {

            animationObj = getTransAnimDefinition(leftVal1 + "px");
            segInfo.animateRows({
                rows: [{
                    sectionIndex: context["sectionIndex"],
                    rowIndex: context["rowIndex"]
                }],
                widgets: ["flxMainTemplate"],
                animation: animationObj
            });

        }
	} 
  	catch(err){
      	kony.print("CATCH: panGestureHandler "+err);
    }
} 
		
/** 

Below method is used to handle the delete on swipe in segment.

**/

function delete_callback(seguiWidget, section, row)
{
	try{
	var segData = currentfrmFP.segPopupPreview.data;
	var selectedItem =[];
	selectedItem.push(segData[row]);
    __deleteCommentFP(selectedItem);

    }
   catch(err){

      kony.print("CATCH: delete_callback "+err);

    }
}
	/*
	* delete notes in popup [call addOrAppendAnnotation function] 
	*/
	var __deleteCommentFP = function(selectedItem){
		currentfrmFP = kony.application.getCurrentForm();
	
		if(selectedItem != null && selectedItem.length > 0)
		{
			var comment = selectedItem[0];
            var kvsession = kony.ds.read("kvsession")[0];
            var userDetails = kvsession['userDetails'];
            if(comment.createdById == userDetails['user_guid']){
				
                delete comment.template;
                kony.print("@@@@@comment: "+JSON.stringify(comment));
                fpas.deleteCommentFROMDS(project_params, comment, function(result){
                            if(result['status'] == 400)
                            {
                                var seg_data = segmentData(result['data']);
                                setSegmentData_popupBottomPreview(seg_data);
                                syncWithCloudDBUtil(function(res){
                                                 if(res.status == 200){
                                                     kony.print("Successfully synced with DB.");
                                                     __refreshSegmentData();
                                                 }
                                                });
                            }else kony.print("Error: "+result['err']);
                        });
            }
		}
	}
	
	var syncWithCloudDBUtil = function(callback){
		var segment_data = [];
		fpnotes.updateNotesToRemoteDB(project_params,function(result){
            if(result.status == 200){
                fpnotes.fetchNotesFromRemoteDB(project_params,function (fetchresult){
                    if(fetchresult.status == 200 && fetchresult.data != null){
                        segment_data = segmentData(fetchresult.data);
                    } else {
                        var annotation = fpas.readAnnotationFromDataStore(project_params);
                        segment_data = segmentData(annotation);
                    }
                    setSegmentData_popupBottomPreview(segment_data);
                    //setSegmentData_popupTopPreview(segment_data);
                    callback({status:200});
                });
            } else {
                callback({status:200});
            }
		});
	}
		
	/*
	* Shake Gesture for notes popup
	*/ 
	
	var onShakeFpApp = function (){
	
		var currentfrm = kony.application.getCurrentForm();	
			if(currentfrm.flxMainAV == null) {
				kony.print("Inside if block of onshake app");
			currentfrm.remove(flxMainAV);
			currentfrm.add(flxMainAV);			
			currentfrm.flxMainAV.setVisibility(true);
			currentfrm.flxExitAppAV.setVisibility(true);
			}
			else {
				currentfrm.flxMainAV.setVisibility(true);
			}
                
               if(currentfrm == null || currentfrm == undefined) return;
               if(currentfrm.info == null || currentfrm.info == undefined) return;			
               ann_id = currentfrm.info.kuid;
               project_params = __projectDetailsParams(ann_id);
		
		
		__showPopupWidBottomContext();
		syncWithCloudDBUtil(function(res){
        //no matter whether it is synced with remote or not, status will be 200 and this will be executed
        if(res.status == 200){
        currentfrm.txtAreaNotesAV.text = "";
        __refreshSegmentData();
        }
        });
	}
	
//startup.js file

function apppostappinitFuncPreview() {
		
		addWidgets_flexContainer();
		var flxMainAV1 = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_NONE,
        "clipBounds": true,
        "height": "100%",
        "id": "flxMainAV",
        "isVisible": true,
        "layoutType": kony.flex.FREE_FORM,
        "left": "0dp",
        "skin": "CopyslFbox0e4fbf5879e9d4a",
        "top": "0dp",
        "width": "100%",
        "zIndex": 1
    }, {}, {});
    flxMainAV1.setDefaultUnit(kony.flex.DP);

		popupOptionsPreview = new kony.ui.Popup({
			"id": "popupOptionsPreview",
			"title": null,
			"transparencyBehindThePopup": 100,
			"skin": "notesPopBG",
			"isModal": true,
			"addWidgets": "addWidgetspopupOptionsFPreview"
		}, {
			"padding": [8, 0, 8, 0],
			"containerWeight": 100,
			"containerHeight": 37,
			"containerHeightReference": constants.HEIGHT_BY_DEVICE_REFERENCE,
			"paddingInPixel": false,
			"layoutType": constants.CONTAINER_LAYOUT_BOX
		}, {
			"windowSoftInputMode": constants.POPUP_ADJUST_RESIZE,
			"inTransitionConfig": {
				"animation": 0
			},
			"outTransitionConfig": {
				"animation": 0
			},
			"directChildrenIDs": ["segPopupFPreview"]
		});

    //Registering the 2 finger press gesture event
	var platName = (kony.os.deviceInfo().name).toLowerCase();
	var x = {};
	if ( platName == 'windows' || platName == 'windowsphone') {
		x = {
	        fingers: 1,
	        pressDuration: 1
	    };
	} else {
		x = {
	        fingers: 2,
	        pressDuration: 1
	    };
	}
    try {
        gestureIDForMenuInChildApp = kony.application.setGestureRecognizerForAllForms(3, x, function(widgetRef, gestureInfo) {
		if (kony.os.toNumber(gestureInfo["gestureType"]) == 3 && kony.os.toNumber(gestureInfo["gesturesetUpParams"]["pressDuration"]) == 1) {
				kony.print("gestureInfo : " + JSON.stringify(gestureInfo));
                 onShakeFpApp();
            }
        });
    } catch (err) {
        alert(typeof err);
        alert("error in function callbackSingleTapGesture:" + err.message);
    }
    
    //Registering the 2 finger swipe gesture event
	//Checking for Windows as it does not set the 'swipevelocity' value accurately
	var platName = (kony.os.deviceInfo().name).toLowerCase();
	kony.print("platName : " + platName);
	var y = {};
	if ( platName == 'windows' || platName == 'windowsphone') {
		y = {
		fingers: 2,
        swipedistance: 30
		};
	} else {
		y = {
        fingers: 2,
        swipedistance: 30,
        swipevelocity: 60
		};
	}
	
    try {
        gestureIDForTwoFingerSwipe = kony.application.setGestureRecognizerForAllForms(2, y, function(widgetRef, gestureInfo) {
            if (kony.os.toNumber(gestureInfo["gestureType"]) == 2) {
                if (kony.os.toNumber(gestureInfo["swipeDirection"]) == 2) {
                    kony.accelerometer.unregisterAccelerationEvents(["shake"]);
					kony.application.removeGestureRecognizerForAllForms(gestureIDForMenuInChildApp);
                    kony.application.removeGestureRecognizerForAllForms(gestureIDForTwoFingerSwipe);
                    kony.application.launchApplication(null);
                }
            }
        });
    } catch (err) {
        alert(typeof err);
        alert("error in function callbackSingleTapGesture:" + err.message);
    }

    //Registering the shake gesture event
	var events = {shake:onShakeFpApp};
	kony.accelerometer.registerAccelerationEvents(events);
};

function btnUpArrowCallBack() {
	var currentfrmFP = kony.application.getCurrentForm();
	currentfrmFP.flxNoteAV.top = "15%";
	currentfrmFP.flxExitAppAV.centerY = "17%";
	currentfrmFP.btnDownArrowNoteAV.isVisible = true;
	currentfrmFP.btnUpArrowNoteAV.isVisible = false;
	
	currentfrmFP.flxExitAppAV.isVisible = true;
}

function btnDownArrowCallBack() {
	var currentfrmFP = kony.application.getCurrentForm();
	currentfrmFP.flxNoteAV.top = "62%";
	currentfrmFP.flxExitAppAV.centerY = "61%";
	currentfrmFP.btnDownArrowNoteAV.isVisible = false;
	currentfrmFP.btnUpArrowNoteAV.isVisible = true;
	
	currentfrmFP.flxExitAppAV.isVisible = true;
}

function btnCloseCallBack() {
	var currentfrmFP = kony.application.getCurrentForm();
	currentfrmFP.flxMainAV.isVisible = false;
}	
	
function btnExitAppNotesCallBack() {
	var currentfrmFP = kony.application.getCurrentForm();
	currentfrmFP.flxMainAV.setVisibility(false);
	kony.accelerometer.unregisterAccelerationEvents(["shake"]);
	kony.application.removeGestureRecognizerForAllForms(gestureIDForMenuInChildApp);
    kony.application.removeGestureRecognizerForAllForms(gestureIDForTwoFingerSwipe);
	kony.application.launchApplication(null);
}
//FP Appended KPopupTemplates.js-----------------------------------------------------------
var flxMainAV;
var flxExitAppAV;
var flxExitAppAVNew;
var platformName = (kony.os.deviceInfo().name).toLowerCase();

function addWidgets_flexContainer() {
    flxMainAV = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_NONE,
        "clipBounds": true,
        "height": "100%",
        "id": "flxMainAV",
        "isVisible": true,
		"bounces": false,
		"isModalContainer": true,
		 "blur": {
                "enabled": true,
                 "value": 0
                },
        "layoutType": kony.flex.FREE_FORM,
        "left": "0dp",
        "skin": "sknFlxMainAv",
        "top": "0dp",
        "width": "100%",
        "zIndex": 1
    }, {}, {});
    flxMainAV.setDefaultUnit(kony.flex.DP);
    var flxNoteAV = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_NONE,
        "clipBounds": true,
        "height": "38%",
        "id": "flxNoteAV",
        "isVisible": true,
        "layoutType": kony.flex.FLOW_VERTICAL,
        "left": "0dp",
        "skin": "sknFlxNoteAV",
        "width": "100%",
        "top": "62%",
        "zIndex": 100
    }, {}, {});
    flxNoteAV.setDefaultUnit(kony.flex.DP);
    var flxSCNoteAV = new kony.ui.FlexContainer({
        "bounces": false,
        "clipBounds": true,
        "height": "100%",
        "id": "flxSCNoteAV",
        "isVisible": true,
		"IsModalContainer": true,
        "layoutType": kony.flex.FREE_FORM,
        "left": "0dp",
        "skin": "sknFlxSCNoteAV",
        "bottom": "1%",
        "width": "100%",
        "zIndex": 100
    }, {}, {});
    flxSCNoteAV.setDefaultUnit(kony.flex.DP);
	var flxNoteHeader = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_NONE,
        "clipBounds": true,
        "height": "12%",
        "id": "flxNoteHeader",
        "isVisible": true,
        "layoutType": kony.flex.FREE_FORM,
        "left": "0dp",
        "skin": "sknFlxHeaderBG3D6E92OP11",
        "top": "0dp",
        "width": "100%",
        "zIndex": 10
    }, {}, {});
    flxNoteHeader.setDefaultUnit(kony.flex.DP);
    var lblNoteHdrAV = new kony.ui.Label({
        "centerY": "50%",
        "id": "lblNoteHdrAV",
        "isVisible": true,
        "left": "5%",
        "skin": "sknLblNoteHeader",
        "text": "NOTES",
        "textStyle": {
            "letterSpacing": 0,
            "strikeThrough": false
        },
        "width": kony.flex.USE_PREFFERED_SIZE,
        "height": kony.flex.USE_PREFFERED_SIZE,
        "zIndex": 100
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "textCopyable": false
    });
	
	var right_dp;
	if(platformName == "iphone" || platformName == "android") {
		right_dp = "45dp";
	}
	else {
		right_dp = "55dp";
	}
    var btnNoteCloseAV = new kony.ui.Button({
        "centerY": "50.00%",
        "focusSkin": "sknBtnNoteCloseAV",
        "height": "18dp",
        "id": "btnNoteCloseAV",
        "isVisible": true,
        "onTouchStart": btnCloseCallBack,
        "right": "2.7%",
        "skin": "sknBtnNoteCloseAV",
        "top": "0dp",
        "width": "18dp",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_CENTER,
        "displayText": true,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "showProgressIndicator": true
    });

    var btnUpArrowNoteAV = new kony.ui.Button({
        "centerY": "50%",
        "focusSkin": "sknBtnNotesUPAV",
        "height": "18dp",
        "id": "btnUpArrowNoteAV",
        "isVisible": true,
        "onTouchStart": btnUpArrowCallBack,
        "skin": "sknBtnNotesUPAV",
        "top": "0dp",
        "width": "18dp",
		"right": right_dp,
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_CENTER,
        "displayText": true,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "showProgressIndicator": true
    });
    var btnDownArrowNoteAV = new kony.ui.Button({
        "centerY": "50%",
        "focusSkin": "dynSkinDownAV",
        "height": "16dp",
        "id": "btnDownArrowNoteAV",
        "isVisible": false,
        "onTouchStart": btnDownArrowCallBack,
        "skin": "dynSkinDownAV",
        "top": "0dp",
        "width": "18dp",
		"right": right_dp,
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_CENTER,
        "displayText": true,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "showProgressIndicator": true
    });
    flxNoteHeader.add(lblNoteHdrAV, btnNoteCloseAV, btnUpArrowNoteAV, btnDownArrowNoteAV);
       	
    var richtxtNoteAV = new kony.ui.RichText({
        "id": "richtxtNoteAV",
        "isVisible": true,
        "left": "0%",
        "linkSkin": "defRichTextLink",
        "skin": "SknRchTxt37414BSFPROReg",
        "text": "RichText",
        "top": "10px",
        "width": "100%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [5, 0, 0, 0],
        "paddingInPixel": false,
        "widgetAlignment": constants.WIDGET_ALIGN_CENTER
    }, {
        "wrapping": constants.WIDGET_TEXT_WORD_WRAP
    });
    
    var flxSegNoteAV = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_HEIGHT,
        "clipBounds": true,
        "id": "flxSegNoteAV",
        "isVisible": true,
        "layoutType": kony.flex.FLOW_HORIZONTAL,
        "left": "0%",
        "isModalContainer": false,
        "skin": "slFbox",
        "top": "0dp",
		"bottom": "11px",
        "width": "100%",
        "zIndex": 1
    }, {
        "padding": [0, 0, 0, 0]
    }, {});
    
	var lblSegNoteAV = new kony.ui.Label({
        "id": "lblSegNoteAV",
        "isVisible": true,
        "left": "0%",
        "skin": "sknLblName",
        "text": "Label",
        "textStyle": {},
        "top": "0dp",
        "width": kony.flex.USE_PREFFERED_SIZE,
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [5, 3, 1, 1],
        "paddingInPixel": false,
        "widgetAlignment": constants.WIDGET_ALIGN_CENTER
    }, {
        "textCopyable": false,
        "wrapping": constants.WIDGET_TEXT_WORD_WRAP
    });
	
	flxSegNoteAV.add(lblSegNoteAV);
	
    var lblSegNoteTSAV = new kony.ui.Label({
        "id": "lblSegNoteTSAV",
        "isVisible": true,
        "left": "0%",
        "skin": "sknLblName",
        "text": "Label",
        "textStyle": {},
        "top": "0dp",
        "width": kony.flex.USE_PREFFERED_SIZE,
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [5, 3, 1, 1],
        "paddingInPixel": false,
        "widgetAlignment": constants.WIDGET_ALIGN_CENTER
    }, {
        "textCopyable": false,
        "wrapping": constants.WIDGET_TEXT_WORD_WRAP
    });
    flxSegNoteAV.add(lblSegNoteTSAV);
	
	var flxDeleteFP = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_HEIGHT,
        "clipBounds": true,
        "id": "flxDeleteFP",
        "isVisible": true,
        "layoutType": kony.flex.FLOW_VERTICAL,
        "left": "0dp",
        "isModalContainer": false,
        "onTouchEnd": function(){
			var currentfrmFP = kony.application.getCurrentForm();
			__deleteCommentFP(currentfrmFP.segPopupPreview.selectedRowItems);},
        "skin": "sknFlxLightRedFP",
        "width": "27dp",
		"top": "15dp",
        "zIndex": 5

    }, {}, {});

    flxDeleteFP.setDefaultUnit(kony.flex.DP);

	var flxContent = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_HEIGHT,
        "clipBounds": true,
        "id": "flxContent",
        "isVisible": true,
        "layoutType": kony.flex.FLOW_VERTICAL,
        "left": "0%",
        "isModalContainer": false,
        "skin": "slFbox",
        "top": "0dp",
        "width": "73%",
        "zIndex": 1
    }, {
        "padding": [0, 0, 0, 0]
    }, {});
	
	flxContent.add(richtxtNoteAV,flxSegNoteAV);
	
	 var flxMainTemplate = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_HEIGHT,
        "clipBounds": true,
        "id": "flxMainTemplate",
        "isVisible": true,
        "layoutType": kony.flex.FLOW_HORIZONTAL,
        "left": "0%",
        "isModalContainer": false,
        "skin": "slFbox",
        "top": "0dp",
        "width": "138%",
        "zIndex": 1
    }, {
        "padding": [0, 0, 0, 0]
    }, {});

	
	flxMainTemplate.add(flxContent,flxDeleteFP)
	
	var segTemplateAV = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_HEIGHT,
        "clipBounds": true,
        "id": "segTemplateAV",
        "isVisible": true,
        "layoutType": kony.flex.FREE_FORM,
        "left": "0dp",
        "isModalContainer": false,
        "skin": "slFbox",
        "top": "0dp",
        "width": "100%"
    }, {
        "padding": [0, 0, 0, 0]
    }, {});

	
    segTemplateAV.add(flxMainTemplate);
	
	var btnDeleteFP = new kony.ui.Button({
        "centerX": "50%",
        "focusSkin": "sknBtnWhiteMLFP",
        "height": kony.flex.USE_PREFFERED_SIZE,
        "id": "btnDeleteFP",
        "isVisible": true,
        "skin": "sknBtnWhiteMLFP",
        "text": "Delete",
        "width": "100%",
        "zIndex": 5
    }, {

        "contentAlignment": constants.CONTENT_ALIGN_BOTTOM_CENTER,
        "displayText": false,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {

        "showProgressIndicator": true
    });
	flxDeleteFP.add(btnDeleteFP);


    var segPopupPreview = new kony.ui.SegmentedUI2({
        "autogrowMode": kony.flex.AUTOGROW_NONE,
        "id": "segPopupPreview",
        "height": "50%",
        "width": "90%",
        "centerX": "50%",
        "isVisible": true,
        "retainSelection": false,
        "widgetDataMap": {
            "lblSegNoteAV": "createdBy",
            "lblSegNoteTSAV": "formattedlmt",
            "richtxtNoteAV": "comment"
        },
        "data": [],
        "rowTemplate": segTemplateAV,
        "widgetSkin": "segTrans",
        "rowSkin": "segRowTrans",
        "rowFocusSkin": "segRowTrans",
        "sectionHeaderSkin": "seg2Header",
        "separatorRequired": true,
		"metaInfo":{editMode:constants.SEGUI_EDIT_MODE_DELETE,
					editModeCustomConfig : [{title:"Delete", backgroundColor:"f35a56", callback:delete_callback}]
		},
        "separatorThickness": 1,
        "separatorColor": "788ea91e",
        "showScrollbars": false,
        "groupCells": false,
        "screenLevelWidget": false,
		"editStyle": constants.SEGUI_EDIT_MODE_DELETE,
        "selectionBehavior": constants.SEGUI_DEFAULT_BEHAVIOR,
        "viewType": constants.SEGUI_VIEW_TYPE_TABLEVIEW,
        "top": "16%",
        "zIndex": 1
		
    }, {
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
		"bounces": false,
        "editStyle": constants.SEGUI_EDITING_STYLE_NONE,
        "enableDictionary": false,
        "indicator": constants.SEGUI_NONE,
        "progressIndicatorColor": constants.PROGRESS_INDICATOR_COLOR_WHITE,
        "showProgressIndicator": true
	});
	
	var textArea_width;
	var doneBtn_visible;
	var currentfrmFP = kony.application.getCurrentForm();

	if(platformName == "android") {
		textArea_width = "82%";
		textArea_centerX = "40%";
		flxTextAreaWidth = "90%";
	}
	else {
		textArea_width = "75%";
		textArea_centerX = "42%";
		flxTextAreaWidth = "100%";
	}

	var btnTextAreaDoneAV = new kony.ui.Button({
        "focusSkin": "dynSkinSubmitAV",
        "height": "44dp",
        "id": "btnTextAreaDoneAV",
        "isVisible": true,
        "onClick": __addAppendCommentFP,
        "right": "3%",
        "skin": "dynSkinSubmitAV",
        "text": "",
        "top": "72.20%",
        "width": "44dp",
		"centerY": "50%",
        "zIndex": 100
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_CENTER,
        "displayText": true,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "showProgressIndicator": true
    });

     var txtAreaNotesAV = new kony.ui.TextArea2({
        "autoCapitalize": constants.TEXTAREA_AUTO_CAPITALIZE_NONE,
        "centerX": textArea_centerX,
        "focusSkin": "sknTxtAreaBG788EA9Focus",
        "top": "0.2%",
        "height": constants.PREFERRED,
        "id": "txtAreaNotesAV",
        "isVisible": true,
        "keyBoardStyle": constants.TEXTAREA_KEY_BOARD_STYLE_DEFAULT,
		"onTextChange": txtAreaCallback,
        "placeholder": "Add a note",
        "skin": "sknTxtAreaBG788EA9Normal",
        "textInputMode": constants.TEXTAREA_INPUT_MODE_ANY,
        "bottom": "4%",
        "width": textArea_width,
        "zIndex": 10,
        "onDone": __addAppendCommentFP
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_TOP_LEFT,
        "padding": [2, 2, 2, 2],
        "paddingInPixel": false
    }, {
	
        "inputAccessoryViewType": constants.TEXTAREA_INPUTACCESSORYVIEW_NEXTPREV,
    });	
    
    var lblNoNotes = new kony.ui.Label({
        "centerX": "50%",
        "height": "50%",
        "id": "lblNoNotes",
        "isVisible": false,
        "left": "0dp",
        "skin": "sknLblNoNotes",
        "text": "Collaborate on prototypes  by adding notes to screens",
        "textStyle": {
            "letterSpacing": 0,
            "strikeThrough": false
        },
        "top": "15%",
        "width": "90%",
        "zIndex": 100
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_CENTER,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "textCopyable": false
    });
	
	 var flxTextAreaNotesAV = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_HEIGHT,
        "clipBounds": true,
        "id": "flxTextAreaNotesAV",
        "isVisible": true,
        "layoutType": kony.flex.FREE_FORM,
        "left": "0dp",
		"right": "4%",
		"centerX": "50%",
        "skin": "flxTextAreaSkin",
        "top": "72%",
        "width": flxTextAreaWidth,
		"height": "60dp",
        "zIndex": 100
    }, {
        "padding": [0, 0, 0, 0]
    }, {});
	
    flxTextAreaNotesAV.setDefaultUnit(kony.flex.DP);
	flxTextAreaNotesAV.add(txtAreaNotesAV,btnTextAreaDoneAV);
	
    flxSCNoteAV.add(flxNoteHeader, segPopupPreview,flxTextAreaNotesAV,lblNoNotes);
    flxNoteAV.add(flxSCNoteAV);
    flxExitAppAV = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_NONE,
        "centerX": "50%",
        "centerY": "61%",
		"clipBounds": true,
        "bounces": false,
        "id": "flxExitAppAV",
        "isVisible": true,
        "layoutType": kony.flex.FREE_FORM,
        "width": "100%",
        "zIndex": 1
    }, {}, {});
    flxExitAppAV.setDefaultUnit(kony.flex.DP);
	
	var btnNotesExitAV = new kony.ui.Button({
        "focusSkin": "SknBtnExitApp",
        "height": "20%",
		"centerX": "50%",
        "id": "btnNotesExitAV",
        "isVisible": true,
        "skin": "SknBtnExitApp",
        "text": "EXIT APP",
        "top": "5dp",
        "onClick": btnExitAppNotesCallBack,
        "width": "60%",
        "zIndex": 200
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_CENTER,
        "displayText": true,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "showProgressIndicator": true
    });

	flxExitAppAV.add(btnNotesExitAV);
	flxMainAV.add(flxNoteAV, flxExitAppAV);
	segTemplateAV.addGestureRecognizer(constants.GESTURE_TYPE_PAN, {
            fingers: 1,
            continuousEvents: false
        }, panGestureHandler);
};

//FP Appended KonySyncLib.js-----------------------------------------------------------
// -- SDK File : KonySyncLib.js 
//  --Generated On Mon Apr 15 17:29:18 IST 2019******************* 
//  **************** Start jsonWriter.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
/*
kony.sync.jsonGetType = function(node) {
	sync.log.trace("Entering kony.sync.jsonGetType ");
    if (kony.type(node) === "table") {
        for (var key in node) {
            if ((key === 1)) {
                return 1;
            } else if (key === "1") {
                return 1;
            } else {
                return 2;
            }
        }
        return 1;
    }
    return 0;
};

kony.sync.createJson = function(key, data) {
	sync.log.trace("Entering kony.sync.createJson ");
    kony.sync.jsonBegin();
    kony.sync.jsonWriteKeyValue(key, data);
    kony.sync.jsonEnd();
    return js;
};

kony.sync.jsonWriteKeyValue = function(key, data) {
	sync.log.trace("Entering kony.sync.jsonWriteKeyValue ");
    kony.sync.jsonBeginElement(key);
    kony.sync.jsonWriteValue(data);
};

kony.sync.jsonWriteValue = function(data) {
	sync.log.trace("Entering kony.sync.jsonWriteValue ");
    datatype = kony.sync.jsonGetType(data);
	var len = null;
    if (datatype === 0) {
        kony.sync.jsonString(data);
    } else if (datatype === 1) {
        kony.sync.jsonBeginArray();
        len = kony.sync.jsonwriter_ipairs_length(data);
        var count1 = 0;
		if(!kony.sync.isNullOrUndefined(data)){
			for (var i = 0; i < data.length; i++) {
				var v = data[i];
				count1 = count1 + 1;
				kony.sync.jsonWriteValue(v);
				if ((count1 !== len)) {
					js = js + ",";
				}
			}
		}
        kony.sync.jsonEndArray();
    } else {
        kony.sync.jsonBeginHash();
        len = kony.sync.jsonwriter_pairs_length(data);
        var count2 = 0;
        for (var key in data) {
            var value = data[key];
            count2 = count2 + 1;
            kony.sync.jsonWriteKeyValue(key, value);
            if ((count2 !== len)) {
                js = js + ",";
            }
        }
        kony.sync.jsonEndHash();
    }
};

kony.sync.jsonBegin = function() {
	sync.log.trace("Entering kony.sync.jsonBegin ");
    js = "{";
};

kony.sync.jsonEnd = function() {
	sync.log.trace("Entering kony.sync.jsonEnd ");
    js = js + " }";
};

kony.sync.jsonBeginElement = function(elementName) {
	sync.log.trace("Entering kony.sync.jsonBeginElement ");
    js = js + "\"" + elementName + "\"" + " : ";
};

kony.sync.jsonBeginArray = function() {
	sync.log.trace("Entering kony.sync.jsonBeginArray ");
    js = js + " \[";
};

kony.sync.jsonEndArray = function() {
	sync.log.trace("Entering kony.sync.jsonEndArray ");
    js = js + " \]";
};

kony.sync.jsonBeginHash = function() {
	sync.log.trace("Entering kony.sync.jsonBeginHash ");
    js = js + " \{";
};

kony.sync.jsonEndHash = function() {
	sync.log.trace("Entering kony.sync.jsonEndHash ");
    js = js + " \}";
};

kony.sync.jsonAddValue = function(key, value) {
	sync.log.trace("Entering kony.sync.jsonAddValue ");
    js = js + " \"" + key + "\" : " + "\"" + value + "\"";
};

kony.sync.jsonString = function(value) {
	sync.log.trace("Entering kony.sync.jsonString ");
    if ((value === "null")) {
        js = js + "null";
    } else {
        js = js + "\"" + value + "\"";
    }
};

kony.sync.jsonwriter_pairs_length = function(tab) {
	sync.log.trace("Entering kony.sync.jsonwriter_pairs_length ");
    var count = 0;
    if (!kony.sync.isNullOrUndefined(tab)) {
        for (var key in tab) {
            count = count + 1;
        }
    }
    return count;
};

kony.sync.jsonwriter_ipairs_length = function(tab) {
	sync.log.trace("Entering kony.sync.jsonwriter_ipairs_length ");
    var count = 0;
    if(!kony.sync.isNullOrUndefined(tab)){
        for (var key = 0; key < tab.length; key++) {
            count = count + 1;
        }
    }
    return count;
};
*/
//  **************** End jsonWriter.js*******************
//  **************** Start KonySyncAPI.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
// Device Auto Registration and Validation Starts here --
sync.startSession = function(config) {
    sync.log.trace("Entering sync.startSession ");
    if (kony.sync.validateSyncConfigParams("startSession", config) === false) {
        return;
    }
    if (kony.sync.preProcessSyncConfig("startSession", config, config[kony.sync.onSyncError]) === false) {
        return;
    }
    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncStart], kony.sync.currentSyncReturnParams);
    var registerSuccess = true;
    var alreadyRegistered = false;
    var isError = false;
    //assign the currentSyncBinaryStats to lastSyncBinaryStats.
    kony.sync.reinitializeBinaryStats();

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, [kony.sync.syncConfigurationColumnDeviceIDName]);
        kony.sync.qb_from(query, kony.sync.syncConfigurationTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params, kony.sync.currentSyncConfigParams[kony.sync.onSyncError]);
        if (resultSet === false) {
            registerSuccess = false;
            isError = true;
            return;
        }
        if (resultSet.rows.length === 0) {
            isError = true;
            return;
        }
        var record = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
        sync.log.debug("Device Record: ", record);
        sync.log.debug("Device ID: ", record.DeviceID);
        if (record.DeviceID !== kony.sync.getDeviceID()) {
            kony.sync.konyRegisterDevice(registerDeviceCallback);
            sync.log.info("Registering Device...");
        } else {
            alreadyRegistered = true;
            sync.log.info("Device already registered");
        }
    }

    function registerDeviceCallback(serverResponse) {
        sync.log.trace("Entering registerDeviceCallback");
        if (!kony.sync.isNullOrUndefined(serverResponse.opstatus) && serverResponse.opstatus != 0) {
            if (!kony.sync.isNullOrUndefined(serverResponse.d)) {
                sync.log.error("Register Device Response : ", serverResponse);
                try {
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse.d));
                } catch (e) {
                    sync.log.error("Unknown error occurred during client callbacks in either stop callback or sync error callback", e);
                }
                if (kony.sync.isSyncStopped) {
                    sync.log.debug("sync stopped after device registration failed in function registerDeviceCallback");
                    kony.sync.stopSyncSession();
                    return;
                }
                kony.sync.isSessionInProgress = false;
            } else {
                sync.log.error("Register Device Response : ", serverResponse);
                try {
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse));
                } catch (e) {
                    sync.log.error("Unknown error occurred during client callbacks in either stop callback or sync error callback", e);
                }
                if (kony.sync.isSyncStopped) {
                    sync.log.debug("sync stopped after device registration failed in function registerDeviceCallback");
                    kony.sync.stopSyncSession();
                    return;
                }
                kony.sync.isSessionInProgress = false;
            }
            kony.sync.httprequestsinglesession = false;
            registerSuccess = false;
            return;
        } else if (kony.sync.isNullOrUndefined(serverResponse.d)) {
            registerSuccess = false;
            kony.sync.isSessionInProgress = false;
            kony.sync.httprequestsinglesession = false;
            try {
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse));
            } catch (e) {
                sync.log.error("Unknown error occurred during client callbacks in either stop callback or sync error callback", e);
            }
            if (kony.sync.isSyncStopped) {
                sync.log.debug("sync stopped after device registration failed in function registerDeviceCallback");
                kony.sync.stopSyncSession();
                return;
            }
            return;
        }
        if ((serverResponse.d.error === "true")) {
            sync.log.error("Register Device Response : ", serverResponse);
            try {
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse.d));
            } catch (e) {
                sync.log.error("Unknown error occurred during client callbacks in either stop callback or sync error callback", e);
            }
            if (kony.sync.isSyncStopped) {
                sync.log.debug("sync stopped after device registration failed in function registerDeviceCallback");
                kony.sync.stopSyncSession();
                return;
            }
            kony.sync.isSessionInProgress = false;
            kony.sync.httprequestsinglesession = false;
            registerSuccess = false;
            return;
        }
        sync.log.debug("Register Device Response : ", serverResponse);
        var connection2 = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, kony.sync.currentSyncConfigParams[kony.sync.onSyncError], "Load device id");
        if (connection2 !== null) {
            kony.sync.startTransaction(connection2, single_device_register_callback, single_transaction_success_callback, single_transaction_error_callback, "Load device id");
        }

        function single_device_register_callback(tx) {
            sync.log.trace("Entering single_device_register_callback");
            kony.sync.instanceId = serverResponse.d.__registerdevice.instanceID;
            var insertTab = {};
            insertTab[kony.sync.syncConfigurationColumnInstanceIDName] = kony.sync.instanceId;
            insertTab[kony.sync.syncConfigurationColumnDeviceIDName] = kony.sync.getDeviceID();
            var wcs = {};
            kony.table.insert(wcs, {
                key: kony.sync.syncConfigurationColumnDeviceIDName,
                value: ""
            });
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, kony.sync.syncConfigurationTableName);
            kony.sync.qb_set(query, insertTab);
            kony.sync.qb_where(query, wcs);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                isError = true;
                return;
            }
            alreadyRegistered = true;
            sync.log.info("Register Device success");
        }
    }

    function single_transaction_error_callback() {
        sync.log.trace("Entering single_transaction_error_callback");
        sync.log.error("Register Device failed");
        //kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getSyncRegisterationFailed());
        kony.sync.isSessionInProgress = false;
        kony.sync.httprequestsinglesession = false;
        kony.sync.callTransactionError(isError, kony.sync.currentSyncConfigParams[kony.sync.onSyncError]);
    }

    function single_transaction_success_callback() {
        sync.log.trace("Entering single_transaction_success_callback");
        if (registerSuccess && alreadyRegistered && !isError) {
            //Check if schema upgrade is pending
            if (kony.sync.schemaUpgradeNeeded) {
                kony.sync.upgradeSchema(kony.sync.syncStartSession);
            } else {
                kony.sync.isDownloadPendingForSchemaUpgrade(isDownloadPendingForSchemaUpgradeCallback);
            }
        } else if (isError) {
            sync.log.fatal("SynConfigTable is empty. There seems to be problem in sync.init");
            kony.sync.getErrorTable(kony.sync.errorCodeMetatableError, kony.sync.getErrorMessage(kony.sync.errorCodeMetatableError), null);
        }
    }

    function isDownloadPendingForSchemaUpgradeCallback(isError, errorObject, pending) {
        sync.log.trace("Entering isDownloadPendingForSchemaUpgradeCallback");
        if (isError) {
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], errorObject);
        } else {
            if (pending) {
                kony.sync.omitUpload = true; //only download
                kony.sync.schemaUpgradeDownloadPending = true;
            }
            kony.sync.syncStartSession();
        }
    }
    var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, kony.sync.currentSyncConfigParams[kony.sync.onSyncError], "Device Registration");
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback, "Device Registration");
    }
};
kony.sync.syncStartSession = function() {
    sync.log.trace("Entering kony.sync.syncStartSession ");
    sync.log.info("Calling syncStartSession...");
    kony.sync.isErrorInAnyScope = false;
    kony.sync.syncErrorMessage = {};
    kony.sync.validateScopeSession();
};
kony.sync.validateScopeSession = function(abortSync, syncErrorObject) {
    sync.log.trace("Entering kony.sync.validateScopeSession ");
    //If sync is aborted not because of scope issues
    if (abortSync === true) {
        sync.log.trace("kony.sync.validateScopeSession->abortSync");
        kony.sync.isSessionInProgress = false;
        kony.sync.httprequestsinglesession = false;
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], syncErrorObject);
        return;
    }
    kony.sync.resetscopesessionglobals(callback);

    function callback(isSyncComplete) {
        sync.log.trace("Entering callback");
        var isError = false;
        if (isSyncComplete === true) {
            sync.log.trace("is Sync Complete true...");
            if (typeof(binary) !== "undefined" && typeof(binary.util) !== "undefined") {
                sync.log.trace("notifying the on demand binary thread. after sync start");
                binary.util.notifyToPrepareJobs();
            }
            //var currentSyncConfig = JSON.stringify(kony.sync.currentSyncConfigParams);
            //store the current sync config so that it can be used later.
            //kony.store.setItem(kony.sync.currentSyncConfigKey, currentSyncConfig);
            //sync.log.trace("resetScopeSessionGlobals callback - "+currentSyncConfig);
            if (kony.sync.forceUpload === true) {
                kony.sync.forceUpload = false;
                kony.sync.omitDownload = false;
                kony.sync.validateScopeSession(true, kony.sync.schemaUpgradeErrorObject);
                return;
            }
            if (kony.sync.forceUploadUpgrade === true) {
                kony.sync.forceUploadUpgrade = false;
                kony.sync.omitDownload = false;
                kony.sync.schemaUpgradeErrorObject();
                return;
            }
            if (!kony.sync.isErrorInAnyScope) {
                if (!kony.sync.performOnlySchemaUpgrade) {
                    //Continue upgrade after upload
                    /*				if(kony.sync.schemaUpgradeNeeded){
                    					kony.sync.upgradeSchema(kony.sync.syncStartSession);
                    					return;
                    				}*/
                    //start normal sync process after downloading changes for schema upgrade
                    if (kony.sync.schemaUpgradeDownloadPending) {
                        kony.sync.schemaUpgradeDownloadPending = false;
                        kony.sync.omitUpload = false;
                        kony.sync.omitDownload = false;
                        kony.sync.resetsyncsessionglobals();
                        kony.sync.syncStartSession();
                        return;
                    }
                }
                kony.sync.omitUpload = false;
                kony.sync.omitDownload = false;
                kony.sync.isSessionInProgress = false;
                kony.sync.performOnlySchemaUpgrade = false;
                sync.log.trace("kony.sync.validateScopeSession->calling onSyncSuccess function");
                kony.sync.schemaUpgradeDownloadPending = false;
                while (kony.sync.pendingBinaryDownloadJobs.length !== 0) {
                    var pendingBinaryJob = kony.sync.pendingBinaryDownloadJobs.pop();
                    kony.sync.getBinary(kony.sync.getDBName(), pendingBinaryJob.tableName, pendingBinaryJob.binaryColumn, pendingBinaryJob.primaryKeyTable, null, function(response) {
                        sync.log.trace("kony.sync.validateScopeSession .. binarySuccessCallback  ", response);
                        kony.sync.incrementCompletedJobs(true);
                        kony.sync.invokeBinaryNotifiers(true);
                    }, function(error) {
                        sync.log.trace("kony.sync.validateScopeSession .. binaryErrorCallback  ", error);
                        kony.sync.incrementFailedJobs(true);
                        kony.sync.invokeBinaryNotifiers(true);
                    });
                }
                try {
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncSuccess], kony.sync.currentSyncReturnParams);
                } catch (e) {
                    sync.log.error("Unknown error occurred during client callbacks in either stop callback or sync errpr callback", e);
                }
                if (kony.sync.isSyncStopped) {
                    sync.log.debug("sync stopped after sync sucess in function validateScopeSession");
                    kony.sync.stopSyncSession();
                    return;
                }
            } else {
                sync.log.error("kony.sync.validateScopeSession->calling onSyncError function");
                kony.sync.isSessionInProgress = false;
                try {
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getErrorTable(kony.sync.errorCodeSyncError, kony.sync.getErrorMessage(kony.sync.errorCodeSyncError), kony.sync.syncErrorMessage));
                } catch (e) {
                    sync.log.error("Unknown error occurred during client callbacks in either stop callback or sync errpr callback", e);
                }
                if (kony.sync.isSyncStopped) {
                    sync.log.debug("sync stopped after sync error in function validateScopeSession");
                    kony.sync.stopSyncSession();
                    return;
                }
            }
            kony.sync.httprequestsinglesession = false;
            return; // Sync Completes here.
        }

        function validateTransaction(tx) {
            sync.log.trace("Entering kony.sync.validateScopeSession->validateTransaction");
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_select(query, null);
            kony.sync.qb_from(query, kony.sync.metaTableName);
            kony.sync.qb_where(query, [{
                key: kony.sync.metaTableScopeColumn,
                value: kony.sync.currentScope[kony.sync.scopeName]
            }, {
                key: kony.sync.metaTableFilterValue,
                value: "no filter"
            }]);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            var resultSet = kony.sync.executeSql(tx, sql, params);
            if (resultSet === false) {
                isError = true;
                return;
            }
            if (resultSet.rows.length !== 1) {
                isError = true;
                return;
            }
            if (kony.sync.schemaUpgradeDownloadPending) {
                //check if download is pending after schema upgrade for this scope
                var rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
                if (rowItem[kony.sync.metaTableSchemaUpgradeSyncTimeColumn] === "0,0") {
                    kony.sync.omitDownload = false; //download for this scope
                } else {
                    kony.sync.omitDownload = true; //this scope has already been downloaded
                }
            }
            kony.sync.currentSyncReturnParams.currentScope = kony.sync.currentScope[kony.sync.scopeName];
        }

        function startScopeSession() {
            sync.log.trace("Entering startScopeSession");
            if (isError === true) {
                errorScopeSession();
                return;
            }
            sync.log.trace("Entering kony.sync.validateScopeSession->startScopeSession");
            kony.sync.deleteMapKey(kony.sync.currentSyncReturnParams, kony.sync.serverDetails);
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onScopeStart], kony.sync.currentSyncReturnParams);
            kony.sync.startUpload();
        }

        function errorScopeSession() {
            sync.log.trace("Entering kony.sync.validateScopeSession->errorScopeSession");
            var isbreak = kony.sync.callTransactionError(isError, kony.sync.currentSyncConfigParams[kony.sync.onScopeError]);
            if (isbreak === true) {
                kony.sync.callTransactionError(isError, kony.sync.currentSyncConfigParams[kony.sync.onSyncError]);
                kony.sync.isSessionInProgress = false;
                kony.sync.httprequestsinglesession = false;
                return;
            }
            kony.sync.validateScopeSession();
        }
        var connection = kony.sync.getConnectionOnly(kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.currentScope[kony.sync.scopeDataSource], errorScopeSession, "validate scope session");
        if (connection !== null) {
            kony.sync.startTransaction(connection, validateTransaction, startScopeSession, errorScopeSession, "validate scope session");
        }
    }
};
kony.sync.startUpload = function() {
    sync.log.trace("Entering kony.sync.startUpload ");
    if (kony.sync.omitUpload) {
        kony.sync.uploadCompleted();
        return;
    }
    if (kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks])) {
        kony.sync.syncUploadChanges(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.uploadCompleted);
    } else {
        var scopename = kony.sync.currentScope[kony.sync.scopeName];
        if (kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename] !== null && kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename] !== undefined && kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename][kony.sync.sessionTaskDoUpload]) {
            kony.sync.syncUploadChanges(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.uploadCompleted);
        } else {
            sync.log.info("Skipping Upload for Scope : ", kony.sync.currentScope[kony.sync.scopeName]);
            kony.sync.uploadCompleted();
        }
    }
};
kony.sync.uploadCompleted = function(error, msg) {
    sync.log.trace("Entering kony.sync.uploadCompleted ");
    if (kony.sync.isSyncStopped) {
        sync.log.debug("sync stopped in uploadCompleted");
        kony.sync.stopSyncSession();
        return;
    }
    if (error === true) {
        sync.log.error("Error Occurred during upload : ", msg);
        //if schema change error occurred - app is not latest one
        if (msg.errorCode === kony.sync.servercodes.appVersionNotLatest) {
            kony.sync.onSchemaUpgradeErrorFromServer(msg);
            return;
        }
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onScopeError], msg);
        kony.sync.isErrorInAnyScope = true;
        kony.sync.syncErrorMessage[kony.sync.currentScope[kony.sync.scopeName]] = msg;
        kony.sync.validateScopeSession();
    } else {
        if (kony.sync.omitDownload) { //In case download is force disabled
            kony.sync.validateScopeSession();
            return;
        }
        if (kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks]) || kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][kony.sync.currentScope[kony.sync.scopeName]])) {
            kony.sync.syncDownloadChanges(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.downloadCompletedCallback);
        } else {
            if (kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][kony.sync.currentScope[kony.sync.scopeName]][kony.sync.sessionTaskDoDownload]) {
                kony.sync.syncDownloadChanges(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.downloadCompletedCallback);
            } else {
                sync.log.info("Skipping Download for Scope : ", kony.sync.currentScope[kony.sync.scopeName]);
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onScopeSuccess], kony.sync.currentSyncReturnParams);
                //In case of OTA scope and dodownload is false, the records for corresponding ack's will be deleted
                /*if (kony.sync.currentScope[kony.sync.syncStrategy] === kony.sync.syncStrategy_OTA){
                	kony.sync.deleteRecordsAfterUpload(deleteRecordsAfterUploadCallback);
                }*/
                if (kony.sync.isUploadErrorPolicyCOE(kony.sync.currentScope)) {
                    if (kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA) {
                        deleteRecordsAfterUploadCallback(0);
                    } else {
                        kony.sync.updateSyncOrderForScope(deleteRecordsAfterUploadCallback);
                    }
                } else {
                    kony.sync.validateScopeSession();
                }
            }
        }
    }

    function deleteRecordsAfterUploadCallback(code) {
        sync.log.trace("Entering deleteRecordsAfterUploadCallback");
        if (code !== 0) {
            kony.sync.isErrorInAnyScope = true;
            var errObject = null;
            //statement error
            if (code === kony.sync.errorCodeSQLStatement) {
                errObject = kony.sync.errorObject;
            }
            //transaction error
            else {
                errObject = kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null);
            }
            kony.sync.syncErrorMessage[kony.sync.currentScope[kony.sync.scopeName]] = errObject;
            sync.log.error("Error occurred in Deleting Records After Upload : ", errObject);
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onScopeError], errObject);
        }
        kony.sync.validateScopeSession();
    }
};
kony.sync.downloadCompletedCallback = function(error, msg) {
    sync.log.trace("Entering kony.sync.downloadCompletedCallback ");
    if (kony.sync.isSyncStopped) {
        sync.log.debug("sync stopped in downloadCompletedCallback");
        kony.sync.stopSyncSession();
        return;
    }
    if (error) {
        sync.log.error("Error occurred during download : ", msg);
        //if schema change error occurred - app is not latest one
        if (msg.errorCode === kony.sync.servercodes.appVersionNotLatest) {
            kony.sync.onSchemaUpgradeErrorFromServer(msg);
            return;
        }
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onScopeError], msg);
        kony.sync.isErrorInAnyScope = true;
        kony.sync.syncErrorMessage[kony.sync.currentScope[kony.sync.scopeName]] = msg;
    } else {
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onScopeSuccess], kony.sync.currentSyncReturnParams);
    }
    kony.sync.validateScopeSession();
};
kony.sync.validateSyncConfigParams = function(opName, config) {
    sync.log.trace("Entering kony.sync.validateSyncConfigParams ");
    if (kony.sync.isNullOrUndefined(config)) {
        kony.sync.alert("Argument type mismatch found for operation:sync." + opName + ". Expected 'config object' Actual 'null or undefined'");
        return false;
    }
    if (typeof(config) !== "object") {
        kony.sync.alert("Argument type mismatch found for operation:sync." + opName + ".  Expected 'config object' Actual '" + typeof(config) + "'");
        return false;
    }
    kony.sync.resetSessionVars();
};
kony.sync.preProcessSyncConfig = function(opName, config, errorcallback, sessionRequired) {
    sync.log.trace("Entering kony.sync.preProcessSyncConfig ");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return false;
    }
    if (!kony.sync.scopenameExist(config, errorcallback)) {
        return false;
    }
    if (kony.sync.isReconciliationInProgress) {
        sync.log.warn("Reconciliation Session already in progress...");
        kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeReconcileSessionInProgress, kony.sync.getErrorMessage(kony.sync.errorCodeReconcileSessionInProgress), null));
        return false;
    }
    kony.sync.syncConfigurationDBName = konysyncClientSyncConfig.AppID;
    config.appVersion = kony.sync.configVersion; //konysyncClientSyncConfig.Version;
    kony.sync.currentSyncConfigParams = config;
    kony.sync.uploadClientContext = {};
    kony.sync.downloadClientContext = {};
    if (sessionRequired !== false) {
        if (kony.sync.isSessionInProgress) {
            sync.log.warn("Sync Session already in progress...");
            kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeSessionInProgress, kony.sync.getErrorMessage(kony.sync.errorCodeSessionInProgress), null));
            return false;
        }
        kony.sync.isSessionInProgress = true;
    }
    sync.log.debug("Starting sync." + opName + " with Current Config Params : ", config);
    kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey] = kony.sync.tonumber(kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey]);
    kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey] = kony.sync.tonumber(kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey]);
    kony.sync.resetsyncsessionglobals(opName);
};
kony.sync.scopenameExist = function(config, errorcallback) {
    sync.log.trace("Entering kony.sync.scopenameExist");
    if (!kony.sync.isNullOrUndefined(config[kony.sync.sessionTasks])) {
        for (var key in config[kony.sync.sessionTasks]) {
            if (kony.sync.isNullOrUndefined(kony.sync.scopeDict[key])) {
                sync.log.error("Wrong scopename given in SessionTasks");
                kony.sync.alert("Wrong scopename given in SessionTasks");
                kony.sync.verifyAndCallClosure(errorcallback, {});
                return false;
            }
        }
    }
    if (!kony.sync.isNullOrUndefined(config[kony.sync.removeAfterUpload])) {
        for (var key in config[kony.sync.removeAfterUpload]) {
            if (kony.sync.isNullOrUndefined(kony.sync.scopeDict[key])) {
                sync.log.error("Wrong scopename given in RemoveAfterUpload");
                kony.sync.alert("Wrong scopename given in RemoveAfterUpload");
                kony.sync.verifyAndCallClosure(errorcallback, {});
                return false;
            }
        }
    }
    return true;
};
sync.stopSession = function(callback) {
    sync.log.trace("Entering sync.stop");
    kony.sync.isSessionInProgress = false;
    kony.sync.httprequestsinglesession = false;
    kony.sync.isSyncStopped = true;
    kony.sync.onSyncStop = callback;
};
kony.sync.stopSyncSession = function() {
    sync.log.trace("Entering kony.sync.stopSyncSession ");
    kony.sync.isSyncStopped = false;
    kony.sync.globalIsDownloadStarted = true;
    try {
        kony.sync.verifyAndCallClosure(kony.sync.onSyncStop);
    } catch (e) {
        sync.log.error("Unknown error occurred during stop callback", e);
    }
};
//  **************** End KonySyncAPI.js*******************
//  **************** Start KonySyncBinaryDataManager.js*******************
/**
 * Created by Krishna Nikhil Vedurumudi on 21/09/16.
 */
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.isValidChunkSize = function(chunkSize) {
    if (typeof(chunkSize) !== "number") {
        sync.log.error("chunk size is not a number ");
        return false;
    }
    if (chunkSize <= 0) {
        sync.log.error("chunk size should be a non-negative number ");
        return false;
    }
    return true;
};

function validateBinaryOperationParameters(tableName, columnName) {
    sync.log.trace("Entering validateBinaryOperationParameters");
    var error = null;
    if (kony.sync.isNullOrUndefined(tableName) || !kony.sync.validateTableName(tableName) || typeof(tableName) !== "string") {
        //error...
        sync.log.error("invalid table name sent for binary operation ", tableName);
        error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidTableName, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidTableName, tableName));
    }
    //validate if the columnName passed is a binary column...
    if (error !== null && (kony.sync.isNullOrUndefined(columnName) || !kony.sync.validateBinaryColumn(tableName, columnName) || typeof(tableName) !== "string")) {
        sync.log.error("invalid column name sent for binary operation ", tableName);
        error = kony.sync.getErrorTable(kony.sync.errorCodeDownloadPolicyNotSupported, kony.sync.getErrorMessage(kony.sync.errorCodeDownloadPolicyNotSupported, tableName + "." + columnName));
    }
    if (!kony.sync.isNullOrUndefined(error)) {
        sync.log.error("Error object", error);
    }
    return error;
}
kony.sync.createDownloadTask = function(dbname, tableName, columnName, primaryKeyTable, config, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.createDownloadTask ");
    var error = validateBinaryOperationParameters(tableName, columnName);
    if (error != null) {
        kony.sync.verifyAndCallClosure(errorCallback, error);
        return;
    }
    //if config is null.. create empty object!
    if (kony.sync.isNullOrUndefined(config)) {
        config = {};
    }
    var primaryKeyColumns = kony.sync.getPrimaryKeyColumns(tableName);
    //validate whether we get all pks in the pk table.
    primaryKeyTable = kony.sync.validatePkTable(primaryKeyColumns, primaryKeyTable);
    sync.log.trace("after validation pks are " + JSON.stringify(primaryKeyTable));
    if (!kony.sync.isNullOrUndefined(primaryKeyTable)) {
        var downloadConfig = {};
        if (!kony.sync.isNullOrUndefined(config)) {
            sync.log.trace("kony.sync.createDownloadTask - config is passed to the download request ", config);
            if (config.hasOwnProperty("ChunkSize")) {
                var chunkSize = config.ChunkSize;
                if (kony.sync.isValidChunkSize(chunkSize)) {
                    downloadConfig.ChunkSize = config.ChunkSize;
                } else {
                    error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidChunkSize, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidChunkSize, chunkSize));
                    kony.sync.verifyAndCallClosure(errorCallback, error);
                    return;
                }
            }
            if (config.hasOwnProperty("NetworkTimeout")) {
                downloadConfig.NetworkTimeout = config.NetworkTimeout;
            }
        }
        var scopeName = kony.sync.scopes.syncTableScopeDic[tableName];
        downloadConfig.URL = kony.sync.getServerURL();
        downloadConfig.ScopeName = scopeName;
        downloadConfig.ResponseType = "Binary";
        downloadConfig.RequestMethod = "GET";
        downloadConfig.ObjectName = tableName;
        downloadConfig.ClientID = kony.sync.getDeviceID();
        sync.log.trace("kony.sync.createDownloadTask -> clientID is ", downloadConfig.ClientID);
        if (!kony.sync.isNullOrUndefined(kony.sync.sessionMap) && !kony.sync.isNullOrUndefined(kony.sync.sessionMap[kony.sync.konySyncSessionID])) {
            downloadConfig.SessionID = kony.sync.sessionMap[kony.sync.konySyncSessionID];
            sync.log.trace("kony.sync.createDownloadTask -> Session ID is ", downloadConfig.SessionID);
        }
        if (!kony.sync.isMbaasEnabled) {
            kony.sync.isMbaasEnabled = true;
        }
        sync.log.trace("Refreshing claims token");

        function claimsRefreshSuccessCallBack() {
            sync.log.trace("Entering kony.sync.createDownloadTask->claimsRefreshSuccessCallBack ");
            var currentClaimToken = kony.sdk.getCurrentInstance().currentClaimToken;
            if (!(kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams)) && kony.sync.currentSyncConfigParams[kony.sync.authTokenKey] != currentClaimToken) {
                kony.sync.currentSyncConfigParams[kony.sync.authTokenKey] = currentClaimToken;
            }
            downloadConfig["X-Kony-Authorization"] = currentClaimToken;
            sync.log.trace("creating download task..!!!!");
            if (typeof(binarydata) !== "undefined") {
                binarydata.createDownloadTask(dbname, tableName, columnName, primaryKeyTable, downloadConfig, successCallback, errorCallback);
            } else {
                sync.log.error("FFI is not configured to use Binary Apis");
                error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDataFFINotConfigured, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDataFFINotConfigured));
                kony.sync.verifyAndCallClosure(errorCallback, error);
            }
        }

        function claimsRefreshFailureCallBack(res) {
            sync.log.error("kony.sync.createDownloadTask->claimsRefreshFailureCallBack " + JSON.stringify(res));
            kony.sync.verifyAndCallClosure(errorCallback, res);
        }
        //claims token.
        kony.sdk.claimsRefresh(claimsRefreshSuccessCallBack, claimsRefreshFailureCallBack);
    } else {
        error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, tableName));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    }
};
kony.sync.startDownload = function(downloadID, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.startDownload for downloadID " + downloadID);
    var error;
    if (downloadID === null || typeof(downloadID) != "string") {
        sync.log.trace("kony.sync.startDownload -> downloadID is invalid " + downloadID);
        error = kony.sync.getErrorTable(kony.sync.errorCodeNullDownloadID, kony.sync.getErrorMessage(kony.sync.errorCodeNullDownloadID));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    } else {
        if (typeof(binarydata) !== "undefined") {
            binarydata.startDownload(downloadID, successCallback, errorCallback);
        } else {
            sync.log.error("FFI is not configured to use Binary Apis");
            error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDataFFINotConfigured, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDataFFINotConfigured));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
kony.sync.pauseDownload = function(downloadID, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.pauseDownload for downloadID " + downloadID);
    var error;
    if (downloadID === null || typeof(downloadID) != "string") {
        sync.log.trace("kony.sync.pauseDownload -> downloadID is invalid " + downloadID);
        error = kony.sync.getErrorTable(kony.sync.errorCodeNullDownloadID, kony.sync.getErrorMessage(kony.sync.errorCodeNullDownloadID));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    } else {
        if (typeof(binarydata) !== "undefined") {
            binarydata.pauseDownload(downloadID, successCallback, errorCallback);
        } else {
            sync.log.error("FFI is not configured to use Binary Apis");
            error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDataFFINotConfigured, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDataFFINotConfigured));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
kony.sync.resumeDownload = function(downloadID, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.resumeDownload for downloadID " + downloadID);
    var error;
    if (downloadID === null || typeof(downloadID) != "string") {
        sync.log.trace("kony.sync.resumeDownload -> downloadID is invalid " + downloadID);
        error = kony.sync.getErrorTable(kony.sync.errorCodeNullDownloadID, kony.sync.getErrorMessage(kony.sync.errorCodeNullDownloadID));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    } else {
        if (typeof(binarydata) !== "undefined") {
            binarydata.resumeDownload(downloadID, successCallback, errorCallback);
        } else {
            sync.log.error("FFI is not configured to use Binary Apis");
            error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDataFFINotConfigured, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDataFFINotConfigured));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
kony.sync.getBinaryDataFilePath = function(databaseName, tableName, binaryColumnName, primaryKeyTable, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.getBinaryDataFilePath ");
    //perform validations..
    var error = validateBinaryOperationParameters(tableName, binaryColumnName);
    if (error !== null) {
        kony.sync.verifyAndCallClosure(errorCallback, error);
        return;
    }
    //validate primary keys.
    var primaryKeyColumns = kony.sync.getPrimaryKeyColumns(tableName);
    //validate whether we get all pks in the pk table.
    primaryKeyTable = kony.sync.validatePkTable(primaryKeyColumns, primaryKeyTable);
    sync.log.trace("after validation pks are " + JSON.stringify(primaryKeyTable));
    if (!kony.sync.isNullOrUndefined(primaryKeyTable)) {
        if (typeof(binarydata) !== "undefined") {
            binarydata.getBinaryDataFilePath(databaseName, tableName, binaryColumnName, primaryKeyTable, successCallback, errorCallback);
        } else {
            sync.log.error("FFI is not configured to use Binary Apis");
            error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDataFFINotConfigured, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDataFFINotConfigured));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    } else {
        error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, tableName));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    }
};
kony.sync.getBinary = function(dbname, tableName, binaryColumnName, primaryKeyTable, config, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.getBinary ");

    function createTaskSuccess(downloadResult) {
        sync.log.trace("kony.sync.getBinary .. create task success with downloadID ", downloadResult);
        kony.sync.startDownload(downloadResult.BlobID, successCallback, errorCallback);
    }

    function createTaskFailure(error) {
        sync.log.trace("kony.sync.getBinary.. error in create task ", error);
        kony.sync.verifyAndCallClosure(errorCallback, error);
    }

    function getBinaryFileSuccess(filePath) {
        sync.log.trace("kony.sync.getBinary - filePath received..", filePath);
        kony.sync.verifyAndCallClosure(successCallback, filePath);
    }

    function getBinaryFileFailure(error) {
        if (!kony.sync.isNullOrUndefined(error)) {
            if (error.errorCode == 5001) {
                kony.sync.createDownloadTask(dbname, tableName, binaryColumnName, primaryKeyTable, config, createTaskSuccess, createTaskFailure);
            } else {
                sync.log.error("kony.sync.getBinary - error received from getFilePath ", error);
                kony.sync.verifyAndCallClosure(errorCallback, error);
            }
        } else {
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
    sync.log.trace("kony.sync.getBinary.. checking if file exists..");
    kony.sync.getBinaryDataFilePath(dbname, tableName, binaryColumnName, primaryKeyTable, getBinaryFileSuccess, getBinaryFileFailure);
};
kony.sync.deleteBinaryObject = function(dbname, tableName, binaryColumnName, primaryKeyTable, options, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.deleteBinaryObject ");
    //perform validations..
    var error = validateBinaryOperationParameters(tableName, binaryColumnName);
    if (error !== null) {
        kony.sync.verifyAndCallClosure(errorCallback, error);
        return;
    }
    //validate primary keys.
    var primaryKeyColumns = kony.sync.getPrimaryKeyColumns(tableName);
    //validate whether we get all pks in the pk table.
    primaryKeyTable = kony.sync.validatePkTable(primaryKeyColumns, primaryKeyTable);
    sync.log.trace("after validation pks are " + JSON.stringify(primaryKeyTable));
    if (kony.sync.isNullOrUndefined(options)) {
        options = {};
    }
    if (!kony.sync.isNullOrUndefined(primaryKeyTable)) {
        if (typeof(binarydata) !== "undefined") {
            binarydata.deleteBinaryObject(dbname, tableName, binaryColumnName, primaryKeyTable, options, successCallback, errorCallback);
        } else {
            sync.log.error("FFI is not configured to use Binary Apis");
            error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDataFFINotConfigured, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDataFFINotConfigured));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
//  **************** End KonySyncBinaryDataManager.js*******************
//  **************** Start KonySyncBlobConstants.js*******************
/**
 * Created by KH9093 on 21-09-2015.
 */
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
kony.sync.BlobType = {
    BASE64: 1,
    FILE: 2
};
kony.sync.currentSyncStats = {};
kony.sync.lastSyncStats = {};
//defining states for blob manager.
kony.sync.blobManager.INSERT_PROCESSING = 1;
kony.sync.blobManager.INSERT_FAILED = 2;
kony.sync.blobManager.UPDATE_PROCESSING = 11;
kony.sync.blobManager.UPDATE_FAILED = 12;
kony.sync.blobManager.DELETE_PROCESSING = 21;
kony.sync.blobManager.DELETE_FAILED = 22;
kony.sync.blobManager.FILE_DOESNOT_EXIST = 31;
kony.sync.blobManager.DOWNLOAD_ACCEPTED = 61;
kony.sync.blobManager.DOWNLOAD_FAILED = 63;
kony.sync.blobManager.DOWNLOAD_IN_PROGRESS = 64;
kony.sync.blobManager.UPLOAD_ACCEPTED = 71;
kony.sync.blobManager.UPLOAD_FAILED = 73;
kony.sync.blobManager.UPLOAD_IN_PROGRESS = 74;
kony.sync.blobManager.NO_OPERATION = 50;
//Binary Chunking states.
kony.sync.blobManager.DOWNLOAD_NOT_STARTED = 101;
kony.sync.blobManager.DOWNLOAD_STARTED = 102;
kony.sync.blobManager.DOWNLOAD_FAIL = 103;
kony.sync.blobManager.DOWNLOAD_PAUSED = 104;
//Delete binary object
kony.sync.blobManager.DELETE_ACCEPTED = 201;
kony.sync.blobManager.DELETE_IN_PROGRESS = 202;
kony.sync.blobManager.ONDEMAND_FETCH_LIMIT = 10;
kony.sync.blobManager.ONDEMAND_FETCH_OFFSET = 0;
//defining state messages..
kony.sync.blobManager.states = {};
kony.sync.blobManager.states[kony.sync.blobManager.INSERT_PROCESSING] = "Insert Operation in Process";
kony.sync.blobManager.states[kony.sync.blobManager.INSERT_FAILED] = "Insert Operation Failed";
kony.sync.blobManager.states[kony.sync.blobManager.UPDATE_PROCESSING] = "Update Operation in Process";
kony.sync.blobManager.states[kony.sync.blobManager.UPDATE_FAILED] = "Update Operation Failed";
kony.sync.blobManager.states[kony.sync.blobManager.DELETE_PROCESSING] = "Delete Operation in Process";
kony.sync.blobManager.states[kony.sync.blobManager.DELETE_FAILED] = "Delete Operation Failed";
kony.sync.blobManager.states[kony.sync.blobManager.FILE_DOESNOT_EXIST] = "Blob File doesn't exist.";
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_ACCEPTED] = "Download request added to the queue";
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_FAILED] = "Download Operation Failed";
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_IN_PROGRESS] = "Download Operation in Process";
kony.sync.blobManager.states[kony.sync.blobManager.NO_OPERATION] = "Blob record available";
kony.sync.blobManager.states[kony.sync.blobManager.UPLOAD_ACCEPTED] = "Upload Request added to the queue";
kony.sync.blobManager.states[kony.sync.blobManager.UPLOAD_IN_PROGRESS] = "Upload Operation In progress";
kony.sync.blobManager.states[kony.sync.blobManager.UPLOAD_FAILED] = "Upload Operation Failed";
//binary chunking state messages
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_NOT_STARTED] = "Download request added to the queue";
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_FAIL] = "Download Operation Failed";
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_STARTED] = "Download Operation in Process";
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_PAUSED] = "Download request is paused";
//Delete binary states
kony.sync.blobManager.states[kony.sync.blobManager.DELETE_ACCEPTED] = "Binary object is marked for delete..";
kony.sync.blobManager.states[kony.sync.blobManager.DELETE_IN_PROGRESS] = "Binary object delete at backend data source is in progress";
//  **************** End KonySyncBlobConstants.js*******************
//  **************** Start KonySyncBlobStoreManager.js*******************
//  **************** Start BlobStoreManager.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
/*columns of the BlobStoreManager table are ---
 id, localPath, type, state, status, size, lastUpdatedTimeStamp
 */
kony.sync.blobManager.tableName = "tableName";
kony.sync.blobManager.columnName = "columnName";
kony.sync.blobManager.localPath = "localPath";
kony.sync.blobManager.id = "id";
kony.sync.blobManager.type = "type";
kony.sync.blobManager.state = "state";
kony.sync.blobManager.status = "status";
kony.sync.blobManager.size = "size";
kony.sync.blobManager.lastUpdatedTimeStamp = "lastUpdatedTimeStamp";
kony.sync.blobManager.retry = 'retry';
var dbname = kony.sync.syncConfigurationDBName;
var tbname = "konysyncBLOBSTOREMANAGER";
var resultset = null;
/**
 * Method used to update the blob store manager record for given blobid.
 * @param tx - transaction id
 * @param blobid - id of the blob store manager row.
 * @param valuesTable - values that are updated in the record.
 * @param errorCallback - error callback in case of failures.
 * @returns {*}
 */
kony.sync.blobManager.updateBlobManager = function(tx, blobid, valuesTable, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.updateBlobManager ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_set(query, valuesTable);
    kony.sync.qb_where(query, [{
        key: kony.sync.blobManager.id,
        value: blobid
    }]);
    kony.sync.qb_update(query, kony.sync.blobStoreManagerTable);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    return resultset;
};
/**
 * This method is used to insert a base64 in the konysyncBLOBSTOREMANAGER table.
 * @param base64 the base64 value which has to be inserted in the blob store
 */
kony.sync.blobManager.saveBlob = function(tx, tableName, columnName, base64, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.saveBlob ");
    if (!kony.sync.isNullOrUndefined(base64) && base64.trim().length > 0) {
        var query = kony.sync.qb_createQuery();
        var error;
        kony.sync.qb_set(query, {
            localPath: "",
            size: base64.length,
            status: 100,
            state: kony.sync.blobManager.INSERT_PROCESSING,
            type: kony.sync.blobTypeBase64,
            tableName: tableName,
            columnName: columnName
        });
        kony.sync.qb_insert(query, kony.sync.blobStoreManagerTable);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
        if (resultset === null || resultset === false) return null;
        var blobId = resultset.insertId;
        var blobFileName = binary.util.saveBase64File("" + blobId, base64);
        sync.log.trace("blob filepath returned is " + blobFileName);
        //if file creation is successful.. insert the file path to the blobstoremanager.
        var valuesTable = {};
        if (blobFileName) {
            valuesTable[kony.sync.blobManager.localPath] = blobFileName;
            valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.NO_OPERATION;
            valuesTable[kony.sync.blobManager.status] = 100;
            kony.sync.blobManager.updateBlobManager(tx, blobId, valuesTable, errorCallback);
        } else {
            valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.INSERT_FAILED;
            valuesTable[kony.sync.blobManager.status] = 0;
            kony.sync.blobManager.updateBlobManager(tx, blobId, valuesTable, errorCallback);
            error = kony.sync.getErrorTable(kony.sync.errorCodeBlobFileNotCreated, kony.sync.getErrorMessage(kony.sync.errorCodeBlobFileNotCreated));
            kony.sync.verifyAndCallClosure(errorCallback, error);
            return;
        }
        return blobId;
    } else {
        error = kony.sync.getErrorTable(kony.sync.errorCodeEmptyOrNullBase64, kony.sync.getErrorMessage(kony.sync.errorCodeEmptyOrNullBase64));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    }
};
/**
 * This method is used to delete records from the konysyncBLOBSTOREMANAGER table.
 * @param id array which contains the list of valid ids whose records has to be deleted
 * @return true if deletion is successful else false
 */
kony.sync.blobManager.deleteBlob = function(tx, blobid, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.deleteBlob ");
    sync.log.info("deleteBlobFromTable..");
    if (blobid === undefined || typeof(blobid) !== "number") {
        var error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidColumnParams, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidColumnParams));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    } else {
        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobid, errorCallback);
        //state, status, localPath
        //delete the record only if it is in valid state.
        var state = null;
        if (!kony.sync.isNullOrUndefined(blobMeta)) {
            state = blobMeta[kony.sync.blobManager.state];
        }
        var possibleStates = [kony.sync.blobManager.INSERT_FAILED, kony.sync.blobManager.DELETE_FAILED,
            kony.sync.blobManager.FILE_DOESNOT_EXIST,
            kony.sync.blobManager.NO_OPERATION, kony.sync.blobManager.UPDATE_FAILED,
            kony.sync.blobManager.DOWNLOAD_FAILED, kony.sync.blobManager.DOWNLOAD_IN_PROGRESS,
            kony.sync.blobManager.DOWNLOAD_ACCEPTED,
            kony.sync.blobManager.UPLOAD_IN_PROGRESS,
            kony.sync.blobManager.DELETE_ACCEPTED,
            kony.sync.blobManager.DOWNLOAD_FAIL,
            kony.sync.blobManager.DOWNLOAD_PAUSED,
            kony.sync.blobManager.DOWNLOAD_NOT_STARTED
        ];
        if (!kony.sync.isNullOrUndefined(state) && possibleStates.indexOf(state) !== -1) {
            var valuesTable = {};
            valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DELETE_PROCESSING;
            kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
            var deleteFile = binary.util.deleteBlobFile(blobMeta[kony.sync.blobManager.localPath]);
            //TODO - add check to deletefile status..
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_delete(query, kony.sync.blobStoreManagerTable);
            var wcs = [{
                key: kony.sync.blobManager.id,
                value: blobid,
                comptype: 'OR'
            }];
            kony.sync.qb_where(query, wcs);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            resultset = kony.db.executeSql(tx, sql, params, errorCallback);
            if (resultset === null || resultset === false) {
                valuesTable = {};
                valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DELETE_FAILED;
                kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback)
            }
            return resultset;
        } else {
            var error = kony.sync.getErrorTable(kony.sync.errorCodeBlobInvalidStateForDelete, kony.sync.getErrorMessage(kony.sync.errorCodeBlobInvalidStateForDelete, kony.sync.blobManager.states[state]));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
/**
 * This method is used to update the binary data referred by id.
 * @param id unique id of the base64 value.
 * @param base64 is the binary value to be updated.
 */
kony.sync.blobManager.updateBlob = function(tx, blobid, base64, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.updateBlob ");
    var error;
    if (blobid === undefined || typeof(blobid) !== "number") {
        error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidColumnParams, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidColumnParams));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    } else {
        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobid, errorCallback);
        //state, status, localPath
        var state = null;
        if (!kony.sync.isNullOrUndefined(blobMeta)) {
            state = blobMeta[kony.sync.blobManager.state];
        }
        var possibleStates = [kony.sync.blobManager.INSERT_FAILED, kony.sync.blobManager.FILE_DOESNOT_EXIST, kony.sync.blobManager.DELETE_FAILED,
            kony.sync.blobManager.NO_OPERATION, kony.sync.blobManager.UPDATE_FAILED, kony.sync.blobManager.DOWNLOAD_FAILED,
            kony.sync.blobManager.DOWNLOAD_ACCEPTED, kony.sync.blobManager.DOWNLOAD_IN_PROGRESS
        ];
        if (!kony.sync.isNullOrUndefined(state) && possibleStates.indexOf(state) !== -1) {
            var valuesTable = {};
            valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.UPDATE_PROCESSING;
            kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
            var isBlobSaved = binary.util.saveBase64File("" + blobid, base64);
            if (isBlobSaved !== null) {
                valuesTable = {};
                valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.NO_OPERATION;
                kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
            } else {
                valuesTable = {};
                valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.UPDATE_FAILED;
                kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
            }
            return blobid;
        } else {
            error = kony.sync.getErrorTable(kony.sync.errorCodeBlobInvalidStateForUpdate, kony.sync.getErrorMessage(kony.sync.errorCodeBlobInvalidStateForUpdate, kony.sync.blobManager.states[state]));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
/**
 * This is a utility method used to insert inline policy blobvalues to konysyncBLOBSTOREMANAGER
 * and return corresponding blob ids
 * @param tx transaction id
 * @param tbname tablename
 * @param values table columns
 * @return object containing columns and their blob indices
 */
kony.sync.blobstore_insert = function(tx, tbname, values, errorCallback) {
    sync.log.trace("Entering kony.sync.blobstore_insert ");
    if (kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) || kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        //TODO - call error callback with apt error.
        return;
    }
    var blobstoreindices = {};
    var j;
    var sql;
    var binaryColumnsList = Object.keys(values);
    var binaryColumnRefs = [];
    for (j = 0; j < binaryColumnsList.length; j++) {
        binaryColumnRefs[j] = kony.sync.binaryMetaColumnPrefix + binaryColumnsList[j]
    }
    for (j = 0; j < binaryColumnsList.length; j++) {
        if (!kony.sync.isNullOrUndefined(values[binaryColumnsList[j]])) {
            var blobIndex = kony.sync.blobManager.saveBlob(tx, tbname, binaryColumnsList[j], values[binaryColumnsList[j]], errorCallback);
            if (!kony.sync.isNullOrUndefined(blobIndex)) {
                blobstoreindices[binaryColumnRefs[j]] = blobIndex;
            }
        }
    }
    return blobstoreindices;
};
/**
 * This is a utility method used to update blobvalues to konysyncBLOBSTOREMANAGER and return
 * corresponding blobids
 * @param tx - transaction id
 * @param tbname - tablename
 * @param values - table columns
 * @param wc - whereclause
 * @param isBatch - indicates whether utility function is used for batch or not
 * @return object containing columns and their blob indices
 */
kony.sync.blobstore_update = function(tx, tbname, values, wc, isBatch, errorCallback) {
    sync.log.trace("Entering kony.sync.blobstore_update ");
    var isUpdateSuccessful = true;
    if (kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) || kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        //TODO - call error callback with apt error.
        return;
    }
    var blobstoreindices = {};
    var query_compile;
    var sql;
    var binaryColumnsList = Object.keys(values);
    var binaryColumnRefs = [];
    for (var i = 0; i < binaryColumnsList.length; i++) {
        binaryColumnRefs[i] = kony.sync.binaryMetaColumnPrefix + binaryColumnsList[i]
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, binaryColumnRefs);
    kony.sync.qb_from(query, tbname);
    if (isBatch === true) {
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0] + " " + wc;
    } else {
        kony.sync.qb_where(query, wc);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
    }
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset !== false && resultset !== null) {
        if (resultset.rows.length > 0) {
            var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
            for (var j = 0; j < binaryColumnRefs.length; j++) {
                var blobIndex;
                if (!kony.sync.isNullOrUndefined(rowItem[binaryColumnRefs[j]])) {
                    if (rowItem[binaryColumnRefs[j]] !== "NULL") blobIndex = kony.sync.blobManager.updateBlob(tx, rowItem[binaryColumnRefs[j]], values[binaryColumnsList[j]], errorCallback);
                    else {
                        blobIndex = kony.sync.blobManager.saveBlob(tx, tbname, binaryColumnsList[j], values[binaryColumnsList[j]], errorCallback);
                    }
                }
                if (!kony.sync.isNullOrUndefined(blobIndex)) {
                    blobstoreindices[binaryColumnRefs[j]] = blobIndex;
                }
            }
        }
        return blobstoreindices;
    }
};
/**
 * This is a utility method used to delete blob from konysyncBLOBSTOREMANAGER
 * @param tx transaction id
 * @param tbname tablename
 * @param isBatch indicates whether utility function is used for batch or not
 * @return
 */
kony.sync.blobstore_delete = function(tx, tbname, wc, isBatch, errorCallback) {
    sync.log.trace("Entering kony.sync.blobstore_delete ");
    if (kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) || kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        return true;
    }
    var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
    var isDeleteSuccessful = true;
    var query_compile = null;
    var sql = null;
    var binaryColumnRefs = [];
    for (var i = 0; i < binaryColumns.length; i++) {
        binaryColumnRefs[i] = kony.sync.binaryMetaColumnPrefix + binaryColumns[i];
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, binaryColumnRefs);
    kony.sync.qb_from(query, tbname);
    if (isBatch === true) {
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0] + " " + wc;
    } else {
        kony.sync.qb_where(query, wc);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
    }
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset !== false && resultset !== null) {
        if (resultset.rows.length > 0) {
            var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
            for (var i = 0; i < binaryColumnRefs.length; i++) {
                var blobIndex;
                if (!kony.sync.isNullOrUndefined(rowItem[binaryColumnRefs[i]])) {
                    blobIndex = rowItem[binaryColumnRefs[i]];
                    if (blobIndex !== "NULL") {
                        var results = kony.sync.blobManager.deleteBlob(tx, blobIndex, errorCallback);
                        if (results === false || results === null) {
                            isDeleteSuccessful = false;
                        }
                    }
                }
            }
        }
        return isDeleteSuccessful;
    }
};
/**
 * Success callback called after successful completion of download.
 * @param response - contains the response from download manager. (blobid, value file/base64).
 */
//expected fields in response.
//blobid,requestState,statusCode, errorResponse
//filePath 
kony.sync.blobManager.onDemandUniversalSuccessCallback = function(response) {
    sync.log.trace(" Entered into kony.sync.blobManager.onDemandUniversalSuccessCallback " + JSON.stringify(response));
    var isDownload = true;
    if (response.hasOwnProperty("blobid")) {
        var successResponse = {};
        var blobId = parseInt(response.blobid);
        //give the response to the user.
        function invokeCallbacks(updateResult, filePath) {
            sync.log.trace("Entering invokeCallbacks");
            if (isDownload) {
                if (updateResult) {
                    var blobType = kony.sync.blobManager.getRegisteredBlobType(blobId);
                    //increment total number of download jobs completed..
                    kony.sync.incrementCompletedJobs(true);
                    if (!kony.sync.isNullOrUndefined(blobType)) {
                        successResponse.pkTable = kony.sync.blobManager.getRegisteredPkTable(blobId);
                        if (blobType === kony.sync.BlobType.FILE) {
                            var decodedFilePath = binary.util.decodeBase64File(filePath);
                            successResponse.filePath = decodedFilePath;
                        } else {
                            var base64String = binary.util.getBase64FromFiles([filePath]);
                            successResponse.base64 = base64String[0];
                        }
                        var successCallback = kony.sync.blobManager.getRegisteredSuccessCallback(blobId);
                        //clean up binarynotifier map..
                        if (!kony.sync.isNullOrUndefined(successCallback)) {
                            kony.sync.verifyAndCallClosure(successCallback, successResponse);
                        }
                    } else {
                        //log download completed..
                        sync.log.info("Download completed for blob id " + blobId);
                    }
                } else {
                    var errorCallback = kony.sync.blobManager.getRegisteredErrorCallback(blobId);
                    //increment total number of download jobs failed..
                    kony.sync.incrementFailedJobs(true);
                    if (!kony.sync.isNullOrUndefined(errorCallback)) {
                        //update status failed after download.
                        var error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDownloadFailed, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDownloadFailed));
                        kony.sync.verifyAndCallClosure(errorCallback, error);
                    }
                }
            } else {
                //increment upload completed jobs..
                kony.sync.incrementCompletedJobs(false);
                if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams) && kony.sync.isValidFunctionType(kony.sync.currentSyncConfigParams["uploadBinarySuccessCallback"])) {
                    var uploadSuccessCallback = kony.sync.currentSyncConfigParams["uploadBinarySuccessCallback"];
                    kony.sync.verifyAndCallClosure(uploadSuccessCallback, response);
                } else {
                    sync.log.info("Upload completed..");
                }
            }
            //invoke the notifier..
            kony.sync.invokeBinaryNotifiers(isDownload);
        }
        //check the type of request.
        var reqState = parseInt(response[kony.sync.requestState]);
        if (reqState != kony.sync.blobManager.DOWNLOAD_IN_PROGRESS) {
            isDownload = false;
        }
        kony.sync.blobManager.updateStatusAfterOndemandJob(response, true, isDownload, invokeCallbacks);
    }
};
/**
 * Failure callback after error in download.
 * @param response - contains the error object and the corresponding blob id.
 */
kony.sync.blobManager.onDemandUniversalErrorCallback = function(response) {
    sync.log.error("universal error callback " + JSON.stringify(response));
    var isDownload = true;
    if (response.hasOwnProperty("blobid")) {
        function invokeCallbacks(updateResult, filePath) {
            sync.log.trace("Entering invokeCallbacks");
            if (isDownload) {
                //increment total number of download jobs failed..
                kony.sync.incrementFailedJobs(true);
                sync.log.trace("invoking error callback for the download request..");
                var errorCallback = kony.sync.blobManager.getRegisteredErrorCallback(response.blobid);
                if (!kony.sync.isNullOrUndefined(errorCallback)) {
                    //create an error object with appropriate details..
                    var errorMessage = kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDownloadFailed) + " status " + response.statusCode + " " + response.errorMessage;
                    var errorObject = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDownloadFailed, errorMessage);
                    kony.sync.verifyAndCallClosure(errorCallback, errorObject);
                }
            } else {
                //increment total number of download jobs failed..
                kony.sync.incrementFailedJobs(false);
                sync.log.trace("invoking error callback for the upload request..");
                if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams) && kony.sync.isValidFunctionType(kony.sync.currentSyncConfigParams["uploadBinaryErrorCallback"])) {
                    var uploadErrorCallback = kony.sync.currentSyncConfigParams["uploadBinaryErrorCallback"];
                    //create an error object with appropriate details..
                    var errorMessage = kony.sync.getErrorMessage(kony.sync.errorCodeBinaryUploadFailed) + " status " + response.statusCode + " " + response.errorMessage;
                    var errorObject = kony.sync.getErrorTable(kony.sync.errorCodeBinaryUploadFailed, errorMessage);
                    kony.sync.verifyAndCallClosure(uploadErrorCallback, errorObject);
                } else {
                    //upload failed.
                    sync.log.error("sync binary upload failed for blob id " + response.blobid);
                }
            }
            //invoke the notifier..
            kony.sync.invokeBinaryNotifiers(isDownload);
        }
        //using the request state find out if the request is for upload/ download.
        if (parseInt(response[kony.sync.requestState]) === kony.sync.blobManager.UPLOAD_IN_PROGRESS) {
            isDownload = false;
        }
        kony.sync.blobManager.updateStatusAfterOndemandJob(response, false, isDownload, invokeCallbacks);
    }
};
/** Method used to register success and error callbacks for given blob download.
 * @param blobid - blobid which is under download
 * @param pks - primary key values which uniquely identify the blob in parent table
 * @param successCallback - success callback to be called after successful download
 * @param errorCallback - error callback to be called in case of failure.
 */
kony.sync.blobManager.registerCallbacks = function(blobid, pks, blobType, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.registerCallbacks ");
    kony.sync.blobManager.binaryNotifierMap[blobid] = [pks, blobType, successCallback, errorCallback];
};
/**
 * Method returns the registered Success callback for the given blobid download request.
 * @param blobid - blobid which is under download.
 * @returns {*}
 */
kony.sync.blobManager.getRegisteredSuccessCallback = function(blobid) {
    sync.log.trace("Entering kony.sync.blobManager.getRegisteredSuccessCallback ");
    if (kony.sync.blobManager.binaryNotifierMap.hasOwnProperty(blobid)) {
        return kony.sync.blobManager.binaryNotifierMap[blobid][2];
    } else {
        return null;
    }
};
/**
 * Method returns the registered error callback for the given blobid download request.
 * @param blobid - blobid which is under download.
 * @returns {*}
 */
kony.sync.blobManager.getRegisteredErrorCallback = function(blobid) {
    sync.log.trace("Entering kony.sync.blobManager.getRegisteredErrorCallback ");
    if (kony.sync.blobManager.binaryNotifierMap.hasOwnProperty(blobid)) {
        return kony.sync.blobManager.binaryNotifierMap[blobid][3];
    } else {
        return null;
    }
};
/**
 * Method returns the registered pk values for the given blobid download request.
 * @param blobid - blobid which is under download.
 * @returns {*}
 */
kony.sync.blobManager.getRegisteredPkTable = function(blobid) {
    sync.log.trace("Entering kony.sync.blobManager.getRegisteredPkTable ");
    if (kony.sync.blobManager.binaryNotifierMap.hasOwnProperty(blobid)) {
        return kony.sync.blobManager.binaryNotifierMap[blobid][0];
    } else {
        return null;
    }
};
kony.sync.blobManager.getRegisteredBlobType = function(blobid) {
    sync.log.trace("Entering kony.sync.blobManager.getRegisteredBlobType ");
    if (kony.sync.blobManager.binaryNotifierMap.hasOwnProperty(blobid)) {
        return kony.sync.blobManager.binaryNotifierMap[blobid][1];
    } else {
        return null;
    }
};
/**
 * Method used to update status of the blob record to completed after completion of donwload.
 * @param blobid - id for which the status has to be updated.
 * @param success - result of operation (true/ false).
 * @param isDownload - operation type. true for download / false for upload.
 */
kony.sync.blobManager.updateStatusAfterOndemandJob = function(response, success, isDownload, updateResultCallback) {
    sync.log.trace("Entering kony.sync.blobManager.updateStatusAfterOndemandJob ");
    var finalFilePath = "";
    var valuesTable = {};

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        var blobid = parseInt(response[kony.sync.blobId]);
        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobid, function(err) {
            sync.log.trace("error in fetching blobMeta --> updateStatusAfterOndemandJob");
        });
        if (isDownload) {
            if (blobMeta[kony.sync.blobManager.state] === parseInt(response[kony.sync.requestState])) {
                //delete the previousFile and rename the temp file.
                if (success) {
                    sync.log.trace(" kony.sync.blobManager.updateStatusAfterOndemandJob: single_transaction_callback ", blobid);
                    var previousFileName = blobMeta[kony.sync.blobManager.localPath];
                    var filePath = response["filePath"];
                    var fileSuccess;
                    if (previousFileName === "") {
                        filePath = filePath.substring(0, filePath.indexOf("_temp"));
                        fileSuccess = binary.util.renameFile(response["filePath"], filePath);
                        finalFilePath = filePath;
                    } else {
                        fileSuccess = binary.util.renameFile(response["filePath"], previousFileName);
                        finalFilePath = previousFileName;
                    }
                    if (fileSuccess) {
                        valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.NO_OPERATION;
                        valuesTable[kony.sync.blobManager.status] = 100;
                        valuesTable[kony.sync.blobManager.localPath] = finalFilePath;
                    } else {
                        valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DOWNLOAD_FAILED;
                        valuesTable[kony.sync.blobManager.status] = 0;
                        success = false;
                    }
                } else {
                    if (response.hasOwnProperty("errorResponse") && !response["errorResponse"] && response["errorResponse"].trim() !== "") {
                        //check if for the errorResponse, we have to retry or not.
                        if (kony.sync.blobManager.isRetryError(response["statusCode"], response["errorResponse"])) {
                            var noOfRetries = blobMeta[kony.sync.blobManager.retry] - 1;
                            if (noOfRetries < 0) {
                                valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DOWNLOAD_FAILED;
                                valuesTable[kony.sync.blobManager.status] = 0;
                            } else {
                                valuesTable[kony.sync.blobManager.retry] = noOfRetries;
                                valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DOWNLOAD_ACCEPTED;
                                valuesTable[kony.sync.blobManager.status] = 0;
                            }
                        } else {
                            sync.log.trace("Not a retry error, so updating status as download failed for blobid:" + blobid);
                            valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DOWNLOAD_FAILED;
                            valuesTable[kony.sync.blobManager.status] = 0;
                        }
                    } else {
                        //download failed. no error Response received.
                        sync.log.error("Download failed. Response from server is " + JSON.stringify(response));
                        valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DOWNLOAD_FAILED;
                        valuesTable[kony.sync.blobManager.status] = 0;
                    }
                }
                kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable);
            } else {
                //user invoked operation after download request. No need to update anything.
                success = false;
                sync.log.trace("some other operation got invoked after download call. So, ignoring downloaded file");
                if (response.hasOwnProperty["filePath"]) {
                    binary.util.deleteBlobFile(response["filePath"]);
                }
            }
        } else {
            //upload response parsing.
            var reqState = parseInt(response[kony.sync.requestState]);
            if (reqState == kony.sync.blobManager.UPLOAD_IN_PROGRESS) {
                if (blobMeta[kony.sync.blobManager.state] === parseInt(response[kony.sync.requestState])) {
                    valuesTable = {};
                    if (success) {
                        valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.NO_OPERATION;
                    } else {
                        valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.UPLOAD_FAILED;
                    }
                    kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable);
                } else {
                    //user invoked another operation after upload request.
                    sync.log.trace("some other operation got invoked after upload call");
                    success = false;
                }
            } else {
                //in case of delete..
                //first delete the record from blobStoreManager.
                if (success) {
                    var deleteResult = kony.sync.blobManager.deleteBlob(tx, blobid);
                    if (deleteResult !== null && deleteResult !== false) {
                        //update blob reference in parent as Null.
                        var tableName = blobMeta[kony.sync.blobManager.tableName];
                        var setClause = {};
                        var blobMetaFieldKey = kony.sync.binaryMetaColumnPrefix + blobMeta[kony.sync.blobManager.columnName];
                        setClause[blobMetaFieldKey] = "NULL";
                        var wcs = [{
                            key: blobMetaFieldKey,
                            value: blobid
                        }];
                        var updateResult = kony.sync.blobManager.updateParentWithBlobReference(tx, tableName, setClause, wcs);
                        if (updateResult === false || updateResult === null) {
                            sync.log.trace("making blob ref to NULL in " + tableName + " failed ");
                            success = false;
                        }
                    } else {
                        sync.log.trace("error in deleting blob record for id " + blobid);
                        success = false;
                    }
                } else {
                    sync.log.trace("error in uploading binary delete.. marked as DELETE again.");
                    valuesTable = {};
                    valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DELETE_ACCEPTED;
                    kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable);
                }
            }
        }
    }

    function single_transaction_success_callback() {
        sync.log.trace("updateStatusAfterOndemandJob -> transaction success");
        updateResultCallback(success, finalFilePath);
    }

    function single_transaction_error_callback() {
        sync.log.trace("updateStatusAfterOndemandJob -> transaction failure");
        success = false;
        updateResultCallback(success, finalFilePath);
    }
    var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName);
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
    }
};
/**
 * Method is used to parse the statusCode and errorResponse that the sdk receives upon DownloadBinary
 * and concludes if the download should be retried or not.
 * @param statusCode - statusCode from http response
 * @param errorResponse - errorResponse fetched from server
 * @returns {boolean} - whether the error leads to retry or not.
 */
kony.sync.blobManager.isRetryError = function(statusCode, errorResponse) {
    sync.log.trace("Entering kony.sync.blobManager.isRetryError ");
    var isRetryError = false;
    sync.log.trace("isRetryError:statusCode: " + statusCode + " errorResponse:", errorResponse);
    statusCode = parseInt(statusCode);
    try {
        errorResponse = JSON.parse(errorResponse);
    } catch (err) {
        sync.log.error("kony.sync.blobManager.isRetryError parsing error response " + errorResponse);
        return isRetryError;
    }
    //depending on the status code and error response, find out if the download should be retried!
    switch (statusCode) {
        case 404:
            isRetryError = false;
            break;
        case 401:
            if (errorResponse.hasOwnProperty("mfcode")) {
                if (errorResponse["mfcode"] === "Auth-9") {
                    sync.log.trace("Got Auth-9 response");
                    isRetryError = true;
                } else if (errorResponse["mfcode"] === "Gateway-5") {
                    sync.log.trace("Got Gateway-5 response");
                    isRetryError = true;
                }
            } else {
                isRetryError = false;
            }
            break;
        case 200:
            if (errorResponse.hasOwnProperty("d") && errorResponse["d"].hasOwnProperty("mfcode")) {
                if (errorResponse["d"]["mfcode"] === "Gateway-5") {
                    isRetryError = true;
                }
            }
            break;
        default:
            isRetryError = false;
    }
    return isRetryError;
};
kony.sync.blobManager.updateParentWithBlobReference = function(tx, tableName, values, wcs, errorCallback) {
    sync.log.trace("kony.sync.blobManager.updateParentWithBlobReference - entered with table " + tableName + " and values ", values);
    sync.log.trace("kony.sync.blobManager.updateParentWithBlobReference - updating parent table with blobref.");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, tableName);
    kony.sync.qb_set(query, values);
    kony.sync.qb_where(query, wcs);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset === false) {
        sync.log.error("Error in updating the parent table with blobId ");
    }
    //update the history table as well..
    sync.log.trace("kony.sync.blobManager.updateParentWithBlobReference - updating history table with blobref.");
    query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, tableName + kony.sync.historyTableName);
    kony.sync.qb_set(query, values);
    kony.sync.qb_where(query, wcs);
    query_compile = kony.sync.qb_compile(query);
    sql = query_compile[0];
    params = query_compile[1];
    resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset === false) {
        sync.log.error("Error in updating the history table with blobId ");
    }
    return resultset;
};
kony.sync.blobManager.createBlobRecord = function(tx, tableName, columnName, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.createBlobRecord ");
    var query = kony.sync.qb_createQuery();
    var state = kony.sync.blobManager.DOWNLOAD_ACCEPTED;
    kony.sync.qb_set(query, {
        localPath: "",
        status: 0,
        state: state,
        type: kony.sync.blobTypeBase64,
        tableName: tableName,
        columnName: columnName,
        retry: kony.sync.maxRetries
    });
    kony.sync.qb_insert(query, kony.sync.blobStoreManagerTable);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset === null || resultset === false) {
        sync.log.error("error in creating a entry in blobstore manager");
        return;
    }
    var blobId = resultset.insertId;
    return blobId;
};
/**
 * Method invokes download operation on the given record.
 * @param tx - transaction id
 * @param tableName - parent table name for the blob reocrd
 * @param columnName - column name of the binary field.
 * @param blobType - download response type . (FILE /BASE64).
 * @param pks - pk table which uniquely identifies the record
 * @param successCallback - success callback for download request.
 * @param errorCallback - error callback for download request.
 * @returns {null}
 */
kony.sync.blobManager.triggerDownload = function(tx, tableName, columnName, pks, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.triggerDownload ");
    sync.log.trace("kony.sync.blobManager.triggerDownload - Entered function with tablename and columnname " + tableName + "--" + columnName);
    var blobId = kony.sync.blobManager.createBlobRecord(tx, tableName, columnName, errorCallback);
    if (!blobId) {
        return;
    }
    sync.log.trace("successfully created an entry in blobstore manager");
    var setClause = {};
    var blobMetaFieldKey = kony.sync.binaryMetaColumnPrefix + columnName;
    setClause[blobMetaFieldKey] = blobId;
    var wcs = [];
    for (var key in pks) {
        var wc = {};
        wc.key = key;
        wc.value = pks[key];
        wcs.push(wc);
    }
    resultset = kony.sync.blobManager.updateParentWithBlobReference(tx, tableName, setClause, wcs, errorCallback);
    if (resultset === false || resultset === null) {
        return;
    }
    sync.log.trace("updated parent table with the blod id.");
    binary.util.notifyToPrepareJobs();
    return blobId;
};
/**
 * Method retriggers the download (incase of force-download / failed download.)
 * @param tx - transaction id
 * @param blobid - id which uniquely identifies the blob
 * @param blobType - download response type (FILE/ base64).
 * @param pks - pk table which uniquely identifies the record.
 * @param successCallback - success callback for download request.
 * @param errorCallback - error callback for download request.
 */
kony.sync.blobManager.retryDownload = function(tx, blobid, blobType, pks, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.retryDownload ");
    //reset the state and status to 0% and DOWNLOAD_ACCEPTED
    var state = kony.sync.blobManager.DOWNLOAD_ACCEPTED;
    var valuesTable = {};
    valuesTable[kony.sync.blobManager.state] = state;
    valuesTable[kony.sync.blobManager.status] = 0;
    kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
    //increment total number of download jobs..
    kony.sync.incrementTotalJobs(true);
    kony.sync.blobManager.registerCallbacks(blobid, pks, blobType, successCallback, errorCallback);
    binary.util.notifyToPrepareJobs();
};
kony.sync.blobManager.getBlobInline = function(tx, blobid, blobType, tableName, columnName, config, pks, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.getBlobInline ");
    var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobid, errorCallback);
    if (!kony.sync.isNullOrUndefined(blobMeta) && blobMeta !== false) {
        var possibleStates = [kony.sync.blobManager.NO_OPERATION, kony.sync.blobManager.UPLOAD_ACCEPTED,
            kony.sync.blobManager.UPLOAD_IN_PROGRESS, kony.sync.blobManager.UPLOAD_FAILED
        ];
        var state = blobMeta[kony.sync.blobManager.state];
        if (blobMeta[kony.sync.blobManager.status] === 100 && possibleStates.indexOf(state) !== -1) {
            //base64 exists. return back the required details.
            var successResponse = {};
            successResponse.pkTable = pks;
            if (blobType === kony.sync.BlobType.FILE) {
                //return blobMeta[kony.sync.blobManager.localPath];
                var decodedFilePath = binary.util.decodeBase64File(blobMeta[kony.sync.blobManager.localPath]);
                successResponse.filePath = decodedFilePath;
                return successResponse;
            } else {
                var base64String = binary.util.getBase64FromFiles([blobMeta[kony.sync.blobManager.localPath]]);
                if (base64String[0].length > 0) {
                    successResponse.base64 = base64String[0];
                    return successResponse;
                } else {
                    //update the state of the file stating the file doesn't exist.
                    var valuesTable = {};
                    valuesTable.state = kony.sync.blobManager.FILE_DOESNOT_EXIST;
                    kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
                    //throw an error saying file doesn't exist.
                    var error = kony.sync.getErrorTable(kony.sync.errorCodeBlobFileDoesnotExist, kony.sync.getErrorMessage(kony.sync.errorCodeBlobFileDoesnotExist));
                    return error;
                }
            }
        } else {
            var error = kony.sync.getErrorTable(kony.sync.errorCodeBlobInvalidState, kony.sync.getErrorMessage(kony.sync.errorCodeBlobInvalidState));
            return error;
        }
    }
};
/**
 * Method called when download request is invoked.
 * @param tx - transaction id
 * @param blobid - id of the blob store manager record.
 * @param blobType - response type (FILE /  BASE64).
 * @param tableName - name of the parent table.
 * @param columnName - binary column to which the record refers to.
 * @param config - configuration parameters for download ( forceDownload).
 * @param pks - pk table that uniquely identies the record in parent table.
 * @param successCallback - success callback for fetch
 * @param errorCallback - error callback for fetch,
 * @returns {*}
 */
kony.sync.blobManager.getBlobOnDemand = function(tx, blobid, blobType, tableName, columnName, config, pks, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.getBlobOnDemand ");
    if (!kony.sync.isNullOrUndefined(config) && config.hasOwnProperty(kony.sync.binaryOperationNetworkTimeoutKey)) {
        kony.sync.binaryOperationNetworkTimeoutValue = config[kony.sync.binaryOperationNetworkTimeoutKey];
    }
    //no blob id. trigger download
    if (blobid === kony.sync.blobRefNotDefined) {
        sync.log.trace("triggering download --> getBlobOnDemand");
        var generatedBlobId = kony.sync.blobManager.triggerDownload(tx, tableName, columnName, pks, errorCallback);
        if (generatedBlobId) {
            kony.sync.blobManager.registerCallbacks(generatedBlobId, pks, blobType, successCallback, errorCallback);
        }
        //increment total number of download jobs..
        kony.sync.incrementTotalJobs(true);
    } else {
        //check if the file is available.
        sync.log.trace("fetching from blobStoreManager --> getBlobOnDemand");
        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobid, errorCallback);
        if (!kony.sync.isNullOrUndefined(blobMeta) && blobMeta !== false) {
            //possible states of the file to read the base64.
            var possibleStates = [kony.sync.blobManager.NO_OPERATION, kony.sync.blobManager.UPLOAD_ACCEPTED,
                kony.sync.blobManager.UPLOAD_IN_PROGRESS, kony.sync.blobManager.UPLOAD_FAILED
            ];
            var state = blobMeta[kony.sync.blobManager.state];
            var forceDownload = false;
            sync.log.trace("blob meta from blobStoreManager.." + JSON.stringify(blobMeta));
            if (!kony.sync.isNullOrUndefined(config) && config.hasOwnProperty(kony.sync.forceDownload)) {
                forceDownload = config.forceDownload;
            }
            sync.log.trace("forceDownload " + forceDownload + " -> getBlobOnDemand");
            //if state is No_operation and status is 100, file exists. read it and return.
            if (blobMeta[kony.sync.blobManager.status] === kony.sync.maxFilePercent && possibleStates.indexOf(state) !== -1) {
                //base64 exists. return back the required details.
                if (!forceDownload) {
                    var successResponse = {};
                    successResponse.pkTable = pks;
                    //if requested response type is FILE, return the filePath.
                    if (blobType === kony.sync.BlobType.FILE) {
                        var decodedFilePath = binary.util.decodeBase64File(blobMeta[kony.sync.blobManager.localPath]);
                        successResponse.filePath = decodedFilePath;
                        sync.log.trace("response to the user with filepath " + JSON.stringify(successResponse));
                        return successResponse;
                    } else {
                        //else read the base64 string from the file.
                        var base64String = binary.util.getBase64FromFiles([blobMeta[kony.sync.blobManager.localPath]])
                        if (base64String[0].length > 0) {
                            successResponse.base64 = base64String[0];
                            sync.log.trace("response to the user with base64 string " + JSON.stringify(successResponse));
                            return successResponse;
                        } else {
                            var valuesTable = {};
                            valuesTable.state = kony.sync.blobManager.FILE_DOESNOT_EXIST;
                            kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
                            sync.log.error("requested file does not exist -> getBlobOnDemand");
                            //throw an error saying file doesn't exist.
                            var error = kony.sync.getErrorTable(kony.sync.errorCodeBlobFileDoesnotExistOnDemand, kony.sync.getErrorMessage(kony.sync.errorCodeBlobFileDoesnotExistOnDemand));
                            return error;
                        }
                    }
                } else {
                    //retrigger download..
                    sync.log.trace("forceDownload is true. ReTriggering download -> getBlobOnDemand");
                    kony.sync.blobManager.retryDownload(tx, blobid, blobType, pks, successCallback, errorCallback);
                }
            }
            //if already download requested on that record, throw an error..
            else if (blobMeta[kony.sync.blobManager.state] === kony.sync.blobManager.DOWNLOAD_ACCEPTED || blobMeta[kony.sync.blobManager.state] === kony.sync.blobManager.DOWNLOAD_IN_PROGRESS) {
                //throw an error download already requested...
                sync.log.error("Download request is already in queue -> getBlobOnDemand");
                var error = kony.sync.getErrorTable(kony.sync.errorCodeDownloadAlreadyInQueue, kony.sync.getErrorMessage(kony.sync.errorCodeDownloadAlreadyInQueue));
                return error;
            }
            //if already ony operation is in progress on the blob entry, download is not allowed.
            else if (blobMeta[kony.sync.blobManager.state] === kony.sync.blobManager.UPDATE_PROCESSING || blobMeta[kony.sync.blobManager.state] === kony.sync.blobManager.DELETE_PROCESSING) {
                sync.log.error("User performing operation..-> getBlobOnDemand");
                var error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidStateForDownload, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidStateForDownload, kony.sync.blobManager.states[blobMeta[kony.sync.blobManager.state]]));
                return error;
            } else {
                //retriger download
                //blob entry exists but not the file.
                sync.log.trace("retriggering download -> getBlobOnDemand");
                kony.sync.blobManager.retryDownload(tx, blobid, blobType, pks, successCallback, errorCallback);
            }
        }
    }
};
/**
 * Method used to read meta info about the record in blobstore manager.
 * @param tx - transaction id.
 * @param blobid - id of the record in blob store manager.
 * @param errorCallback - error callback for unsuccesful transactions.
 * @returns {{}} JSON object with state and status information.
 */
kony.sync.blobManager.getBlobMetaDetails = function(tx, blobid, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.getBlobMetaDetails ");
    var wcs = [{
        key: "id",
        value: blobid
    }];
    var requiredColumns = [kony.sync.blobManager.state, kony.sync.blobManager.status,
        kony.sync.blobManager.localPath, kony.sync.blobManager.retry,
        kony.sync.blobManager.tableName, kony.sync.blobManager.columnName
    ];
    var response = {};
    resultset = kony.sync.queryTable(tx, kony.sync.blobStoreManagerTable, requiredColumns, wcs);
    if (resultset !== null && resultset !== false) {
        var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        response.state = rowItem[kony.sync.blobManager.state];
        response.status = rowItem[kony.sync.blobManager.status];
        response.localPath = rowItem[kony.sync.blobManager.localPath];
        response.retry = rowItem[kony.sync.blobManager.retry];
        response.tableName = rowItem[kony.sync.blobManager.tableName];
        response.columnName = rowItem[kony.sync.blobManager.columnName];
    }
    return response;
};
/**
 * This method is used to get the fetch the rows from blob tables and populate the ondemand download request
 * @return
 */
kony.sync.blobManager.prepareJobs = function() {
    sync.log.trace("Entering kony.sync.blobManager.prepareJobs ");
    //incase current sync config params are undefined, retrieve them from local storage.
    var errorcallback = function(err) {
        sync.log.error("Error occured in prepareJobs " + JSON.stringify(err));
    };
    var successcallback = kony.sync.blobManager.onDemandManager.setJobs;
    var payloadList = [];
    var isError = false;
    var errorInfo = {};
    sync.log.trace("Entering kony.sync.blobManager.prepareJobs ");

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.blobManager.prepareJobs->single_select_transaction_success");
        if (isError) {
            sync.log.error("Error occured in single_transaction_success_callback " + JSON.stringify(errorInfo))
            kony.sync.verifyAndCallClosure(errorcallback, errorInfo);
            return;
        }
        if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams) && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.authTokenKey])) {
            if (!kony.sync.isMbaasEnabled) {
                kony.sync.isMbaasEnabled = true;
            }
            sync.log.trace("Refreshing claims token");
            kony.sdk.claimsRefresh(claimsRefreshSuccessCallBack, claimsRefreshFailureCallBack);
        } else {
            sync.log.trace("Calling successcallback with payload list " + JSON.stringify(payloadList));
            kony.sync.verifyAndCallClosure(successcallback, payloadList);
        }
    }

    function claimsRefreshSuccessCallBack() {
        sync.log.trace("Entering kony.sync.blobManager.prepareJobs->claimsRefreshSuccessCallBack ");
        var currentClaimToken = kony.sdk.getCurrentInstance().currentClaimToken;
        if (kony.sync.currentSyncConfigParams[kony.sync.authTokenKey] != currentClaimToken) {
            kony.sync.currentSyncConfigParams[kony.sync.authTokenKey] = currentClaimToken;
        }
        var payloadListSize = payloadList.length;
        var payload = null;
        for (var i = 0; i < payloadListSize; i++) {
            payload = payloadList[i];
            if (!kony.sync.isNullOrUndefined(payload) && !kony.sync.isNullOrUndefined(payload.httpheaders)) {
                payload.httpheaders["X-Kony-Authorization"] = currentClaimToken;
            }
        }
        sync.log.trace("Calling successcallback with payloadlist " + JSON.stringify(payloadList));
        kony.sync.verifyAndCallClosure(successcallback, payloadList);
    }

    function claimsRefreshFailureCallBack(res) {
        sync.log.error("kony.sync.blobManager.prepareJobs->claimsRefreshFailureCallBack " + JSON.stringify(res));
        kony.sync.verifyAndCallClosure(errorcallback, res);
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.blobManager.prepareJobs->single_select_transaction_failed");
        kony.sync.verifyAndCallClosure(errorcallback);
    }

    function populateOnDemandPayload(tx, rowItemsList, isDownload) {
        sync.log.trace("Entering populateOnDemandPayload");
        try {
            sync.log.trace("Entering kony.sync.blobManager.prepareJobs->populateOnDemandPayload isDOwnload " + isDownload);
            sync.log.trace("populate on demand payload -> rowItemsList " + JSON.stringify(rowItemsList));
            var rowItemsListLength = rowItemsList.length;
            var binaryMetaColumnName = null;
            var binaryColumnName = null;
            var binaryTableName = null;
            var rowItem = null;
            var query = null;
            var query_compile = null;
            var sql = null;
            var params = null;
            var resultSet = null;
            var whereClause = [];
            var queryOpenBrace = true;
            var blobId = null;
            //Iterating over the on demand download/upload rows
            for (var j = 0; j < rowItemsListLength; j++) {
                rowItem = rowItemsList[j];
                blobId = rowItem[kony.sync.blobManager.id];
                binaryColumnName = rowItem[kony.sync.blobManager.columnName];
                binaryTableName = rowItem[kony.sync.blobManager.tableName];
                var scope = kony.sync.scopes[kony.sync.scopes.syncTableScopeDic[binaryTableName]];
                var columns = kony.sync.createClone(scope.syncTableDic[binaryTableName].Pk_Columns);
                columns.push(binaryColumnName);
                if (!isDownload) {
                    columns.push(kony.sync.mainTableChangeTypeColumn);
                }
                var blobWhereClause = [];
                binaryMetaColumnName = kony.sync.binaryMetaColumnPrefix + binaryColumnName;
                kony.table.insert(blobWhereClause, {
                    key: binaryMetaColumnName,
                    value: blobId,
                    optype: "EQ"
                });
                resultSet = kony.sync.queryTable(tx, binaryTableName, columns, blobWhereClause);
                if (resultSet === false) {
                    sync.log.error("Error executing query", sql, " params ", JSON.stringify(params));
                    isError = true;
                    return;
                }
                if (resultSet !== null && resultSet.rows.length > 0) {
                    var data = null;
                    for (var k = 0; k < resultSet.rows.length; k++) {
                        data = kony.db.sqlResultsetRowItem(tx, resultSet, k);
                        //check if there is context in the binarycolumn. \
                        if (isDownload) {
                            if (data[binaryColumnName] === kony.sync.blobRefNotDefined) {
                                sync.log.error("NULL found in binary data column. ");
                                isError = true;
                                return;
                            }
                        }
                        //adding state of the binary column.
                        data["state"] = rowItem["state"];
                        var payload = populateOnDemandParams(tx, blobId, binaryColumnName, binaryTableName, data, isDownload);
                        payloadList.push(payload);
                    }
                }
                var mp = {};
                mp[kony.sync.queryKey] = kony.sync.blobManager.id;
                mp[kony.sync.queryValue] = rowItem[kony.sync.blobManager.id];
                mp[kony.sync.optype] = "EQ";
                mp[kony.sync.comptype] = "OR";
                if (j === 0) {
                    mp[kony.sync.openbrace] = true;
                }
                if (j === (rowItemsListLength - 1)) {
                    mp[kony.sync.closebrace] = true;
                }
                whereClause.push(mp);
            }
            //Update blobstoremanager table with DOWNLOAD_INPROGRESS/UPLOAD_INPROGRESS FOR corresponding ids
            //if there are any jobs. 
            if (whereClause.length > 0) {
                query = kony.sync.qb_createQuery();
                kony.sync.qb_update(query, kony.sync.blobStoreManagerTable);
                var setClause = {};
                //TODO - add a check before updating the state. 
                if (isDownload) {
                    setClause[kony.sync.blobManager.state] = kony.sync.blobManager.DOWNLOAD_IN_PROGRESS;
                } else {
                    setClause[kony.sync.blobManager.state] = kony.sync.blobManager.UPLOAD_IN_PROGRESS;
                }
                kony.sync.qb_set(query, setClause);
                kony.sync.qb_where(query, whereClause);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                sync.log.trace("Executing query for updating states ", sql, " params ", JSON.stringify(params));
                resultSet = kony.sync.executeSql(tx, sql, params);
                if (resultSet === false) {
                    isError = true;
                    return;
                }
            }
        } catch (err) {
            isError = true;
            //to avoid the thread to wait in case of exception.
            kony.sync.blobManager.onDemandManager.setJobs(null);
            sync.log.trace("catch block for the error-> populateOnDemandPayload " + JSON.stringify(err));
            errorInfo = err;
        }
    }

    function populateOnDemandParams(tx, blobIndex, binaryColumnName, tableName, data, isDownload) {
        sync.log.trace("Entering kony.sync.blobManager.prepareJobs->populateOnDemandParams ");
        sync.log.trace("params to the method are blobIdex " + blobIndex + " column " + tableName + "." + binaryColumnName);
        var job = {};
        var params = {};
        var scopeName = kony.sync.scopes.syncTableScopeDic[tableName];
        params.scopename = scopeName;
        params.blobid = blobIndex;
        params.strategy = kony.sync.scopes[scopeName][kony.sync.syncStrategy];
        params.instanceid = kony.sync.getInstanceID();
        params.clientid = kony.sync.getDeviceID();
        params.appVersion = kony.sync.configVersion;
        if (isDownload) {
            params.url = kony.sync.getDownloadBinaryURL();
        } else {
            params.url = kony.sync.getUploadBinaryURL();
        }
        //This will populate userid, password, appid, sessionid, requestnumber
        kony.sync.commonServiceParams(params);
        params.enablebatching = "true";
        var syncContext = getLastSyncContext(tx, scopeName);
        var ondemandrequest = getOnDemandRequest(tx, syncContext, scopeName, tableName, data, isDownload, blobIndex, binaryColumnName);
        sync.log.trace("populate on demand params -synccontext " + ondemandrequest);
        if (isDownload) {
            params.downloadrequest = ondemandrequest;
            job[kony.sync.requestState] = kony.sync.blobManager.DOWNLOAD_IN_PROGRESS;
            job[kony.sync.requestType] = kony.sync.isDownload;
        } else {
            params.uploadrequest = ondemandrequest;
            if (data.state == kony.sync.blobManager.UPLOAD_ACCEPTED) {
                job[kony.sync.requestState] = kony.sync.blobManager.UPLOAD_IN_PROGRESS;
            } else {
                job[kony.sync.requestState] = kony.sync.blobManager.DELETE_IN_PROGRESS;
            }
            job[kony.sync.requestType] = kony.sync.isUpload;
        }
        job[kony.sync.params] = params;
        job[kony.sync.httpHeaders] = kony.sync.createClone(params[kony.sync.httpHeaders]);
        if (isDownload) {
            job[kony.sync.url] = kony.sync.getDownloadBinaryURL();
        } else {
            job[kony.sync.url] = kony.sync.getUploadBinaryURL();
        }
        job[kony.sync.blobId] = blobIndex;
        job[kony.sync.blobName] = binaryColumnName;
        //adding timeout for the binary operation.
        if (!kony.sync.isNullOrUndefined(kony.sync.binaryOperationNetworkTimeoutValue)) {
            sync.log.trace("populateOnDemandParams - using binary operation timeout of " + kony.sync.binaryOperationNetworkTimeoutValue);
            job[kony.sync.networkTimeOutKey] = kony.sync.binaryOperationNetworkTimeoutValue;
        } else if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams) && !kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
            sync.log.trace("populateOnDemandParams - using sync network timeout of " + kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]);
            job[kony.sync.networkTimeOutKey] = kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey];
        } else {
            sync.log.trace("populateOnDemandParams - using default timeout of 180000 milli seconds");
            job[kony.sync.networkTimeOutKey] = 180000; //default timeout used by frameworks..
        }
        delete params[kony.sync.httpHeaders];
        sync.log.info("job details are " + JSON.stringify(job));
        return job;
    }

    function getOnDemandRequest(tx, downloadContext, scopename, tableName, binaryColumnData, isDownload, blobIndex, binaryColumnName) {
        sync.log.trace("Entering getOnDemandRequest");
        var resultSet = [];
        var result = {};
        var metaData = {};
        metaData[kony.sync.type] = tableName;
        var isDelete = false;
        //add the changetype for upload/delete request.
        if (!isDownload) {
            if (binaryColumnData.state == kony.sync.blobManager.UPLOAD_ACCEPTED) {
                metaData[kony.sync.syncStatusColumn] = "update";
            } else if (binaryColumnData.state == kony.sync.blobManager.DELETE_ACCEPTED) {
                sync.log.trace("getOnDemandRequest - Received Delete binary request!");
                isDelete = true;
                metaData[kony.sync.syncStatusColumn] = "delete";
            }
        }
        result[kony.sync.metadata] = metaData;
        result[kony.sync.konySyncReplaySequence] = 1;
        if (!isDownload) {
            delete binaryColumnData[kony.sync.mainTableChangeTypeColumn];
        }
        for (var column in binaryColumnData) {
            if (column === "state") {
                continue;
            }
            if (column === binaryColumnName) {
                if (isDownload) {
                    result[column] = binaryColumnData[column];
                } else {
                    //read the filepath.
                    if (!isDelete) {
                        sync.log.trace("getOnDemandRequest - Received Upload request!");
                        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobIndex, function(err) {
                            sync.log.trace("Entering 						var blobMeta ");
                        });
                        //if the blobMeta has filePath.
                        //from the native, we read base64 content and add it to payload.
                        if (!kony.sync.isNullOrUndefined(blobMeta[kony.sync.blobManager.localPath])) {
                            result["filePath"] = blobMeta[kony.sync.blobManager.localPath];
                        }
                    }
                }
            } else {
                result[column] = binaryColumnData[column];
            }
        }
        resultSet.push(result);
        //creating the d object.
        var d = {};
        d[kony.sync.syncobjects] = resultSet;
        d[kony.sync.sync] = "not implemented";
        d[kony.sync.blobSyncScope] = scopename;
        d[kony.sync.serverBlob] = downloadContext[kony.sync.metaTableSyncTimeColumn];
        d[kony.sync.clientId] = kony.sync.getDeviceID();
        d[kony.sync.moreChangesAvailable] = false;
        d[kony.sync.SequenceNumber] = 0;
        var request = {};
        request["d"] = d;
        sync.log.trace("request object in getOnDemandRequest --> " + JSON.stringify(request));
        return request;
    }

    function getLastSyncContext(tx, scopename) {
        sync.log.trace("Entering kony.sync.blobManager.prepareJobs->getLastSyncContext");
        var scope = kony.sync.scopes[scopename];
        var datasource = scope[kony.sync.scopeDataSource];
        var whereClause = [{
            key: kony.sync.metaTableScopeColumn,
            value: scopename
        }, {
            key: kony.sync.metaTableFilterValue,
            value: "no filter"
        }];
        var resultSet = kony.sync.queryTable(tx, kony.sync.metaTableName, null, whereClause);
        if (resultSet === false) {
            sync.log.error("Error executing query on table " + kony.sync.metaTableName);
            isError = true;
            return;
        }
        var rowItem = null;
        if (resultSet !== null && resultSet.rows.length > 0) {
            rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
        }
        return rowItem;
    }

    function getNextOnDemandRows(tx, isDownload) {
        sync.log.trace("Entering kony.sync.blobManager.prepareJobs->getNextOnDemandRows");
        //Select id, tablename, columnname from blobstoremanager table with status as 0% and state as DOWNLOAD_ACCEPTED
        var selectClause = [kony.sync.blobManager.id, kony.sync.blobManager.tableName, kony.sync.blobManager.columnName,
            kony.sync.blobManager.state
        ];
        var wcs = [];
        if (isDownload) {
            kony.table.insert(wcs, {
                key: kony.sync.blobManager.status,
                value: 0,
                optype: "EQ",
                comptype: "AND"
            });
            kony.table.insert(wcs, {
                key: kony.sync.blobManager.state,
                value: kony.sync.blobManager.DOWNLOAD_ACCEPTED,
                optype: "EQ"
            });
        } else {
            kony.table.insert(wcs, {
                key: kony.sync.blobManager.state,
                value: kony.sync.blobManager.UPLOAD_ACCEPTED,
                optype: "EQ",
                comptype: "OR"
            });
            kony.table.insert(wcs, {
                key: kony.sync.blobManager.state,
                value: kony.sync.blobManager.DELETE_ACCEPTED,
                optype: "EQ",
                comptype: "OR"
            });
        }
        return kony.sync.queryTable(tx, kony.sync.blobStoreManagerTable, selectClause, wcs, kony.sync.blobManager.ONDEMAND_FETCH_LIMIT);
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        try {
            sync.log.trace("Entering kony.sync.blobManager.prepareJobs->single_transaction_callback");
            //First check for ondemand rows to be downloaded
            var download = true;
            var resultSet = getNextOnDemandRows(tx, download);
            var rowItemsList = [];
            var rowItem = null;
            var resultSetLength = null;
            if (resultSet === false) {
                sync.log.error("Error executing query ");
                isError = true;
                return;
            }
            if ((resultSet !== null) && (resultSet.rows.length === 0)) {
                //If there are no records to download, fetch the records to be uploaded
                sync.log.trace(" No records to download, get next records to upload ");
                download = false;
                resultSet = getNextOnDemandRows(tx, download);
                if (resultSet === false) {
                    sync.log.error("Error executing query ");
                    isError = true;
                    return;
                }
            }
            if (resultSet !== null) {
                resultSetLength = resultSet.rows.length;
                for (var i = 0; i < resultSetLength; i++) {
                    rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, i);
                    if (!kony.sync.isNullOrUndefined(rowItem)) {
                        rowItemsList.push(rowItem);
                    }
                }
                if (rowItemsList.length > 0) {
                    sync.log.trace("jobs retrieved from database.. " + JSON.stringify(rowItemsList));
                    populateOnDemandPayload(tx, rowItemsList, download);
                } else {
                    return;
                }
            }
        } catch (err) {
            sync.log.error("kony.sync.blobManager.prepareJobs->exception occured " + JSON.stringify(err));
            //errorcallback(err);
            isError = true;
            errorInfo = err;
        }
    }
    var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, errorcallback);
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
    }
};
kony.sync.blobManager.onDemandManager = function() {
    sync.log.trace("Entering kony.sync.blobManager.onDemandManager ");
};
kony.sync.blobManager.onDemandManager.jobs = null;
kony.sync.blobManager.onDemandManager.setJobs = function(jobs) {
    sync.log.trace("Entering kony.sync.blobManager.onDemandManager.setJobs ");
    kony.sync.blobManager.onDemandManager.jobs = null;
    kony.sync.blobManager.onDemandManager.jobs = jobs;
    binary.util.notifyToProcessJobs();
};
kony.sync.blobManager.getPreparedJobs = function() {
    sync.log.trace("Entering kony.sync.blobManager.getPreparedJobs ");
    //var map = {'key':kony.sync.blobManager.onDemandManager.jobs};
    //return map;
    return kony.sync.blobManager.onDemandManager.jobs;
};
kony.sync.blobManager.onDemandManager.getJobs = function() {
    sync.log.trace("Entering kony.sync.blobManager.onDemandManager.getJobs ");
    return kony.sync.blobManager.onDemandManager.jobs;
};
kony.sync.blobManager.performCleanUp = function(cleanUpCallback) {
    sync.log.trace("Entering kony.sync.performCleanUp");
    var isError = false;
    //once clean up is completed
    function single_transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.performCleanUp - single_transaction_callback");
        //parse through the konysyncBlobStoreManager and remove unwanted rows.
        //Delete the rows in case of following states.
        var deleteRecordStates = [kony.sync.blobManager.INSERT_PROCESSING, kony.sync.blobManager.INSERT_FAILED,
            kony.sync.blobManager.DOWNLOAD_FAILED, kony.sync.blobManager.DOWNLOAD_IN_PROGRESS, kony.sync.blobManager.DOWNLOAD_ACCEPTED,
            kony.sync.blobManager.UPDATE_FAILED, kony.sync.blobManager.UPDATE_PROCESSING,
            kony.sync.blobManager.FILE_DOESNOT_EXIST
        ];
        var whereClause = [];
        for (var i = 0; i < deleteRecordStates.length; i++) {
            var wc = {};
            wc.key = kony.sync.blobManager.state;
            wc.value = deleteRecordStates[i];
            wc.comptype = "OR";
            whereClause.push(wc);
        }
        var selectClause = [kony.sync.blobManager.id, kony.sync.blobManager.tableName, kony.sync.blobManager.columnName];
        var result_set = kony.sync.queryTable(tx, kony.sync.blobStoreManagerTable, selectClause, whereClause);
        var rowItem;
        var valuesTable;
        if (result_set !== null && result_set !== false) {
            if (result_set.rows.length > 0) {
                for (var k = 0; k < result_set.rows.length; k++) {
                    //delete the blob entries with the given where clause.
                    rowItem = kony.db.sqlResultsetRowItem(tx, result_set, k);
                    sync.log.trace("record to be deleted in konysyncBlobStoreManager is " + JSON.stringify(rowItem));
                    var deleteResult = kony.sync.blobManager.deleteBlob(tx, rowItem[kony.sync.blobManager.id], function(err) {
                        kony.sync.errorObject = err;
                        sync.log.error("kony.sync.blobManager.performCleanUp -error in deleteBlob " + JSON.stringify(err));
                        isError = true;
                    });
                    sync.log.trace("after deleting record with id " + rowItem[kony.sync.blobManager.id] + " result is " + JSON.stringify(deleteResult));
                    if (deleteResult !== null && deleteResult !== false) {
                        //tx, tableName, values, wcs, errorCallback
                        var binaryColumnName = kony.sync.binaryMetaColumnPrefix + rowItem[kony.sync.blobManager.columnName];
                        valuesTable = {};
                        var wcs = [{
                            key: binaryColumnName,
                            value: rowItem[kony.sync.blobManager.id]
                        }];
                        valuesTable[binaryColumnName] = kony.sync.blobRefNotDefined;
                        var updateResult = kony.sync.blobManager.updateParentWithBlobReference(tx, rowItem[kony.sync.blobManager.tableName], valuesTable, wcs, function(err) {
                            sync.log.trace("Entering ");
                            kony.sync.errorObject = err;
                            sync.log.error("kony.sync.blobManager.performCleanUp -error in updateParentWithBlobReference " + JSON.stringify(err));
                            isError = true;
                        });
                        sync.log.trace("after updating record's blobref result is " + JSON.stringify(updateResult));
                        if (updateResult === null || updateResult === false) {
                            sync.log.error("kony.sync.blobManager.performCleanUp -error in updateParentWithBlobReference ");
                            isError = true;
                        }
                    } else {
                        sync.log.error("kony.sync.blobManager.performCleanUp -error in deleteBlob");
                        isError = true;
                    }
                }
            }
            if (!isError) {
                //change the state of upload_in_progress to upload_failed.
                whereClause = [{
                    key: kony.sync.blobManager.state,
                    value: kony.sync.blobManager.UPLOAD_IN_PROGRESS
                }];
                result_set = kony.sync.queryTable(tx, kony.sync.blobStoreManagerTable, selectClause, whereClause);
                if (result_set !== null && result_set !== false) {
                    if (result_set.rows.length > 0) {
                        for (var k = 0; k < result_set.rows.length; k++) {
                            rowItem = kony.db.sqlResultsetRowItem(tx, result_set, k);
                            valuesTable = {};
                            valuesTable.state = kony.sync.blobManager.UPLOAD_FAILED;
                            kony.sync.blobManager.updateBlobManager(tx, rowItem[kony.sync.blobManager.id], valuesTable, function(err) {
                                sync.log.trace("Entering ");
                                kony.sync.errorObject = err;
                                sync.log.error("kony.sync.blobManager.performCleanUp -error in updateBlobManager " + JSON.stringify(err));
                                isError = true;
                            });
                        }
                    }
                } else {
                    sync.log.error("kony.sync.blobManager.performCleanUp - error in fetchFromBlobStoreManager");
                    isError = true;
                }
            }
        } else {
            sync.log.error("kony.sync.blobManager.performCleanUp - error in fetchFromBlobStoreManager");
            isError = true;
        }
    }

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.performCleanUp - single_transaction_success_callback");
        if (!isError) {
            kony.sync.isCleanUpJobCompleted = true;
        }
        cleanUpCallback(isError);
    }

    function single_transaction_error_callback() {
        sync.log.trace("Entering kony.sync.performCleanUp - single_transaction_error_callback");
        cleanUpCallback(true);
    }
    var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, cleanUpCallback);
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
    }
};
//  **************** End KonySyncBlobStoreManager.js*******************
//  **************** Start KonySyncBlobUtils.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
/**
 * Method returns the download policy of the given column in the table if the type of column is binary
 * else returns null
 * @param tableName - tablename
 * @param columnName - column name
 * @returns {*} -downloadPolicy for binary column, null for non binary columns.
 */
kony.sync.getDownloadPolicy = function(tableName, columnName) {
    sync.log.trace("Entering kony.sync.getDownloadPolicy ");
    var downloadPolicy = kony.sync.notSupported;
    if (!kony.sync.isNullOrUndefined(kony.sync.scopes) && kony.sync.scopes.syncTableScopeDic.hasOwnProperty(tableName)) {
        var scope = kony.sync.scopes[kony.sync.scopes.syncTableScopeDic[tableName]];
        var tableColumns = scope.syncTableDic[tableName].Columns;
        var isColumn = false;
        for (var i = 0; i < tableColumns.length; i++) {
            if (tableColumns[i].Name === columnName && tableColumns[i].type === "binary") {
                isColumn = true;
                if (tableColumns[i].hasOwnProperty(kony.sync.binaryPolicy)) {
                    downloadPolicy = tableColumns[i][kony.sync.binaryPolicy];
                } else {
                    downloadPolicy = kony.sync.inline;
                }
                break;
            }
        };
    }
    return downloadPolicy;
};
/**
 * Method checks whether the given column in binary column or not.
 * @param tbname - table to which column belongs to.
 * @param columnName - name of the column
 * @returns {number|Number} - returns -1 if the column is not binary.
 */
kony.sync.getBinaryColumnsByPolicy = function(tbname, policy) {
    sync.log.trace("Entering kony.sync.getBinaryColumnsByPolicy ");
    var columnsWithRequestedPolicy = [];
    if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        var binaryColumnsOfTable = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
        for (var j = 0; j < binaryColumnsOfTable.length; j++) {
            var downloadPolicy = kony.sync.getDownloadPolicy(tbname, binaryColumnsOfTable[j]);
            if (downloadPolicy === policy) {
                columnsWithRequestedPolicy.push(binaryColumnsOfTable[j]);
            }
        }
    }
    return columnsWithRequestedPolicy;
};
/**
 * Method checks whether the given column in binary column or not.
 * @param tbname - table to which column belongs to.
 * @param columnName - name of the column
 * @returns {number|Number} - returns -1 if the column is not binary.
 */
kony.sync.isBinaryColumn = function(tbname, columnName) {
    sync.log.trace("Entering kony.sync.isBinaryColumn ");
    if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        var binaryColumnsOfTable = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
        return binaryColumnsOfTable.indexOf(columnName);
    }
    return -1;
};
/**
 * Method used to find Blobref for the given record.
 * @param tx - transaction id
 * @param sql - sql statement
 * @param params - sql params
 * @param column - column name
 * @param errorNotifier - error callback.
 * @returns {{}} - blobref object containing pk values and blobreference.
 */
kony.sync.getBlobRef = function(tx, tableName, columnName, pks, errorNotifier) {
        sync.log.trace("Entering kony.sync.getBlobRef ");
        var wcs = [];
        for (var key in pks) {
            var wc = {};
            wc.key = key;
            wc.value = pks[key];
            wc.comptype = "AND";
            wcs.push(wc);
        }
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_from(query, tableName);
        var blobRefColumn = kony.sync.binaryMetaColumnPrefix + columnName;
        kony.sync.qb_select(query, [blobRefColumn]);
        kony.sync.qb_where(query, wcs);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var blobRef = kony.sync.blobRefNotFound;
        //"NULL"
        var result = kony.db.executeSql(tx, sql, params, function(err) {
            sync.log.error("error in transaction call back " + JSON.stringify(err));
            errorNotifier(err);
            return;
        });
        if (result !== null && result !== false) {
            if (result.rows.length > 0) {
                var rowItem = kony.db.sqlResultsetRowItem(tx, result, 0);
                var rowValue = rowItem[kony.sync.binaryMetaColumnPrefix + columnName];
                if (!kony.sync.isNullOrUndefined(rowValue)) {
                    blobRef = rowValue;
                }
            }
        }
        return blobRef;
    }
    /**
     * Method used to validate pkTable.
     * @param pkColumns - pkColumns related to the table
     * @param pkTable - received pkTable from the user.
     * @returns {*} - updated pkTable after removing non binary keys.
     * returns null incase all the pk keys are not sent.
     */
kony.sync.validatePkTable = function(pkColumns, pkTable) {
    sync.log.trace("Entering kony.sync.validatePkTable ");
    var receivedPkColumns = Object.keys(pkTable);
    //remove non pk columns..
    for (var i = receivedPkColumns.length - 1; i >= 0; i--) {
        if (pkColumns.indexOf(receivedPkColumns[i]) === -1) {
            delete pkTable[receivedPkColumns[i]];
            receivedPkColumns.splice(i, 1);
        }
    }
    //check if info is received for all pks.
    if (receivedPkColumns.length !== pkColumns.length) {
        //throw an error. info about all pks is mandate.
        return null;
    } else {
        return pkTable;
    }
};
kony.sync.removeBinaryMetaColumns = function(tablename, columns) {
    sync.log.trace("Entering kony.sync.removeBinaryMetaColumns ");
    var nonMetaColumns = [];
    for (var j = 0; j < columns.length; j++) {
        if (columns[j].Name.indexOf(kony.sync.binaryMetaColumnPrefix) !== 0) {
            nonMetaColumns.push(columns[j]);
        }
    }
    return nonMetaColumns;
}
kony.sync.getBlobContext = function(tx, tableName, columnName, pks, errorNotifier) {
    sync.log.trace("Entering kony.sync.getBlobContext ");
    var wcs = [];
    for (var key in pks) {
        var wc = {};
        wc.key = key;
        wc.value = pks[key];
        wc.comptype = "AND";
        wcs.push(wc);
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_from(query, tableName);
    kony.sync.qb_select(query, [columnName]);
    kony.sync.qb_where(query, wcs);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var blobContext = kony.sync.blobRefNotFound;
    //"NULL"
    var result = kony.db.executeSql(tx, sql, params, function(err) {
        sync.log.error("error in transaction call back " + JSON.stringify(err));
        errorNotifier(err);
    });
    if (result !== null && result !== false) {
        if (result.rows.length > 0) {
            var rowItem = kony.db.sqlResultsetRowItem(tx, result, 0);
            blobContext = rowItem[columnName];
        }
    }
    return blobContext;
};
kony.sync.getBinaryColumns = function(tablename) {
    sync.log.trace("Entering kony.sync.getBinaryColumns ");
    if (kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename]) || kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns])) {
        return;
    } else {
        return kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns];
    }
};
kony.sync.getSyncToDeviceField = function(tableName, columnName) {
    sync.log.trace("Entering kony.sync.getSyncToDeviceField for table " + tableName + " and column " + columnName);
    if (kony.sync.isNullOrUndefined(kony.sync.scopes.syncToDeviceMap) && !kony.sync.scopes.syncToDeviceMap.hasOwnProperty(tableName + columnName)) {
        return;
    }
    return kony.sync.scopes.syncToDeviceMap[tableName + columnName];
};
//initialize Binary stats properties
kony.sync.initBinaryStatProperties = function() {
    sync.log.trace("Entering kony.sync.initBinaryStatProperties ");
    //current sync cycle stats
    var uploadBinaryStats = {};
    var downloadBinaryStats = {};
    //initializing upload related stats..
    uploadBinaryStats.totalNumberOfUploads = 0;
    uploadBinaryStats.uploadsCompleted = 0;
    uploadBinaryStats.uploadsFailed = 0;
    //initializing download related stats..
    downloadBinaryStats.totalNumberOfDownloads = 0;
    downloadBinaryStats.downloadsCompleted = 0;
    downloadBinaryStats.downloadsFailed = 0;
    kony.sync.currentSyncStats.uploadBinaryStats = uploadBinaryStats;
    kony.sync.currentSyncStats.downloadBinaryStats = downloadBinaryStats;
};
//initialize stat params
kony.sync.initBinaryStats = function() {
    sync.log.trace("Entered kony.sync.initBinaryStats - initializing binary stats parameters.. ");
    kony.sync.currentSyncStats = {};
    kony.sync.initBinaryStatProperties();
    //last sync cycle stats
    kony.sync.lastSyncStats = {};
};
//assign currentSyncStats to lastSyncStats
kony.sync.reinitializeBinaryStats = function() {
    sync.log.trace("Entering kony.sync.reinitializeBinaryStats ");
    kony.sync.lastSyncStats = kony.sync.currentSyncStats;
    //current sync cycle stats
    kony.sync.currentSyncStats = {};
    kony.sync.initBinaryStatProperties();
};
//increment number of uploads/ downloads..
kony.sync.incrementTotalJobs = function(isDownload) {
    sync.log.trace("Entering kony.sync.incrementTotalJobs ");
    if (isDownload) {
        sync.log.trace("kony.sync.incrementTotalJobs downloads incremented");
        kony.sync.currentSyncStats.downloadBinaryStats.totalNumberOfDownloads = kony.sync.currentSyncStats.downloadBinaryStats.totalNumberOfDownloads + 1;
    } else {
        sync.log.trace("kony.sync.incrementTotalJobs uploads incremented");
        kony.sync.currentSyncStats.uploadBinaryStats.totalNumberOfUploads = kony.sync.currentSyncStats.uploadBinaryStats.totalNumberOfUploads + 1;
    }
};
//increment number of completed uploads / downloads
kony.sync.incrementCompletedJobs = function(isDownload) {
    sync.log.trace("Entering kony.sync.incrementCompletedJobs ");
    if (isDownload) {
        sync.log.trace("kony.sync.incrementCompletedJobs downloads incremented");
        kony.sync.currentSyncStats.downloadBinaryStats.downloadsCompleted = kony.sync.currentSyncStats.downloadBinaryStats.downloadsCompleted + 1;
    } else {
        sync.log.trace("kony.sync.incrementCompletedJobs uploads incremented");
        kony.sync.currentSyncStats.uploadBinaryStats.uploadsCompleted = kony.sync.currentSyncStats.uploadBinaryStats.uploadsCompleted + 1;
    }
};
//increment number of failed uploads / downloads
kony.sync.incrementFailedJobs = function(isDownload) {
    sync.log.trace("Entering kony.sync.incrementFailedJobs ");
    if (isDownload) {
        sync.log.trace("kony.sync.incrementFailedJobs downloads incremented");
        kony.sync.currentSyncStats.downloadBinaryStats.downloadsFailed = kony.sync.currentSyncStats.downloadBinaryStats.downloadsFailed + 1;
    } else {
        sync.log.trace("kony.sync.incrementFailedJobs uploads incremented");
        kony.sync.currentSyncStats.uploadBinaryStats.uploadsFailed = kony.sync.currentSyncStats.uploadBinaryStats.uploadsFailed + 1;
    }
};
kony.sync.invokeBinaryNotifiers = function(isDownload) {
    sync.log.trace("Entering kony.sync.invokeBinaryNotifiers ");
    if (isDownload) {
        if (kony.sync.onBinaryDownload && kony.sync.isValidFunctionType(kony.sync.onBinaryDownload)) {
            kony.sync.onBinaryDownload(kony.sync.currentSyncStats.downloadBinaryStats);
        }
    } else {
        if (kony.sync.onBinaryUpload && kony.sync.isValidFunctionType(kony.sync.onBinaryUpload)) {
            kony.sync.onBinaryUpload(kony.sync.currentSyncStats.uploadBinaryStats);
        }
    }
};
kony.sync.validateTableName = function(tableName) {
    sync.log.trace("Entering kony.sync.validateTableName ");
    var tableinfo = kony.sync.getTableInfo(tableName);
    return !kony.sync.isNullOrUndefined(tableinfo);
};
kony.sync.validateBinaryColumn = function(tableName, columnName) {
    sync.log.trace("Entering kony.sync.validateBinaryColumn ");
    var downloadPolicy = kony.sync.getDownloadPolicy(tableName, columnName);
    if (downloadPolicy === kony.sync.notSupported) {
        return false;
    }
    return true;
};
kony.sync.getPrimaryKeyColumns = function(tableName) {
    sync.log.trace("Entering kony.sync.getPrimaryKeyColumns ");
    var scopename = kony.sync.scopes.syncTableScopeDic[tableName];
    var scope = kony.sync.scopes[scopename];
    return scope.syncTableDic[tableName].Pk_Columns;
};
//  **************** End KonySyncBlobUtils.js*******************
//  **************** Start KonySyncChunkingHelper.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
//Checks whether download response is eligible for chunking or not
kony.sync.eligibleForChunking = function(result) {
    sync.log.trace("Entering kony.sync.eligibleForChunking");
    if (!kony.sync.isNull(result.opstatus) && result.opstatus != 0) {
        return false;
    }
    return (!kony.sync.isNull(result.d) && result.d.error === "false" && !kony.sync.isNull(result.d.__sync[kony.sync.payloadIdKey]));
};
//Add chunk info in metatable
kony.sync.startChunking = function(url, serviceParams, result, callback) {
    sync.log.trace("Entering kony.sync.startChunking");
    sync.log.info("storing payload info in konysyncchunkmetainfo");
    var isError = false;
    var payloadId = result.d.__sync[kony.sync.payloadIdKey];
    var chunkCount = result.d.__sync[kony.sync.chunkCountKey];
    var hashSum = result.d.__sync[kony.sync.chunkHashSum];
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, transactionFailedCallback);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, transactionCallback, transactionFailedCallback, transactionSuccessCallback);
    }

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.startChunking->transactionCallback");
        //clear meta data from chunking table
        if (kony.sync.clearChunkMetaData(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
            isError = true;
            return;
        }
        //store payload info in konysyncchunkmetainfo
        var values = {};
        values[kony.sync.metaTablePayloadId] = payloadId;
        values[kony.sync.metaTableChunkSize] = kony.sync.getChunkSize();
        values[kony.sync.metaTableChunkAck] = kony.sync.chunkNotAcknowledged;
        values[kony.sync.metaTableChunkHashSum] = hashSum;
        values[kony.sync.metaTableChunkDiscarded] = kony.sync.chunkNotDiscarded;
        values[kony.sync.metaTableChunkCount] = chunkCount;
        values[kony.sync.metaTableScopeColumn] = kony.sync.currentScope[kony.sync.scopeName];
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_set(query, values);
        kony.sync.qb_insert(query, kony.sync.chunkMetaTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            isError = true;
        }
    }
    //call callback with framed error
    function transactionFailedCallback() {
        sync.log.trace("Entering kony.sync.startChunking->transactionFailedCallback");
        if (isError) {
            sync.log.error("Error occurred while inserting chunk information in metatable");
            callback(kony.sync.frameDownloadError(null, null, 1));
        } else {
            var errMsg = "Error occurred while opening transaction to store chunk information in metatable";
            sync.log.error(errMsg);
            callback(kony.sync.frameDownloadError(null, errMsg, 2));
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.startChunking->transactionSuccessCallback");
        kony.sync.downloadChunks(url, serviceParams, payloadId, chunkCount, hashSum, result, false, null, callback);
    }
};
//Starts Chunking
kony.sync.downloadChunks = function(url, serviceParams, payloadId, chunkCount, hashSum, initialData, isResumed, downloadedChunks, callback) {
    sync.log.trace("Entering kony.sync.downloadChunks ");
    if (kony.sync.isSyncStopped) {
        kony.sync.stopSyncSession();
        return;
    }
    var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
    var serverParams = {};
    serviceParams[kony.sync.payloadIdKey] = payloadId;
    serviceParams[kony.sync.chunkCountKey] = chunkCount.toString();
    sync.log.trace("kony.sync.downloadChunks chunkCount " + chunkCount + " and downloadedChunks ", downloadedChunks);
    var noOfParallelCalls = 1;
    //temporarily disabling parallel calls
    /*if(!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey])){
    	if(kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey] > 0){
    		noOfParallelCalls = kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey];
    	}
    }*/
    //sync.log.info("Maximum parallel chunks:" + noOfParallelCalls);
    var chunkingFailed = 0;
    var chunkProcessed = 0;
    var chunkErrorMap = {};
    var utf8data = null;
    var corruptedData = false;
    var callNo = 0;
    var infoObj = {};
    var chunkMap;
    var i = null;
    var areAllChunksDownloaded = true; //flag to check if all the chunks are downloaded,
    //process first chunk if chunking is not resumed from an earlier point
    sync.log.trace("kony.sync.downloadChunks isResumed ", isResumed);
    if (!isResumed) {
        downloadNetworkCallback(initialData, 1);
    }
    /*if(!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey])){
    	//infoObj[kony.sync.numberOfRetriesKey] = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
    }*/
    if (isResumed) {
        //find the remaining ids
        //create map for all the ids
        sync.log.trace("kony.sync.downloadChunks - isResumed true for chunkCount " + chunkCount + " with downloadedChunks ", downloadedChunks);
        var chunkMap = [];
        for (var i = 1; i <= chunkCount; i++) {
            chunkMap[i] = 0; //initially set 0 for all the ids
        }
        for (var i = 0; i < downloadedChunks.length; i++) {
            sync.log.trace("kony.sync.downloadChunks process chunks ", downloadedChunks);
            chunkMap[downloadedChunks[i]] = 1; //set 1 for downloaded ids
            chunkProcessed++; //count processed chunks
        }
        i = 1;
        for (callNo = 1; callNo <= chunkCount; callNo++) {
            if (chunkMap[callNo] === 0) {
                areAllChunksDownloaded = false; //all the chunks are not downloaded. Disabling the flag.
                infoObj[kony.sync.chunkNoKey] = callNo.toString();
                serviceParams[kony.sync.chunkNoKey] = callNo.toString();
                kony.sync.callOnChunkStart(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], callNo, serviceParams);
                sync.log.info("Hitting the service with URL :" + url + " with params:" + JSON.stringify(serviceParams));
                retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
                kony.sync.invokeServiceAsync(url, serviceParams, downloadNetworkCallbackStatus, infoObj);
                if (i >= noOfParallelCalls) {
                    callNo++;
                    break;
                }
                i++;
            }
        }
    } else {
        for (callNo = 2; callNo <= chunkCount; callNo++) {
            areAllChunksDownloaded = false; //all the chunks are not downloaded. disabling the flag.
            infoObj[kony.sync.chunkNoKey] = callNo.toString();
            serviceParams[kony.sync.chunkNoKey] = callNo.toString();
            kony.sync.callOnChunkStart(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], callNo, serviceParams);
            sync.log.info("Hitting the service with URL :" + url + " with params:" + JSON.stringify(serviceParams));
            retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
            kony.sync.invokeServiceAsync(url, serviceParams, downloadNetworkCallbackStatus, infoObj);
            if (callNo > noOfParallelCalls) {
                callNo++;
                break;
            }
        }
    }
    //All the chunks have been downloaded. Start processing them
    if (areAllChunksDownloaded === true) {
        sync.log.trace("kony.sync.downloadChunks -> All the chunks are downloaded.. Starting the processing");
        kony.sync.getChunksFromDB(payloadId, chunkCount, kony.sync.currentScope[kony.sync.scopeName], chunkDataProcessCallback);
    }

    function downloadNetworkCallbackStatus(status, result, info) {
        sync.log.trace("Entering kony.sync.downloadChunks->downloadNetworkCallbackStatus with status " + status + " result " + JSON.stringify(result) + " info ", info);
        if (status === 400) {
            sync.log.info("Got Response for Chunk No:" + info[kony.sync.chunkNoKey]);
            //fallback when opstatus < 0
            if (result.opstatus < 0) {
                sync.log.info("Got result.opstatus:" + result.opstatus + " and result.errcode:" + result.errcode + "setting errcode to opstatus");
                result.opstatus = result.errcode;
            }
            if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                retries--;
                kony.sync.retryServiceCall(url, result, info, retries, downloadNetworkCallback, serviceParams);
            } else {
                kony.sync.setSessionID(result);
                downloadNetworkCallback(result, info[kony.sync.chunkNoKey]);
            }
        } else if (status === 300) {
            sync.log.warn("Got status 300 for Chunk, Network call Cancelled.");
            if (!kony.sync.isNullOrUndefined(retries) && (retries > 0)) {
                retries--;
                if (kony.sync.isNullOrUndefined(info)) {
                    info = {};
                }
                info.retryOnNetworkCancel = true;
                sync.log.debug("Retrying the network call for status 300 ");
                if (kony.sync.isNullOrUndefined(result)) {
                    result = kony.sync.getNetworkCancelError();
                }
                kony.sync.retryServiceCall(url, result, info, retries, downloadNetworkCallback, serviceParams);
            } else {
                downloadNetworkCallback(kony.sync.getNetworkCancelError(), info[kony.sync.chunkNoKey]);
            }
        }
    }

    function isChunkPayloadIdInvalid(result) {
        sync.log.trace("Entering isChunkPayloadIdInvalid");
        if (!kony.sync.isNullOrUndefined(result) && !kony.sync.isNullOrUndefined(result.d)) {
            if ((result.d.error === "true") && (result.d.errcode === kony.sync.servercodes.chunkPayloadIdInvalid)) {
                return true;
            }
        }
        return false;
    }

    function clearChunkMetaDataAndAllChunksSuccessCallback() {
        sync.log.trace("Entering clearChunkMetaDataAndAllChunksSuccessCallback");
        kony.sync.syncDownloadChanges(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.downloadCompletedCallback);
    }

    function clearChunkMetaDataAndAllChunksErrorCallback(error) {
        sync.log.trace("Entering clearChunkMetaDataAndAllChunksErrorCallback");
        kony.sync.downloadFailed(error);
    }

    function downloadNetworkCallback(result, info) {
        sync.log.trace("Entering kony.sync.downloadChunks->downloadNetworkCallback with result " + JSON.stringify(result) + " " + "info -> ", info);
        serverParams[kony.sync.hostName] = kony.sync.getServerDetailsHostName(result);
        serverParams[kony.sync.ipAddress] = kony.sync.getServerDetailsIpAddress(result);
        var chunkId = info;
        if (kony.sync.isValidJSTable(info)) {
            chunkId = info[kony.sync.chunkNoKey];
        }
        if (isChunkPayloadIdInvalid(result)) {
            sync.log.trace(" Chunk PayloadId is Invalid : " + payloadId);
            chunkingFailed++;
            kony.sync.callOnChunkError(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], chunkId, chunkCount - chunkProcessed, chunkProcessed, kony.sync.errorCodeChunkInvalidPayloadId, result.d.msg, serverParams);
            kony.sync.clearChunkMetaDataAndAllChunks(payloadId, kony.sync.currentScope[kony.sync.scopeName], clearChunkMetaDataAndAllChunksSuccessCallback, clearChunkMetaDataAndAllChunksErrorCallback);
        } else {
            if (callNo <= chunkCount) {
                if (!isResumed) {
                    if (callNo !== 0) {
                        infoObj[kony.sync.chunkNoKey] = callNo.toString();
                        serviceParams[kony.sync.chunkNoKey] = callNo.toString();
                        kony.sync.callOnChunkStart(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], callNo, serviceParams);
                        sync.log.info("Hitting the service with URL :" + url + " with params:", serviceParams);
                        retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
                        kony.sync.invokeServiceAsync(url, serviceParams, downloadNetworkCallbackStatus, infoObj);
                        callNo++;
                    }
                } else {
                    for (; callNo <= chunkCount; callNo++) {
                        if (chunkMap[callNo] === 0) {
                            infoObj[kony.sync.chunkNoKey] = callNo.toString();
                            serviceParams[kony.sync.chunkNoKey] = callNo.toString();
                            kony.sync.callOnChunkStart(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], callNo, serviceParams);
                            sync.log.info("Hitting the service with URL :" + url + " with params:", serviceParams);
                            retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
                            kony.sync.invokeServiceAsync(url, serviceParams, downloadNetworkCallbackStatus, infoObj);
                            if (callNo >= noOfParallelCalls + 1) {
                                callNo++;
                                break;
                            }
                        }
                    }
                }
            }
            if (!kony.sync.isNull(result.opstatus) && result.opstatus != 0) {
                chunkingFailed++;
                sync.log.error("Error occurred while downloading chunks: Code=" + result.opstatus + ", message=" + result.errmsg);
                chunkErrorMap[chunkId] = result.errmsg;
                kony.sync.callOnChunkError(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], chunkId, chunkCount - chunkProcessed, chunkProcessed, result.opstatus, result.errmsg, serverParams);
                if (allChunksProcessed()) {
                    handleError();
                }
            } else if (result.d.error === "true") {
                chunkingFailed++;
                sync.log.error("Error occurred while downloading chunks: message=" + result.d.msg);
                chunkErrorMap[chunkId] = result.d.msg;
                kony.sync.callOnChunkError(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], chunkId, chunkCount - chunkProcessed, chunkProcessed, kony.sync.errorCodeUnknownServerError, result.d.msg, serverParams);
                if (allChunksProcessed()) {
                    handleError();
                }
            } else {
                //store in local DB
                kony.sync.storeChunkInDB(payloadId, chunkId, result.d[kony.sync.chunkDataKey], kony.sync.currentScope[kony.sync.scopeName], chunkDataStoredCallback);
                if (allChunksProcessed()) {
                    handleError();
                }
            }
        }
    }

    function allChunksProcessed() {
        sync.log.trace("allChunksProcessed chunkProcessed " + chunkProcessed + " chunkingFailed " + chunkingFailed + " chunkCount " + chunkCount);
        var areAllChunksProcessed = (chunkProcessed + chunkingFailed === chunkCount);
        sync.log.trace("allChunksProcessed result " + areAllChunksProcessed);
        return areAllChunksProcessed;
    }

    function handleError() {
        sync.log.info("All chunking calls for current batch with total of " + chunkCount + " completed.")
        if (chunkProcessed > 0) {
            sync.log.info("Chunks successfully downloaded and stored in DB:" + chunkProcessed);
        }
        //error occurred in one or more chunks
        if (chunkingFailed > 0) {
            sync.log.error("Chunks failed either to downloaded or while storing in DB:" + chunkingFailed);
            //frame error
            var framedErrorResponse = kony.sync.frameDownloadError(kony.sync.getErrorMessage(kony.sync.errorCodeChunking), chunkErrorMap, null, kony.sync.errorCodeChunking);
            sync.log.error(kony.sync.getErrorMessage(kony.sync.errorCodeChunking), chunkErrorMap);
            //call download complete callback with error
            callback(framedErrorResponse);
            return false;
        } else {
            return true;
        }
    }

    function chunkDataStoredCallback(chunkId, errorMap) {
        sync.log.trace("Entering kony.sync.downloadChunks->chunkDataStoredCallback");
        //if error, add to errorMap
        if (!kony.sync.isNull(errorMap)) {
            sync.log.error("chunkDataStoredCallback errorMap incrementing chunkingFailed. ", errorMap);
            chunkingFailed++;
            chunkErrorMap[chunkId] = errorMap.errorCode;
            sync.log.error("Error occurred while storing chunk " + chunkId + " in DB");
            kony.sync.callOnChunkError(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], chunkId, chunkCount - chunkProcessed, chunkProcessed, errorMap.errorCode, errorMap.errorMessage, serverParams, errorMap.errorInfo);
        } else {
            chunkProcessed++;
            sync.log.trace("chunkDataStoredCallback incrementing number of chunks processed.." + chunkProcessed);
            kony.sync.callOnChunkSuccess(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], chunkId, chunkCount - chunkProcessed, chunkProcessed, serverParams);
        }
        sync.log.trace("chunkDataStoredCallback - calling allChunksProcessed ");
        if (allChunksProcessed() && handleError()) {
            //gather all results from chunkMap
            sync.log.trace("chunkDataStoredCallback allChunksProcessed true and handleError true");
            kony.sync.getChunksFromDB(payloadId, chunkCount, kony.sync.currentScope[kony.sync.scopeName], chunkDataProcessCallback);
        }
        /*else {
			sync.log.error("chunkDataStoredCallback Either allChunksProcessed or handleError is not true..");
			var errorObj = kony.sync.getErrorTable(kony.sync.errorCodeChunking, kony.sync.getErrorMessage(kony.sync.errorCodeChunking));
			sync.log.error("Error in chunking ", errorObj);

			//call download complete callback with error
			callback(errorObj);
		}*/
    }

    function chunkDataProcessCallback(data, isError, errorType) {
        sync.log.trace("Entering kony.sync.downloadChunks->chunkDataProcessCallback");
        //error occurred while retrieving info
        if (isError) {
            //frame error
            sync.log.error(kony.sync.getErrorMessage(kony.sync.errorCodeChunking), data);
            var framedErrorResponse = null;
            if (errorType === 1 || errorType === 2) {
                framedErrorResponse = kony.sync.frameDownloadError(null, null, errorType);
            } else {
                framedErrorResponse = kony.sync.frameDownloadError(kony.sync.getErrorMessage(kony.sync.errorCodeChunking), data, null, kony.sync.errorCodeChunking);
            }
            //call download complete callback with error
            callback(framedErrorResponse);
        }
        //all chunks downloaded successfully
        else {
            utf8data = data;
            //calculate checksum hash of utf8data;
            var checksum = kony.sync.createHash("sha256", utf8data);
            //compare checksum with server sent hashsum;
            if (!kony.string.equalsIgnoreCase(checksum, hashSum)) {
                sync.log.error("Received corrupted chunk data for payloadId= " + payloadId + ", clearing erroneous chunks from db.");
                corruptedData = true;
            }
            //release checksum
            checksum = null;
            //clear the payload from metainfo;
            kony.sync.clearChunkForPayload(payloadId, kony.sync.currentScope[kony.sync.scopeName], corruptedData, chunkDataClearback);
        }
    }

    function chunkDataClearback(data, isError) {
        sync.log.trace("Entering kony.sync.downloadChunks->chunkDataClearback");
        //error occurred while clearing chunkInfo
        if (isError || corruptedData) {
            //create error message
            var errMsg = "Following errors occurred:";
            if (isError) {
                errMsg += "Error occurred while clearing chunk information from DB";
            }
            if (corruptedData) {
                if (isError) {
                    errMsg += ", ";
                }
                errMsg += "Received corrupted chunk data for payloadId= " + payloadId;
            }
            errMsg += ".";
            sync.log.error(errMsg);
            //frame error
            var framedErrorResponse = kony.sync.frameDownloadError(errMsg, data, null, kony.sync.errorCodeChunking);
            //call download complete callback with error
            callback(framedErrorResponse);
        } else {
            //convert json string to json object
            var myJsonObject = null;
            try {
                myJsonObject = JSON.parse(utf8data);
            } catch (e) {
                var errMsg = kony.sync.getErrorMessage(kony.sync.errorCodeParseError, utf8data, e);
                sync.log.error(errMsg);
                myJsonObject = null;
                utf8data = null;
                callback(kony.sync.frameDownloadError(errMsg, e, null, kony.sync.errorCodeParseError));
                return;
            }
            utf8data = null;
            //call the callback with final result			
            callback(myJsonObject);
        }
    }
};
//framing download error
kony.sync.frameDownloadError = function(errorMessage, errorInfo, dbError, errorCode) {
    sync.log.trace("Entering kony.sync.frameDownloadError");
    var result = {};
    result.d = {};
    result.d.error = "true";
    if (dbError === 1) { //statement error
        result.d.opstatus = kony.sync.errorObject.errorCode;
        result.d.msg = kony.sync.errorObject.errorMessage;
        result.d.errorInfo = kony.sync.errorObject.errorInfo;
    } else if (dbError === 2) { //transaction error
        result.d.opstatus = kony.sync.errorCodeTransaction;
        result.d.msg = kony.sync.getErrorMessage(kony.sync.errorCodeTransaction);
        result.d.errorInfo = kony.sync.errorObject.errorInfo;
        sync.log.error(result.d.msg);
    } else {
        result.d.msg = errorMessage;
        result.d.errorInfo = errorInfo;
        result.d.opstatus = errorCode;
    }
    return result;
};
//This method will store chunks in DB
kony.sync.storeChunkInDB = function(payloadId, chunkId, chunkData, scopeName, callback, storedChunkCallback) {
    sync.log.trace("Entering kony.sync.storeChunkInDB for chunkId " + chunkId);
    var isError = false;
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.storeChunkInDB->transactionCallback for chunkID " + chunkId);
        sync.log.trace("kony.sync.storeChunkInDB - payloadId -> " + payloadId + " chunkId -> " + chunkId + " chunkData -> ", chunkData);
        //check for dupicate chunks
        var wcs = [];
        wcs.push({
            key: kony.sync.metaTableScopeColumn,
            value: scopeName
        });
        wcs.push({
            key: kony.sync.chunkTableChunkId,
            value: chunkId
        });
        wcs.push({
            key: kony.sync.chunkTablePayloadId,
            value: payloadId
        });
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_where(query, wcs);
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, kony.sync.chunkTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultset = kony.sync.executeSql(tx, sql, params);
        sync.log.trace("kony.sync.storeChunkInDB - resultset for check duplicate counts ", resultset);
        if (resultset === null || resultset === false) {
            isError = true;
            return;
        }
        if (resultset.rows.length > 0) {
            //ignore the chunk as it is already stored by some earlier call
            return;
        }
        //store chunk into DB
        var values = {};
        values[kony.sync.chunkTableChunkData] = chunkData;
        values[kony.sync.chunkTableChunkId] = chunkId;
        values[kony.sync.chunkTablePayloadId] = payloadId;
        values[kony.sync.metaTableScopeColumn] = scopeName;
        values[kony.sync.chunkTableTimeStamp] = (new Date()).toString();
        query = kony.sync.qb_createQuery();
        kony.sync.qb_set(query, values);
        kony.sync.qb_insert(query, kony.sync.chunkTableName);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        var storeChunkResultSet = kony.sync.executeSql(tx, sql, params);
        sync.log.trace("kony.sync.storeChunkInDB - resultset storing chunk into db ", storeChunkResultSet);
        if (storeChunkResultSet === false || storeChunkResultSet === null) {
            isError = true;
        }
    }

    function transactionFailedCallback() {
        sync.log.trace("Entering kony.sync.storeChunkInDB->transactionFailedCallback");
        callback(chunkId, kony.sync.getTransactionError(isError));
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.storeChunkInDB->transactionSuccessCallback");
        callback(chunkId);
    }
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, transactionFailedCallback);
    if (dbconnection !== null) {
        sync.log.trace("kony.sync.storeChunkInDb - dbConnection successful");
        kony.db.transaction(dbconnection, transactionCallback, transactionFailedCallback, transactionSuccessCallback);
    }
};
//This method will retrieve all chunks from DB
kony.sync.getChunksFromDB = function(payloadId, chunkCount, scopeName, callback) {
    sync.log.trace("Entering kony.sync.getChunksFromDB");
    var isError = false;
    var base64 = "";
    var unknownError = "";
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, transactionFailedCallback);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, transactionCallback, transactionFailedCallback, transactionSuccessCallback);
    }

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.getChunksFromDB->transactionCallback");
        var wcs = [];
        wcs.push({
            key: kony.sync.metaTableScopeColumn,
            value: scopeName
        });
        wcs.push({
            key: kony.sync.chunkTablePayloadId,
            value: payloadId
        });
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_where(query, wcs);
        kony.sync.qb_select(query, null);
        kony.sync.qb_orderBy(query, [{
            key: kony.sync.chunkTableChunkId,
            sortType: "asc"
        }]);
        kony.sync.qb_from(query, kony.sync.chunkTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultset = kony.sync.executeSql(tx, sql, params);
        if (resultset === false) {
            isError = true;
            return;
        }
        if (resultset.rows.length !== chunkCount) {
            //should never reach here
            unknownError = "Unknown Error: Chunks in DB(" + resultset.rows.length + ") are not equal to chunkcount(" + chunkCount + ")";
            sync.log.error(unknownError);
            isError = true;
            return;
        }
        for (var i = 0; i < resultset.rows.length; i++) {
            var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, i);
            base64 = base64 + rowItem[kony.sync.chunkTableChunkData];
        }
    }

    function transactionFailedCallback() {
        sync.log.trace("Entering kony.sync.getChunksFromDB->transactionFailedCallback");
        callback(null, true, isError === true ? 1 : 2);
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.getChunksFromDB->transactionSuccessCallback");
        if (isError) {
            callback(unknownError, true);
        } else {
            callback(base64, false);
        }
    }
};
//clear chunking info from DB
kony.sync.clearChunkForPayload = function(payloadId, scopeName, chunkError, callback) {
    sync.log.trace("Entering kony.sync.clearChunkForPayload");
    var isError = false;
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, transactionFailedCallback);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, transactionCallback, transactionFailedCallback, transactionSuccessCallback);
    }

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.clearChunkForPayload->transactionCallback");
        //set complete flag in metainfo table
        var values = {};
        values[kony.sync.metaTableChunkAck] = kony.sync.chunkCompleteButNotAcknowledged;
        //if problem occurred while chunking, mark discard flag for next download
        if (chunkError === true) {
            values[kony.sync.metaTableChunkDiscarded] = kony.sync.chunkDiscarded;
        }
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_set(query, values);
        kony.sync.qb_update(query, kony.sync.chunkMetaTableName);
        kony.sync.qb_where(query, [{
            key: kony.sync.metaTableScopeColumn,
            value: scopeName
        }]);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            isError = true;
            return;
        }
        //clearing chunkdata from chunk table
        var wcs = [];
        wcs.push({
            key: kony.sync.metaTableScopeColumn,
            value: scopeName
        });
        wcs.push({
            key: kony.sync.chunkTablePayloadId,
            value: payloadId
        });
        query = kony.sync.qb_createQuery();
        kony.sync.qb_where(query, wcs);
        kony.sync.qb_delete(query, kony.sync.chunkTableName);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            isError = true;
            return;
        }
    }

    function transactionFailedCallback() {
        sync.log.trace("Entering kony.sync.clearChunkForPayload->transactionFailedCallback");
        var errMsg = "";
        if (isError) {
            errMsg = "Error occurred while clearing chunk information from " + kony.sync.chunkTableName;
            callback({
                "errorCode": kony.sync.errorCodeSQLStatement,
                "errorMessage": errMsg
            }, true);
        } else {
            errMsg = "Error occurred while opening transaction for clearing chunk information from " + kony.sync.chunkTableName;
            callback({
                "errorCode": kony.sync.errorCodeTransaction,
                "errorMessage": errMsg
            }, true);
        }
        sync.log.error(errMsg);
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.clearChunkForPayload->transactionSuccessCallback");
        callback(null, false);
    }
};
kony.sync.getChunkSize = function() {
    sync.log.trace("Entering kony.sync.getChunkSize");
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.chunkSizeKey])) {
        return kony.sync.currentSyncConfigParams[kony.sync.chunkSizeKey].toString();
    }
};
//This API checks whether chunking should be called before download or not
kony.sync.checkForChunkingBeforeDownload = function(serverblob, normalDownloadCallback, downloadNetworkCallback, schemaUpgradeServerblob) {
    sync.log.trace("Entering kony.sync.checkForChunkingBeforeDownload");
    var scopeName = kony.sync.currentScope[kony.sync.scopeName];
    var isError = false;
    var chunkingResumed = 0;
    var lastsynctime = serverblob;
    var chunkData = [];
    var chunkMetaData = null;
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, transactionFailedCallback);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, transactionCallback, transactionFailedCallback, transactionSuccessCallback);
    }

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.checkForChunkingBeforeDownload->transactionCallback");
        var wcs = [];
        wcs.push({
            key: kony.sync.metaTableScopeColumn,
            value: scopeName
        });
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_where(query, wcs);
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, kony.sync.chunkMetaTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultset = kony.sync.executeSql(tx, sql, params);
        if (resultset === false) {
            isError = true;
            return;
        }
        if (resultset.rows.length > 0) {
            var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
            var pendingAck = rowItem[kony.sync.metaTableChunkAck];
            var chunkDiscarded = rowItem[kony.sync.metaTableChunkDiscarded];
            if (pendingAck === 0 && chunkDiscarded === 0) {
                chunkingResumed = 1; //resume chunking				
            } else {
                chunkingResumed = 2; //just send payloadid for acknowledgement
            }
            chunkMetaData = rowItem; //get meta data
            if (chunkingResumed === 2 && pendingAck !== kony.sync.chunkCompleteAndWaitingForAck) {
                //updating metadata status as sent for acknowledgement
                var values = {};
                values[kony.sync.metaTableChunkAck] = kony.sync.chunkCompleteAndWaitingForAck;
                query = kony.sync.qb_createQuery();
                kony.sync.qb_where(query, wcs);
                kony.sync.qb_set(query, values);
                kony.sync.qb_update(query, kony.sync.chunkMetaTableName);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                resultset = kony.sync.executeSql(tx, sql, params);
                if (resultset === false) {
                    isError = true;
                    return;
                }
            }
            //get chunk ids for that payloadid
            wcs = [];
            wcs.push({
                key: kony.sync.metaTableScopeColumn,
                value: scopeName
            });
            wcs.push({
                key: kony.sync.chunkTablePayloadId,
                value: rowItem[kony.sync.metaTablePayloadId]
            });
            query = kony.sync.qb_createQuery();
            kony.sync.qb_select(query, [kony.sync.chunkTableChunkId]);
            kony.sync.qb_where(query, wcs);
            kony.sync.qb_from(query, kony.sync.chunkTableName);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            resultset = kony.sync.executeSql(tx, sql, params);
            if (resultset === false) {
                isError = true;
                return;
            }
            for (var i = 0; i < resultset.rows.length; i++) {
                rowItem = kony.db.sqlResultsetRowItem(tx, resultset, i);
                chunkData[i] = rowItem[kony.sync.chunkTableChunkId];
            }
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.checkForChunkingBeforeDownload->transactionSuccessCallback");
        if (chunkingResumed === 1) {
            //continue chunking from last point
            var params = kony.sync.getChunkingParams(lastsynctime, schemaUpgradeServerblob);
            var hashSum = chunkMetaData[kony.sync.metaTableChunkHashSum];
            var chunkCount = chunkMetaData[kony.sync.metaTableChunkCount];
            var payloadId = chunkMetaData[kony.sync.metaTablePayloadId];
            kony.sync.globalIsDownloadStarted = false;
            kony.sync.isChunkingResumedPostSyncError = true;
            kony.sync.downloadChunks(kony.sync.getChunkDownloadURL(), params, payloadId, chunkCount, hashSum, null, true, chunkData, downloadNetworkCallback);
        } else if (chunkingResumed === 2) {
            normalDownloadCallback(chunkMetaData[kony.sync.metaTablePayloadId]);
        } else {
            //proceed with normal download
            normalDownloadCallback();
        }
    }

    function transactionFailedCallback() {
        sync.log.trace("Entering kony.sync.checkForChunkingBeforeDownload->transactionFailedCallback");
        var errMsg = "";
        if (isError) {
            errMsg = "Error occurred while inserting chunk information in metatable";
            downloadNetworkCallback(kony.sync.frameDownloadError(null, errMsg, 1));
        } else {
            errMsg = "Error occurred while opening transaction to store chunk information in metatable";
            downloadNetworkCallback(kony.sync.frameDownloadError(null, errMsg, 2));
        }
        sync.log.error(errMsg);
    }
};
kony.sync.getChunkingParams = function(serverblob, schemaUpgradeServerblob) {
    sync.log.trace("Entering kony.sync.getChunkingParams");
    //create params
    if (kony.sync.isNullOrUndefined(serverblob)) {
        serverblob = "";
    }
    var params = {};
    kony.sync.commonServiceParams(params);
    if (kony.sync.schemaUpgradeDownloadPending) {
        params.tickcount = schemaUpgradeServerblob;
        params.uppertickcount = serverblob;
        if (!kony.sync.isNullOrUndefined(kony.sync.schemaUpgradeContext)) {
            params.upgradecontext = kony.sync.schemaUpgradeContext;
        }
    } else {
        params.tickcount = serverblob;
    }
    params.clientid = kony.sync.getDeviceID();
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
        params.httpconfig = {
            timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
        };
    }
    return params;
};
//API to abort all pending chunk requests
sync.cancelPendingChunkRequests = function(successcallback, errorcallback) {
    sync.log.trace("Entering kony.sync.cancelPendingChunkRequests");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return;
    }
    var isError = false;
    var dbname = kony.sync.scopes[0][kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, transactionFailedCallback);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, transactionCallback, transactionFailedCallback, transactionSuccessCallback);
    }

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.cancelPendingChunkRequests->transactionCallback");
        //change status in metatable to discarded
        var values = {};
        values[kony.sync.metaTableChunkDiscarded] = kony.sync.chunkDiscarded;
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_set(query, values);
        kony.sync.qb_update(query, kony.sync.chunkMetaTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            isError = true;
        }
        //delete pending chunks from chunk table
        query = kony.sync.qb_createQuery();
        kony.sync.qb_delete(query, kony.sync.chunkTableName);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            isError = true;
            return;
        }
    }

    function transactionFailedCallback() {
        sync.log.trace("Entering kony.sync.cancelPendingChunkRequests->transactionFailedCallback");
        kony.sync.callTransactionError(errorcallback, isError);
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.cancelPendingChunkRequests->transactionSuccessCallback");
        kony.sync.verifyAndCallClosure(successcallback);
    }
};
//This will delete chunk data from metatable after receiving acknowledgement
kony.sync.clearChunkMetaData = function(tx, scopeName) {
    sync.log.trace("Entering kony.sync.clearChunkMetaData");
    var wcs = [];
    wcs.push({
        key: kony.sync.metaTableScopeColumn,
        value: scopeName
    });
    wcs.push({
        key: kony.sync.metaTableChunkAck,
        value: kony.sync.chunkCompleteAndWaitingForAck
    });
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_where(query, wcs);
    kony.sync.qb_delete(query, kony.sync.chunkMetaTableName);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
kony.sync.callOnChunkStart = function(chunkCount, payloadId, scope, chunkid, chunkRequest) {
    sync.log.trace("Entering kony.sync.callOnChunkStart");
    var params = {};
    params[kony.sync.chunkCountKey] = chunkCount.toString();
    params[kony.sync.payloadIdKey] = payloadId;
    params[kony.sync.metaTableScopeColumn] = scope;
    params[kony.sync.chunkTableChunkId] = chunkid;
    params[kony.sync.chunkRequestKey] = chunkRequest;
    return kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onChunkStart], params);
};
kony.sync.callOnChunkSuccess = function(chunkCount, payloadId, scope, chunkid, pendingChunks, chunksDownloaded, serverParams) {
    sync.log.trace("Entering kony.sync.callOnChunkSuccess");
    var params = {};
    params[kony.sync.chunkCountKey] = chunkCount.toString();
    params[kony.sync.payloadIdKey] = payloadId;
    params[kony.sync.metaTableScopeColumn] = scope;
    params[kony.sync.chunkTableChunkId] = chunkid;
    params[kony.sync.pendingChunksKey] = pendingChunks;
    params[kony.sync.chunksDownloadedKey] = chunksDownloaded;
    params[kony.sync.serverDetails] = serverParams;
    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onChunkSuccess], params);
};
kony.sync.callOnChunkError = function(chunkCount, payloadId, scope, chunkid, pendingChunks, chunksDownloaded, errorCode, errorMsg, serverParams, errorInfo) {
    sync.log.trace("Entering kony.sync.callOnChunkError");
    var params = {};
    params[kony.sync.chunkCountKey] = chunkCount.toString();
    params[kony.sync.payloadIdKey] = payloadId;
    params[kony.sync.metaTableScopeColumn] = scope;
    params[kony.sync.chunkTableChunkId] = chunkid;
    params[kony.sync.pendingChunksKey] = pendingChunks;
    params[kony.sync.chunksDownloadedKey] = chunksDownloaded;
    params.errorCode = errorCode;
    params.errorMessage = errorMsg;
    params[kony.sync.serverDetails] = serverParams;
    params.errorInfo = errorInfo;
    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onChunkError], params);
};
kony.sync.clearChunkMetaDataAndAllChunks = function(payloadId, scopeName, successCallback, errorCallback) {
        sync.log.trace("Entering kony.sync.clearAllChunksAndChunkMetaData");
        var isError = false;
        var dbName = kony.sync.currentScope[kony.sync.scopeDataSource];
        var dbConnection = kony.sync.getConnectionOnly(dbName, dbName, transactionErrorCallback);
        if (dbConnection !== null) {
            kony.db.transaction(dbConnection, transactionCallback, transactionErrorCallback, transactionSuccessCallback);
        }

        function transactionCallback(tx) {
            //clearing metadata from konysyncCHUNKMETAINFO table for particular payloadId
            sync.log.trace("Entering kony.sync.clearAllChunksAndChunkMetaData->transactionCallback");
            var wcs = [];
            wcs.push({
                key: kony.sync.metaTableScopeColumn,
                value: scopeName
            });
            wcs.push({
                key: kony.sync.chunkTablePayloadId,
                value: payloadId
            });
            query = kony.sync.qb_createQuery();
            kony.sync.qb_where(query, wcs);
            kony.sync.qb_delete(query, kony.sync.chunkMetaTableName);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                isError = true;
                return;
            }
            //clearing all chunks from konysyncCHUNKDATA table for particular payloadId
            query = kony.sync.qb_createQuery();
            kony.sync.qb_where(query, wcs);
            kony.sync.qb_delete(query, kony.sync.chunkTableName);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                isError = true;
                return;
            }
        }

        function transactionErrorCallback() {
            sync.log.trace("Entering kony.sync.clearAllChunksAndChunkMetaData->transactionErrorCallback");
            if (isError) {
                sync.log.trace("Error occurred while deleting chunk data for invalid payloadid from konysyncCHUNKMETAINFO/konysyncCHUNKDATA");
            } else {
                sync.log.trace("Transaction occurred when deleting chunk data from konysyncCHUNKMETAINFO/konysyncCHUNKDATA");
            }
            errorCallback(isError);
        }

        function transactionSuccessCallback() {
            sync.log.trace("Entering kony.sync.clearAllChunksAndChunkMetaData->transactionSuccessCallback");
            successCallback();
        }
    }
    //  **************** End KonySyncChunkingHelper.js*******************
    //  **************** Start KonySyncDataReconciliation.js*******************
    //  **************** Start KonySyncDataReconciliation.js*******************
kony.sync.tempTableKey = "_tempReconciliation";
kony.sync.reconcileCacheKey = "_cacheReconciliation";
kony.sync.currentReconcileScopeIndex = null;
kony.sync.lastProcessedTables = {};
kony.sync.ReconcileErrorMessage = {};
kony.sync.reconcileBatchingBlobContext = {};
kony.sync.currentReconcileReturnParams = {};
kony.sync.reconcileObjectLevelInfoMap = {};
kony.sync.isReconciliationInProgress = false;
kony.sync.reconcileTotalDownloaded = 0;
kony.sync.reconcileTotalInserts = 0;
kony.sync.reconcileTotalDeletes = 0;
kony.sync.reconcilePendingScopes = {};
kony.sync.reconcilePendingRecords = [];
kony.sync.preProcessReconcileConfig = function(opname, config, errorcallback) {
    sync.log.trace("Entering kony.sync.preProcessReconcileConfig ");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return false;
    }
    if (!kony.sync.scopenameExist(config, errorcallback)) {
        return false;
    }
    if (kony.sync.isReconciliationInProgress) {
        sync.log.warn("Reconciliation Session already in progress...");
        kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeReconcileSessionInProgress, kony.sync.getErrorMessage(kony.sync.errorCodeReconcileSessionInProgress), null));
        return false;
    }
    if (kony.sync.isSessionInProgress) {
        sync.log.warn("Sync Session already in progress...");
        kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeSessionInProgress, kony.sync.getErrorMessage(kony.sync.errorCodeSessionInProgress), null));
        return false;
    }
    kony.sync.syncConfigurationDBName = konysyncClientSyncConfig.AppID;
    config.appVersion = kony.sync.configVersion; //konysyncClientSyncConfig.Version;
    kony.sync.currentSyncConfigParams = config;
    kony.sync.uploadClientContext = {};
    kony.sync.downloadClientContext = {};
    kony.sync.downloadReconcileClientContext = {};
    kony.sync.bulkGetDownloadReconcileClientContext = {};
    kony.sync.isReconciliationInProgress = true;
    sync.log.debug("Starting reconcile. " + opname + " with Current Config Params : ", config);
    kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey] = kony.sync.tonumber(kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey]);
    kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey] = kony.sync.tonumber(kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey]);
    kony.sync.resetsyncsessionglobals(opname);
};
//kony.sync.reconcile
sync.startReconciliation = function(config) {
    sync.log.trace("Entering sync.startReconciliation");
    if (kony.sync.validateSyncConfigParams("startReconciliation", config) === false) {
        return;
    }
    if (kony.sync.preProcessReconcileConfig("startReconciliation", config, config[kony.sync.onReconciliationError]) === false) {
        return;
    }

    function initReconcileMetaInfo(reconcileScopes) {
        sync.log.trace("Entering initReconcileMetaInfo");

        function initReconcileDictionaryForScope(scopeName) {
            sync.log.trace("Entering  initReconcileDictionaryForScope");
            if (kony.sync.isNullOrUndefined(kony.sync.reconcileScopes[scopeName])) {
                kony.sync.reconcileScopes[scopeName] = {};
            }
            if (kony.sync.isNullOrUndefined(kony.sync.reconcileScopes[scopeName].ReconcileTables)) {
                kony.sync.reconcileScopes[scopeName].ReconcileTables = [];
            }
        }
        //storing  reconcilation metadata for data reconciliation
        sync.log.trace("Entering function initReconcileMetaInfo")
        kony.sync.reconcileScopes = {};
        //array to store list of scopes to be iterated
        kony.sync.reconcileScopes.scopeList = [];
        if (!kony.sync.isEmptyObject(reconcileScopes)) {
            for (var scopeName in reconcileScopes) {
                //checking if the scope is undefined
                if (kony.sync.isNullOrUndefined(kony.sync.scopeDict[scopeName])) {
                    sync.log.error("scope:" + scopeName + " doesnot exists...");
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getErrorTable(kony.sync.errorCodeScopeDoesNotExist, kony.sync.getErrorMessage(kony.sync.errorCodeScopeDoesNotExist, scopeName), null));
                    return false;
                }
                var scopeTablesArray = reconcileScopes[scopeName];
                if (scopeTablesArray instanceof Array === false) {
                    sync.log.error("value of scope " + scopeName + " Array required ");
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getErrorTable(kony.sync.errorCodeInvalidReconcileConfig, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidReconcileConfig, scopeName), null));
                    return false;
                }
                var currentScope = kony.sync.scopeDict[scopeName];
                initReconcileDictionaryForScope(scopeName);
                if (scopeTablesArray.length == 0) {
                    for (var i = 0; i < currentScope.ScopeTables.length; i++) {
                        var syncTable = currentScope.ScopeTables[i];
                        var tablename = syncTable.name;
                        kony.sync.reconcileScopes[scopeName].ReconcileTables.push(syncTable.Name);
                    }
                } else {
                    for (var i = 0; i < scopeTablesArray.length; i++) {
                        var tableMap = scopeTablesArray[i];
                        if (tableMap instanceof Object === false) {
                            sync.log.error("value of table for " + scopeName + " for index" + i + " Object required ");
                            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getErrorTable(kony.sync.errorCodeInvalidReconcileConfig, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidReconcileConfig, scopeName), null));
                            return false;
                        }
                        for (tablename in tableMap) {
                            //checkiing if the table is undefined
                            if (kony.sync.isNullOrUndefined(kony.sync.scopes.syncTableScopeDic[tablename])) {
                                sync.log.error("table:" + tablename + " doesnot exists... in scope " + scopeName);
                                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getErrorTable(kony.sync.errorCodeTableDoesNotExist, kony.sync.getErrorMessage(kony.sync.errorCodeTableDoesNotExist, tablename, scopeName), null));
                                return false;
                            }
                            kony.sync.reconcileScopes[scopeName].ReconcileTables.push(tablename);
                        }
                    }
                }
                kony.sync.reconcileScopes.scopeList.push(scopeName);
            }
        } else {
            //reconcilescopes parameters is empty so reconciliation is done for all the scopes
            var syncscopes = kony.sync.scopes;
            for (var i = 0; i < kony.sync.scopes.length; i++) {
                var scopeName = syncscopes[i].ScopeName;
                initReconcileDictionaryForScope(scopeName);
                var currentScope = kony.sync.scopeDict[scopeName];
                if (!kony.sync.isNullOrUndefined(currentScope.ScopeTables)) {
                    for (var k = 0; k < currentScope.ScopeTables.length; k++) {
                        var syncTable = currentScope.ScopeTables[k];
                        var tablename = syncTable.Name;
                        kony.sync.reconcileScopes[scopeName].ReconcileTables.push(tablename);
                    }
                }
                kony.sync.reconcileScopes.scopeList.push(scopeName);
            }
        }
        return true; //successfully initialised
    }

    function validateReconcileConfig() {
        sync.log.trace("Entering validateReconcileConfig");
        if (config.hasOwnProperty("reconciliation") === true) {
            var reconcileScopes = config.reconciliation;
            var isError = initReconcileMetaInfo(reconcileScopes);
            if (isError === false) {
                kony.sync.isReconciliationInProgress = false;
                return;
            }
        } else {
            kony.sync.isReconciliationInProgress = false;
            sync.log.error("No reconciliation data is defined in the config");
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getErrorTable(kony.sync.errorReconcileKeyUndefined, kony.sync.getErrorMessage(kony.sync.errorReconcileKeyUndefined), null));
            return;
        }
        //After validations calling reconcilationstart callback
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationStart], config);
        var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, startReconcileErrorCallBack, "reconcile sync session");
        if (connection !== null) {
            kony.sync.startTransaction(connection, startReconcileTransactionCallBack, startReconcileSuccessCallBack, startReconcileErrorCallBack, "reconcile sync session");
        }
    }

    function startReconcileTransactionCallBack(tx) {
        sync.log.trace("Entering startReconcileTransactionCallBack");

        function createTempTables() {
            sync.log.trace("Entering function createTempTables ");
            //creating temp tables to store the downloaded data
            var scopeNames = kony.sync.reconcileScopes.scopeList;
            for (var i = 0; i < scopeNames.length; i++) {
                var scopeName = scopeNames[i];
                var reconcileTables = kony.sync.reconcileScopes[scopeName].ReconcileTables;
                for (var j = 0; j < reconcileTables.length; j++) {
                    var tableName = reconcileTables[j];
                    var sql = "create table " + tableName + "" + kony.sync.tempTableKey + " ( "
                    var scope = kony.sync.scopeDict[scopeName];
                    var syncTable = scope.syncTableDic[tableName];
                    var columns = syncTable.Columns;
                    var pkColumns = syncTable.Pk_Columns;
                    var pkCount = pkColumns.length;
                    for (var k = 0, pks = 0; k < columns.length; k++) {
                        var syncColumn = columns[k];
                        if (syncColumn.IsPrimaryKey === true) {
                            if (syncColumn.type === "string") {
                                var stringSize = syncColumn.Length;
                                if (kony.sync.isNullOrUndefined(stringSize)) {
                                    stringSize = 4000;
                                }
                                sql += syncColumn.Name + " nvarchar( " + stringSize + " ) not null ";
                            } else sql += syncColumn.Name + " " + syncColumn.type + " not null ";
                            if (pks != pkCount - 1) {
                                sql += ",";
                            } else {
                                sql += " )";
                            }
                            pks++;
                        }
                    }
                    if (kony.sync.executeSql(tx, sql) === false) {
                        sync.log.error("failure in creating temptable for table " + tableName)
                        isError = true;
                        return;
                    }
                }
            }
        }
        kony.sync.deleteReconcileTempTables(tx);
        createTempTables();
        kony.sync.resetReconcileGlobals();
    }

    function startReconcileSuccessCallBack() {
        sync.log.trace("Entering sync.startReconciliation SuccessCallBack : startReconcileSuccessCallBack ")
            //change scope settings
        kony.sync.currentReconcileScopeIndex = null; //null indicates starting scope
        kony.sync.validateReconcileSession(false);
        //kony.sync.syncDownloadReconcileScopes(null);
    }

    function startReconcileErrorCallBack() {
        sync.log.trace("Entering sync.startReconciliation ErrorCallBack : startReconcileErrorCallBack")
        kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
        kony.sync.callTransactionError(isError, kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError]);
        //call reconcileErrorCallBack with apt error
    }
    kony.sync.checkForRegisterDevice(registerDeviceCallback);

    function registerDeviceCallback() {
        sync.log.trace("Entering registerDeviceCallback");
        //check if upgrade is required
        kony.sync.areSyncConfigVersionDifferent(areSyncConfigVersionDifferentCallback);

        function areSyncConfigVersionDifferentCallback(isError, errorObject, isDifferent) {
            sync.log.trace("Entering areSyncConfigVersionDifferentCallback");
            if (isError) {
                kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
                kony.sync.verifyAndCallClosure(config[kony.sync.onReconciliationError], errorObject);
            } else {
                if (isDifferent) {
                    kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
                    kony.sync.verifyAndCallClosure(config[kony.sync.onReconciliationError], {
                        upgradeRequired: true
                    });
                } else {
                    validateReconcileConfig();
                }
            }
        }
    }
}
kony.sync.checkForRegisterDevice = function(onRegisterSuccessCallback) {
    sync.log.trace("Entering kony.sync.checkForRegisterDevice ");
    var registerSuccess = true;
    var alreadyRegistered = false;
    var isError = false;

    function single_transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.checkForRegisterDevice single_transaction_callback");
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, [kony.sync.syncConfigurationColumnDeviceIDName]);
        kony.sync.qb_from(query, kony.sync.syncConfigurationTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params, kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError]);
        if (resultSet === false) {
            registerSuccess = false;
            isError = true;
            return;
        }
        if (resultSet.rows.length === 0) {
            isError = true;
            return;
        }
        var record = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
        sync.log.debug("Device Record: ", record);
        sync.log.debug("Device ID: ", record.DeviceID);
        if (record.DeviceID !== kony.sync.getDeviceID()) {
            kony.sync.konyRegisterDevice(registerDeviceCallback);
            sync.log.info("Registering Device...");
        } else {
            alreadyRegistered = true;
            sync.log.info("Device already registered");
        }
    }

    function registerDeviceCallback(serverResponse) {
        sync.log.trace("Entering registerDeviceCallback");
        if (!kony.sync.isNullOrUndefined(serverResponse.opstatus) && serverResponse.opstatus != 0) {
            if (!kony.sync.isNullOrUndefined(serverResponse.d)) {
                sync.log.error("Register Device Response : ", serverResponse);
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getServerError(serverResponse.d));
                kony.sync.isSessionInProgress = false;
            } else {
                sync.log.error("Register Device Response : ", serverResponse);
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getServerError(serverResponse));
                kony.sync.isSessionInProgress = false;
            }
            kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
            kony.sync.httprequestsinglesession = false;
            registerSuccess = false;
            return;
        } else if (kony.sync.isNullOrUndefined(serverResponse.d)) {
            registerSuccess = false;
            kony.sync.isSessionInProgress = false;
            kony.sync.httprequestsinglesession = false;
            kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getServerError(serverResponse));
            return;
        }
        if ((serverResponse.d.error === "true")) {
            sync.log.error("Register Device Response : ", serverResponse);
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getServerError(serverResponse.d));
            kony.sync.isSessionInProgress = false;
            kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
            kony.sync.httprequestsinglesession = false;
            registerSuccess = false;
            return;
        }
        sync.log.debug("Register Device Response : ", serverResponse);
        var connection2 = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], "Load device id");
        if (connection2 !== null) {
            kony.sync.startTransaction(connection2, single_device_register_callback, single_transaction_success_callback, single_transaction_error_callback, "Load device id");
        }

        function single_device_register_callback(tx) {
            sync.log.trace("Entering single_device_register_callback");
            kony.sync.instanceId = serverResponse.d.__registerdevice.instanceID;
            var insertTab = {};
            insertTab[kony.sync.syncConfigurationColumnInstanceIDName] = kony.sync.instanceId;
            insertTab[kony.sync.syncConfigurationColumnDeviceIDName] = kony.sync.getDeviceID();
            var wcs = {};
            kony.table.insert(wcs, {
                key: kony.sync.syncConfigurationColumnDeviceIDName,
                value: ""
            });
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, kony.sync.syncConfigurationTableName);
            kony.sync.qb_set(query, insertTab);
            kony.sync.qb_where(query, wcs);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                isError = true;
                return;
            }
            alreadyRegistered = true;
            sync.log.info("Register Device success");
        }
    }

    function single_transaction_error_callback() {
        sync.log.trace("Entering single_transaction_error_callback");
        sync.log.error("Register Device failed");
        //kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getSyncRegisterationFailed());
        kony.sync.isSessionInProgress = false;
        kony.sync.httprequestsinglesession = false;
        kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
        kony.sync.callTransactionError(isError, kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError]);
    }

    function single_transaction_success_callback() {
        sync.log.trace("Entering single_transaction_success_callback");
        if (registerSuccess && alreadyRegistered && !isError) {
            onRegisterSuccessCallback();
        } else if (isError) {
            sync.log.fatal("SynConfigTable is empty. There seems to be problem in sync.init");
            kony.sync.getErrorTable(kony.sync.errorCodeMetatableError, kony.sync.getErrorMessage(kony.sync.errorCodeMetatableError), null);
        }
    }
    var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], "Device Registration");
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback, "Device Registration");
    }
}
kony.sync.syncDownloadReconcileScopes = function(serverblob) {
        sync.log.trace("Entering kony.sync.syncDownloadReconcileScopes ");

        function populateChangeSet(newserverblob, scopeName) {
            sync.log.trace("Entering populateChangeSet");
            var currentReconcileScopeIndex = kony.sync.currentReconcileScopeIndex;
            var scope = kony.sync.scopeDict[scopeName];
            var dataSourceURI = scope[kony.sync.scopeDataSource];
            var changeset = {
                clientid: kony.sync.getDeviceID(),
                serverblob: newserverblob,
                scopeName: scopeName,
                uri: dataSourceURI,
                tables: []
            };
            return changeset;
        }
        var serverChanges = null;
        var scopeName = kony.sync.reconcileScopes.scopeList[kony.sync.currentReconcileScopeIndex];
        var changeset = populateChangeSet(serverblob, scopeName);
        var isError = false;
        kony.sync.konyReconcileChanges(scopeName, changeset, serverblob, downloadcallback);
        var readyToComputeTables = [];
        var newserverblob = null;
        var morechanges = false;
        var pendingbatches = null;
        var serverChangesCount = 0;
        var clientDownloadCount = 0;

        function downloadNextBatch(tx) {
            sync.log.trace("Entering downloadNextBatch");
            morechanges = serverChanges.d.__sync.moreChangesAvailable;
            newserverblob = serverChanges.d.__sync.serverblob;
            //kony.sync.reconcilePendingBatches = serverChanges.d.__sync.pendingBatches;
            //kony.sync.currentReconcileReturnParams[kony.sync.lastSyncTimestamp] = serverblob;
            processChanges(tx, serverChanges);
        }

        function computeLeftOverChanges(postProcessingChanges) {
            sync.log.trace("Entering computeLeftOverChanges");
            for (var tablename in kony.sync.lastProcessedTables) {
                readyToComputeTables.push(tablename);
            }
            kony.sync.computeDifference(readyToComputeTables, postProcessingChanges);
        }
        //populate batch statistics
        function getBatchContext() {
            sync.log.trace("Entering  getBatchContext");
            var batchcontext = {};
            batchcontext[kony.sync.reconcileBatchDownloads] = kony.sync.reconcileTotalBatchDownloads;
            batchcontext[kony.sync.reconcileBatchInsertions] = kony.sync.reconcileTotalBatchInserts;
            batchcontext[kony.sync.reconcileBatchDeletions] = kony.sync.reconcileTotalBatchDeletes;
            kony.sync.reconcileTotalDownloaded = kony.sync.reconcileTotalDownloaded + kony.sync.reconcileTotalBatchDownloads;
            kony.sync.reconcileTotalInserts = kony.sync.reconcileTotalInserts + kony.sync.reconcileTotalBatchInserts;
            kony.sync.reconcileTotalDeletes = kony.sync.reconcileTotalDeletes + kony.sync.reconcileTotalBatchDeletes;
            //batchcontext[kony.sync.pendingBatches] = kony.sync.tonumber(kony.sync.reconcilePendingBatches);
            //kony.sync.currentReconcileReturnParams[kony.sync.batchContext] = batchcontext;
            return batchcontext;
        }

        function downloadCompleted() {
            sync.log.trace("Entering datareconciliation downloadCompleted");
            if (readyToComputeTables.length != 0) {
                kony.sync.reconcileBatchingBlobContext["serverblob"] = newserverblob;
                kony.sync.reconcileBatchingBlobContext["morechanges"] = morechanges;
                kony.sync.reconcileBatchingBlobContext["pendingbatches"] = pendingbatches;
                kony.sync.computeDifference(readyToComputeTables, postProcessingChanges);
            } else {
                //morechangesavailable for this scope
                if (morechanges) {
                    //calling successcallback for currentbatch before making a call for next batch
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBatchprocessingSuccess], getBatchContext());
                    kony.sync.resetReconcileBatchSessionGlobals();
                    kony.sync.syncDownloadReconcileScopes(newserverblob);
                } else {
                    //when there are no changes and no readytocompute tables are available
                    //but there are some last processed table present
                    //so add all lastprocessedtables to readytocomputetables
                    if (kony.sync.isEmptyObject(kony.sync.lastProcessedTables) === false) computeLeftOverChanges(postProcessingChanges);
                    else {
                        //all the changes all are successfully processed
                        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBatchprocessingSuccess], getBatchContext());
                        kony.sync.resetReconcileBatchSessionGlobals();
                        kony.sync.reconcileCompletedCallback(false, {}); //TODO change to getscopecontext
                    }
                }
            }

            function postProcessingChanges() {
                sync.log.trace("Entering postProcessingChanges");
                //Not called by computeLeftOverChanges
                if (kony.sync.isEmptyObject(kony.sync.reconcileBatchingBlobContext) === false) {
                    var savedBlobContext = kony.sync.reconcileBatchingBlobContext;
                    var _moreChanges = savedBlobContext.morechanges;
                    var _serverblob = savedBlobContext.serverblob;
                    kony.sync.reconcileBatchingBlobContext = {}; //resetting it to empty
                    if (_moreChanges) {
                        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBatchprocessingSuccess], getBatchContext());
                        kony.sync.resetReconcileBatchSessionGlobals();
                        kony.sync.syncDownloadReconcileScopes(_serverblob);
                    } else {
                        //this case happens when there are some lastprocessedtables left which are yet to be processed
                        if (kony.sync.isEmptyObject(kony.sync.lastProcessedTables) === false) computeLeftOverChanges(postProcessingChanges);
                        sync.log.debug("Reconciliation is completed successfully ");
                    }
                } else {
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBatchprocessingSuccess], getBatchContext());
                    kony.sync.resetReconcileBatchSessionGlobals();
                    //all the changes for current scope are successfully processed
                    kony.sync.reconcileCompletedCallback(false, {}); //TODO change to getscopecontext
                }
            }
        }

        function downloadNextBatchFailed(error) {
            sync.log.trace("Entering downloadNextBatchFailed");
            //alert("error in batch download " +JSON.stringify(error));
            sync.log.error("error in batch download " + JSON.stringify(error));
            if (isError) {
                kony.sync.reconcileCompletedCallback(true, kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
            } else {
                kony.sync.reconcileCompletedCallback(true, kony.sync.errorObject);
                kony.sync.errorObject = null;
            }
        }

        function downloadcallback(serverChangesResult) {
            sync.log.trace("Entering downloadcallback");
            serverChanges = serverChangesResult;
            sync.log.info("ServerChanges:", serverChanges);
            if (!kony.sync.isNullOrUndefined(serverChanges.opstatus) && serverChanges.opstatus != 0) {
                if (!kony.sync.isNullOrUndefined(serverChanges.d)) {
                    kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges.d, "download"));
                } else {
                    kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges));
                }
                return;
            } else if (kony.sync.isNullOrUndefined(serverChanges.d)) {
                kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges));
                return;
            }
            kony.sync.currentReconcileReturnParams[kony.sync.serverDetails] = {};
            kony.sync.currentReconcileReturnParams[kony.sync.serverDetails][kony.sync.hostName] = kony.sync.getServerDetailsHostName(serverChanges);
            kony.sync.currentReconcileReturnParams[kony.sync.serverDetails][kony.sync.ipAddress] = kony.sync.getServerDetailsIpAddress(serverChanges);
            if ((serverChanges.d.error === "true")) {
                kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges));
                return;
            }
            var dbname = kony.sync.syncConfigurationDBName;
            var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, kony.sync.syncFailed);
            if (dbconnection === null) {
                return;
            }
            kony.db.transaction(dbconnection, downloadNextBatch, downloadNextBatchFailed, downloadCompleted);
        }

        function processChanges(tx, serverChanges) {
            sync.log.trace("Entering processChanges");
            //insert pk data into tempReconciliationtables
            sync.log.info("Entering data reconciliation processChanges ");
            var results = serverChanges.d.results;
            var scopeName = kony.sync.reconcileScopes.scopeList[kony.sync.currentReconcileScopeIndex];
            var reconcileList = kony.sync.reconcileScopes[scopeName].ReconcileTables;
            var processedTableNames = {};
            for (var i = 0; i < results.length; i++) {
                var row = results[i];
                var tableName = row.__metadata.type;
                //initialising object level info map
                kony.sync.initReconcileObjectLevelInfoMap(tableName);
                var scopename = kony.sync.scopes.syncTableScopeDic[tableName];
                var scope = kony.sync.scopeDict[scopename];
                var changeType = row.__metadata.changeType; //not required
                //add into processedTableNames
                processedTableNames[tableName] = "true";
                var pkColumns = scope.syncTableDic[tableName].Pk_Columns;
                var length = pkColumns.length;
                var record = [];
                for (var j = length - 1; j >= 0; j--) {
                    if (!kony.sync.isNullOrUndefined(row[pkColumns[j]])) {
                        record[pkColumns[j]] = row[pkColumns[j]];
                    }
                }
                var query = kony.sync.qb_createQuery();
                kony.sync.qb_set(query, record);
                kony.sync.qb_insert(query, tableName + kony.sync.tempTableKey);
                query_compile = kony.sync.qb_compile(query);
                var sql = query_compile[0];
                var params = query_compile[1];
                var result = kony.sync.executeSql(tx, sql, params);
                //exit incase of SQL error
                if (result === false) {
                    sync.log.error("row insertion failed" + JSON.stringify(result));
                    isError = true;
                    return false;
                }
                kony.sync.reconcileTotalBatchDownloads = kony.sync.reconcileTotalBatchDownloads + 1;
                kony.sync.reconcileObjectLevelInfoMap[tableName][kony.sync.reconcileTotalDownloads] += 1;
            }
            for (var currentTableName in processedTableNames) {
                if (!kony.sync.isNullOrUndefined(kony.sync.lastProcessedTables[currentTableName])) {
                    delete kony.sync.lastProcessedTables[currentTableName];
                }
            }
            for (var tablename in kony.sync.lastProcessedTables) {
                readyToComputeTables.push(tablename);
            }
            kony.sync.lastProcessedTables = {};
            for (var currentTableName in processedTableNames) {
                kony.sync.lastProcessedTables[currentTableName] = "true";
            }
        };
    }
    //getAllPks call
kony.sync.konyReconcileChanges = function(scopeName, changeset, serverblob, downloadNetworkCallback) {
    sync.log.trace("Entering kony.sync.konyReconcileChanges ");
    var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];

    function fetchGetAllPKSContext() {
        sync.log.trace("Entering fetchGetAllPKSContext");
        var scopeName = kony.sync.reconcileScopes.scopeList[kony.sync.currentReconcileScopeIndex];
        var scope = kony.sync.scopeDict[scopeName];
        var FilterContext = {};
        var scopeReconcileTables = kony.sync.reconcileScopes[scopeName].ReconcileTables;
        for (var k = 0; k < scopeReconcileTables.length; k++) {
            var syncTableName = scopeReconcileTables[k];
            var syncTable = scope.syncTableDic[syncTableName];
            if (kony.sync.isNullOrUndefined(FilterContext[syncTableName])) FilterContext[syncTableName] = {};
            if (!kony.sync.isNullOrUndefined(syncTable.Pk_Columns)) {
                var fields = [];
                var pkColumns = syncTable.Pk_Columns;
                for (j = 0; j < pkColumns.length; j++) {
                    fields.push(pkColumns[j]);
                }
                FilterContext[syncTableName].fields = fields;
            }
        }
        //filterparams
        if (kony.sync.isValidJSTable(kony.sync.currentSyncConfigParams[kony.sync.filterParams])) {
            kony.sync.currentSyncScopeFilter = kony.sync.currentSyncConfigParams[kony.sync.filterParams][scopeName];
        }
        return FilterContext;
    }

    function downloadNetworkCallbackStatus(status, result) {
        sync.log.trace("Entering downloadNetworkCallbackStatus");
        if (status === 400) {
            sync.log.trace("Entering kony.sync.konyReconcileChanges->downloadNetworkCallbackStatus");
            if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                retries--;
                kony.sync.retryServiceCall(kony.sync.getDownloadURL(), result, null, retries, downloadNetworkCallback, params);
            } else {
                kony.sync.setSessionID(result);
                downloadNetworkCallback(result);
            }
        } else if (status === 300) {
            downloadNetworkCallback(kony.sync.getNetworkCancelError());
        }
    }
    if (kony.sync.isNullOrUndefined(serverblob)) {
        serverblob = "";
    }
    var params = {};
    var filterparams = fetchGetAllPKSContext();
    var reconcileScopefilter = {
        "d": filterparams
    };
    var jsonContext = null;
    var filterParams = null;
    jsonContext = JSON.stringify(reconcileScopefilter);
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncScopeFilter)) {
        var scopejsonfilter = {
            "d": {
                Filters: kony.sync.currentSyncScopeFilter
            }
        };
        filterParams = JSON.stringify(scopejsonfilter);
    }
    kony.sync.commonServiceParams(params);
    params.filterContext = jsonContext;
    params.context = filterParams;
    params.enablebatching = "true";
    params.batchsize = kony.sync.getReconcileDownloadBatchSize();
    params.tickcount = serverblob;
    params.scopename = scopeName;
    var scope = kony.sync.scopeDict[scopeName];
    params.strategy = scope[kony.sync.syncStrategy];
    params.instanceid = kony.sync.getInstanceID();
    params.clientid = kony.sync.getDeviceID();
    params.appVersion = kony.sync.currentSyncConfigParams.appVersion;
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
        params.httpconfig = {
            timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
        };
    }
    var paramsToSend = null;
    var currentReconcileReturnParamsTemp = kony.sync.currentReconcileReturnParams;
    currentReconcileReturnParamsTemp.downloadRequest = params;
    kony.sync.deleteMapKey(currentReconcileReturnParamsTemp, kony.sync.serverDetails);
    if (kony.sync.isFirstReconcileDownload) {
        paramsToSend = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationDownloadStart], currentReconcileReturnParamsTemp);
        kony.sync.isFirstReconcileDownload = false;
        if (!kony.sync.isNullOrUndefined(paramsToSend)) {
            params = paramsToSend;
            kony.sync.downloadReconcileClientContext = params.clientcontext;
        }
    }
    currentReconcileReturnParamsTemp.downloadRequest = params;
    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBatchprocessingStart], kony.sync.currentReconcileReturnParams);
    if (paramsToSend != null) {
        params = paramsToSend;
        kony.sync.downloadReconcileClientContext = params.clientcontext;
    }
    currentReconcileReturnParamsTemp = null;
    paramsToSend = null;
    params.clientcontext = JSON.stringify(kony.sync.downloadReconcileClientContext);
    sync.log.info("Hitting the service with URL " + kony.sync.getDownloadURL(), params);
    kony.sync.invokeServiceAsync(kony.sync.getDownloadURL(), params, downloadNetworkCallbackStatus, null);
};
kony.sync.computeDifference = function(tablenames, postProcessingChangesCallBack) {
    sync.log.trace("Entering kony.sync.computeDifference ");

    function delete_api(tx, tableName, pkColumns) {
        sync.log.trace("Entering delete_api");
        sync.log.info("calling delete_api in kony.sync.computeDifference transaction callback");
        var deleteBatchLimit = kony.sync.reconcileMaxDeleteLimit;
        var offSet = 0;
        var deleteBatchLimitString = deleteBatchLimit.toString();
        while (1) {
            var deleteDeltaRecordsQuery = "SELECT * FROM " + tableName + "" + kony.sync.reconcileCacheKey + " LIMIT " + deleteBatchLimitString + " OFFSET " + offSet;
            var resultset = kony.sync.executeSql(tx, deleteDeltaRecordsQuery); //need to handle error callback if required
            if (resultset != false) {
                var resultset_length = resultset.rows.length;
                //need to delete records one by one hierarchially based on the cascade information
                if (resultset_length >= 1) {
                    var whereClause = "";
                    for (var i = 0; i < resultset_length; i++) {
                        var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, i);
                        //check in cascade information provided and delete if and only if the record in not present
                        //in the history table
                        kony.sync.deleteHierarchialChildRecords(tx, rowItem, tableName, computeDifferenceErrorCallBack);
                    }
                }
            } else {
                sync.log.error("Error in delete_api in kony.sync.computeDifference transaction callback while executing query " + deleteDeltaRecordsQuery)
            }
            if (resultset_length < 1000) {
                //rows obtained are less than 1000 ,so all rows are processed for the given table
                break;
            }
            offSet += deleteBatchLimit;
        }
    }
    var recordPKValues = [];
    var isError = false;

    function computeDifferenceTransaction(tx) {
        sync.log.trace("Entering kony.sync.computeDifference transactioncallback ");
        //delete delta A-B
        for (var i = 0; i < tablenames.length; i++) {
            var tableName = tablenames[i];
            var scopeName = kony.sync.scopes.syncTableScopeDic[tableName];
            var scope = kony.sync.scopeDict[scopeName];
            var pkColumns = scope.syncTableDic[tableName].Pk_Columns;
            var length = pkColumns.length;
            var selectClause = "";
            var whereClause = "";
            for (var j = 0; j < length; j++) {
                selectClause += tableName + "." + pkColumns[j];
                whereClause += tableName + "." + pkColumns[j] + " = " + tableName + "" + kony.sync.tempTableKey + "." + pkColumns[j];
                if (j != length - 1) {
                    selectClause += ",";
                    whereClause += " and ";
                }
            }
            //creating the cache table with left join ,here left join is formed between maintable and temptable
            //here the records which are to be deleted will be present in the cache table
            var createTempTable = "create table " + tableName + "" + kony.sync.reconcileCacheKey + " as select " + selectClause + " from " + tableName + " where NOT EXISTS (select 1 from " + tableName + "" + kony.sync.tempTableKey + " where " + whereClause + " )";
            if (kony.sync.executeSql(tx, createTempTable) === false) {
                sync.log.error("Error in creating cache table in executing query" + createTempTable + "in kony.sync.computeDifference computeDifference");
                isError = true;
                return;
            }
            delete_api(tx, tableName, pkColumns);
            //deleting the cache table as the A-B delta calculation is successfully completed
            var dropCacheTable = "drop table if exists " + tableName + "" + kony.sync.reconcileCacheKey;
            if (kony.sync.executeSql(tx, dropCacheTable) === false) {
                sync.log.error("error in executing query  " + dropCacheTable + " in kony.sync.computeDifference computeDifference");
                isError = true;
                return;
            }
            sync.log.debug("successful in executing query  " + dropCacheTable + " in kony.sync.computeDifference computeDifference");
        }
    }

    function computeDifferenceSuccessCallBack() {
        sync.log.trace("Entering kony.sync.computeDifference SuccessCallBack : computeDifferenceSuccessCallBack");
        var tableIndex = 0;
        var Offset = 0;
        kony.sync.downloadReconcileChanges(null, tablenames, tableIndex, Offset, postProcessingChangesCallBack);
    }

    function computeDifferenceErrorCallBack(isError) {
        sync.log.trace("Entering kony.sync.computeDifference ErrorCallBack : computeDifferenceErrorCallBack")
        if (!kony.sync.isNullOrUndefined(isError) && isError === true) {
            kony.sync.reconcileCompletedCallback(true, kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.reconcileCompletedCallback(true, isError);
            kony.sync.errorObject = null;
        }
    }
    var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, computeDifferenceErrorCallBack, "compute  difference");
    if (connection !== null) {
        kony.sync.startTransaction(connection, computeDifferenceTransaction, computeDifferenceSuccessCallBack, computeDifferenceErrorCallBack, "validate scope session");
    }
}
kony.sync.deleteRow = function(tx, parentTableName, rowItem, errorCallBack) {
    sync.log.trace("Entering kony.sync.deleteRow ");

    function delete_row(wcs, tablename) {
        sync.log.trace("Entering delete_row");
        var deleteParentQuery = kony.sync.qb_createQuery();
        kony.sync.qb_delete(deleteParentQuery, tablename);
        kony.sync.qb_where(deleteParentQuery, wcs);
        var query_compile = kony.sync.qb_compile(deleteParentQuery);
        var sql = query_compile[0];
        var params = query_compile[1];
        resultset = kony.db.executeSql(tx, sql, params, errorCallBack);
        if (resultset === false) {
            sync.log.error("Error in kony.sync.deleteHierarchialChildRecordsForRow for parentTable " + tablename + " with query " + sql + " params :" + params);
            return;
        }
    }
    var scopename = kony.sync.scopes.syncTableScopeDic[parentTableName];
    var pkColumns = kony.sync.scopes[scopename].syncTableDic[parentTableName].Pk_Columns;
    var wcs = [];
    for (var i = 0; i < pkColumns.length; i++) {
        wcs.push({
            key: pkColumns[i],
            value: rowItem[pkColumns[i]]
        });
    }
    delete_row(wcs, parentTableName); //delete in main table
    delete_row(wcs, parentTableName + kony.sync.originalTableName); //delete in original table
    kony.sync.reconcileTotalBatchDeletes = kony.sync.reconcileTotalBatchDeletes + 1;
    kony.sync.initReconcileObjectLevelInfoMap(parentTableName);
    kony.sync.reconcileObjectLevelInfoMap[parentTableName][kony.sync.reconcileTotalDeletions] += 1;
}
kony.sync.deleteHierarchialChildRecords = function(tx, rowItem, parentTableName, errorCallBack) {
    sync.log.trace("Entering kony.sync.deleteHierarchialChildRecords-> for parent table " + parentTableName);
    var scopename = kony.sync.scopes.syncTableScopeDic[parentTableName];
    var scope = kony.sync.scopes[scopename];
    var OTM = scope.syncTableDic[parentTableName].Relationships.OneToMany;
    var isDeleteOTM = kony.sync.deleteHierarchialChildRecordsForRow(tx, rowItem, parentTableName, OTM, errorCallBack);
    var MTO = scope.reverseRelationships[parentTableName];
    var isDeleteMTO = kony.sync.deleteHierarchialChildRecordsForRow(tx, rowItem, parentTableName, MTO, errorCallBack);
    var OTO = scope.syncTableDic[parentTableName].Relationships.OneToOne;
    var isDeleteOTO = kony.sync.deleteHierarchialChildRecordsForRow(tx, rowItem, parentTableName, OTO, errorCallBack);
    if (isDeleteOTM === true && isDeleteMTO === true && isDeleteOTO === true) {
        kony.sync.deleteRow(tx, parentTableName, rowItem, errorCallBack);
        return true;
    } else {
        return false;
    }
}
kony.sync.deleteHierarchialChildRecordsForRow = function(tx, rowItem, parentTableName, relationshipSet, errorCallBack) {
    sync.log.trace("Entering kony.sync.deleteHierarchialChildRecordsForRow for parenttable " + parentTableName);
    var allChildsDeleted = true; //true means yes ,false means no
    if (!kony.sync.isNullOrUndefined(relationshipSet)) {
        for (var i = 0; i < relationshipSet.length; i++) {
            var childTableName = relationshipSet[i].TargetObject;
            sync.log.trace("processing childtable :  " + childTableName + " for parent:" + parentTableName);
            var isCascade = false;
            var selectChildrenQuery = null;
            var params = null;
            if (kony.sync.isNullOrUndefined(relationshipSet[i].Cascade)) {
                sync.log.warn("no Cascade flag found for relationship for parentable " + parentTableName + " and " + childTableName + " so cascade is considered as false");
            } else isCascade = relationshipSet[i].Cascade;
            var wcs = [];
            if (!kony.sync.isNullOrUndefined(relationshipSet[i].RelationshipAttributes)) {
                var relationshipAttributes = relationshipSet[i].RelationshipAttributes;
                for (var attName in rowItem) {
                    for (var k = 0; k < relationshipAttributes.length; k++) {
                        if (attName === relationshipAttributes[k].SourceObject_Attribute) {
                            wcs.push({
                                key: relationshipAttributes[k].TargetObject_Attribute,
                                value: rowItem[attName]
                            });
                        }
                    }
                }
                var query = kony.sync.qb_createQuery();
                kony.sync.qb_select(query, null);
                kony.sync.qb_from(query, childTableName);
                kony.sync.qb_where(query, wcs);
                var query_compile = kony.sync.qb_compile(query);
                selectChildrenQuery = query_compile[0];
                params = query_compile[1];
            } else {
                //need to remove this logic as this is not required post 7.0
                wcs[0] = {
                    key: relationshipSet[i].TargetObject_Attribute,
                    value: rowItem[relationshipSet[i].SourceObject_Attribute]
                };
                selectChildrenQuery = "select * from " + childTableName + " where " + relationshipSet[i].TargetObject_Attribute + " = '" + rowItem[relationshipSet[i].SourceObject_Attribute] + "'";
            }
            sync.log.debug("kony.sync.deleteHierarchialChildRecordsForRow executing query  " + selectChildrenQuery + " with params " + params);
            var resultset = kony.sync.executeSql(tx, selectChildrenQuery, params); //need to handle error callback if required
            if (resultset != false) {
                var resultset_length = resultset.rows.length;
                //logic to process the resultset
                if (resultset_length >= 1) {
                    if (isCascade === "true" || isCascade === true) {
                        for (var j = 0; j < resultset_length; j++) {
                            var newRowItem = kony.db.sqlResultsetRowItem(tx, resultset, j);
                            if (childTableName === parentTableName) {
                                var matchCount = 0;
                                var relationshipAttributes = relationshipSet[i].RelationshipAttributes;
                                for (var colName in rowItem) {
                                    for (var attributeIndex = 0; attributeIndex < relationshipAttributes.length; attributeIndex++) {
                                        if (colName === relationshipAttributes[attributeIndex].SourceObject_Attribute) {
                                            var parentColumnValue = rowItem[relationshipAttributes[attributeIndex].SourceObject_Attribute];
                                            var ChildColumnValue = newRowItem[relationshipAttributes[attributeIndex].TargetObject_Attribute];
                                            if (parentColumnValue === ChildColumnValue) {
                                                matchCount++;
                                            }
                                        }
                                    }
                                }
                                if (matchCount == relationshipAttributes.length) {
                                    sync.log.warn("Cyclic dependency ignoring the record " + JSON.stringify(rowItem));
                                    continue;
                                }
                            }
                            sync.log.info("calling kony.sync.deleteHierarchialChildRecords for tablename " + childTableName + " with rowItem " + JSON.stringify(newRowItem));
                            var deletedStatus = kony.sync.deleteHierarchialChildRecords(tx, newRowItem, childTableName);
                            if (deletedStatus === false) allChildsDeleted = false;
                        }
                    } else {
                        allChildsDeleted = false;
                    }
                }
            } else {
                sync.log.info("No Corresponding children:" + childTableName + " found for corresponding parent:" + parentTableName + " for query:" + selectChildrenQuery);
                return;
            }
        }
        return allChildsDeleted;
    } else {
        return true;
    }
}
kony.sync.downloadReconcileChanges = function(serverblob, tableNames, tableIndex, offSet, postProcessingChangesCallBack) {
        sync.log.trace("entering kony.sync.downloadreconcilechanges")
        var recordPKValues = {};
        var totalFetchedRowCount = 0;

        function createCacheTable(tx, currentCacheTableName) {
            sync.log.info("calling  createCacheTable on " + currentCacheTableName + " in transactionCallBack of kony.sync.downloadReconcileChanges");
            var scopename = kony.sync.scopes.syncTableScopeDic[currentCacheTableName];
            var scope = kony.sync.scopeDict[scopename];
            var pkColumns = scope.syncTableDic[currentCacheTableName].Pk_Columns;
            var length = pkColumns.length;
            var pkString = "";
            for (var j = length - 1; j >= 0; j--) {
                pkString += pkColumns[j];
                if (j != 0) {
                    pkString += ",";
                }
            }
            //here this cache table contains the pkrecords on which bulkget needs to be called
            var createBulkGetRowsTable = "create table " + currentCacheTableName + "" + kony.sync.reconcileCacheKey + " as select " + pkString + " from " + currentCacheTableName + "" + kony.sync.tempTableKey + " except select " + pkString + " from " + currentCacheTableName;
            if (kony.sync.executeSql(tx, createBulkGetRowsTable) === false) {
                sync.log.error("failure in creating cache table " + currentCacheTableName + " with query " + createBulkGetRowsTable);
                isError = true;
                return;
            }
        }

        function getRecords(tx, numberOfRecords, offSet, currentCacheTableName) {
            sync.log.info("calling getRecords on " + currentCacheTableName + " in transactionCallBack of kony.sync.downloadReconcileChanges");
            if (kony.sync.isNullOrUndefined(recordPKValues[currentCacheTableName])) {
                recordPKValues[currentCacheTableName] = [];
            }
            var bulkGetDataQuery = "select * from " + currentCacheTableName + "" + kony.sync.reconcileCacheKey + " LIMIT " + numberOfRecords + " OFFSET " + offSet;
            var resultset = kony.sync.executeSql(tx, bulkGetDataQuery); //need to handle error callback if required
            if (resultset != false) {
                var fetchedRowCount = resultset.rows.length;
                if (fetchedRowCount >= 1) {
                    for (var i = 0; i < fetchedRowCount; i++) {
                        var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, i);
                        recordPKValues[currentCacheTableName].push(rowItem);
                    }
                }
            } else {
                sync.log.error("failed to getRecords for table " + currentCacheTableName + " with query " + bulkGetDataQuery);
                kony.sync.reconcileCompletedCallback(true, "failed to getRecords for table " + currentCacheTableName + " with query " + bulkGetDataQuery);
            }
            return fetchedRowCount;
        }

        function transactionCallBack(tx) {
            sync.log.trace("entering kony.sync.downloadReconcileChanges transactioncallback ");
            var fetchedRecordsCount = 0;
            var batchSize = kony.sync.getReconcileBulkGetBatchSize(); //change to actual batchsize
            var numberOfRecords = batchSize;
            //var Offset = 0;
            while ((fetchedRecordsCount != batchSize) && (tableIndex < tableNames.length)) {
                var currentCacheTableName = tableNames[tableIndex];
                if (offSet === 0) {
                    createCacheTable(tx, currentCacheTableName);
                }
                var obtainedRecordsCount = getRecords(tx, numberOfRecords, offSet, currentCacheTableName);
                if (obtainedRecordsCount != numberOfRecords) {
                    offSet = 0;
                    numberOfRecords -= obtainedRecordsCount;
                    //current table processing finished
                    var dropTempTable = "drop table if exists " + currentCacheTableName + "" + kony.sync.reconcileCacheKey;
                    if (kony.sync.executeSql(tx, dropTempTable) === false) {
                        sync.log.error("failed to drop the cache table " + currentCacheTableName + "in transactionCallBack of kony.sync.downloadReconcileChanges");
                        isError = true;
                        return;
                    }
                    sync.log.debug("successful : drop the cache table " + currentCacheTableName + "in transactionCallBack of kony.sync.downloadReconcileChanges");
                    tableIndex = tableIndex + 1; //go to next table
                } else {
                    offSet += obtainedRecordsCount;
                }
                fetchedRecordsCount += obtainedRecordsCount;
            }
            totalFetchedRowCount = fetchedRecordsCount;
        }

        function getBulkGetParams() {
            sync.log.info("calling getBulkGetParams in  kony.sync.downloadReconcileChanges successCallBack ");
            var filterParamsMap = {};
            for (var tableName in recordPKValues) {
                if (kony.sync.isNullOrUndefined(filterParamsMap[tableName])) {
                    filterParamsMap[tableName] = {};
                }
                if (kony.sync.isNullOrUndefined(filterParamsMap[tableName].keys)) {
                    filterParamsMap[tableName].keys = [];
                    filterParamsMap[tableName].fields = [];
                }
                var records = filterParamsMap[tableName].keys;
                var scopename = kony.sync.scopes.syncTableScopeDic[tableName];
                var scope = kony.sync.scopeDict[scopename];
                var pkColumns = scope.syncTableDic[tableName].Pk_Columns;
                var columns = scope.syncTableDic[tableName].Columns;
                var fields = filterParamsMap[tableName].fields;
                for (var i = 0; i < columns.length; i++) {
                    fields.push(columns[i].Name);
                }
                var tableResultSet = recordPKValues[tableName];
                for (var i = 0; i < tableResultSet.length; i++) {
                    var pkKeys = [];
                    var rowItem = tableResultSet[i];
                    for (var j = 0; j < pkColumns.length; j++) {
                        var pkColumn = pkColumns[j];
                        var pkMap = {};
                        pkMap.Name = pkColumn;
                        pkMap.Value = rowItem[pkColumn];
                        pkKeys.push(pkMap);
                    }
                    records.push(pkKeys);
                }
            }
            return filterParamsMap;
        }

        function successCallBack() {
            sync.log.trace("entering kony.sync.downloadReconcileChanges successCallBack ");
            if (totalFetchedRowCount == 0) {
                //if all the tables processing is finished we get totalFetchedRowCount as 0
                postProcessingChangesCallBack();
            } else {
                //make params
                var filterParams = getBulkGetParams();
                var contextParams = {
                    "tableNames": tableNames,
                    "tableIndex": tableIndex,
                    "offSet": offSet,
                    "callback": postProcessingChangesCallBack
                };
                kony.sync.applyReconcileDownloadChanges(serverblob, filterParams, contextParams);
            }
        }

        function errorCallBack() {
            sync.log.trace("entering kony.sync.downloadReconcileChanges errorCallBack ");
        }
        var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, errorCallBack, "reconcile sync session");
        if (connection !== null) {
            kony.sync.startTransaction(connection, transactionCallBack, successCallBack, errorCallBack, "validate scope session");
        }
    }
    //inserting the delta B-A into database
kony.sync.applyReconcileDownloadChanges = function(serverblob, filterParams, contextParams) {
    sync.log.trace("Entering function kony.sync.applyReconcileDownloadChanges");
    var serverChanges = null;
    var newserverblob = null;
    var isError = false;
    bulkGetNetworkCall();

    function bulkGetNetworkCall() {
        sync.log.trace("Entering kony.sync.applyReconcileDownloadChanges :bulkGetNetworkCall");
        var scopeName = kony.sync.reconcileScopes.scopeList[kony.sync.currentReconcileScopeIndex];
        var scope = kony.sync.scopeDict[scopeName];
        var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];

        function downloadNetworkCallbackStatus(status, result) {
            sync.log.trace("Entering downloadNetworkCallbackStatus");
            if (status === 400) {
                sync.log.trace("Entering kony.sync.applyReconcileDownloadChanges->downloadNetworkCallbackStatus");
                if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                    retries--;
                    kony.sync.retryServiceCall(kony.sync.getDownloadURL(), result, null, retries, downloadNetworkCallback, params);
                } else {
                    kony.sync.setSessionID(result);
                    downloadNetworkCallback(result);
                }
            } else if (status === 300) {
                downloadNetworkCallback(kony.sync.getNetworkCancelError());
            }
        }
        if (kony.sync.isNullOrUndefined(serverblob)) {
            serverblob = "";
        }
        var params = {};
        var jsonContext = null;
        var reconcileScopefilter = {
            "d": filterParams
        };
        var clientFilterParams = null;
        if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncScopeFilter)) {
            var scopejsonfilter = {
                "d": {
                    Filters: kony.sync.currentSyncScopeFilter
                }
            };
            clientFilterParams = JSON.stringify(scopejsonfilter);
        }
        params.context = clientFilterParams;
        jsonContext = JSON.stringify(reconcileScopefilter);
        kony.sync.commonServiceParams(params);
        params.filterContext = jsonContext;
        params.tickcount = serverblob;
        params.scopename = scopeName;
        params.strategy = scope[kony.sync.syncStrategy];
        params.instanceid = kony.sync.getInstanceID();
        params.clientid = kony.sync.getDeviceID();
        params.appVersion = kony.sync.currentSyncConfigParams.appVersion;
        params.batchsize = kony.sync.getReconcileBulkGetBatchSize();
        params.enablebatching = "true"
        if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
            params.httpconfig = {
                timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
            };
        }
        var paramsToSend = null;
        var currentReconcileReturnParamsTemp = {};
        currentReconcileReturnParamsTemp.downloadRequest = params;
        kony.sync.deleteMapKey(currentReconcileReturnParamsTemp, kony.sync.serverDetails);
        if (kony.sync.isFirstBulkGetReconcileDownload) {
            paramsToSend = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBulkGetDownloadStart], currentReconcileReturnParamsTemp);
            kony.sync.isFirstBulkGetReconcileDownload = false;
            if (!kony.sync.isNullOrUndefined(paramsToSend)) {
                params = paramsToSend;
                kony.sync.bulkGetDownloadReconcileClientContext = params.clientcontext;
            }
        }
        currentReconcileReturnParamsTemp.downloadRequest = params;
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBulkGetBatchprocessingStart], currentReconcileReturnParamsTemp);
        if (paramsToSend != null) {
            params = paramsToSend;
            kony.sync.bulkGetDownloadReconcileClientContext = params.clientcontext;
        }
        currentReconcileReturnParamsTemp = null;
        paramsToSend = null;
        params.clientcontext = JSON.stringify(kony.sync.bulkGetDownloadReconcileClientContext);
        sync.log.info("Hitting the service with URL " + kony.sync.getDownloadURL(), params);
        kony.sync.invokeServiceAsync(kony.sync.getDownloadURL(), params, downloadNetworkCallbackStatus, null);
    }

    function transactionCallBack(tx) {
        sync.log.trace("Entering function kony.sync.applyReconcileDownloadChanges: transactionCallBack");
        var results = serverChanges.d.results;
        newserverblob = serverChanges.d.__sync.serverblob;
        for (var i = 0; i < results.length; i++) {
            var row = results[i];
            var tablename = row.__metadata.type;
            var changeType = row.__metadata.changeType;
            var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
            var scope = kony.sync.scopes[scopename];
            var columns = scope.syncTableDic[tablename].Columns
            var length = columns.length;
            var record = [];
            for (var j = length - 1; j >= 0; j--) {
                if (!kony.sync.isNullOrUndefined(row[columns[j].Name])) {
                    record[columns[j].Name] = row[columns[j].Name];
                }
            }
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_set(query, record);
            kony.sync.qb_insert(query, tablename);
            query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            var result = kony.sync.executeSql(tx, sql, params);
            //exit incase of SQL error
            if (result === false) {
                sync.log.error("row insertion failed" + JSON.stringify(result));
                isError = true;
                return false;
            }
            kony.sync.reconcileTotalBatchInserts = kony.sync.reconcileTotalBatchInserts + 1;
            kony.sync.initReconcileObjectLevelInfoMap(tablename);
            kony.sync.reconcileObjectLevelInfoMap[tablename][kony.sync.reconcileTotalInsertions] += 1;
        }
    }

    function successCallBack() {
        sync.log.trace("Entering successCallBack");
        var batchcontext = {};
        batchcontext[kony.sync.reconcileBatchInsertions] = kony.sync.reconcileTotalBatchInserts;
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBulkGetBatchprocessingSuccess], batchcontext);
        sync.log.trace("Entering function kony.sync.applyReconcileDownloadChanges: successCallBack");
        var tableNames = contextParams.tableNames;
        var tableIndex = contextParams.tableIndex;
        var offSet = contextParams.offSet;
        var postProcessingChangesCallBack = contextParams.callback;
        if (tableIndex != tableNames.length) {
            kony.sync.downloadReconcileChanges(newserverblob, tableNames, tableIndex, offSet, postProcessingChangesCallBack);
        } else {
            postProcessingChangesCallBack();
        }
    }

    function errorCallBack() {
        sync.log.trace("Entering function kony.sync.applyReconcileDownloadChanges: errorCallBack");
        if (!isError) {
            kony.sync.reconcileCompletedCallback(true, kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.reconcileCompletedCallback(true, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }

    function downloadNetworkCallback(serverChangesResult) {
        sync.log.trace("Entering function kony.sync.applyReconcileDownloadChanges: downloadNetworkCallback");
        serverChanges = serverChangesResult;
        sync.log.info("ServerChanges:", serverChanges);
        if (!kony.sync.isNullOrUndefined(serverChanges.opstatus) && serverChanges.opstatus != 0) {
            if (!kony.sync.isNullOrUndefined(serverChanges.d)) {
                kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges.d, "download"));
            } else {
                kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges));
            }
            return;
        } else if (kony.sync.isNullOrUndefined(serverChanges.d)) {
            kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges));
            return;
        }
        if ((serverChanges.d.error === "true")) {
            kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges));
            return;
        }
        var dbname = kony.sync.syncConfigurationDBName;
        var connection = kony.sync.getConnectionOnly(dbname, dbname, errorCallBack, "reconcile sync session");
        if (connection !== null) {
            kony.sync.startTransaction(connection, transactionCallBack, successCallBack, errorCallBack, "reconcile sync session");
        }
    }
}
kony.sync.resetReconcileGlobals = function() {
    sync.log.trace("Entering kony.sync.resetReconcileGlobals ");
    kony.sync.lastProcessedTables = {};
    kony.sync.currentReconcileScopeIndex = 0;
    kony.sync.reconcileBatchingBlobContext = {};
    kony.sync.currentReconcileReturnParams = {};
    kony.sync.reconcilePendingScopes = {};
    kony.sync.isReconciliationInProgress = false;
    kony.sync.reconcilePendingRecords = [];
    kony.sync.currentSyncScopeFilter = null;
    kony.sync.resetReconcileSessionGlobals();
    kony.sync.resetReconcileBatchSessionGlobals();
}
kony.sync.isEmptyObject = function(object) {
    sync.log.trace("Entering kony.sync.isEmptyObject ");
    for (var key in object) {
        return false;
    }
    return true;
}
kony.sync.checkIfChangesExistInHistoryTable = function(tx, tablename) {
    sync.log.trace("entering function checkIfChangesExistInHistoryTable for tablename" + tablename);
    var sql = "select count(*) as rowcount from " + tablename + "" + kony.sync.historyTableName;
    var resultset = kony.sync.executeSql(tx, sql, null);
    if (resultset === false) {
        return false;
    } else {
        var record = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        var count = record["rowcount"];
        if (count == 0) {
            return "";
        } else {
            return true;
        }
    }
}
kony.sync.checkForPendingUploadInTransaction = function(scopename, successCallBack, errorCallBack) {
    sync.log.trace("entering function kony.sync.checkForPendingUploadInTransaction  for scopename " + scopename);
    var isError = false;
    var pendingObjectsInScope = []; //objects with pending changes
    function checkForPendingUploadTxCallBack(tx) {
        sync.log.trace("Entering checkForPendingUploadTxCallBack");
        var reconcileTables = kony.sync.reconcileScopes[scopename].ReconcileTables;
        for (var i = 0; i < reconcileTables.length; i++) {
            var tablename = reconcileTables[i];
            var resultset = kony.sync.checkIfChangesExistInHistoryTable(tx, tablename);
            if (resultset === false) {
                sync.log.error("checkForPendingUploadInTransaction : error in checkIfChangesExistInHistoryTable for tablename " + tablename);
                isError = true;
                return;
            } else if (resultset === "") {
                sync.log.debug("checkForPendingUploadInTransaction : no pending changes in historytable " + tablename);
            } else {
                sync.log.debug("checkForPendingUploadInTransaction :  pending changes in historytable " + tablename);
                pendingObjectsInScope.push(tablename);
            }
        }
    }

    function checkForPendingUploadSuccCallBack() {
        sync.log.trace("Entering checkForPendingUploadSuccCallBack");
        successCallBack(pendingObjectsInScope);
    }

    function checkForPendingUploadErrCallBack() {
        sync.log.trace("Entering checkForPendingUploadErrCallBack");
        errorCallBack();
    }
    var dbname = kony.sync.syncConfigurationDBName;
    var connection = kony.sync.getConnectionOnly(dbname, dbname, checkForPendingUploadErrCallBack, "check pendingupload for scope");
    if (connection !== null) {
        kony.sync.startTransaction(connection, checkForPendingUploadTxCallBack, checkForPendingUploadSuccCallBack, checkForPendingUploadErrCallBack, "check pendingupload for scope");
    }
}
kony.sync.reconcileCompletedCallback = function(error, msg) {
    sync.log.trace("Entering kony.sync.reconcileCompletedCallback ");
    if (error) {
        sync.log.error("Error occurred during reconcilation : ", msg);
        //kony.sync.deleteReconcileTempTables(tx);
        //kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationScopeError], msg);
        //return;
    } else {
        //calling scope scopesucesscallback
        kony.sync.isReconciliationInProgress = false;
        //todo changescopecontext
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationScopeSuccess], {});
    }
    kony.sync.validateReconcileSession(error, msg);
};
kony.sync.resetReconcileSessionGlobals = function() {
    sync.log.trace("Entering kony.sync.resetReconcileSessionGlobals ");
    //delete kony.sync.currentReconcileReturnParams[kony.sync.reconcileContext];
    //reconcile_total_inserts = 0;
    kony.sync.reconcileTotalInserts = 0;
    kony.sync.reconcileTotalDeletes = 0;
    kony.sync.reconcileTotalDownloaded = 0;
    kony.sync.reconcileObjectLevelInfoMap = {};
};
kony.sync.resetReconcileBatchSessionGlobals = function() {
    sync.log.trace("Entering kony.sync.resetReconcileBatchSessionGlobals ");
    delete kony.sync.currentReconcileReturnParams[kony.sync.batchContext];
    //kony.sync.reconcilePendingBatches = 0;
    kony.sync.reconcileTotalBatchDownloads = 0;
    kony.sync.reconcileTotalBatchInserts = 0;
    kony.sync.reconcileTotalBatchDeletes = 0;
};
kony.sync.initReconcileObjectLevelInfoMap = function(tablename) {
    sync.log.trace("Entering kony.sync.initReconcileObjectLevelInfoMap ");
    if (kony.sync.isNullOrUndefined(kony.sync.reconcileObjectLevelInfoMap[tablename])) {
        kony.sync.reconcileObjectLevelInfoMap[tablename] = {};
        kony.sync.reconcileObjectLevelInfoMap[tablename][kony.sync.reconcileTotalDownloads] = 0;
        kony.sync.reconcileObjectLevelInfoMap[tablename][kony.sync.reconcileTotalInsertions] = 0;
        kony.sync.reconcileObjectLevelInfoMap[tablename][kony.sync.reconcileTotalDeletions] = 0;
    }
}
kony.sync.validateReconcileSession = function(error, errorContext, validateReconcileSessionError) {
    sync.log.trace("Entering kony.sync.validateReconcileSession ");

    function validateReconcileSessionSuccess() {
        sync.log.trace("Entering  validateReconcileSessionSuccess");
        kony.sync.isFirstReconcileDownload = true;
        kony.sync.isFirstBulkGetReconcileDownload = true;
        var reconcileContext = kony.sync.getReconcileContext();
        kony.sync.resetReconcileGlobals();
        //todo add reconcilecontext to errorcontext
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationSuccess], reconcileContext);
    }

    function validateReconcileSessionError() {
        sync.log.trace("Entering  validateReconcileSessionError");
        kony.sync.currentSyncScopeFilter = null;
        kony.sync.isFirstReconcileDownload = true;
        kony.sync.isFirstBulkGetReconcileDownload = true;
        kony.sync.resetReconcileGlobals();
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], errorContext);
    }
    if (error === true) {
        validateReconcileSessionError();
    } else {
        kony.sync.currentSyncScopeFilter = null;
        if (kony.sync.currentReconcileScopeIndex == null) kony.sync.currentReconcileScopeIndex = 0;
        else kony.sync.currentReconcileScopeIndex = kony.sync.currentReconcileScopeIndex + 1;
        if (kony.sync.currentReconcileScopeIndex >= kony.sync.reconcileScopes.scopeList.length) {
            validateReconcileSessionSuccess();
            return;
        }
        var scopename = kony.sync.reconcileScopes.scopeList[kony.sync.currentReconcileScopeIndex];
        kony.sync.checkForPendingUploadInTransaction(scopename, successCallBack, validateReconcileSessionError);

        function populatePendingScopes(pendingObjectsInScope) {
            sync.log.trace("Entering populatePendingScopes");
            var currentReconcileScopeIndex = kony.sync.currentReconcileScopeIndex;
            var scopename = kony.sync.reconcileScopes.scopeList[currentReconcileScopeIndex];
            if (kony.sync.isNullOrUndefined(kony.sync.reconcilePendingScopes[scopename])) {
                kony.sync.reconcilePendingScopes[scopename] = null;
            }
            kony.sync.reconcilePendingScopes[scopename] = pendingObjectsInScope;
        }

        function successCallBack(pendingObjectsInScope) {
            sync.log.trace("Entering successCallBack");
            if (pendingObjectsInScope.length > 0) {
                populatePendingScopes(pendingObjectsInScope);
                var pendingInfoMap = {};
                var skippedScopeName = kony.sync.reconcileScopes.scopeList[kony.sync.currentReconcileScopeIndex];
                pendingInfoMap[kony.sync.reconcileSkippedScopeName] = skippedScopeName;
                pendingInfoMap[kony.sync.reconcilePendingObjectsInScope] = pendingObjectsInScope;
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationScopeSuccess], pendingInfoMap);
                kony.sync.currentReconcileScopeIndex = kony.sync.currentReconcileScopeIndex + 1;
                var currentReconcileScopeIndex = kony.sync.currentReconcileScopeIndex;
                if (currentReconcileScopeIndex < kony.sync.reconcileScopes.scopeList.length) {
                    var scopename = kony.sync.reconcileScopes.scopeList[currentReconcileScopeIndex];
                    kony.sync.checkForPendingUploadInTransaction(scopename, successCallBack);
                } else {
                    validateReconcileSessionSuccess();
                }
            } else {
                var currentReconcileScopeIndex = kony.sync.currentReconcileScopeIndex;
                if (currentReconcileScopeIndex < kony.sync.reconcileScopes.scopeList.length) {
                    var scopename = kony.sync.reconcileScopes.scopeList[currentReconcileScopeIndex];
                    var scopeContext = {};
                    scopeContext[scopename] = kony.sync.reconcileScopes[scopename].ReconcileTables;
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationScopeStart], scopeContext);
                    kony.sync.syncDownloadReconcileScopes(null);
                } else {
                    validateReconcileSessionSuccess();
                }
            }
        }
    }
}
kony.sync.getReconcileContext = function() {
    sync.log.trace("Entering kony.sync.getReconcileContext ");
    var reconcilecontext = {};
    reconcilecontext[kony.sync.reconcileObjectLevelInfo] = kony.sync.reconcileObjectLevelInfoMap;
    reconcilecontext[kony.sync.reconcileTotalInsertions] = kony.sync.reconcileTotalInserts;
    reconcilecontext[kony.sync.reconcileTotalDeletions] = kony.sync.reconcileTotalDeletes;
    reconcilecontext[kony.sync.reconcileTotalDownloads] = kony.sync.reconcileTotalDownloaded;
    reconcilecontext[kony.sync.pendingReconcileScopesWithHistoryChanges] = kony.sync.reconcilePendingScopes;
    return reconcilecontext;
}
kony.sync.getReconcileBulkGetBatchSize = function() {
    sync.log.trace("Entering kony.sync.getReconcileUploadBatchSize ");
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.reconcileBulkGetBatchSize])) {
        return kony.sync.currentSyncConfigParams[kony.sync.reconcileBulkGetBatchSize];
    }
    if (kony.os.deviceInfo().name === "blackberry") {
        return "50";
    } else {
        return "500";
    }
};
kony.sync.getReconcileDownloadBatchSize = function() {
    sync.log.trace("Entering kony.sync.getReconcileDownloadBatchSize ");
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.reconcileDownloadBatchSize])) {
        return kony.sync.currentSyncConfigParams[kony.sync.reconcileDownloadBatchSize];
    }
    if (kony.os.deviceInfo().name === "blackberry") {
        return "50";
    } else {
        return "500";
    }
};
kony.sync.deleteReconcileTempTables = function(tx) {
        sync.log.trace("Entering function kony.sync.deleteReconcileTempTables ");
        //deleting temp tables to store the downloaded data
        var scopeNames = kony.sync.reconcileScopes.scopeList;
        var isError = false;
        for (var i = 0; i < scopeNames.length; i++) {
            var scopeName = scopeNames[i];
            var reconcileTables = kony.sync.reconcileScopes[scopeName].ReconcileTables;
            for (var j = 0; j < reconcileTables.length; j++) {
                var tableName = reconcileTables[j];
                var dropCacheTable = "drop table if exists " + tableName + "" + kony.sync.reconcileCacheKey;
                if (kony.sync.executeSql(tx, dropCacheTable) === false) {
                    sync.log.error("failure in dropping cachetable for table " + tableName)
                    isError = true;
                }
                var dropTempTable = "drop table if exists " + tableName + "" + kony.sync.tempTableKey;
                if (kony.sync.executeSql(tx, dropTempTable) === false) {
                    sync.log.error("failure in dropping temptable for table " + tableName)
                    isError = true;
                }
            }
        }
    }
    //  **************** End KonySyncDataReconciliation.js*******************
    //  **************** End KonySyncDataReconciliation.js*******************
    //  **************** Start KonySyncDBOperations.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.insert = function(tx, tablename, values, insert_callback, markForUpload, options) {
    sync.log.trace("Entering kony.sync.insert ");
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    if (markForUpload === false) {
        values[kony.sync.mainTableChangeTypeColumn] = kony.sync.insertColStatusDI;
    } else {
        values[kony.sync.mainTableChangeTypeColumn] = kony.sync.insertColStatus;
    }
    values[kony.sync.mainTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
    var scope = kony.sync.scopes[scopename];
    var generatedPK = kony.sync.replaceautogeneratedPK(scopename, scope.syncTableDic[tablename], values, tx, insert_callback);
    if (generatedPK === false) {
        return false;
    }
    //Check if it is original or save the original state.
    if (markForUpload === false) {
        if (kony.sync.addToRollBack(tx, tablename, values, kony.sync.insertColStatusDI, null, insert_callback) === false) {
            return false;
        }
    } else {
        if (kony.sync.addToRollBack(tx, tablename, values, kony.sync.insertColStatus, null, insert_callback) === false) {
            return false;
        }
    }
    if (kony.sync.insertEx(tx, tablename, values, insert_callback) === false) {
        return false;
    }
    //By default, sync tracking is enabled
    var synctracking = kony.sync.getSyncTracking(options);
    //If sync tracking is off, avoid inserting the record in history table
    if (synctracking === false) {
        return generatedPK;
    }
    var syncorder = kony.sync.getSyncOrder(scopename, tx, insert_callback);
    if (syncorder !== null && syncorder !== false) {
        values[kony.sync.mainTableChangeTypeColumn] = null;
        values[kony.sync.mainTableSyncVersionColumn] = null;
        if (markForUpload === false) {
            values[kony.sync.historyTableChangeTypeColumn] = kony.sync.insertColStatusDI;
        } else {
            values[kony.sync.historyTableChangeTypeColumn] = kony.sync.insertColStatus;
        }
        values[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
        values[kony.sync.historyTableReplaySequenceColumn] = syncorder + 1;
        if (kony.sync.insertEx(tx, tablename + kony.sync.historyTableName, values, insert_callback) === false) {
            return false;
        }
        if (kony.sync.setSyncOrder(scopename, syncorder + 1, tx, insert_callback) === false) {
            return false;
        }
    } else {
        // not expected to come here
        sync.log.fatal("Invalid sync order in insert function");
    }
    return generatedPK;
};
kony.sync.insertEx = function(tx, tablename, values, errorcallback, rollback) {
    sync.log.trace("Entering kony.sync.insertEx ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_set(query, values);
    kony.sync.qb_insert(query, tablename);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params, errorcallback, rollback);
};
kony.sync.purgeInsertEx = function(tx, tablename, values, rollback) {
    sync.log.trace("Entering kony.sync.purgeInsertEx ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_purgeInsert(query, tablename, values);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params, null, rollback);
};
kony.sync.error_callbackdb = function(error) {
    sync.log.trace("Entering kony.sync.error_callbackdb ");
    sync.log.error("@@@@@@@@@@@@@ -" + error.message + " @@@ " + error.code);
};
kony.sync.update = function(tx, tablename, values, wc, markForUpload, options) {
    sync.log.trace("Entering kony.sync.update ");
    //Check if it is original or save the original state.
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename + "_history");
    kony.sync.qb_where(query, wc);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var myres = kony.sync.executeSql(tx, sql, params);
    if (myres === false) {
        return false;
    }
    for (var k = 0; k < myres.rows.length; k++) {
        var recordres = kony.db.sqlResultsetRowItem(tx, myres, 0);
        if (recordres === null) {
            return false;
        }
        var prevMarkForupload = recordres.konysyncchangetype;
        if (prevMarkForupload == 90 && markForUpload == true) {
            return kony.sync.errorCodeInvalidMarkForUploadValue;
        }
    }
    if (markForUpload === false) {
        if (kony.sync.addToRollBack(tx, tablename, values, kony.sync.updateColStatusDU, wc) === false) {
            return false;
        }
    } else {
        if (kony.sync.addToRollBack(tx, tablename, values, kony.sync.updateColStatus, wc) === false) {
            return false;
        }
    }
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    if (markForUpload === false) {
        values[kony.sync.mainTableChangeTypeColumn] = kony.sync.updateColStatusDU;
    } else {
        values[kony.sync.mainTableChangeTypeColumn] = kony.sync.updateColStatus;
    }
    values[kony.sync.mainTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
    var resultSet = kony.sync.updateEx(tx, tablename, values, wc);
    var updateResult = {};
    if (resultSet === false) {
        return false;
    } else {
        updateResult[kony.sync.numberOfRowsUpdated] = resultSet.rowsAffected;
    }
    var synctracking = kony.sync.getSyncTracking(options);
    //If sync tracking is off, just return dont insert the record in history table
    if (synctracking === false) {
        return updateResult;
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    kony.sync.qb_where(query, wc);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var syncorder = kony.sync.getSyncOrder(scopename, tx);
    if (syncorder === false) {
        return false;
    }
    resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet === false) {
        return false;
    } else if (resultSet.rows.length === 0) {
        sync.log.error("No record found with the given where condition " + JSON.stringify(wc));
        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeRecordDoNotExist, kony.sync.getErrorMessage(kony.sync.errorCodeRecordDoNotExist, JSON.stringify(wc)));
        return false;
    }
    var record = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
    if (record === null) {
        return false;
    }
    if (!kony.sync.isNullOrUndefined(syncorder)) {
        record[kony.sync.historyTableReplaySequenceColumn] = syncorder + 1;
        if (markForUpload === false) {
            record[kony.sync.historyTableChangeTypeColumn] = kony.sync.updateColStatusDU;
        } else {
            record[kony.sync.historyTableChangeTypeColumn] = kony.sync.updateColStatus;
        }
        record[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
        if (kony.sync.addUpdateToHistoryTable(tx, tablename + kony.sync.historyTableName, record) === false) {
            return false;
        }
        if (kony.sync.setSyncOrder(scopename, syncorder + 1, tx) === false) {
            return false;
        }
    } else {
        // not expected to come here
        sync.log.fatal("Invalid sync order in insert function");
    }
    return updateResult;
};
kony.sync.updateBatch = function(tx, tablename, values, wc, markForUpload, primaryKey, options) {
    sync.log.trace("Entering kony.sync.updateBatch ");
    //adding original values to rollback tables if exists
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0] + " " + wc;
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params, null, null, "Adding original values to rollback tables if exists");
    var i = 0;
    var record = null;
    if (resultSet === false) {
        return false;
    }
    var num_records = resultSet.rows.length;
    for (i = 0; i < num_records; i++) {
        record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
        if (markForUpload === false) {
            record[kony.sync.originalTableChangeTypeColumn] = kony.sync.updateColStatusDU;
        } else {
            record[kony.sync.originalTableChangeTypeColumn] = kony.sync.updateColStatus;
        }
        record[kony.sync.originalTableSyncVersionColumn] = record[kony.sync.originalTableChangeTypeColumn];
        record[kony.sync.mainTableChangeTypeColumn] = null;
        record[kony.sync.mainTableSyncVersionColumn] = null;
        //record[kony.sync.mainTableHashSumColumn] = null;
        kony.sync.insertEx(tx, tablename + kony.sync.originalTableName, record, null, false);
    }
    //Get Primary Key from where clause
    query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    query_compile = kony.sync.qb_compile(query);
    sql = query_compile[0] + " " + wc;
    params = query_compile[1];
    resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet === false) {
        return false;
    }
    num_records = resultSet.rows.length;
    var pkSet = [];
    for (i = 0; i < num_records; i++) {
        record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
        var pkRecord = [];
        for (var j = 0; j < primaryKey.length; j++) {
            pkRecord.push({
                "key": primaryKey[j],
                "value": record[primaryKey[j]]
            });
        }
        pkSet.push(pkRecord);
    }
    //updating main tables
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    if (markForUpload === false) {
        values[kony.sync.mainTableChangeTypeColumn] = kony.sync.updateColStatusDU;
    } else {
        values[kony.sync.mainTableChangeTypeColumn] = kony.sync.updateColStatus;
    }
    values[kony.sync.mainTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
    // update the flag only if this record is present on server
    resultSet = kony.sync.updateEx(tx, tablename, values, wc, null, true);
    var updateResult = {};
    if (resultSet === false) {
        return false;
    } else {
        updateResult[kony.sync.numberOfRowsUpdated] = resultSet.rowsAffected;
        //kony.sync.verifyAndCallClosure(update_callback, {kony.sync.numberOfRowsUpdated:resultSet.rowsAffected});
    }
    var synctracking = kony.sync.getSyncTracking(options);
    //Don't insert into history table if sync tracking is off
    if (synctracking === false) {
        return updateResult;
    }
    var syncorder = kony.sync.getSyncOrder(scopename, tx);
    if (syncorder === false) {
        return false;
    }
    for (var i = 0; i < pkSet.length; i++) {
        query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, tablename);
        kony.sync.qb_where(query, pkSet[i]);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        resultSet = kony.sync.executeSql(tx, sql, params);
        if (resultSet === false) {
            return false;
        }
        record = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
        syncorder = syncorder + 1;
        record[kony.sync.historyTableReplaySequenceColumn] = syncorder;
        record[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
        if (kony.sync.addUpdateToHistoryTable(tx, tablename + kony.sync.historyTableName, record) === false) {
            return false;
        }
    }
    if (kony.sync.setSyncOrder(scopename, syncorder, tx) === false) {
        return false;
    }
    return updateResult;
};
kony.sync.updateEx = function(tx, tablename, values, wc, update_callback, isBatch) {
    sync.log.trace("Entering kony.sync.updateEx ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_set(query, values);
    kony.sync.qb_update(query, tablename);
    if (kony.sync.isNullOrUndefined(isBatch)) {
        kony.sync.qb_where(query, wc);
    }
    //local sqlUpdate = "update "..tablename.." set "..updateStr..wc;
    var query_compile = kony.sync.qb_compile(query);
    var sqlUpdate = "";
    if (isBatch === true) {
        sqlUpdate = query_compile[0] + " " + wc;
    } else {
        sqlUpdate = query_compile[0];
    }
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sqlUpdate, params);
};
kony.sync.upsertEx = function(tx, tablename, values, wc, callback) {
    sync.log.trace("Entering kony.sync.upsertEx ");
    var result = kony.sync.purgeInsertEx(tx, tablename, values, callback);
    if (result !== false && result.rowsAffected === 0) {
        kony.sync.serverUpdateCount = kony.sync.serverUpdateCount + 1;
        // update if the user hasn't changed the record
        kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] + 1;
        kony.sync.updateEx(tx, tablename, values, wc);
    } else {
        kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] + 1;
        kony.sync.serverInsertCount = kony.sync.serverInsertCount + 1;
    }
};
kony.sync.isrowexists = function(tx, tablename, wc, errorCallback) {
    sync.log.trace("Entering kony.sync.isrowexists ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    kony.sync.qb_where(query, wc);
    //local sql = "select * from "..tablename..wc;
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset === false) {
        return false;
    }
    if (resultset.rows.length === 1) {
        return true;
    } else {
        return null; //if row doesn't exists, we should add it to rollback table
    }
};
//Function to delete one(batch)change
kony.sync.remove = function(tx, tablename, wc, isLocal, markForUpload, errorCallback, options) {
    sync.log.trace("Entering kony.sync.remove ");
    //Check if it is original or save the original state.
    if (isLocal !== true) {
        if (markForUpload === false) {
            if (kony.sync.addToRollBack(tx, tablename, null, kony.sync.deleteColStatusDD, wc, errorCallback) === false) {
                return false;
            }
        } else {
            if (kony.sync.addToRollBack(tx, tablename, null, kony.sync.deleteColStatus, wc, errorCallback) === false) {
                return false;
            }
        }
    }
    //Getting the records with the where clause
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    var scope = kony.sync.scopes[scopename];
    var syncTable = scope.syncTableDic[tablename];
    var record = null;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    kony.sync.qb_where(query, wc);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultSet === false) {
        return false;
    }
    var num_records = resultSet.rows.length;
    var rowsDeleted = 0;
    var synctracking = kony.sync.getSyncTracking(options);
    for (var i = 0; i < num_records; i++) {
        //adding changes to history table
        if (isLocal !== true) {
            if (synctracking === true) {
                record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
                var values = {};
                values[kony.sync.historyTableHashSumColumn] = record[kony.sync.mainTableHashSumColumn];
                if (!kony.sync.isNullOrUndefined(syncTable.Columns)) {
                    for (var j = 0; j < syncTable.Columns.length; j++) {
                        var column = syncTable.Columns[j];
                        values[column.Name] = record[column.Name];
                    }
                }
                var syncorder = kony.sync.getSyncOrder(scopename, tx, errorCallback);
                if (syncorder === false) {
                    return false;
                }
                if (syncorder !== null) {
                    values[kony.sync.historyTableReplaySequenceColumn] = syncorder + 1;
                    if (markForUpload === false) {
                        values[kony.sync.historyTableChangeTypeColumn] = kony.sync.deleteColStatusDD;
                    } else {
                        values[kony.sync.historyTableChangeTypeColumn] = kony.sync.deleteColStatus;
                    }
                    values[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
                    if (kony.sync.insertEx(tx, tablename + kony.sync.historyTableName, values, null, errorCallback) === false) {
                        return false;
                    }
                    if (kony.sync.setSyncOrder(scopename, syncorder + 1, tx, errorCallback) === false) {
                        return false;
                    }
                } else {
                    // not expected to come here
                    sync.log.fatal("Invalid sync order in insert function");
                }
            }
        } else {
            //deleting all local changes from history
            record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            sync.log.debug("Removing Local Changes: ", record);
            query = kony.sync.qb_createQuery();
            kony.sync.qb_delete(query, null);
            kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
            kony.sync.qb_where(query, wc);
            query_compile = kony.sync.qb_compile(query);
            params = query_compile[1];
            sql = query_compile[0];
            if (kony.sync.executeSql(tx, sql, params, errorCallback) === false) {
                return false;
            }
            //deleting all local changes from original
            record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            sync.log.debug("Removing Local Changes from original: ", record);
            query = kony.sync.qb_createQuery();
            kony.sync.qb_delete(query, null);
            kony.sync.qb_from(query, tablename + kony.sync.originalTableName);
            kony.sync.qb_where(query, wc);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params, errorCallback) === false) {
                return false;
            }
        }
        //deleting from main table
        var resultSet1 = kony.sync.removeEx(tx, tablename, wc, null, errorCallback);
        if (resultSet1 === false) {
            return false;
        }
        rowsDeleted = rowsDeleted + resultSet1.rowsAffected;
    }
    var deleteResult = {};
    deleteResult[kony.sync.numberOfRowsDeleted] = rowsDeleted;
    return deleteResult;
};
//Function to delete more than one(batch)changes
kony.sync.deleteBatch = function(tx, tablename, wc, isLocal, markForUpload, errorCallback, options) {
    sync.log.trace("Entering kony.sync.deleteBatch ");
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    var i = null;
    var record = null;
    //adding original values to rollback tables if exists
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0] + " " + wc;
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultSet === false) {
        return false;
    }
    var num_records = resultSet.rows.length;
    if (isLocal === false) {
        for (i = 0; i <= num_records - 1; i++) {
            record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            record[kony.sync.originalTableChangeTypeColumn] = kony.sync.deleteColStatus;
            record[kony.sync.originalTableSyncVersionColumn] = record[kony.sync.originalTableChangeTypeColumn];
            record[kony.sync.mainTableChangeTypeColumn] = null;
            record[kony.sync.mainTableSyncVersionColumn] = null;
            //record[kony.sync.mainTableHashSumColumn] = null;
            kony.sync.insertEx(tx, tablename + kony.sync.originalTableName, record, null, false);
        }
    }
    query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    query_compile = kony.sync.qb_compile(query);
    sql = query_compile[0] + " " + wc;
    params = query_compile[1];
    var syncorder = kony.sync.getSyncOrder(scopename, tx, errorCallback);
    if (syncorder === false) {
        return false;
    }
    resultSet = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultSet === false) {
        return false;
    }
    num_records = resultSet.rows.length;
    var synctracking = kony.sync.getSyncTracking(options);
    if ((syncorder !== null)) {
        for (i = 0; i < num_records; i++) {
            record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            //adding change replay to history tables
            if (isLocal === false) {
                if (synctracking === true) {
                    syncorder = syncorder + 1;
                    record[kony.sync.historyTableReplaySequenceColumn] = syncorder;
                    if (markForUpload === false) {
                        record[kony.sync.historyTableChangeTypeColumn] = kony.sync.deleteColStatusDD;
                    } else {
                        record[kony.sync.historyTableChangeTypeColumn] = kony.sync.deleteColStatus;
                    }
                    record[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
                    if (kony.sync.insertEx(tx, tablename + kony.sync.historyTableName, record, errorCallback) === false) {
                        return false;
                    }
                }
            }
            //deleting local changes from history table
            else {
                sync.log.debug("Removing Local Changes: ", record);
                query = kony.sync.qb_createQuery();
                kony.sync.qb_delete(query, null);
                kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0] + " " + wc;
                params = query_compile[1];
                if (kony.sync.executeSql(tx, sql, params, errorCallback) === false) {
                    return false;
                }
                sync.log.debug("Removing Local Changes from original: ", record);
                query = kony.sync.qb_createQuery();
                kony.sync.qb_delete(query, null);
                kony.sync.qb_from(query, tablename + kony.sync.originalTableName);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0] + " " + wc;
                params = query_compile[1];
                if (kony.sync.executeSql(tx, sql, params, errorCallback) === false) {
                    return false;
                }
            }
        }
        if (kony.sync.setSyncOrder(scopename, syncorder, tx, errorCallback) === false) {
            return false;
        }
    } else {
        // not expected to come here
        sync.log.fatal("Invalid sync order in insert function");
    }
    //deleting main tables
    resultSet = kony.sync.removeEx(tx, tablename, wc, true, errorCallback);
    if (resultSet === false) {
        return false;
    }
    var deleteResult = {};
    deleteResult[kony.sync.numberOfRowsDeleted] = resultSet.rowsAffected;
    return deleteResult;
};
kony.sync.removeEx = function(tx, tablename, wc, isBatch, errorcallback) {
    sync.log.trace("Entering kony.sync.removeEx ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_delete(query, tablename);
    if (kony.sync.isNullOrUndefined(isBatch)) {
        kony.sync.qb_where(query, wc);
    }
    //local sql = "delete from "..tablename.." "..wc;
    var query_compile = kony.sync.qb_compile(query);
    var sql = "";
    if (isBatch === true) {
        sql = query_compile[0] + " " + wc;
    } else {
        sql = query_compile[0];
    }
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params, errorcallback);
};
kony.sync.addToRollBack = function(tx, tablename, values, changetype, wcs, errorCallback) {
    sync.log.trace("Entering kony.sync.addToRollBack ");
    var originalwcs = kony.sync.createClone(wcs);
    var originalvalues = kony.sync.createClone(values);
    var rowExists = null;
    if (changetype === kony.sync.insertColStatus || changetype === kony.sync.insertColStatusDI) {
        originalvalues[kony.sync.originalTableChangeTypeColumn] = changetype;
        originalvalues[kony.sync.originalTableSyncVersionColumn] = null;
        originalvalues[kony.sync.mainTableChangeTypeColumn] = null;
        originalvalues[kony.sync.mainTableSyncVersionColumn] = null;
        originalvalues[kony.sync.mainTableHashSumColumn] = null;
        var scope = kony.sync.scopes[kony.sync.scopes.syncTableScopeDic[tablename]];
        var pkColumns = scope.syncTableDic[tablename].Pk_Columns;
        var pkRecord = [];
        for (var j = 0; j < pkColumns.length; j++) {
            pkRecord.push({
                "key": pkColumns[j],
                "value": originalvalues[pkColumns[j]]
            });
        }
        rowExists = kony.sync.isrowexists(tx, tablename + kony.sync.originalTableName, pkRecord);
        if (rowExists === true) {
            //Original State is already saved, no need to save again
            return true;
        } else if (rowExists === false) {
            return false;
        } else {
            if (kony.sync.insertEx(tx, tablename + kony.sync.originalTableName, originalvalues) === false) {
                return false;
            } else {
                return true;
            }
        }
    }
    rowExists = kony.sync.isrowexists(tx, tablename + kony.sync.originalTableName, wcs);
    if (rowExists === true) {
        //Original State is already saved, no need to save again
        return true;
    } else if (rowExists === false) {
        return false;
    } else if (rowExists === null) {
        kony.table.insert(originalwcs, {
            key: kony.sync.mainTableChangeTypeColumn,
            value: "nil",
            comptype: "OR",
            openbrace: true
        });
        kony.table.insert(originalwcs, {
            key: kony.sync.mainTableChangeTypeColumn,
            value: "-1",
            comptype: "OR",
            closebrace: true
        });
        //table.insert(originalwcs,{key = kony.sync.mainTableChangeTypeColumn, value = "-1"})
        var record = kony.sync.getOriginalRow(tx, tablename, originalwcs, errorCallback);
        if (record === false) {
            return false;
        }
        /* This logic is not needed as when row is not already present in rollback table and 
        	waiting for acknowledgement,it should not be backed up in original table because 
        	rollbacking it would lead to inconsistency
        	Note: This case generally occurs in persistent strategy when record waits for acknowledgement
        if (record === null) {
        	//means record got changed but pending for acknowledgement
        	kony.table.remove(originalwcs);
        	kony.table.insert(originalwcs, {
        		key : kony.sync.mainTableChangeTypeColumn,
        		value : "-1",
        		optype : "EQ",
        		comptype : "OR",
        		openbrace : true
        	});
        	kony.table.insert(originalwcs, {
        		key : kony.sync.mainTableChangeTypeColumn,
        		value : changetype,
        		optype : "EQ",
        		comptype : "OR"
        	});
        	kony.table.insert(originalwcs, {
        		key : kony.sync.mainTableChangeTypeColumn,
        		value : "90",
        		optype : "EQ",
        		comptype : "OR"
        	});
        	kony.table.insert(originalwcs, {
        		key : kony.sync.mainTableChangeTypeColumn,
        		value : "91",
        		optype : "EQ",
        		closebrace : true
        	});
        	record = kony.sync.getOriginalRow(tx, tablename, originalwcs, errorCallback);
        	if (record === false) {
        		return false;
        	}
        }
        */
        if (record !== null) {
            //Records not equal to nil means that it is not pending to be uploaded/acknowledged. So original state has to saved.
            record[kony.sync.originalTableChangeTypeColumn] = changetype;
            record[kony.sync.originalTableSyncVersionColumn] = record[kony.sync.mainTableSyncVersionColumn];
            record[kony.sync.mainTableChangeTypeColumn] = null;
            record[kony.sync.mainTableSyncVersionColumn] = null;
            //record[kony.sync.mainTableHashSumColumn] = null;
            record[kony.sync.mainTableHashSumColumn] = record[kony.sync.originalTableHashSumColumn];
            return kony.sync.insertEx(tx, tablename + kony.sync.originalTableName, record);
        }
    }
};
kony.sync.getOriginalRow = function(tx, tablename, wcs, errorcallback) {
    sync.log.trace("Entering kony.sync.getOriginalRow ");
    var sql = "";
    var params = "";
    if (typeof(wcs) == "string" || typeof(wcs) == "String") {
        sql = "select * from " + tablename + " " + wcs + " ;";
        params = null;
    } else {
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, tablename);
        kony.sync.qb_where(query, wcs);
        var query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
    }
    var resultset = kony.sync.executeSql(tx, sql, params, errorcallback);
    if (!resultset) {
        return false;
    }
    if (resultset.rows.length === 1) {
        return kony.db.sqlResultsetRowItem(tx, resultset, 0);
    } else {
        return null;
    }
};
kony.sync.syncDropDatabase = function(dbList, successcallback, errorcallback) {
    sync.log.trace("Entering kony.sync.syncDropDatabase ");
    sync.log.info("Dropping database list: ", dbList);
    var isError = false;

    function single_transaction_success_callback(res) {
        sync.log.trace("Entering single_transaction_success_callback");
        sync.log.debug("Single Select callback result: ", res);
        if (!kony.sync.isNullOrUndefined(dbList) && !kony.sync.isNullOrUndefined(dbList[0]) && !kony.sync.isNullOrUndefined(dbList[0].dbname)) {
            dbname = dbList[0].dbname;
            //var connection1 = kony.db.openDatabaseSync(dbname, "1.0", dbname, 5 * 1024 * 1024);
            //kony.db.transaction(connection1, single_transaction_callback, single_transaction_error_callback, single_transaction_success_callback);
            var connection1 = kony.sync.getConnectionOnly(dbname, dbname);
            kony.sync.startTransaction(connection1, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
        } else {
            sync.log.info("Deleting all binary files ");
            if (typeof(binary) !== "undefined" && typeof(binary.util) !== "undefined") {
                binary.util.deleteAllBinaryFiles();
            }
            sync.log.info("Reinitializing...");
            sync.init(successcallback, errorcallback);
        }
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        sync.log.info("Dropping database: ", dbList[0].dbname);
        for (var i = 0; i < dbList[0].tableList.length; i++) {
            var v = dbList[0].tableList[i];
            if (kony.sync.dropTable(tx, v) === false) {
                isError = true;
                return;
            }
        }
        dbList = dbList.slice(1);
    }

    function single_transaction_error_callback(res) {
        sync.log.trace("Entering single_transaction_error_callback");
        sync.log.error("Sync Reset failed ", res);
        //kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getSyncResetFailed());
        kony.sync.isResetInProgress = false;
        kony.sync.callTransactionError(isError, errorcallback);
    }
    var dbname = dbList[0].dbname;
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
};
kony.sync.dropTable = function(tx, tablename) {
    sync.log.trace("Entering kony.sync.dropTable ");
    sync.log.info("Dropping tablename ", tablename);
    var query = null;
    if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLCE)) {
        query = "Drop Table " + tablename;
    } else if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLLite)) {
        query = "Drop Table if exists " + tablename;
    }
    return kony.sync.executeSql(tx, query, null);
};
kony.sync.addUpdateToHistoryTable = function(tx, tablename, values) {
    sync.log.trace("Entering kony.sync.addUpdateToHistoryTable ");
    var toUpdate = false;
    if (!kony.sync.trackIntermediateUpdates) {
        //frame primary key
        var scope = kony.sync.scopes[kony.sync.scopes.syncTableScopeDic[tablename]];
        var pkColumns = scope.syncTableDic[tablename].Pk_Columns;
        var wc = [];
        if (!kony.sync.isNullOrUndefined(pkColumns)) {
            for (var j = 0; j < pkColumns.length; j++) {
                if (!kony.sync.isNullOrUndefined(values[pkColumns[j]])) {
                    kony.table.insert(wc, {
                        key: pkColumns[j],
                        value: values[pkColumns[j]]
                    });
                }
            }
        }
        //Get the row and check its changetype
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, tablename);
        kony.sync.qb_where(query, wc);
        kony.sync.qb_orderBy(query, [{
            key: kony.sync.historyTableReplaySequenceColumn,
            sortType: "desc"
        }]);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params);
        var lastRecord = null;
        var lastChangeType = null;
        if (resultSet === false) {
            return false;
        }
        if (resultSet.rows.length > 0) {
            lastRecord = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
            lastChangeType = "" + lastRecord[kony.sync.historyTableChangeTypeColumn];
            if (lastChangeType === kony.sync.updateColStatus || lastChangeType === kony.sync.updateColStatusDU) {
                toUpdate = true;
                //update the last row
                query = kony.sync.qb_createQuery();
                kony.sync.qb_set(query, values);
                kony.sync.qb_update(query, tablename);
                kony.table.insert(wc, {
                    key: kony.sync.historyTableReplaySequenceColumn,
                    value: lastRecord[kony.sync.historyTableReplaySequenceColumn]
                });
                kony.sync.qb_where(query, wc);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                return kony.sync.executeSql(tx, sql, params);
            }
        }
    }
    if (!toUpdate) {
        var query1 = kony.sync.qb_createQuery();
        kony.sync.qb_set(query1, values);
        kony.sync.qb_insert(query1, tablename);
        var query_compile1 = kony.sync.qb_compile(query1);
        var sql1 = query_compile1[0];
        var params1 = query_compile1[1];
        return kony.sync.executeSql(tx, sql1, params1);
    }
};
//  **************** End KonySyncDBOperations.js*******************
//  **************** Start KonySyncDownload.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
kony.sync.pendingBinaryDownloadJobs = [];
kony.sync.syncDownloadChanges = function(sname, dbname, onCompletion) {
    sync.log.trace("Entering kony.sync.syncDownloadChanges ");
    kony.sync.onDownloadCompletion = onCompletion;
    kony.sync.resetbatchsessionglobals();
    kony.sync.PersisChangestobeDeleted = []; //Used for upload after delete in persistence strategey 
    sync.log.info("Download started for scope : ", sname);
    kony.sync.currentSyncScopeFilter = null;
    if (kony.sync.isValidJSTable(kony.sync.currentSyncConfigParams[kony.sync.filterParams])) {
        var scopeFilter = kony.sync.currentSyncConfigParams[kony.sync.filterParams][kony.sync.currentScope[kony.sync.scopeName]];
        sync.log.info("scope Filter for " + kony.sync.currentScope[kony.sync.scopeName] + " is :" + scopeFilter);
        if (kony.sync.isNullOrUndefined(scopeFilter)) {
            kony.sync.getLastSynctime(sname, dbname, kony.sync.syncDownloadchangesGetLastSynctime);
        } else {
            //current_sync_scopefilter_index = 0;
            //kony.sync.syncDownloadbyFilter(current_sync_scopefilter_index);
            kony.sync.syncDownloadbyFilter();
        }
    } else {
        kony.sync.getLastSynctime(sname, dbname, kony.sync.syncDownloadchangesGetLastSynctime);
    }
};
//kony.sync.syncDownloadbyFilter = function (index) {
kony.sync.syncDownloadbyFilter = function() {
    sync.log.trace("Entering kony.sync.syncDownloadbyFilter ");
    var scopeFilter = kony.sync.currentSyncConfigParams[kony.sync.filterParams][kony.sync.currentScope[kony.sync.scopeName]];
    //if (index < scopeFilter.length) {
    var scopejsonfilter = {
        //"d" : scopeFilter[index]
        "d": scopeFilter
    };
    var filtervaluejson = JSON.stringify(scopejsonfilter);
    sync.log.debug(filtervaluejson);
    kony.sync.currentSyncScopeFilter = scopeFilter; //scopeFilter[index];
    kony.sync.getLastSynctimeFilter(kony.sync.currentScope[kony.sync.scopeName], filtervaluejson, kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.syncDownloadchangesGetLastSynctime);
    /*} else {
    	kony.sync.globalIsDownloadStarted = true;
    	kony.sync.onDownloadCompletion(false, null);
    }*/
};
kony.sync.syncDownloadchangesGetLastSynctime = function(rowItem) {
    sync.log.trace("Entering kony.sync.syncDownloadchangesGetLastSynctime ");
    var lastsynctime = rowItem[0][kony.sync.metaTableSyncTimeColumn];
    sync.log.info("Last Sync Time with Server : " + lastsynctime);
    var upgradeSchemaLastSyncTime = rowItem[0][kony.sync.metaTableSchemaUpgradeSyncTimeColumn];
    var serverChanges = null;
    var startTime = new Date();
    var isError = false;
    if (kony.sync.schemaUpgradeDownloadPending && kony.sync.isSchemaUpgradeTimeStampEmpty(lastsynctime)) {
        sync.log.trace("Skipping download for schema upgrade as no data available");
        kony.sync.onDownloadCompletion(false);
        return;
    }

    function downloadNextBatch(tx) {
        sync.log.trace("Entering downloadNextBatch");
        var morechanges = serverChanges.d.__sync.moreChangesAvailable;
        var serverblob = serverChanges.d.__sync.serverblob;
        var pendingbatches = serverChanges.d.__sync.pendingBatches;
        kony.sync.currentSyncReturnParams[kony.sync.lastSyncTimestamp] = serverblob;
        if (kony.sync.isApplyChangesSync()) {
            if (kony.sync.applyChanges(tx, kony.sync.currentScope, serverChanges) === false) {
                isError = true;
                return;
            }
            if (kony.sync.postApplyChanges(tx, serverblob, morechanges, pendingbatches) === false) {
                isError = true;
                return;
            }
        } else {
            kony.sync.applyChangesAsync(tx, kony.sync.currentScope, serverChanges, serverblob, morechanges);
        }
    }

    function downloadCompleted() {
        sync.log.trace("Entering downloadCompleted");
        if (kony.sync.globalIsDownloadStarted) {
            //This means that download has failed and variable is reset;
            return;
        }
        var endTime = new Date();
        var diff = endTime.getTime() - startTime.getTime();
        sync.log.debug("Time Taken for Batch Insertion Download : " + diff);
        kony.sync.batchInsertionTimer = kony.sync.batchInsertionTimer + diff;
        var params = {};
        params.pending_batches = kony.sync.tonumber(kony.sync.syncPendingBatchesNo);
        params.serverinsertcount = "Server Insert Count :" + kony.sync.serverInsertCount;
        params.serverupdatecount = "Server Update Count :" + kony.sync.serverUpdateCount;
        params.serverinsertackcount = "Server Insert Ack Count :" + kony.sync.serverInsertAckCount;
        params.serverupdateackcount = "Server Update Ack Count :" + kony.sync.serverUpdateAckCount;
        sync.log.debug("@@@@@@" + params);
        kony.table.insert(kony.sync.currentSyncLog, params);
        sync.log.debug(kony.sync.serverInsertCount);
        if (kony.sync.isSyncStopped) {
            sync.log.debug("sync stopped in downloadCompleted");
            kony.sync.stopSyncSession();
            return;
        }
        var batchcontext = {};
        batchcontext[kony.sync.numberOfRowsDownloaded] = kony.sync.serverInsertCount + kony.sync.serverUpdateCount + kony.sync.serverDeleteCount;
        batchcontext[kony.sync.numberOfRowsInserted] = kony.sync.serverInsertCount;
        batchcontext[kony.sync.numberOfRowsUpdated] = kony.sync.serverUpdateCount;
        batchcontext[kony.sync.numberOfRowsDeleted] = kony.sync.serverDeleteCount;
        batchcontext[kony.sync.numberOfRowsFailedtoUpload] = kony.sync.serverFailedCount;
        batchcontext[kony.sync.failedRowInfo] = kony.sync.uploadSummary;
        batchcontext[kony.sync.objectLevelInfo] = kony.sync.objectLevelInfoMap;
        kony.sync.objectLevelInfoMap = {};
        if ((kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA)) {
            batchcontext[kony.sync.numberOfRowsAcknowledged] = kony.sync.serverInsertAckCount + kony.sync.serverUpdateAckCount + kony.sync.serverDeleteAckCount;
            batchcontext[kony.sync.numberOfRowsInsertedAck] = kony.sync.serverInsertAckCount;
            batchcontext[kony.sync.numberOfRowsUpdatedAck] = kony.sync.serverUpdateAckCount;
            batchcontext[kony.sync.numberOfRowsDeletedAck] = kony.sync.serverDeleteAckCount;
        }
        batchcontext[kony.sync.pendingBatches] = kony.sync.tonumber(kony.sync.syncPendingBatchesNo);
        kony.sync.currentSyncReturnParams[kony.sync.batchContext] = batchcontext;
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onBatchProcessingSuccess], kony.sync.currentSyncReturnParams);
        if ((kony.sync.moreChangesAvailable)) {
            kony.sync.syncDownloadChanges(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.onDownloadCompletion);
        } else {
            kony.sync.printScopeLog(kony.sync.currentSyncLog);
            delete kony.sync.currentSyncReturnParams[kony.sync.batchContext];
            //clearing sync order and then deleting records after upload
            if (kony.sync.isUploadErrorPolicyCOE(kony.sync.currentScope)) {
                if (kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA) {
                    removeAfterUpload(0);
                } else {
                    kony.sync.updateSyncOrderForScope(removeAfterUpload);
                }
            } else {
                removeAfterUpload(0);
            }
        }
    }
    //wrapper for removeafterupload
    function removeAfterUpload(code) {
        sync.log.trace("Entering removeAfterUpload");
        if (code === 0) {
            kony.sync.deleteRecordsAfterUpload(postDownloadProcessing);
        } else {
            //statement error
            if (code === kony.sync.errorCodeSQLStatement) {
                kony.sync.downloadFailed(true);
            }
            //transaction error
            else {
                kony.sync.downloadFailed(false);
            }
        }
    }
    //This function should be called after finishing all post download tasks like removeafterupload
    function postDownloadProcessing(code) {
        sync.log.trace("Entering postDownloadProcessing");
        if (kony.sync.isSyncStopped) {
            sync.log.debug("Stopped in  postDownloadProcessing");
            kony.sync.stopSyncSession();
            return;
        }
        if (code === 0) {
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onDownloadSuccess], kony.sync.currentSyncReturnParams);
            /*if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncScopeFilter)) {
            	kony.sync.syncDownloadbyFilter(kony.sync.currentSyncScopeFilterIndex + 1);
            } else {*/
            kony.sync.globalIsDownloadStarted = true;
            kony.sync.onDownloadCompletion(false, null);
            //}
        } else {
            //statement error
            if (code === kony.sync.errorCodeSQLStatement) {
                kony.sync.downloadFailed(true);
            }
            //transaction error
            else {
                kony.sync.downloadFailed(false);
            }
        }
    }
    //Used for upload after delete in persistence strategey , Adding all the merged records in delete queue
    function recsToBeDeletedAfterUploadForPersistentStrategy(serverChanges) {
        sync.log.trace("Entering recsToBeDeletedAfterUploadForPersistentStrategy");
        var scopename = kony.sync.currentScope[kony.sync.scopeName];
        if (!kony.sync.isNullOrUndefined(serverChanges.d) && !kony.sync.isNullOrUndefined(serverChanges.d.results)) {
            for (var i = 0; i < serverChanges.d.results.length; i++) {
                var tablename = serverChanges.d.results[i].__metadata.type;
                if (kony.sync.checkForDeleteAfterUpload(tablename, scopename) === true && !kony.sync.isNullOrUndefined(serverChanges.d.results[i][kony.sync.mergedWithEIS]) && serverChanges.d.results[i][kony.sync.mergedWithEIS] === "1") {
                    kony.sync.PersisChangestobeDeleted.push(serverChanges.d.results[i]);
                }
            }
            sync.log.info("Changes to be deleted after upload", kony.sync.PersisChangestobeDeleted);
        }
    }

    function downloadcallback(serverChangesResult) {
        sync.log.trace("Entering downloadcallback");
        var endTime = new Date();
        var diff = endTime.getTime() - startTime.getTime();
        sync.log.debug("Time Taken for Network Batch Download : " + diff);
        kony.sync.batchDownloadTimer = kony.sync.batchDownloadTimer + diff;
        serverChanges = serverChangesResult;
        sync.log.info("ServerChanges:", serverChanges);
        if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.removeAfterUpload]) && kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA) {
            recsToBeDeletedAfterUploadForPersistentStrategy(serverChanges);
        }
        if (!kony.sync.isNullOrUndefined(serverChanges.opstatus) && serverChanges.opstatus != 0) {
            kony.sync.globalIsDownloadStarted = true;
            if (kony.sync.isSyncStopped) {
                sync.log.debug("Sync stopped in downloadcallback in opstatus check");
                kony.sync.stopSyncSession();
                return;
            }
            if (!kony.sync.isNullOrUndefined(serverChanges.d)) {
                kony.sync.onDownloadCompletion(true, kony.sync.getServerError(serverChanges.d, "download"));
            } else {
                kony.sync.onDownloadCompletion(true, kony.sync.getServerError(serverChanges));
            }
            return;
        } else if (kony.sync.isNullOrUndefined(serverChanges.d)) {
            if (kony.sync.isSyncStopped) {
                sync.log.debug("Sync stopped in downloadcallback in serverchanges.d check");
                kony.sync.stopSyncSession();
                return;
            }
            kony.sync.globalIsDownloadStarted = true;
            kony.sync.onDownloadCompletion(true, kony.sync.getServerError(serverChanges));
            return;
        }
        kony.sync.currentSyncReturnParams[kony.sync.serverDetails] = {};
        kony.sync.currentSyncReturnParams[kony.sync.serverDetails][kony.sync.hostName] = kony.sync.getServerDetailsHostName(serverChanges);
        kony.sync.currentSyncReturnParams[kony.sync.serverDetails][kony.sync.ipAddress] = kony.sync.getServerDetailsIpAddress(serverChanges);
        if ((serverChanges.d.error === "true")) {
            kony.sync.globalIsDownloadStarted = true;
            var hasResults = serverChanges.d.hasOwnProperty("results");
            if (hasResults && (serverChanges.d["results"].length > 0)) {
                applyDownloadBatchChangesToDBonError();
            } else {
                if (kony.sync.isSyncStopped) {
                    sync.log.debug("Sync stopped in downloadcallback in serverchanges.d.error true");
                    kony.sync.stopSyncSession();
                    return;
                }
                kony.sync.onDownloadCompletion(true, kony.sync.getServerError(serverChanges.d, "download"));
            }
            return;
        }
        //If has uploadErrors for persistentSync incase of AbortOnError Sync Strategy
        if (hasUploadErrors(serverChanges)) {
            kony.sync.globalIsDownloadStarted = true;
            var hasResults = serverChanges.d.hasOwnProperty("results");
            if (hasResults && (serverChanges.d["results"].length > 0)) {
                applyDownloadBatchChangesToDBonError();
                //Update Sync Order for failed records
                updateVersionNumberOnPersistentDownload();
            } else {
                var uploadErrorsInfoMap = getUploadErrorsInfoMap(serverChanges);
                //Update Sync Order for failed records
                updateVersionNumberOnPersistentDownload();
                kony.sync.onDownloadCompletion(true, uploadErrorsInfoMap);
            }
            return;
        }
        var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
        var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, kony.sync.syncFailed);
        if (dbconnection === null) {
            return;
        }
        if (kony.sync.isApplyChangesSync()) {
            kony.db.transaction(dbconnection, downloadNextBatch, downloadNextBatchFailed, downloadCompleted);
        } else {
            kony.db.transaction(dbconnection, downloadNextBatch, downloadNextBatchFailed, downloadCompleted, {
                isCommitTransaction: false
            });
        }
    }

    function hasUploadErrors(serverChanges) {
        sync.log.trace("Entering hasUploadErrors");
        if (!kony.sync.isNullOrUndefined(serverChanges) && !kony.sync.isNullOrUndefined(serverChanges.d) && (serverChanges.d.error === "false") && !kony.sync.isNullOrUndefined(serverChanges.d.__sync) && !kony.sync.isNullOrUndefined(serverChanges.d.__sync.UploadErrors)) {
            return true;
        }
        return false;
    }

    function getUploadErrorsInfoMap(serverChanges) {
        sync.log.trace("Entering getUploadErrorsInfoMap");
        var failedRowsInfoMap = {};
        if (kony.sync.isNullOrUndefined(serverChanges) || kony.sync.isNullOrUndefined(serverChanges.d) || kony.sync.isNullOrUndefined(serverChanges.d.__sync) || kony.sync.isNullOrUndefined(serverChanges.d.__sync.UploadErrors)) {
            return failedRowsInfoMap;
        }
        var errors = serverChanges.d.__sync.UploadErrors;
        var failedRowsInfo = {};
        var errorMap = null;
        var serverDetails = {};
        for (var i = 0; i < errors.length; i++) {
            errorMap = errors[i];
            for (var key in errorMap) {
                var contextMap = errorMap[key];
                failedRowsInfo.push({
                    key: contextMap.primaryKeys,
                    type: contextMap.type,
                    errorMessage: contextMap.errorMessage
                });
            }
        }
        failedRowsInfoMap[kony.sync.failedRowInfo] = failedRowsInfo;
        if (!kony.sync.isNullOrUndefined(serverChanges.d.server)) {
            serverDetails[kony.sync.hostName] = serverChanges.d.server.hostName;
            serverDetails[kony.sync.ipAddress] = serverChanges.d.server.ipAddress;
        }
        failedRowsInfoMap[kony.sync.serverDetails] = serverDetails;
        return failedRowsInfoMap;
    }

    function updateVersionNumberOnPersistentDownload() {
        sync.log.trace("Entering updateVersionNumberOnPersistentDownload ");
        var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
        var scopename = kony.sync.currentScope[kony.sync.scopeName];
        var sql = null;
        var params = null;
        var query = null;
        var query_compile = null;
        kony.sync.getConnection(dbname, dbname, transactionCallback, successCallback, failureCallback);

        function transactionCallback(tx) {
            sync.log.trace("Entering transactionCallback");
            var versionNo = kony.sync.getseqnumber(tx, scopename);
            if (!kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables)) {
                for (var i = 0; i < kony.sync.currentScope.ScopeTables.length; i++) {
                    var syncTable = kony.sync.currentScope.ScopeTables[i];
                    if (kony.sync.isNullOrUndefined(syncTable)) {
                        continue;
                    }
                    var tbname = syncTable.Name;
                    query = kony.sync.qb_createQuery();
                    kony.sync.qb_select(query, null);
                    kony.sync.qb_from(query, tbname + kony.sync.historyTableName);
                    query_compile = kony.sync.qb_compile(query);
                    sql = query_compile[0];
                    params = query_compile[1];
                    var resultSet = kony.sync.executeSql(tx, sql, params);
                    if (resultSet !== false) {
                        var num_records = resultSet.rows.length;
                        if (num_records > 0) {
                            var versionMap = {};
                            versionMap[kony.sync.historyTableSyncVersionColumn] = versionNo.versionnumber;
                            var whereClause = [];
                            kony.table.insert(whereClause, {
                                key: kony.sync.historyTableChangeTypeColumn,
                                value: "9%",
                                optype: "NOT LIKE"
                            });
                            query = kony.sync.qb_createQuery();
                            kony.sync.qb_update(query, tbname + kony.sync.historyTableName);
                            kony.sync.qb_set(query, versionMap);
                            kony.sync.qb_where(query, whereClause);
                            query_compile = kony.sync.qb_compile(query);
                            sql = query_compile[0];
                            params = query_compile[1];
                            if (kony.sync.executeSql(tx, sql, params) === false) {
                                return;
                            }
                        }
                    } else {
                        return;
                    }
                }
            }
        }

        function failureCallback() {
            sync.log.error(" Failed to update version number for failed rows on persistent download ");
        }

        function successCallback() {
            sync.log.trace(" Updated version number for failed rows on persistent download ");
        }
    }

    function ondownloadComplete() {
        if (hasUploadErrors(serverChanges)) {
            kony.sync.onDownloadCompletion(true, getUploadErrorsInfoMap(serverChanges));
        } else {
            kony.sync.onDownloadCompletion(true, kony.sync.getServerError(serverChanges.d, "download"));
        }
    }

    function applyDownloadBatchChangesToDBonError() {
        var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
        var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, kony.sync.syncFailed);
        if (dbconnection === null) {
            return;
        }
        if (kony.sync.globalIsDownloadStarted) {
            if (kony.sync.isApplyChangesSync()) {
                kony.db.transaction(dbconnection, downloadNextBatch, currentBatchDownloadError, ondownloadComplete);
            } else {
                kony.db.transaction(dbconnection, downloadNextBatch, currentBatchDownloadError, ondownloadComplete, {
                    isCommitTransaction: false
                });
            }
        }
    }

    function currentBatchDownloadError() {
        sync.log.trace("Entering currentBatchDownloadError");
        var serverError = null;
        if (!kony.sync.isNullOrUndefined(serverChanges.d)) {
            serverError = kony.sync.getServerError(serverChanges.d, "download");
        }
        var errorTable = kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null);
        if (serverError === null) {
            kony.sync.onDownloadCompletion(true, errorTable);
            return;
        }
        if (serverError && serverError.errorMessage && errorTable && errorTable.errorMessage) {
            serverError.errorMessage = serverError.errorMessage + " and " + errorTable.errorMessage;
        }
        kony.sync.onDownloadCompletion(true, serverError);
    }

    function downloadNextBatchFailed() {
        sync.log.trace("Entering downloadNextBatchFailed");
        kony.sync.downloadFailed(isError);
    }

    function scopeSettingsCallback(isInitialized) {
        sync.log.trace("Entering scopeSettingsCallback");
        kony.sync.konyDownloadChanges(lastsynctime, null, downloadcallback, isInitialized, upgradeSchemaLastSyncTime);
    }
    kony.sync.isScopeInitialized(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], scopeSettingsCallback);
};
kony.sync.downloadFailed = function(dbError) {
    sync.log.trace("Entering kony.sync.downloadFailed ");
    kony.sync.gSyncFailed = true;
    kony.sync.globalIsDownloadStarted = true;
    //kony.sync.onDownloadCompletion(true, JSON.stringify(connection));
    sync.log.error("Scope Download Failed");
    if (!dbError) {
        kony.sync.onDownloadCompletion(true, kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
    } else {
        kony.sync.onDownloadCompletion(true, kony.sync.errorObject);
        kony.sync.errorObject = null;
    }
};
kony.sync.applyChanges = function(tx, currentScope, serverChanges) {
    sync.log.trace("Entering kony.sync.applyChanges ");
    sync.log.info("Applying Changes from Server................... ----------->");
    var results = serverChanges.d.results;
    if (!kony.sync.isNullOrUndefined(results)) {
        return kony.sync.applyChangesToDB({
            "tx": tx,
            "currentScope": currentScope,
            "results": results,
            "startposition": 0,
            "endposition": results.length
        });
    }
};
kony.sync.postApplyChanges = function(tx, serverblob, moreChangesAvailable, pendingBatches) {
    sync.log.trace("Entering kony.sync.postApplyChanges ");
    if (kony.sync.clearChunkMetaData(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
        return false;
    }
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncScopeFilter)) {
        var scopejsonfilter = {
            "d": kony.sync.currentSyncScopeFilter
        };
        var filtervaluejson = JSON.stringify(scopejsonfilter);
        if (kony.sync.setLastSyncTimeFilter(tx, kony.sync.currentScope[kony.sync.scopeName], filtervaluejson, null, serverblob) === false) {
            return false;
        }
    } else {
        if (kony.sync.setLastSyncTime(tx, kony.sync.currentScope[kony.sync.scopeName], null, serverblob) === false) {
            return false;
        }
    }
    //shrink memory execution
    kony.db.executeSql(tx, "PRAGMA shrink_memory");
    if (!kony.sync.isNullOrUndefined(moreChangesAvailable)) {
        var temp = moreChangesAvailable;
        temp = temp + "";
        temp = temp.toLowerCase();
        if ((temp === "true")) {
            //Enable below code if PendingBatches is implemented.
            if (!kony.sync.isNullOrUndefined(pendingBatches)) {
                kony.sync.syncPendingBatchesNo = pendingBatches;
            }
            kony.sync.moreChangesAvailable = true;
        } else {
            kony.sync.moreChangesAvailable = false;
            kony.sync.syncPendingBatchesNo = 0;
        }
    } else {
        kony.sync.moreChangesAvailable = false;
    }
    sync.log.info("more changes available " + kony.sync.moreChangesAvailable);
    if (!kony.sync.moreChangesAvailable) {
        //After Every successful Scope download completion we will check and update the Scope Settings to make that scope Initialized;
        if (kony.sync.updateScopeSettings(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
            return false;
        }
        //After Every successful Scope download completion we will check if this download was for schema upgrade and mark it complete
        if (kony.sync.setSchemaUpgradeDownloadComplete(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
            return false;
        }
    }
};
kony.sync.applyChangesAsync = function(tx, currentScope, serverChanges, serverblob, morechanges) {
    sync.log.trace("Entering kony.sync.applyChangesAsync ");
    sync.log.info("Applying Changes from Server................... ----------->");
    var results = serverChanges.d.results;
    var bbBatchSize = kony.sync.getAsyncDownloadBatchSize();
    var lastbatch = results.length % bbBatchSize;
    var noofloops = (results.length - lastbatch) / bbBatchSize;
    var context = {
        "tx": tx,
        counter: 0,
        "currentScope": currentScope,
        "results": results,
        "noofloops": noofloops,
        "lastbatch": lastbatch,
        "serverblob": serverblob,
        "morechanges": morechanges
    };
    sync.log.debug("sending context");
    kony.api.executeAsync(kony.sync.applyChangesToDBAsync, context);
};
kony.sync.applyChangesToDBAsync = function(context) {
    sync.log.trace("Entering kony.sync.applyChangesToDBAsync ");
    sync.log.debug("point ******b : ", context);
    if (context.counter >= context.noofloops) {
        if (context.lastbatch > 0) {
            context.startposition = context.counter * kony.sync.getAsyncDownloadBatchSize();
            context.endposition = context.startposition + context.lastbatch;
            kony.sync.applyChangesToDB(context);
            context.counter = context.counter + 1;
            context.lastbatch = 0;
            kony.api.executeAsync(kony.sync.applyChangesToDBAsync, context);
        } else {
            kony.sync.postApplyChanges(context.tx, context.serverblob, context.morechanges);
            kony.db.commitTransaction(context.tx);
        }
    } else {
        context.startposition = context.counter * kony.sync.getAsyncDownloadBatchSize();
        context.endposition = context.startposition + kony.sync.getAsyncDownloadBatchSize();
        kony.sync.applyChangesToDB(context);
        context.counter = context.counter + 1;
        sync.log.debug("point ******c : ", context);
        kony.api.executeAsync(kony.sync.applyChangesToDBAsync, context);
    }
};
kony.sync.updateSyncVerisonNumberForFailedRow = function(tx, tablename, pkKey, pkValue) {
    sync.log.trace("Entering kony.sync.updateSyncVerisonNumberForFailedRow ");
    var versionNo = kony.sync.getseqnumber(tx, kony.sync.currentScope[kony.sync.scopeName]);
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet !== false) {
        if (resultSet.rows.length > 0) {
            var versionMap = {};
            versionMap[kony.sync.historyTableSyncVersionColumn] = versionNo.versionnumber;
            var whereClause = [];
            kony.table.insert(whereClause, {
                key: kony.sync.historyTableChangeTypeColumn,
                value: "9%",
                optype: "NOT LIKE"
            });
            kony.table.insert(whereClause, {
                key: pkKey,
                value: pkValue
            });
            query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, tablename + kony.sync.historyTableName);
            kony.sync.qb_set(query, versionMap);
            kony.sync.qb_where(query, whereClause);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return;
            }
        }
    }
};
kony.sync.addBinaryRecordsToDownload = function(tx, tablename, pkColumns) {
    sync.log.trace("Entering kony.sync.addBinaryRecordsToDownload ");

    function errorCallback(err) {
        sync.log.trace("Entering errorCallback");
        kony.sync.errorObject = err;
        kony.sync.downloadFailed(false);
    }
    //from the table fetch all the records having NULL for blobref columns with "always" policy.
    var alwaysColumns = kony.sync.getBinaryColumnsByPolicy(tablename, kony.sync.always);
    //var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
    var resultSet;
    for (var k = 0; k < alwaysColumns.length; k++) {
        sync.log.trace("kony.sync.addBinaryRecordsToDownload - alwaysColumn is " + alwaysColumns[k]);
        var konysyncBinaryMetaColumn = kony.sync.binaryMetaColumnPrefix + alwaysColumns[k];
        var whereClause = [{
            key: konysyncBinaryMetaColumn,
            value: kony.sync.blobRefNotDefined
        }, {
            key: alwaysColumns[k],
            value: kony.sync.blobRefNotDefined,
            optype: "NOT_EQ"
        }];
        resultSet = kony.sync.queryTable(tx, tablename, pkColumns, whereClause);
        //parse through the result set, create blob record for each record and update its reference at parent table.
        if (resultSet) {
            sync.log.trace("kony.sync.addBinaryRecordsToDownload - Number of always records to be added to the download queue " + resultSet.rows.length);
            for (var l = 0; l < resultSet.rows.length; l++) {
                var rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, l);
                //create a record in blobStoreManager.
                kony.sync.blobManager.triggerDownload(tx, tablename, alwaysColumns[k], rowItem, errorCallback);
                //increment total number of download jobs..
                kony.sync.incrementTotalJobs(true);
            }
        } else {
            sync.log.error("Error in querying table " + tablename);
            return;
        }
    }
    //for ifRecordValue columns...
    var ifRecordValueColumns = kony.sync.getBinaryColumnsByPolicy(tablename, kony.sync.ifRecordValue);
    for (var k = 0; k < ifRecordValueColumns.length; k++) {
        //fetch the synctodevicefield for the column.
        var syncToDeviceColumn = kony.sync.getSyncToDeviceField(tablename, ifRecordValueColumns[k]);
        if (syncToDeviceColumn) {
            sync.log.trace("kony.sync.addBinaryRecordsToDownload - alwaysColumn is " + ifRecordValueColumns[k]);
            var konysyncBinaryMetaColumn = kony.sync.binaryMetaColumnPrefix + ifRecordValueColumns[k];
            var whereClause = [{
                key: konysyncBinaryMetaColumn,
                value: kony.sync.blobRefNotDefined
            }, {
                key: ifRecordValueColumns[k],
                value: kony.sync.blobRefNotDefined,
                optype: "NOT_EQ"
            }, {
                key: syncToDeviceColumn,
                value: "true"
            }];
            resultSet = kony.sync.queryTable(tx, tablename, pkColumns, whereClause);
            if (resultSet) {
                sync.log.trace("kony.sync.addBinaryRecordsToDownload - Number of ifrecordvalue records to be added to the download queue " + resultSet.rows.length);
                for (var l = 0; l < resultSet.rows.length; l++) {
                    var rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, l);
                    //create a record in blobStoreManager.
                    kony.sync.blobManager.triggerDownload(tx, tablename, ifRecordValueColumns[k], rowItem, errorCallback);
                    //increment total number of download jobs..
                    kony.sync.incrementTotalJobs(true);
                }
            } else {
                sync.log.error("Error in querying table " + tablename);
                return;
            }
        }
    }
    return true;
};
kony.sync.applyChangesToBlobStoreDB = function(tx, tablename, row, blobMap, changeType, pks) {
    sync.log.trace("Entering kony.sync.applyChangesToBlobStoreDB ");

    function errorCallback(err) {
        sync.log.trace("Entering errorCallback");
        kony.sync.errorObject = err;
        kony.sync.downloadFailed(false);
    }

    function binarySuccessCallback(response) {
        sync.log.trace("kony.sync.applyChangesToBlobStoreDB .. binarySuccessCallback  ", response);
        kony.sync.incrementCompletedJobs(true);
        kony.sync.invokeBinaryNotifiers(true);
    }

    function binaryErrorCallback(error) {
        sync.log.trace("kony.sync.applyChangesToBlobStoreDB .. binaryErrorCallback  ", error);
        kony.sync.incrementFailedJobs(true);
        kony.sync.invokeBinaryNotifiers(true);
    }
    var blobStoreIndices = {};
    var dbname = kony.sync.getDBName();
    //adding the always, ifrecordvalue policy binaries to download queue..
    var binaryColumns = kony.sync.getBinaryColumns(tablename);
    if (binaryColumns) {
        for (var k = 0; k < binaryColumns.length; k++) {
            //create primaryKey Map.
            var primaryKeyTable = {};
            var primaryKeyColumns = kony.sync.getPrimaryKeyColumns(tablename);
            for (var index in primaryKeyColumns) {
                primaryKeyTable[primaryKeyColumns[index]] = row[primaryKeyColumns[index]];
            }
            switch (kony.sync.getDownloadPolicy(tablename, binaryColumns[k])) {
                case kony.sync.always:
                    var pendingJob = {
                        "tableName": tablename,
                        "binaryColumn": binaryColumns[k],
                        "primaryKeyTable": primaryKeyTable
                    };
                    kony.sync.pendingBinaryDownloadJobs.push(pendingJob);
                    break;
                case kony.sync.ifRecordValue:
                    var syncToDeviceField = kony.sync.getSyncToDeviceField(tablename, binaryColumns[k]);
                    if (syncToDeviceField && row[syncToDeviceField] === "true") {
                        var pendingJob = {
                            "tableName": tablename,
                            "binaryColumn": binaryColumns[k],
                            "primaryKeyTable": primaryKeyTable
                        };
                        kony.sync.pendingBinaryDownloadJobs.push(pendingJob);
                    }
                    break;
            }
        }
    }
    sync.log.trace("inserting inline base64 data in kony blobstoremanager..");
    if (changeType === "insert") {
        if (Object.keys(blobMap).length > 0) {
            var inlineBlobStoreIndices = kony.sync.blobstore_insert(tx, tablename, blobMap, errorCallback);
            if (inlineBlobStoreIndices) {
                for (var blobKey in inlineBlobStoreIndices) {
                    blobStoreIndices[blobKey] = inlineBlobStoreIndices[blobKey];
                }
            } else {
                sync.log.error("applyChangesToDb - error in inserting inline base64 data for table " + tablename);
                return false;
            }
        }
    } else if (changeType === "update") {
        if (Object.keys(blobMap).length > 0) {
            var inlineBlobStoreIndices = kony.sync.blobstore_update(tx, tablename, blobMap, pks, false, errorCallback);
            if (inlineBlobStoreIndices) {
                for (var blobKey in inlineBlobStoreIndices) {
                    blobStoreIndices[blobKey] = inlineBlobStoreIndices[blobKey];
                }
            } else {
                sync.log.error("applyChangesToDb - error in updating inline base64 data for table " + tablename);
                return false;
            }
        }
    }
    if (Object.keys(blobStoreIndices).length > 0) {
        var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
        sync.log.trace("updating blobref values in parent table.. " + JSON.stringify(blobStoreIndices));
        //update the parent table with blob references.
        var wcs = [];
        for (var key = 0; key < pkColumns.length; key++) {
            var wc = {};
            wc.key = pkColumns[key];
            wc.value = row[pkColumns[key]];
            wcs.push(wc);
        }
        var resultset = kony.sync.blobManager.updateParentWithBlobReference(tx, tablename, blobStoreIndices, wcs, errorCallback);
        if (resultset === false || kony.sync.isNullOrUndefined(resultset)) {
            return false;
        }
    }
    //invoke the status update notifier..
    kony.sync.invokeBinaryNotifiers(true);
};
kony.sync.applyChangesToDB = function(context) {
    sync.log.trace("Entering kony.sync.applyChangesToDB ");
    var tx = context.tx;
    var results = context.results;
    var startposition = context.startposition;
    var endposition = context.endposition;
    var newVersion = kony.sync.getseqnumber(tx, kony.sync.currentScope.ScopeName);
    var newVersionNo = newVersion.versionnumber;
    var j = null;
    var pk = null;
    var query_compile = null;
    var query = null;
    var sql = null;
    var params = null;
    var resultset = null;
    var prevTable = '';
    var internalBatchSize = 53;
    var currentSqlQuery = "";
    var insertUpdateCounter = 0;
    var currentScope = context.currentScope;
    var columnsInScopeTable = {};
    //populate columns for tables.
    for (var tableCount = 0; tableCount < currentScope.ScopeTables.length; tableCount++) {
        var syncTable = currentScope.ScopeTables[tableCount];
        var tableName = syncTable.Name;
        if (tableName) {
            var columns = syncTable["Columns"];
            var columnList = [kony.sync.mainTableHashSumColumn, kony.sync.mainTableSyncVersionColumn];
            for (var columnCount = 0; columnCount < columns.length; columnCount++) {
                kony.table.insert(columnList, columns[columnCount]["Name"]);
            }
        }
        columnsInScopeTable[tableName] = columnList;
    }

    function getColumnsForInsertORReplaceQuery(tableName) {
        var columnNamesForInsertQuery = "(";
        var columnList = columnsInScopeTable[tableName];
        for (var colIndex = 0; colIndex < columnList.length - 1; colIndex++) {
            columnNamesForInsertQuery += columnList[colIndex] + ",";
        }
        return columnNamesForInsertQuery + columnList[columnList.length - 1] + ")";
    }

    function getInsertORReplaceQueryStringForTable(tableName) {
        var sqlQuery = "INSERT" + " OR REPLACE " + "INTO " + tableName + " " + getColumnsForInsertORReplaceQuery(tableName) + " VALUES ";
        return sqlQuery;
    }

    function getColumnsValuesForInsertORReplaceQuery(tableName, tableDataFromResponse) {
        var columnsValuesForInsertQuery = "(";
        var columns = columnsInScopeTable[tableName];
        /* 
        	Changes done for [MFSDK-3879]
        	As we are creating raw queries for bulk insert, we are replacing " character with "" characters
        	to avoid malformed query. SQL reads "" as " in a raw query, and inserts it accordingly. 
        */
        for (var colIndex = 0; colIndex < columns.length - 1; colIndex++) {
            var value = tableDataFromResponse[columns[colIndex]];
            if ((typeof value) == "Undefined" || value == null) {
                value = "NULL";
            }
            value = value.replace(/"/gi, "\"\"");
            columnsValuesForInsertQuery = columnsValuesForInsertQuery + "\"" + value + "\",";
        }
        var value = tableDataFromResponse[columns[columns.length - 1]];
        if ((typeof value) == "Undefined" || value == null) {
            value = "NULL";
        }
        value = value.replace(/"/gi, "\"\"");
        columnsValuesForInsertQuery = columnsValuesForInsertQuery + "\"" + value + "\"" + ")";
        return columnsValuesForInsertQuery;
    }

    function bulkInsert(tableName, tableDataFromResponse) {
        if (currentSqlQuery !== "") {
            currentSqlQuery += "," + getColumnsValuesForInsertORReplaceQuery(tableName, tableDataFromResponse);
        } else {
            currentSqlQuery = getInsertORReplaceQueryStringForTable(tableName) + getColumnsValuesForInsertORReplaceQuery(tableName, tableDataFromResponse);
        }
        return currentSqlQuery;
    }

    function executeBulkInsert(sqlQuery) {
        return kony.sync.executeSql(tx, sqlQuery, null, null);
    }
    if (kony.sync.isNullOrUndefined(results)) {
        return;
    }
    var insertNull = kony.sync.getInsertNullForFieldsMissingInPayload();
    //before updating changes to db, addBinaryRecordsToDownload.
    sync.log.trace("kony.sync.applyChangesToDb - addBinaryRecordsToDownload.");
    var syncscopes = konysyncClientSyncConfig.ArrayOfSyncScope;
    if (!kony.sync.isNullOrUndefined(syncscopes)) {
        for (var scopeCount = 0; scopeCount < syncscopes.length; scopeCount++) {
            var scope = syncscopes[scopeCount];
            sync.log.trace("kony.sync.applyChangesToDb - current scope " + scope.ScopeName);
            if (!kony.sync.isNullOrUndefined(scope.ScopeTables)) {
                for (var tableCount = 0; tableCount < scope.ScopeTables.length; tableCount++) {
                    var syncTable = scope.ScopeTables[tableCount];
                    var tablename = syncTable.Name;
                    sync.log.trace("kony.sync.applyChangesToDb - addBinaryRecordsToDownload for " + tablename);
                    if (tablename) {
                        var addingPendingBinariesForDownload = kony.sync.addBinaryRecordsToDownload(tx, tablename, syncTable.Pk_Columns);
                        if (!addingPendingBinariesForDownload) {
                            sync.log.trace("kony.sync.applyChangesToDb - addBinaryRecordsToDownload failed..");
                            return false;
                        }
                    }
                }
            }
        }
    }
    var _upgradeContextForBulkInsert = kony.sync.schemaUpgradeContext;
    var _upgradeContextJSONForBulkInsert = null;
    if (!kony.sync.isNullOrUndefined(_upgradeContextForBulkInsert)) {
        _upgradeContextJSONForBulkInsert = JSON.parse(_upgradeContextForBulkInsert);
    }
    for (var i = startposition; i < endposition; i++) {
        var row = results[i];
        var tablename = row.__metadata.type;
        if (kony.sync.isNullOrUndefined(kony.sync.objectLevelInfoMap[tablename])) {
            kony.sync.objectLevelInfoMap[tablename] = {};
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDownloaded] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeleted] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInsertedAck] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdatedAck] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeletedAck] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsAcknowledged] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsFailedtoUpload] = 0;
        }
        if (kony.sync.objectLevelInfoMap[tablename][kony.sync.reconciledKeysKey] == null) {
            kony.sync.objectLevelInfoMap[tablename][kony.sync.reconciledKeysKey] = [];
        }
        var changeType = row.__metadata.changeType;
        var values = [];
        var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
        var pkwcs = [];
        var pkset = null;
        var pksetwcs = [];
        var blobMap = {};
        //var currentversion = kony.sync.getCurrentVersionNumber(tablename);
        var MergedWithEIS = row[kony.sync.mergedWithEIS];
        var versionNumber = row[kony.sync.mainTableSyncVersionColumn];
        versionNumber = kony.sync.tonumber(versionNumber);
        sync.log.trace("row is are " + JSON.stringify(row));
        if (MergedWithEIS !== "1" && MergedWithEIS !== "0") {
            if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename])) {
                var binaryDataColumns = kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns];
                sync.log.trace("values are " + JSON.stringify(values));
                var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns];
                for (var j = 0; j < binaryColumns.length; j++) {
                    //getDownloadPolicy of the column
                    var downloadPolicy = kony.sync.getDownloadPolicy(tablename, binaryColumns[j]);
                    if (downloadPolicy == kony.sync.inline) {
                        if (!kony.sync.isNullOrUndefined(row[binaryColumns[j]]) && row[binaryColumns[j]].trim().length > 0) blobMap[binaryColumns[j]] = row[binaryColumns[j]];
                        delete row[binaryColumns[j]];
                    }
                }
            }
        }
        sync.log.trace("after applyDB blobstore " + JSON.stringify(row));
        values = kony.sync.removeprovisioncolumns(row, kony.sync.currentScope.syncTableDic[tablename].Columns, true, insertNull);
        if (MergedWithEIS !== "1" && MergedWithEIS !== "0") {
            var hasInstanceInMainTable = false;
            var binaryColumns;
            if (kony.sync.enableBulkInsert && changeType === "update" && (kony.sync.isNullOrUndefined(_upgradeContextJSONForBulkInsert) || kony.sync.isNullOrUndefined(_upgradeContextJSONForBulkInsert[tableName]))) {
                //This case takes care of insert/update during sync and no schema upgrade for table.
                var result = null;
                //execute query in case of different table name or query batch limit is reached.
                if (prevTable !== tablename || insertUpdateCounter % internalBatchSize == 0) {
                    prevTable = tablename;
                    //checks whether record already exist or not.
                    binaryColumns = kony.sync.getBinaryColumns(tablename);
                    if (currentSqlQuery != "") {
                        result = executeBulkInsert(currentSqlQuery);
                        currentSqlQuery = "";
                        insertUpdateCounter = 0;
                        sync.log.trace("result is " + JSON.stringify(result));
                        if (result === false) {
                            sync.log.error("Bulk insert in download failed");
                            return false;
                        }
                    }
                }
                //add the null columns update scenario
                var columnsDefinedForTable = kony.sync.removeBinaryMetaColumns(tablename, kony.sync.currentScope.syncTableDic[tablename].Columns);
                values = kony.sync.removeprovisioncolumns(row, columnsDefinedForTable, true, insertNull);
                if (!kony.sync.isNullOrUndefined(pkColumns)) {
                    for (j = 0; j < pkColumns.length; j++) {
                        pk = pkColumns[j];
                        if (!kony.sync.isNullOrUndefined(row[kony.sync.clientPKPrefix + pk])) {
                            //pkset = pkset.." "..pk.."='"..row[pk].."'";
                            if (kony.sync.isNullOrUndefined(pkset)) {
                                pkset = {};
                            }
                            kony.table.insert(pkwcs, {
                                key: pk,
                                value: row[kony.sync.clientPKPrefix + pk]
                            });
                            pkset[pk] = row[pk];
                            kony.table.insert(pksetwcs, {
                                key: pk,
                                value: row[pk]
                            });
                        } else {
                            kony.table.insert(pkwcs, {
                                key: pk,
                                value: row[pk]
                            });
                            kony.table.insert(pksetwcs, {
                                key: pk,
                                value: row[pk]
                            });
                        }
                    }
                }
                kony.table.insert(pkwcs, {
                    key: kony.sync.mainTableChangeTypeColumn,
                    value: "nil",
                    optype: "EQ",
                    comptype: "OR",
                    openbrace: true
                });
                kony.table.insert(pkwcs, {
                    key: kony.sync.mainTableChangeTypeColumn,
                    value: -1,
                    optype: "EQ",
                    comptype: "OR",
                    closebrace: true
                });
                var originalwcs = kony.sync.CreateCopy(pksetwcs);
                var hasInstanceInHistoryTable = false;
                if (!kony.sync.enableOverride) {
                    hasInstanceInHistoryTable = kony.sync.checkForHistoryInstance(tx, tablename, values, originalwcs);
                }
                if (hasInstanceInHistoryTable === 0) {
                    return false;
                }
                if (hasInstanceInHistoryTable === false) {
                    //Adds current row to query.
                    bulkInsert(tablename, row);
                    insertUpdateCounter++;
                }
                if (binaryColumns) {
                    hasInstanceInMainTable = kony.sync.checkForInstance(tx, tablename, values, originalwcs);
                }
                if (hasInstanceInMainTable) {
                    //update the blob store manager..
                    function updateBlobStoreManager(pks) {
                        kony.sync.applyChangesToBlobStoreDB(tx, tablename, row, blobMap, "update", pks);
                    }
                    //for binary columns, delete the existing entries.
                    function deleteOnDemandBinaryEntries() {
                        sync.log.trace("entering deleteOnDemandBinaryEntries..");

                        function updateBlobErrorCallback(err) {
                            kony.sync.errorObject = err;
                            kony.sync.downloadFailed(false);
                        }
                        if (binaryColumns) {
                            sync.log.trace("onDemandColumns for " + tablename + " are " + JSON.stringify(binaryColumns));
                            for (var j = 0; j < binaryColumns.length; j++) {
                                if (kony.sync.getDownloadPolicy(tablename, binaryColumns[j]) !== kony.sync.inline) {
                                    var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
                                    var pkTable = {};
                                    for (var pk = 0; pk < pkColumns.length; pk++) {
                                        pkTable[pkColumns[pk]] = row[pkColumns[pk]];
                                    }
                                    //get the blobrefs of ondemand columns and delete that entries in blob store manager.
                                    var blobRef = kony.sync.getBlobRef(tx, tablename, binaryColumns[j], pkTable, updateBlobErrorCallback);
                                    sync.log.trace("blobRef for the data is " + blobRef + "for pkTable " + JSON.stringify(pkTable) + "in tablename " + tablename);
                                    if (blobRef !== kony.sync.blobRefNotFound && blobRef !== kony.sync.blobRefNotDefined) {
                                        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobRef, updateBlobErrorCallback);
                                        //delete the record only if it is not in queue for upload.
                                        if (blobMeta[kony.sync.blobManager.state] !== kony.sync.blobManager.UPLOAD_ACCEPTED && blobMeta[kony.sync.blobManager.state] !== kony.sync.blobManager.UPLOAD_IN_PROGRESS && blobMeta[kony.sync.blobManager.state] !== kony.sync.blobManager.UPLOAD_FAILED) {
                                            //TODO - open item. delete the image after upload.
                                            var isDeleteSuccessful = kony.sync.blobManager.deleteBlob(tx, blobRef, updateBlobErrorCallback);
                                            sync.log.trace("isDeleteSuccessful uploadBlobStoreManager " + isDeleteSuccessful);
                                            if (!isDeleteSuccessful) return false;
                                            //update NULL in the parent table.
                                            sync.log.trace("deleteOnDemandEntries - updating blobref column for " + binaryColumns[j] + " with NULL");
                                            values[kony.sync.binaryMetaColumnPrefix + binaryColumns[j]] = kony.sync.blobRefNotDefined;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (hasInstanceInHistoryTable === 0) {
                        return false;
                    }
                    if (hasInstanceInHistoryTable === false) {
                        //first delete the blob entries for the respective column.
                        deleteOnDemandBinaryEntries();
                        if (!kony.sync.isNullOrUndefined(pkset)) {
                            //update blobstore manager ?
                            updateBlobStoreManager(pksetwcs);
                        } else {
                            //update blobstore manager ?
                            updateBlobStoreManager(pkwcs);
                        }
                    }
                    kony.sync.serverUpdateCount = kony.sync.serverUpdateCount + 1;
                    // update if the user hasn't changed the record
                    kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] + 1;
                } else {
                    kony.sync.applyChangesToBlobStoreDB(tx, tablename, row, blobMap, "insert");
                    kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] + 1;
                    kony.sync.serverInsertCount = kony.sync.serverInsertCount + 1;
                }
            } else if ((changeType === "update")) {
                //do purge logic here.
                var result = null;
                result = kony.sync.insertEx(tx, tablename, values, null, true);
                if (result === false) {
                    return false;
                }
                if (result !== false && result.rowsAffected === 0) {
                    sync.log.trace("Change type is update in sync session- insert failed.. ");
                    var _upgradeContext = kony.sync.schemaUpgradeContext;
                    var _upgradeContextJSON = null;
                    if (!kony.sync.isNullOrUndefined(_upgradeContext)) {
                        _upgradeContextJSON = JSON.parse(_upgradeContext);
                    }
                    //add the null columns update scenario
                    if (kony.sync.isNullOrUndefined(_upgradeContextJSON) || kony.sync.isNullOrUndefined(_upgradeContextJSON[tablename])) {
                        var columnsDefinedForTable = kony.sync.removeBinaryMetaColumns(tablename, kony.sync.currentScope.syncTableDic[tablename].Columns);
                        values = kony.sync.removeprovisioncolumns(row, columnsDefinedForTable, true, insertNull);
                    } else {
                        //DSC scenario
                        var columnsDefinedForTable = kony.sync.removeBinaryMetaColumns(tablename, kony.sync.currentScope.syncTableDic[tablename].Columns);
                        values = kony.sync.removeprovisioncolumns(row, columnsDefinedForTable, true, false);
                    }
                    if (!kony.sync.isNullOrUndefined(pkColumns)) {
                        for (j = 0; j < pkColumns.length; j++) {
                            pk = pkColumns[j];
                            if (!kony.sync.isNullOrUndefined(row[kony.sync.clientPKPrefix + pk])) {
                                //pkset = pkset.." "..pk.."='"..row[pk].."'";
                                if (kony.sync.isNullOrUndefined(pkset)) {
                                    pkset = {};
                                }
                                kony.table.insert(pkwcs, {
                                    key: pk,
                                    value: row[kony.sync.clientPKPrefix + pk]
                                });
                                pkset[pk] = row[pk];
                                kony.table.insert(pksetwcs, {
                                    key: pk,
                                    value: row[pk]
                                });
                            } else {
                                kony.table.insert(pkwcs, {
                                    key: pk,
                                    value: row[pk]
                                });
                                kony.table.insert(pksetwcs, {
                                    key: pk,
                                    value: row[pk]
                                });
                            }
                        }
                    }
                    kony.table.insert(pkwcs, {
                        key: kony.sync.mainTableChangeTypeColumn,
                        value: "nil",
                        optype: "EQ",
                        comptype: "OR",
                        openbrace: true
                    });
                    kony.table.insert(pkwcs, {
                        key: kony.sync.mainTableChangeTypeColumn,
                        value: -1,
                        optype: "EQ",
                        comptype: "OR",
                        closebrace: true
                    });
                    /* kony.table.insert(pkwcs, {
                     key: kony.sync.mainTableSyncVersionColumn,
                     value: currentversion,
                     optype : "EQ"
                     });*/
                    var originalwcs = kony.sync.CreateCopy(pksetwcs);
                    var hasInstanceInHistoryTable = kony.sync.checkForHistoryInstance(tx, tablename, values, originalwcs);
                    //update the blob store manager..
                    function updateBlobStoreManager(pks) {
                        sync.log.trace("Entering updateBlobStoreManager");
                        kony.sync.applyChangesToBlobStoreDB(tx, tablename, row, blobMap, "update", pks);
                    }
                    //for binary columns, delete the existing entries.
                    function deleteOnDemandBinaryEntries() {
                        sync.log.trace("entering deleteOnDemandBinaryEntries..");

                        function updateBlobErrorCallback(err) {
                            sync.log.trace("Entering updateBlobErrorCallback");
                            kony.sync.errorObject = err;
                            kony.sync.downloadFailed(false);
                        }
                        var binaryColumns = kony.sync.getBinaryColumns(tablename);
                        if (binaryColumns) {
                            sync.log.trace("onDemandColumns for " + tablename + " are " + JSON.stringify(binaryColumns));
                            for (var j = 0; j < binaryColumns.length; j++) {
                                if (kony.sync.getDownloadPolicy(tablename, binaryColumns[j]) !== kony.sync.inline) {
                                    var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
                                    var pkTable = {};
                                    for (var pk = 0; pk < pkColumns.length; pk++) {
                                        pkTable[pkColumns[pk]] = row[pkColumns[pk]];
                                    }
                                    //get the blobrefs of ondemand columns and delete that entries in blob store manager.
                                    var blobRef = kony.sync.getBlobRef(tx, tablename, binaryColumns[j], pkTable, updateBlobErrorCallback);
                                    sync.log.trace("blobRef for the data is " + blobRef + "for pkTable " + JSON.stringify(pkTable) + "in tablename " + tablename);
                                    if (blobRef !== kony.sync.blobRefNotFound && blobRef !== kony.sync.blobRefNotDefined) {
                                        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobRef, updateBlobErrorCallback);
                                        //delete the record only if it is not in queue for upload.
                                        if (blobMeta[kony.sync.blobManager.state] !== kony.sync.blobManager.UPLOAD_ACCEPTED && blobMeta[kony.sync.blobManager.state] !== kony.sync.blobManager.UPLOAD_IN_PROGRESS && blobMeta[kony.sync.blobManager.state] !== kony.sync.blobManager.UPLOAD_FAILED) {
                                            //TODO - open item. delete the image after upload.
                                            var isDeleteSuccessful = kony.sync.blobManager.deleteBlob(tx, blobRef, updateBlobErrorCallback);
                                            sync.log.trace("isDeleteSuccessful uploadBlobStoreManager " + isDeleteSuccessful);
                                            if (!isDeleteSuccessful) return false;
                                            //update NULL in the parent table.
                                            sync.log.trace("deleteOnDemandEntries - updating blobref column for " + binaryColumns[j] + " with NULL");
                                            values[kony.sync.binaryMetaColumnPrefix + binaryColumns[j]] = kony.sync.blobRefNotDefined;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (hasInstanceInHistoryTable === 0) {
                        return false;
                    }
                    if (hasInstanceInHistoryTable === false) {
                        //first delete the blob entries for the respective column.
                        deleteOnDemandBinaryEntries();
                        if (!kony.sync.isNullOrUndefined(pkset)) {
                            if (kony.sync.updateEx(tx, tablename, values, pksetwcs) === false) {
                                return false;
                            } else {
                                //update blobstore manager ?
                                updateBlobStoreManager(pksetwcs);
                            }
                        } else {
                            if (kony.sync.updateEx(tx, tablename, values, pkwcs) === false) {
                                return false;
                            } else {
                                //update blobstore manager ?
                                updateBlobStoreManager(pkwcs);
                            }
                        }
                    }
                    kony.sync.serverUpdateCount = kony.sync.serverUpdateCount + 1;
                    // update if the user hasn't changed the record
                    kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] + 1;
                    //					if(kony.sync.updateEx(tx, tablename, values, pkwcs)===false){
                    //						return false;
                    //					}
                } else {
                    kony.sync.applyChangesToBlobStoreDB(tx, tablename, row, blobMap, "insert");
                    kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] + 1;
                    kony.sync.serverInsertCount = kony.sync.serverInsertCount + 1;
                }
            } else if ((changeType === "delete")) {
                values = kony.sync.removeprovisioncolumns(row, kony.sync.currentScope.syncTableDic[tablename].Columns, true, insertNull);
                // delete the record if it hasn't been changed by the user
                if (!kony.sync.isNullOrUndefined(pkColumns)) {
                    for (j = 0; j < pkColumns.length; j++) {
                        pk = pkColumns[j];
                        if (!kony.sync.isNullOrUndefined(row[kony.sync.clientPKPrefix + pk])) {
                            //pkwc = pkwc.." "..pk.."='"..row["Client_"..pk].."'";
                            //pkset = pkset.." "..pk.."='"..row[pk].."'";
                            if (kony.sync.isNullOrUndefined(pkset)) {
                                pkset = {};
                            }
                            kony.table.insert(pkwcs, {
                                key: pk,
                                value: row[kony.sync.clientPKPrefix + pk]
                            });
                            pkset[pk] = row[pk];
                            kony.table.insert(pksetwcs, {
                                key: pk,
                                value: row[pk]
                            });
                        } else {
                            kony.table.insert(pkwcs, {
                                key: pk,
                                value: row[pk]
                            });
                        }
                    }
                }
                kony.table.insert(pkwcs, {
                    key: kony.sync.mainTableChangeTypeColumn,
                    value: "nil",
                    optype: "EQ",
                    comptype: "OR",
                    openbrace: true
                });
                kony.table.insert(pkwcs, {
                    key: kony.sync.mainTableChangeTypeColumn,
                    value: -1,
                    optype: "EQ",
                    closebrace: true
                });
                kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeleted] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeleted] + 1;
                kony.sync.serverDeleteCount = kony.sync.serverDeleteCount + 1;
                /*WARNING: Undefined method call for kony.sync.deleteEx*/
                function blobDeleteErrorCallback(err) {
                    sync.log.trace("Entering blobDeleteErrorCallback");
                    kony.sync.errorObject = err;
                    kony.sync.downloadFailed(false);
                }
                //delete the blob record first.
                if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns])) {
                    var binaryDataColumns = kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns];
                    //get the blobRef for the column and delete the blobrecord.
                    for (var blobColumn = 0; blobColumn < binaryDataColumns.length; blobColumn++) {
                        var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
                        var pks = {};
                        for (var pk = 0; pk < pkColumns.length; pk++) {
                            pks[pkColumns[pk]] = row[pkColumns[pk]];
                        }
                        var blobRef = kony.sync.getBlobRef(tx, tablename, binaryDataColumns[blobColumn], pks, blobDeleteErrorCallback);
                        if (blobRef !== kony.sync.blobRefNotFound && blobRef !== kony.sync.blobRefNotDefined) {
                            var isDeleteSuccessful = kony.sync.blobManager.deleteBlob(tx, blobRef, blobDeleteErrorCallback);
                            if (!isDeleteSuccessful) return false;
                        }
                    }
                }
                if (kony.sync.removeEx(tx, tablename, pkwcs) === false) {
                    return false;
                }
            }
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDownloaded] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] + kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] + kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeleted];
        } else {
            //deleting data of binary columns. but only in case of inline.
            if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns])) {
                var binaryDataColumns = kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns];
                var binaryColumn = null;
                for (var k = 0; k < binaryDataColumns.length; k++) {
                    binaryColumn = binaryDataColumns[k];
                    var downloadPolicy = kony.sync.getDownloadPolicy(tablename, binaryColumn);
                    if (downloadPolicy === kony.sync.inline) {
                        delete row[binaryColumn];
                    }
                }
            }
            var pkTable = {};
            var originalChangeType = row[kony.sync.mainTableChangeTypeColumn];
            if (kony.sync.isNullOrUndefined(originalChangeType)) {
                originalChangeType = 1;
            }
            //ignore the blobref columns in removeprovisioncolumns method.
            var columnsDefinedForTable = kony.sync.removeBinaryMetaColumns(tablename, kony.sync.currentScope.syncTableDic[tablename].Columns);
            values = kony.sync.removeprovisioncolumns(row, columnsDefinedForTable, true, insertNull);
            //creating a map of reconciled primary keys
            var keyMap = {};
            var isAutoGenPkPresent = false;
            if (!kony.sync.isNullOrUndefined(pkColumns)) {
                for (j = 0; j < pkColumns.length; j++) {
                    pk = pkColumns[j];
                    pkTable[pk] = row[pk]; //creating pk for uploadcontext
                    if (!kony.sync.isNullOrUndefined(row[kony.sync.clientPKPrefix + pk])) {
                        if (kony.sync.isNullOrUndefined(pkset)) {
                            pkset = {};
                        }
                        kony.table.insert(pkwcs, {
                            key: pk,
                            value: row[kony.sync.clientPKPrefix + pk]
                        });
                        pkset[pk] = row[pk];
                        kony.table.insert(pksetwcs, {
                            key: pk,
                            value: row[pk]
                        });
                        isAutoGenPkPresent = true;
                        keyMap[pk] = {
                            newpk: row[pk],
                            oldpk: row[kony.sync.clientPKPrefix + pk]
                        };
                    } else {
                        kony.table.insert(pkwcs, {
                            key: pk,
                            value: row[pk]
                        });
                        kony.table.insert(pksetwcs, {
                            key: pk,
                            value: row[pk]
                        });
                    }
                }
            }
            var originalwcs = kony.sync.CreateCopy(pksetwcs);
            if (isAutoGenPkPresent) {
                kony.sync.objectLevelInfoMap[tablename][kony.sync.reconciledKeysKey].push(keyMap);
            }
            sync.log.debug("Inside MergedWithEis");
            var isError = false;
            var prevErrors = 0;
            if (!kony.sync.isNullOrUndefined(row.__metadata.intermediateErrors)) {
                prevErrors = row.__metadata.intermediateErrors.length;
            }
            //checking for error on continueonerror upload policy
            if (!kony.sync.isNullOrUndefined(row.__metadata.errorMessage)) {
                kony.sync.serverFailedCount = kony.sync.serverFailedCount + 1 + prevErrors;
                kony.sync.uploadSummary.push({
                    key: pkTable,
                    type: row.__metadata.type,
                    errorMessage: row.__metadata.errorMessage,
                    errorRootCause: row.__metadata.errorRootCause,
                    intermediateErrors: row.__metadata.intermediateErrors
                });
                kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsFailedtoUpload] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsFailedtoUpload] + 1 + prevErrors;
                isError = true;
                if ((kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA) && kony.sync.isUploadErrorPolicyCOE(kony.sync.currentScope)) {
                    //Increase the version number of the failed row
                    kony.sync.updateSyncVerisonNumberForFailedRow(tx, tablename, pk, row[pk]);
                }
            }
            //checking for previous errors
            else if (prevErrors !== 0) {
                kony.sync.uploadSummary.push({
                    key: pkTable,
                    type: row.__metadata.type,
                    errorMessage: null,
                    errorRootCause: null,
                    intermediateErrors: row.__metadata.intermediateErrors
                });
                kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsFailedtoUpload] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsFailedtoUpload] + prevErrors;
                kony.sync.serverFailedCount = kony.sync.serverFailedCount + prevErrors;
            }
            var settable = {};
            //before updating the pk
            //remove row from history, original and main(in case of removeafterupload) tables for COE error upload policy if success
            var isRemoved = false;
            isRemoved = kony.sync.clearDataForCOE(tx, kony.sync.currentScope.ScopeName, tablename, pkwcs, pksetwcs, changeType, pkset, row[kony.sync.historyTableReplaySequenceColumn], values, isError);
            if (isRemoved === 0) {
                return false;
            }
            if (!kony.sync.isNullOrUndefined(pkset)) {
                /*update related tables foreign keys*/
                //reconciliation starts here .....
                //row implies record here,i inplies index of the record
                var _isError = kony.sync.reconcileForeignKeyForChildren(tx, pkset, pkwcs, tablename, row, i, endposition, results);
                if (_isError === 0) return false;
            }
            if (isError === false) {
                kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsAcknowledged] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInsertedAck] + kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdatedAck] + kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeletedAck];
                //continue if removed to skip updates for same record
                if (isRemoved === true) {
                    continue;
                }
                //if no error, change changetype to null in main table
                settable[kony.sync.mainTableChangeTypeColumn] = "nil";
            } else {
                //checking for error on continueonerror upload policy and making the reconciled values consistent in child tables
                if (!kony.sync.isNullOrUndefined(row.__metadata.errorMessage)) {
                    //querying the foreignkey values from from child table and replacing in setclause to maintain reconciled values properly in child table
                    selectClause = [];
                    parentRelationshipMap = kony.sync.currentScope.syncTableDic[tablename + kony.sync.parentRelationshipMap];
                    //onetomany relationships from parent table
                    for (var tname in parentRelationshipMap) {
                        var relationshipAttributes = parentRelationshipMap[tname];
                        var relationshipAttributes_length = relationshipAttributes.length;
                        for (var k = 0; k < relationshipAttributes_length; k++) {
                            relationshipAttribute = relationshipAttributes[k];
                            var columnName = relationshipAttribute["ChildObject_Attribute"];
                            selectClause.push(columnName);
                        }
                    }
                    synctable = kony.sync.currentScope.syncTableDic[tablename];
                    ManyToOne = synctable.Relationships.ManyToOne; //manytone relationships
                    //manytoone relationships in childtable
                    if (!kony.sync.isNullOrUndefined(ManyToOne)) {
                        ManyToOne_length = ManyToOne.length;
                        for (var k = 0; k < ManyToOne_length; k++) {
                            if (!kony.sync.isNullOrUndefined(ManyToOne[k].RelationshipAttributes)) {
                                var relationshipAttributes = ManyToOne[k].RelationshipAttributes;
                                for (var j = 0; j < relationshipAttributes.length; j++) {
                                    var columnName = relationshipAttributes[j].SourceObject_Attribute;
                                    selectClause.push(columnName);
                                };
                            }
                        }
                    }
                    //reverse relationships in childtable
                    reverseRelationships = kony.sync.currentScope.reverseRelationships[tablename];
                    if (!(kony.sync.isNullOrUndefined(reverseRelationships))) {
                        for (var k = 0; k < reverseRelationships.length; k++) {
                            relationshipAttributes = reverseRelationships[k].RelationshipAttributes;
                            for (var j = 0; j < relationshipAttributes.length; j++) {
                                var columnName = relationshipAttributes[j].SourceObject_Attribute;
                                selectClause.push(columnName);
                            }
                        }
                    }
                    if (selectClause.length != 0) {
                        query = kony.sync.qb_createQuery();
                        kony.sync.qb_select(query, selectClause);
                        kony.sync.qb_from(query, tablename);
                        kony.sync.qb_where(query, pkwcs); //using the whereClause already generated
                        query_compile = kony.sync.qb_compile(query);
                        sql = query_compile[0];
                        params = query_compile[1];
                        resultset = kony.sync.executeSql(tx, sql, params); //need to handle error callback if required
                        //logic to process the resultset
                        if (resultset.rows.length >= 1) {
                            var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
                            for (var j = 0; j < selectClause.length; j++) {
                                var columnName = selectClause[j];
                                values[columnName] = rowItem[columnName];
                            }
                        }
                    }
                }
                //updating history table to make relationship data consistent
                var whereClause = kony.sync.CreateCopy(pkwcs);
                //versionMap[kony.sync.historyTableSyncVersionColumn] = versionNo[ "versionnumber"];
                kony.table.insert(whereClause, {
                    key: kony.sync.historyTableReplaySequenceColumn,
                    value: row[kony.sync.historyTableReplaySequenceColumn]
                });
                if (kony.sync.updateEx(tx, tablename + kony.sync.historyTableName, values, whereClause) === false) {
                    return false;
                }
                //there is possibility that record is deleted by an earlier successful record, so insert it
                if (changeType !== "delete") {
                    if (!kony.sync.isNullOrUndefined(pkset)) {
                        whereClause = pksetwcs;
                    } else {
                        whereClause = pkwcs;
                    }
                    values[kony.sync.mainTableChangeTypeColumn] = originalChangeType;
                    values[kony.sync.mainTableSyncVersionColumn] = newVersionNo + 1;
                    query = kony.sync.qb_createQuery();
                    kony.sync.qb_select(query, null);
                    kony.sync.qb_from(query, tablename);
                    kony.sync.qb_where(query, whereClause);
                    query_compile = kony.sync.qb_compile(query);
                    sql = query_compile[0];
                    params = query_compile[1];
                    resultset = kony.sync.executeSql(tx, sql, params);
                    if (resultset !== false) {
                        var num_records = resultset.rows.length;
                        //updated if not deleted
                        if (num_records > 0) {
                            kony.sync.updateEx(tx, tablename, values, whereClause);
                        } else {
                            query = kony.sync.qb_createQuery();
                            kony.sync.qb_set(query, values);
                            kony.sync.qb_insert(query, tablename);
                            query_compile = kony.sync.qb_compile(query);
                            sql = query_compile[0];
                            params = query_compile[1];
                            if (kony.sync.executeSql(tx, sql, params) === false) {
                                //exit incase of SQL error
                                return false;
                            }
                        }
                    } else {
                        //exit incase of SQL error
                        return false;
                    }
                }
                continue;
            }
            if (!kony.sync.isNullOrUndefined(pkset)) {
                /* clear dirty flag if not updated again*/
                kony.table.insert(pksetwcs, {
                    key: kony.sync.mainTableSyncVersionColumn,
                    value: versionNumber,
                    optype: "LT_EQ",
                    openbrace: true,
                    comptype: "OR"
                });
                kony.table.insert(pksetwcs, {
                    key: kony.sync.mainTableSyncVersionColumn,
                    value: "nil",
                    closebrace: true
                });
                query = kony.sync.qb_createQuery();
                kony.sync.qb_update(query, tablename);
                kony.sync.qb_set(query, settable);
                kony.sync.qb_where(query, pksetwcs);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                if (kony.sync.executeSql(tx, sql, params) === false) {
                    return false;
                }
            } else {
                kony.table.insert(pkwcs, {
                    key: kony.sync.mainTableSyncVersionColumn,
                    value: versionNumber,
                    optype: "LT_EQ",
                    openbrace: true,
                    comptype: "OR"
                });
                kony.table.insert(pkwcs, {
                    key: kony.sync.mainTableSyncVersionColumn,
                    value: "nil",
                    closebrace: true
                });
                query = kony.sync.qb_createQuery();
                kony.sync.qb_update(query, tablename);
                kony.sync.qb_set(query, settable);
                kony.sync.qb_where(query, pkwcs);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                if (kony.sync.executeSql(tx, sql, params) === false) {
                    return false;
                }
            }
            if (changeType === "update") {
                // clear the dirty flag
                values[kony.sync.mainTableChangeTypeColumn] = "nil";
                values[kony.sync.mainTableSyncVersionColumn] = "nil";
                var hasInstanceInHistoryTable = kony.sync.checkForHistoryInstance(tx, tablename, values, originalwcs);
                if (hasInstanceInHistoryTable === 0) {
                    return false;
                }
                if (hasInstanceInHistoryTable === false) {
                    if (!kony.sync.isNullOrUndefined(pkset)) {
                        if (kony.sync.updateEx(tx, tablename, values, pksetwcs) === false) {
                            return false;
                        }
                    } else {
                        if (kony.sync.updateEx(tx, tablename, values, pkwcs) === false) {
                            return false;
                        }
                    }
                }
            } else if (changeType === "delete") {
                if (!kony.sync.isNullOrUndefined(pkset)) {
                    kony.table.insert(pksetwcs, {
                        key: kony.sync.mainTableSyncVersionColumn,
                        value: versionNumber
                    });
                    if (kony.sync.removeEx(tx, tablename, pksetwcs) === false) {
                        return false;
                    }
                } else {
                    kony.table.insert(pkwcs, {
                        key: kony.sync.mainTableSyncVersionColumn,
                        value: versionNumber
                    });
                    if (kony.sync.removeEx(tx, tablename, pkwcs) === false) {
                        return false;
                    }
                }
            }
        }
    }
    if (kony.sync.enableBulkInsert && !MergedWithEIS && insertUpdateCounter > 0) {
        if (currentSqlQuery != "") {
            result = executeBulkInsert(currentSqlQuery);
            currentSqlQuery = "";
            insertUpdateCounter = 0;
            sync.log.trace("result is " + JSON.stringify(result));
            if (result === false) {
                sync.log.error("Bulk insert in download failed");
                return false;
            }
        }
    }
};
kony.sync.reconcileForeignKeyForChildren = function(tx, pksetwcs, pkwcs, tablename, parentRow, currentIndex, endposition, results) {
    sync.log.trace("Entering kony.sync.reconcileForeignKeyForChildren ");
    //populate setClause and whereClause for the child tables
    function populateMetaDataForReconciliation(_pkColumns, _row, _pkset, _pkwcs) {
        sync.log.trace("Entering populateMetaDataForReconciliation");
        if (!kony.sync.isNullOrUndefined(_pkColumns)) {
            for (var j = 0; j < _pkColumns.length; j++) {
                var pk = _pkColumns[j];
                if (!kony.sync.isNullOrUndefined(_row[kony.sync.clientPKPrefix + pk])) {
                    kony.table.insert(_pkwcs, {
                        key: pk,
                        value: _row[kony.sync.clientPKPrefix + pk]
                    });
                    _pkset[pk] = _row[pk];
                }
            }
        }
    }
    //get the childrow 
    var childRowFound = false;
    for (var j = currentIndex + 1; j < endposition; j++) {
        var childPkwcs = [];
        var childPkset = {};
        var childRow = results[j];
        var childMetaData = childRow.__metadata;
        var childTablename = childMetaData.type;
        var childPkColumns = kony.sync.currentScope.syncTableDic[childTablename].Pk_Columns;
        var parentAttributes = [];
        var childAttributes = [];
        //Forward Relationships(OneToMany) reconcilation
        var OneToMany = kony.sync.currentScope.syncTableDic[tablename].Relationships.OneToMany;
        if (!kony.sync.isNullOrUndefined(OneToMany)) {
            for (var k = 0; k < OneToMany.length; k++) {
                if (OneToMany[k].TargetObject === childTablename) {
                    var currentRelation = OneToMany[k];
                    //relation found add the SourceObject_Attributes and TargetObject_Attributes to corresponding arrays
                    var relationshipAttributes = currentRelation.RelationshipAttributes;
                    for (var l = 0; l < relationshipAttributes.length; l++) {
                        parentAttributes.push(relationshipAttributes[l].SourceObject_Attribute);
                        childAttributes.push(relationshipAttributes[l].TargetObject_Attribute);
                    }
                    break;
                }
            }
        }
        //Forward Relationships(OneToOne) reconcilation
        var OneToOne = kony.sync.currentScope.syncTableDic[tablename].Relationships.OneToOne;
        if (!kony.sync.isNullOrUndefined(OneToOne)) {
            for (var k = 0; k < OneToOne.length; k++) {
                if (OneToOne[k].TargetObject === childTablename) {
                    var currentRelation = OneToOne[k];
                    //relation found add the SourceObject_Attributes and TargetObject_Attributes to corresponding arrays
                    var relationshipAttributes = currentRelation.RelationshipAttributes;
                    for (var l = 0; l < relationshipAttributes.length; l++) {
                        parentAttributes.push(relationshipAttributes[l].SourceObject_Attribute);
                        childAttributes.push(relationshipAttributes[l].TargetObject_Attribute);
                    }
                    break;
                }
            }
        }
        //Reverse Relationships(ManyToOne) reconcilation
        var ManyToOne = kony.sync.currentScope.reverseRelationships[tablename];
        if (!kony.sync.isNullOrUndefined(ManyToOne)) {
            for (var k = 0; k < ManyToOne.length; k++) {
                if (ManyToOne[k].TargetObject === childTablename) {
                    var currentRelation = ManyToOne[k];
                    //relation found add the SourceObject_Attributes and TargetObject_Attributes to corresponding arrays
                    var relationshipAttributes = currentRelation.RelationshipAttributes;
                    for (var l = 0; l < relationshipAttributes.length; l++) {
                        parentAttributes.push(relationshipAttributes[l].SourceObject_Attribute);
                        childAttributes.push(relationshipAttributes[l].TargetObject_Attribute);
                    }
                    break;
                }
            }
        }
        if (parentAttributes.length === 0) continue;
        else {
            var matchCount = 0;
            //identifying if the record is child of the parent record
            for (var k = 0; k < parentAttributes.length; k++) {
                var parentAttribute = parentAttributes[k];
                var childAttribute = childAttributes[k];
                //modifying the parent reconciled values in child record's non-reconciled field to make relationship data consistent
                if (childRow[kony.sync.clientPKPrefix + childAttribute] != undefined) {
                    if (childRow[kony.sync.clientPKPrefix + childAttribute] === parentRow[kony.sync.clientPKPrefix + parentAttribute]) matchCount++;
                    else break;
                }
            }
            //childrow found
            if (matchCount === parentAttributes.length) {
                childRowFound = true;
                populateMetaDataForReconciliation(childPkColumns, childRow, childPkset, childPkwcs);
                //tx,pkset,pkwcs,tablename,parentRow,currentIndex
                kony.sync.reconcileForeignKeyForChildren(tx, childPkset, childPkwcs, childTablename, childRow, j, endposition, results); //childrowindex			
                if (kony.sync.reconcileForeignKey(tx, pksetwcs, pkwcs, tablename) === false) {
                    return false;
                }
                //reconcilation of child rows which are not part of changeset but exist in history table
                //it should be done after because we should not do disturb changeset records in history table
                reconcileChildrenInHistoryTable(tablename, pkwcs, pksetwcs);
                //modifying the parent reconciled values in child record's non-reconciled field to make relationship data consistent
                for (var k = 0; k < parentAttributes.length; k++) {
                    var parentAttribute = parentAttributes[k];
                    var childAttribute = childAttributes[k];
                    if (childRow[kony.sync.clientPKPrefix + childAttribute] != undefined) childRow[kony.sync.clientPKPrefix + childAttribute] = parentRow[parentAttribute];
                }
            }
        }
    }
    if (childRowFound === false) {
        var _isError = reconcileChildrenInHistoryTable(tablename, pkwcs, pksetwcs);
        if (_isError === 0) {
            sync.log.error("error in reconciliation of records of history table not in changeset with parent " + tablename + " with setclause " + JSON.stringify(pksetwcs) + " and whereClause " + JSON.stringify(pkwcs));
            return 0;
        }
        if (kony.sync.reconcileForeignKey(tx, pksetwcs, pkwcs, tablename) === false) {
            sync.log.error("error in reconciliation of records with parent " + tablename + " with setclause " + JSON.stringify(pksetwcs) + " and whereClause " + JSON.stringify(pkwcs));
            return 0;
        }
    }
    //reconcileChildrenInHistoryTable(tablename,pkwcs,pksetwcs);
    // no need to check if this is a error record because as this call is made by non-error records
    //reconcile records that are not part of server response inside device db ( history table records)
    function reconcileChildrenInHistoryTable(parentTableName, parentwcs, parentSetClause) {
        sync.log.trace("Entering  reconcileChildrenInHistoryTable");

        function reconcileUpdateHelper(childTablename, childSetClause, childwcs) {
            sync.log.trace("Entering reconcileUpdateHelper");
            if (kony.sync.isEmpty(childSetClause)) {
                return;
            }
            //update history table 
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, childTablename + kony.sync.historyTableName);
            kony.sync.qb_set(query, childSetClause);
            kony.sync.qb_where(query, childwcs);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                sync.log.error("reconcilation: error in updating records of " + childTablename + "" + kony.sync.historyTableName + " with whereClause " + JSON.stringify(childwcs) + " and setclause " + childSetClause);
                return 0;
            }
            //update main table
            kony.sync.qb_update(query, childTablename);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                sync.log.error("reconcilation: error in updating records of " + childTablename + " with whereClause " + JSON.stringify(childwcs) + " and setclause " + childSetClause);
                return 0;
            }
        }

        function fetchChildHistoryTableRows(childTablename, childwcs) {
            sync.log.trace("Entering fetchChildHistoryTableRows");
            //select the records
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_select(query, null);
            kony.sync.qb_from(query, childTablename + kony.sync.historyTableName);
            kony.sync.qb_where(query, childwcs);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            var resultset = kony.sync.executeSql(tx, sql, params);
            return resultset;
        }
        //fill the current child whereClause and childSetClause
        function populateChildQueryParams(relationshipAttributes, childwcs, childSetClause, childTablename, parentTableName) {
            sync.log.trace("Entering populateChildQueryParams");
            for (var i = 0; i < relationshipAttributes.length; i++) {
                var parentPk = relationshipAttributes[i].SourceObject_Attribute;
                var childPk = relationshipAttributes[i].TargetObject_Attribute;
                var whereClauseValue = null;
                //need to set only the parentSetClause Columns not all the columns in relationshipattributes set
                if (parentSetClause[parentPk] != undefined) {
                    childSetClause[childPk] = parentSetClause[parentPk];
                }
                for (var j = 0; j < parentwcs.length; j++) {
                    var currentObject = parentwcs[j];
                    if (currentObject.key == parentPk) {
                        whereClauseValue = currentObject.value;
                        break;
                    }
                }
                if (whereClauseValue === null) {
                    sync.log.error("reconcilation:error in forming whereClause for " + childTablename + " having foreign key " + childPk + " with parent table " + parentTableName + " primary key " + parentPk);
                    return 0;
                }
                kony.table.insert(childwcs, {
                    key: childPk,
                    value: whereClauseValue
                });
            }
        }
        //make new whereClause to go recursive
        function populateChildWCSParams(rowItem, childPkColumns, newWhereClause, childTablename) {
            sync.log.trace("Entering populateChildWCSParams");
            for (var i = 0; i < childPkColumns.length; i++) {
                var columnName = childPkColumns[i];
                var columnValue = rowItem[columnName];
                if (columnName === undefined) {
                    sync.log.error("reconcilation:error in creating where clause for " + childTablename + " with childrow " + JSON.stringify(rowItem));
                    return 0;
                }
                kony.table.insert(newWhereClause, {
                    key: columnName,
                    value: columnValue
                });
            }
        }

        function checkIfParentColumnsArePrimaryKeys(parentRelationshipAttributes, childPkColumns) {
            sync.log.trace("Entering checkIfParentColumnsArePrimaryKeys");
            var columnCount = 0;
            for (var i = 0; i < parentRelationshipAttributes.length; i++) {
                for (var j = 0; j < childPkColumns.length; j++) {
                    if (parentRelationshipAttributes[i].TargetObject_Attribute === childPkColumns[j]) {
                        columnCount++;
                        break;
                    }
                }
            }
            return columnCount;
        }
        //entry here
        function reconcileForRelation(RelationShipSet, parentTableName) {
            sync.log.trace("Entering reconcileForRelation");
            if (!kony.sync.isNullOrUndefined(RelationShipSet)) {
                for (var k = 0; k < RelationShipSet.length; k++) {
                    var currentRelation = RelationShipSet[k];
                    var childTablename = currentRelation.TargetObject;
                    var childwcs = []; // all foreign key columns
                    var childSetClause = {};
                    var parentRelationshipAttributes = currentRelation.RelationshipAttributes;
                    var childPkColumns = kony.sync.currentScope.syncTableDic[childTablename].Pk_Columns;
                    var _isError = populateChildQueryParams(parentRelationshipAttributes, childwcs, childSetClause, childTablename, parentTableName); //child tablename and parent tablename are passed only for error handling
                    if (_isError === 0) return _isError;
                    //call child only if parent columns are part of primary key set
                    var columnCount = checkIfParentColumnsArePrimaryKeys(parentRelationshipAttributes, childPkColumns);
                    if (columnCount === parentRelationshipAttributes.length) {
                        // newWhereClause to goto parent grand child
                        var newWhereClause = [];
                        //fetch rows from child history table
                        var childresultset = fetchChildHistoryTableRows(childTablename, childwcs);
                        if (childresultset === false) {
                            sync.log.error("Reconciliation:error in fetching records from " + childTablename + " history table with parent " + parentTableName);
                            return 0;
                        } else {
                            for (var m = 0; m < childresultset.rows.length; m++) {
                                var rowItem = kony.db.sqlResultsetRowItem(tx, childresultset, 0);
                                var _isError = populateChildWCSParams(rowItem, childPkColumns, newWhereClause, childTablename);
                                if (_isError === 0) return _isError;
                                //make recursive call
                                _isError = reconcileChildrenInHistoryTable(childTablename, newWhereClause, childSetClause);
                                if (_isError === 0) return _isError;
                            }
                        }
                    }
                    var _isError = reconcileUpdateHelper(childTablename, childSetClause, childwcs);
                    if (_isError === 0) return _isError;
                }
            }
        }
        //Forward Relationships(OneToMany) reconcilation
        var OneToMany = kony.sync.currentScope.syncTableDic[parentTableName].Relationships.OneToMany;
        var _isError = reconcileForRelation(OneToMany, parentTableName);
        if (_isError === 0) return _isError;
        //Forward Relationships(OneToOne) reconcilation
        var OneToOne = kony.sync.currentScope.syncTableDic[parentTableName].Relationships.OneToOne;
        var _isError = reconcileForRelation(OneToOne, parentTableName);
        if (_isError === 0) return _isError;
        //Reverse Relationships(ManyToOne) reconcilation
        var ManyToOne = kony.sync.currentScope.reverseRelationships[parentTableName];
        var _isError = reconcileForRelation(ManyToOne, parentTableName);
        if (_isError === 0) return _isError;
    }
}
kony.sync.checkForHistoryInstance = function(tx, tablename, values, whereClause) {
    sync.log.trace("Entering kony.sync.checkForHistoryInstance ");
    //var sql = "select count(*) from " + tablename + kony.sync.historyTableName + " " + wcs;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
    kony.sync.qb_where(query, whereClause);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet === false) {
        return 0;
    }
    if (resultSet.rows.length === 0) {
        return false;
    }
    return true;
}
kony.sync.checkForInstance = function(tx, tablename, values, whereClause) {
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, tablename);
        kony.sync.qb_where(query, whereClause);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params);
        if (resultSet === false) {
            return 0;
        }
        if (resultSet.rows.length === 0) {
            return false;
        }
        return true;
    }
    //This function removes successful uploads mostly in case of dummy updates
kony.sync.deleteRecordsAfterUpload = function(callback) {
    sync.log.trace("Entering kony.sync.deleteRecordsAfterUpload ");
    var isError = false;
    if ((kony.sync.OTAChangestobeDeleted.length === 0 && kony.sync.PersisChangestobeDeleted.length === 0) || kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.removeAfterUpload])) {
        callback(0);
        return;
    }
    //Concatinating both OTA uploadqueue and persistent delete queue
    var results = kony.sync.OTAChangestobeDeleted.concat(kony.sync.PersisChangestobeDeleted);
    var length = results.length;
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var scopename = kony.sync.currentScope[kony.sync.scopeName];
    kony.sync.getConnection(dbname, dbname, myTransactionCallBack, mySucessCallBack, myErrorCallBack);

    function myTransactionCallBack(tx) {
        sync.log.trace("Entering myTransactionCallBack");
        for (var i = 0; i < length; i++) {
            var row = results[i];
            var tablename = row.__metadata.type;
            //checking for removeafteruploadpolicy
            if (kony.sync.checkForDeleteAfterUpload(tablename, scopename) !== true) {
                continue;
            }
            //skipping if error
            if (!kony.sync.isNullOrUndefined(row.__metadata.errorMessage)) {
                continue;
            }
            var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
            var pkwcs = [];
            for (var j = 0; j < pkColumns.length; j++) {
                kony.table.insert(pkwcs, {
                    key: pkColumns[j],
                    value: row[pkColumns[j]],
                    optype: "EQ"
                });
            }
            //Get records to be deleted from history table;
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_select(query, null);
            kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
            kony.sync.qb_where(query, pkwcs);
            kony.sync.qb_distinct(query);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            var resultSet = kony.sync.executeSql(tx, sql, params);
            //do not delete from main table if there is some instance in history table
            if (resultSet === false) {
                isError = true;
                return;
            }
            if (resultSet.rows.length !== 0) {
                continue;
            }
            query = kony.sync.qb_createQuery();
            kony.sync.qb_delete(query, tablename);
            kony.sync.qb_where(query, pkwcs);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                isError = true;
                return;
            }
        }
    }

    function myErrorCallBack() {
        sync.log.trace("Entering deleteRecordsAfterUpload myErrorCallBack");
        kony.sync.OTAChangestobeDeleted = [];
        kony.sync.PersisChangestobeDeleted = [];
        if (isError) {
            callback(kony.sync.errorCodeSQLStatement);
        } else {
            callback(kony.sync.errorCodeTransaction);
        }
    }

    function mySucessCallBack() {
        sync.log.trace("Entering deleteRecordsAfterUpload mySucessCallBack");
        kony.sync.OTAChangestobeDeleted = [];
        kony.sync.PersisChangestobeDeleted = [];
        callback(0);
    }
};
//  **************** End KonySyncDownload.js*******************
//  **************** Start KonySyncErrors.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
//error codes
kony.sync.errorCodeInvalidDataType = 7001;
kony.sync.errorCodeMandatoryAttribute = 7002;
kony.sync.errorCodePrimaryKeyNotSpecified = 7003; //Primary Key CategoryID not specified in updating an item in Categories
kony.sync.errorCodeScopeLoading = 7004; //"Scopes loading failed",
kony.sync.errorCodeSyncReset = 7005; //"Sync Reset failed",
kony.sync.errorCodeRegisterDevice = 7006; //"Register device failed",
kony.sync.errorCodeSessionBreak = 7007; //"Session breaks since user scope failure",
kony.sync.errorCodeSessionInProgress = 7008; //"Session in progress",
kony.sync.errorCodeNoDataWithPrimaryKey = 7009; //No data with specified primary key found in SyncObject Categories
kony.sync.errorCodeTransaction = 7010; //"Transaction failed"
kony.sync.errorCodeDbConnection = 7011; //"Database connection closed"
kony.sync.errorCodeMarkForUpload = 7012; // "ERROR: [KONYSYNC] Record does not exist on server, mark it for upload before updating/deleting it"
kony.sync.errorCodeDeferredUpload = 7013; // "Error during Deferred Upload Transaction"
kony.sync.errorCodeReferentialIntegrity = 7014; //"Error because of referential integrity failure"
kony.sync.errorCodeLengthValidationFailed = 7015; //Length exceeds than specified limit
kony.sync.errorCodeDuplicatePrimaryKey = 7016;
kony.sync.errorCodeInputTableNotDefined = 7017;
kony.sync.errorCodeMaliciousType = 7018;
kony.sync.errorCodeSQLStatement = 7019;
kony.sync.errorCodeUploadFailed = 7020;
kony.sync.errorCodeDownloadFailed = 7021;
kony.sync.errorCodeSyncError = 7022;
kony.sync.errorCodeParseError = 7023;
kony.sync.errorCodeChunking = 7024;
kony.sync.errorCodeNetworkCallCancelled = 7025;
kony.sync.errorCodeMetatableError = 7026;
kony.sync.errorCodeNullValue = 7027;
kony.sync.errorCodeInvalidMarkForUploadValue = 7028;
kony.sync.errorCodeDuplicateUniqueKey = 7029;
kony.sync.errorCodeScopeDoesNotExist = 7030;
kony.sync.errorCodeTableDoesNotExist = 7031;
kony.sync.errorCodeInvalidReconcileConfig = 7032;
kony.sync.errorReconcileKeyUndefined = 7033;
kony.sync.errorCodeReconcileSessionInProgress = 7034; //"Reconcile Session in progress",
kony.sync.errorCodeBackendTokenExpiredForOfflineAuth = 7035;
kony.sync.errorUnknown = 7777;
kony.sync.errorCodeUnknownServerError = 8888;
kony.sync.errorCodeChunkInvalidPayloadId = 9999;
kony.sync.errorCodeBlobFileNotCreated = 9000;
kony.sync.errorCodeInvalidColumnType = 9001;
kony.sync.errorCodeEmptyOrNullBase64 = 9002;
kony.sync.errorCodeBlobFileDoesnotExist = 9003;
kony.sync.errorCodeBlobInvalidState = 9004;
kony.sync.errorCodeDownloadAlreadyInQueue = 9005;
kony.sync.errorCodeBlobInvalidStateForDelete = 9006;
kony.sync.errorCodeBlobInvalidStateForUpdate = 9007;
kony.sync.errorCodeInvalidPksGiven = 9008;
kony.sync.errorCodeInvalidColumnParams = 9009;
kony.sync.errorCodeDownloadPolicyNotSupported = 9010;
kony.sync.errorCodeInvalidStateForDownload = 9011;
kony.sync.errorCodeBinaryDownloadFailed = 9012;
kony.sync.errorCodeBlobFileDoesnotExistOnDemand = 9013;
kony.sync.errorCodeParentMappingAttributeNotFound = 9014;
kony.sync.errorCodeChildObjectShouldBeArray = 9015;
kony.sync.errorCodeNullPrimaryKeyValue = 9016;
kony.sync.errorCodeInvalidTableName = 9017;
kony.sync.errorCodeRecordDoNotExist = 9018;
kony.sync.errorCodeBinaryUploadFailed = 9019;
kony.sync.errorCodeBinaryDataFFINotConfigured = 9020;
kony.sync.errorCodeNullDownloadID = 9021;
kony.sync.errorCodeInvalidChunkSize = 9022;
kony.sync.retryErrors = {};
//Server ErrorCodes
kony.sync.servercodes = {};
kony.sync.servercodes.appVersionNotLatest = "SY3001E";
kony.sync.servercodes.chunkPayloadIdInvalid = "SY3008E";
kony.sync.getSessionInProgressError = function() {
    sync.log.trace("Entering kony.sync.getSessionInProgressError ");
    return kony.sync.getErrorTable(kony.sync.errorCodeSessionInProgress, kony.sync.getErrorMessage(kony.sync.errorCodeSessionInProgress), null);
};
kony.sync.getScopeLoadingFailed = function() {
    sync.log.trace("Entering kony.sync.getScopeLoadingFailed ");
    return kony.sync.getErrorTable(kony.sync.errorCodeScopeLoading, kony.sync.getErrorMessage(kony.sync.errorCodeScopeLoading), null);
};
kony.sync.getSyncResetFailed = function() {
    sync.log.trace("Entering kony.sync.getSyncResetFailed ");
    return kony.sync.getErrorTable(kony.sync.errorCodeSyncReset, kony.sync.getErrorMessage(kony.sync.errorCodeSyncReset), null);
};
kony.sync.getSyncRegisterationFailed = function() {
    sync.log.trace("Entering kony.sync.getSyncRegisterationFailed ");
    return kony.sync.getErrorTable(kony.sync.errorCodeRegisterDevice, kony.sync.getErrorMessage(kony.sync.errorCodeRegisterDevice), null);
};
kony.sync.getScopeFailed = function() {
    sync.log.trace("Entering kony.sync.getScopeFailed ");
    return kony.sync.getErrorTable(kony.sync.errorCodeSessionBreak, kony.sync.getErrorMessage(kony.sync.errorCodeSessionBreak), null);
};
kony.sync.getServerError = function(ServerReport, moduleType) {
    sync.log.trace("Entering kony.sync.getServerError ");
    var serverDetails = {};
    if (!kony.sync.isNullOrUndefined(ServerReport)) {
        if (!kony.sync.isNullOrUndefined(ServerReport.server)) {
            serverDetails[kony.sync.hostName] = ServerReport.server.hostName;
            serverDetails[kony.sync.ipAddress] = ServerReport.server.ipAddress;
        }
        //error occurred at application layer
        if (!kony.sync.isNullOrUndefined(ServerReport.msg)) {
            var errorCode = ServerReport.errcode;
            if (kony.sync.isNullOrUndefined(ServerReport.errcode)) { //should not hit this ideally
                if (moduleType === "upload") {
                    errorCode = kony.sync.errorCodeUploadFailed;
                } else if (moduleType === "download") {
                    errorCode = kony.sync.errorCodeDownloadFailed;
                } else {
                    errorCode = kony.sync.errorCodeUnknownServerError;
                }
            }
            var otherParams = {};
            if (errorCode === kony.sync.servercodes.appVersionNotLatest) {
                otherParams.newApplicationVersion = ServerReport.newapplicationversion;
                otherParams.oldApplicationVersion = ServerReport.oldapplicationversion;
            }
            if (kony.sync.isMbaasEnabled && !kony.sync.isNullOrUndefined(ServerReport.mfcode)) {
                if (kony.sdk.offline.isOfflineEnabled) {
                    errorCode = kony.sync.errorCodeBackendTokenExpiredForOfflineAuth;
                    otherParams.mfcode = ServerReport.mfcode;
                    ServerReport.msg = kony.sync.getErrorMessage(errorCode);
                } else {
                    otherParams.mfcode = ServerReport.mfcode;
                    ServerReport.msg = getAuthErrorMessage(ServerReport.mfcode);
                }
            }
            return kony.sync.getErrorTable(errorCode, ServerReport.msg, ServerReport.stacktrace, serverDetails, otherParams);
        }
        //error occurred at network layer
        if (!kony.sync.isNullOrUndefined(ServerReport.errmsg)) {
            return kony.sync.getErrorTable(ServerReport.opstatus, ServerReport.errmsg, null, serverDetails);
        }
    }
    return kony.sync.getErrorTable(kony.sync.errorCodeUnknownServerError, "Unknown Error from the server", ServerReport, serverDetails);
};
kony.sync.getErrorTable = function(errorCode, errorMessage, errorInfo, serverDetails, otherParams) {
    sync.log.trace("Entering kony.sync.getErrorTable ");
    var errorTable = {};
    errorTable.errorCode = errorCode;
    errorTable.errorMessage = errorMessage;
    errorTable.errorInfo = errorInfo;
    errorTable[kony.sync.serverDetails] = serverDetails;
    if (!kony.sync.isNullOrUndefined(otherParams)) {
        for (var i in otherParams) {
            errorTable[i] = otherParams[i];
        }
    }
    if (!kony.sync.isNullOrUndefined(errorInfo)) {
        if (!kony.sync.isNullOrUndefined(errorInfo[kony.sync.errorInfoDatabaseError])) {
            if (!kony.sync.isEmptyString(errorInfo[kony.sync.errorInfoDatabaseError])) {
                errorTable.errorMessage = errorMessage + ". \n" + "System Error:" + errorInfo[kony.sync.errorInfoDatabaseError].message;
            }
        }
    }
    return errorTable;
};
kony.sync.getErrorMessage = function(errorCode, objectName, attributeName) {
    sync.log.trace("Entering kony.sync.getErrorMessage ");
    var errorMap = {};
    errorMap[kony.sync.errorCodeMandatoryAttribute] = "Mandatory attribute " + attributeName + " is missing for the SyncObject " + objectName + ".";
    errorMap[kony.sync.errorCodeScopeLoading] = "Scopes loading failed.";
    errorMap[kony.sync.errorCodeSyncReset] = "Sync Reset failed.";
    errorMap[kony.sync.errorCodeRegisterDevice] = "Register device failed.";
    errorMap[kony.sync.errorCodeSessionBreak] = "Session breaks since user scope failure.";
    errorMap[kony.sync.errorCodeSessionInProgress] = "Session in progress.";
    errorMap[kony.sync.errorCodeTransaction] = "Transaction failed.";
    errorMap[kony.sync.errorCodeDbConnection] = "Error occurred while establishing a Database connection.";
    errorMap[kony.sync.errorCodeMarkForUpload] = "Record does not exist on server, mark it for upload before updating/deleting it.";
    errorMap[kony.sync.errorCodeDeferredUpload] = "Error during Deferred Upload Transaction.";
    errorMap[kony.sync.errorCodeNoDataWithPrimaryKey] = "No data with specified primary key found in SyncObject " + objectName + ".";
    errorMap[kony.sync.errorCodeDuplicatePrimaryKey] = "Primary Key " + attributeName + " already exists in table " + objectName + ". Please give different value of primary key.";
    errorMap[kony.sync.errorCodeDuplicateUniqueKey] = "Unique Key " + attributeName + " already exists in table " + objectName + ". Please give different value of unique key.";
    errorMap[kony.sync.errorCodeInputTableNotDefined] = "Input Table not defined";
    errorMap[kony.sync.errorCodeMaliciousType] = "Malicious value '" + attributeName + "' given for attribute " + objectName + ".";
    errorMap[kony.sync.errorCodeSQLStatement] = "Some error occurred in executing SQL statement";
    errorMap[kony.sync.errorCodeSyncError] = "Error occurred while syncing one or more scopes";
    errorMap[kony.sync.errorCodeDownloadFailed] = "Error occurred in Downloading changes from Sever";
    errorMap[kony.sync.errorCodeUploadFailed] = "Error occurred in Uploading changes to Server";
    errorMap[kony.sync.errorUnknown] = "The following error occurred while performing " + objectName + " : \"" + attributeName + "\"." + " Possible reasons can be sync.init may not have been invoked.";
    errorMap[kony.sync.errorCodeParseError] = "Following error occurred while parsing " + JSON.stringify(objectName) + " : \"" + attributeName + "\"";
    errorMap[kony.sync.errorCodeChunking] = "Error occurred while downloading one or more chunks.";
    errorMap[kony.sync.errorCodeMetatableError] = "Meta tables did not get created successfully because of some unknown problem in sync.init, please invoke sync.reset";
    errorMap[kony.sync.errorCodeNullValue] = "Null values passed in input array";
    errorMap[kony.sync.errorCodeBlobFileNotCreated] = "Error occurred when creating a file";
    errorMap[kony.sync.errorCodeInvalidColumnType] = "Expecting an array and got type " + objectName + "instead for columns";
    errorMap[kony.sync.errorCodeEmptyOrNullBase64] = "Empty or Null value should not be passed for Base64";
    errorMap[kony.sync.errorCodeBlobFileDoesnotExistOnDemand] = "Request file doesn't exist. Please retrigger the download of the binary";
    errorMap[kony.sync.errorCodeBlobFileDoesnotExist] = "Request file doesn't exist.";
    errorMap[kony.sync.errorCodeBlobInvalidState] = "BlobFile in invalid state. Could not upload.";
    errorMap[kony.sync.errorCodeDownloadAlreadyInQueue] = "Binary download already requested";
    errorMap[kony.sync.errorCodeBlobInvalidStateForDelete] = "Blob cannot be deleted in " + objectName + " state";
    errorMap[kony.sync.errorCodeBlobInvalidStateForUpdate] = "Blob cannot be updated in " + objectName + " state";
    errorMap[kony.sync.errorCodeInvalidPksGiven] = "Invalid primary keys given for table " + objectName;
    errorMap[kony.sync.errorCodeInvalidColumnParams] = "Invalid column params ";
    errorMap[kony.sync.errorCodeDownloadPolicyNotSupported] = "Download policy not supported for " + objectName;
    errorMap[kony.sync.errorCodeInvalidStateForDownload] = "Blob cannot be downloaded in " + objectName + " state";
    errorMap[kony.sync.errorCodeBinaryDownloadFailed] = "Binary Download operation failed ";
    errorMap[kony.sync.errorCodeParentMappingAttributeNotFound] = "Parent Mapping Attribute not found for given child " + objectName;
    errorMap[kony.sync.errorCodeChildObjectShouldBeArray] = "Child objects should be of Array type for complex object CUD";
    errorMap[kony.sync.errorCodeNullPrimaryKeyValue] = "Null value passed for primary key " + objectName;
    errorMap[kony.sync.errorCodeInvalidTableName] = "Invalid table name sent for DB Operation " + objectName;
    errorMap[kony.sync.errorCodeRecordDoNotExist] = "Record doesn't exists with given conditions " + objectName;
    errorMap[kony.sync.errorCodeInvalidMarkForUploadValue] = "MarkforUpload value can not be made true if the object is created with mark for upload as false";
    errorMap[kony.sync.errorCodeBinaryUploadFailed] = "Binary Upload operation failed ";
    errorMap[kony.sync.errorReconcileKeyUndefined] = "No reconciliation field defined in reconciliation config";
    errorMap[kony.sync.errorCodeReconcileSessionInProgress] = "Reconcile session in progress";
    errorMap[kony.sync.errorCodeScopeDoesNotExist] = "Scope:" + objectName + " Doesnot exists ";
    errorMap[kony.sync.errorCodeTableDoesNotExist] = "table:" + objectName + " doesnot exists in scope: " + attributeName;
    errorMap[kony.sync.errorCodeInvalidReconcileConfig] = "invalid reconcile config found for scope: " + objectName;
    errorMap[kony.sync.errorCodeBackendTokenExpiredForOfflineAuth] = "Backend token has expired. Please login with network before invoking online services";
    errorMap[kony.sync.errorCodeBinaryDataFFINotConfigured] = "binary data ffi is not configured to use the Binary APIs.";
    errorMap[kony.sync.errorCodeNullDownloadID] = "Download ID for a download operation cannot be null";
    errorMap[kony.sync.errorCodeInvalidChunkSize] = "ChunkSize value given is invalid " + objectName;
    if (errorMap[errorCode] === null) {
        return "Some unknown client error";
    } else {
        return errorMap[errorCode];
    }
};
kony.sync.getInvalidDataTypeMsg = function(objectName, attributeName, expectedType, actualType) {
    sync.log.trace("Entering kony.sync.getInvalidDataTypeMsg ");
    return "Invalid data type for the attribute " + attributeName + " in " + objectName + ".\nExpected:\"" + expectedType + "\"\nActual:\"" + actualType + "\"";
};
kony.sync.getPrimaryKeyNotSpecifiedMsg = function(primaryKey, operation, table) {
    sync.log.trace("Entering kony.sync.getPrimaryKeyNotSpecifiedMsg ");
    return "Primary Key " + primaryKey + " not specified in " + operation + " an item in " + table + ".";
};
kony.sync.getReferetialIntegrityerrMessg = function(sourceAttribute, TargetAttributes, TargetValues) {
    sync.log.trace("Entering kony.sync.getReferetialIntegrityerrMessg ");
    //return  "Referential Integrity Constraints Violation: " + TargetAttribute+" = " + TargetValue + " does not exists in " + sourceAttribute + ".";
    var integrityMessage = "";
    for (var i = 0; i < TargetAttributes.length; i++) {
        integrityMessage = integrityMessage + TargetAttributes[i] + " = " + TargetValues[i];
        if (i != TargetAttributes.length - 1) {
            integrityMessage = integrityMessage + " AND ";
        }
    };
    integrityMessage = integrityMessage + " does not exists in " + sourceAttribute + ".";
    //return  "Referential Integrity Constraints Violation: " + TargetAttribute+" = " + TargetValue + " does not exists in " + sourceAttribute + ".";
    return "Referential Integrity Constraints Violation: " + integrityMessage;
};
kony.sync.getReferetialIntegrityDeleteErrMessg = function(sourceAttribute, TargetAttribute, targetValue, srcValue) {
    sync.log.trace("Entering kony.sync.getReferetialIntegrityDeleteErrMessg ");
    return "Referential Integrity Constraints Violation: " + "Delete dependent records from " + targetValue + " before deleting record(s) in " + srcValue + ".";
};
kony.sync.getValidateLengthErrMsg = function(tablename, colname, expectedLength, actualLength) {
    sync.log.trace("Entering kony.sync.getValidateLengthErrMsg ");
    return "Length exceeds the limit for the attribute " + colname + " in " + tablename + ".\nExpected:\'" + expectedLength + "\'\nActual:\'" + actualLength + "\'";
};
kony.sync.getSchemaUpgradeNeededError = function() {
    sync.log.trace("Entering kony.sync.getSchemaUpgradeNeededError");
    //TODO:needs to be replaced with actual schema error
    return kony.sync.getErrorTable(kony.sync.errorCodeSessionBreak, kony.sync.getErrorMessage(kony.sync.errorCodeSessionBreak), null);
};
kony.sync.getNetworkCancelError = function() {
        sync.log.trace("Entering kony.sync.getNetworkCancelError ");
        var errCreate = {};
        errCreate.opstatus = 7025;
        errCreate.errmsg = "Error occurred, Network Call Cancelled";
        return errCreate;
    }
    //  **************** End KonySyncErrors.js*******************
    //  **************** Start KonySyncGlobals.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
//This enables the Print Statements in the Sync Library
kony.sync.syncLibPrint = true;
kony.sync.downloadNextBatchServerblob = null; //not used
kony.sync.scopes = [];
kony.sync.gMoreChanges = true; //not used
kony.sync.gSyncFailed = false;
kony.sync.gPolicy = 0;
kony.sync.isMbaasEnabled = false;
//Sync Config
kony.sync.currentSyncConfigParams = null;
kony.sync.currentSyncLog = [];
//Binary Config.
kony.sync.binaryOperationNetworkTimeoutKey = "binaryOperationNetworkTimeout";
kony.sync.binaryOperationNetworkTimeoutValue = null;
//Sync Call Backs Constants
kony.sync.sessionTasks = "sessiontasks";
kony.sync.sessionTaskDoUpload = "doupload";
kony.sync.sessionTaskDoDownload = "dodownload";
kony.sync.blobStoreManagerTable = "konysyncBLOBSTOREMANAGER";
kony.sync.filterParams = "filterparams";
kony.sync.onSyncStart = "onsyncstart";
kony.sync.onScopeStart = "onscopestart";
kony.sync.onScopeError = "onscopeerror";
kony.sync.onScopeSuccess = "onscopesuccess";
kony.sync.onAuthenticationSuccess = "onauthenticationsuccess";
kony.sync.onUploadStart = "onuploadstart";
kony.sync.onUploadSuccess = "onuploadsuccess";
kony.sync.onUploadBatchStart = "onuploadbatchstart";
kony.sync.onUploadBatchSuccess = "onuploadbatchsuccess";
kony.sync.onDownloadStart = "ondownloadstart";
kony.sync.onDownloadSuccess = "ondownloadsuccess";
kony.sync.onBatchStored = "onbatchstored";
kony.sync.onBatchProcessingStart = "onbatchprocessingstart";
kony.sync.onBatchProcessingSuccess = "onbatchprocessingsuccess";
kony.sync.onSyncSuccess = "onsyncsuccess";
kony.sync.onSyncError = "onsyncerror";
kony.sync.removeAfterUpload = "removeafterupload";
kony.sync.passwordHashingAlgo = "passwordhashalgo";
//Reconciliation CallBacks
kony.sync.onReconciliationStart = "onreconciliationstart"
kony.sync.onReconciliationScopeStart = "onreconciliationscopestart";
kony.sync.onReconciliationScopeSuccess = "onreconciliationscopesuccess";
kony.sync.onReconciliationScopeError = "onreconciliationscopeerror";
kony.sync.onReconciliationBatchprocessingStart = "onreconciliationbatchprocessingstart";
kony.sync.onReconciliationDownloadStart = "onreconciliationdownloadstart";
kony.sync.onReconciliationBulkGetDownloadStart = "onreconciliationbulkgetdownloadstart";
kony.sync.onReconciliationBulkGetBatchprocessingStart = "onreconciliationbulkgetbatchprocessingstart";
kony.sync.onReconciliationBulkGetBatchprocessingSuccess = "onreconciliationbulkgetbatchprocessingsuccess";
kony.sync.onReconciliationBatchprocessingSuccess = "onreconciliationbatchprocessingsuccess";
kony.sync.onReconciliationSuccess = "onreconciliationsuccess";
kony.sync.onReconciliationError = "onreconciliationerror";
//Sync Context Params
kony.sync.reconcileObjectLevelInfo = "reconcileobjectlevelinfo";
kony.sync.objectLevelInfo = "objectlevelinfo";
kony.sync.authenticateURL = "authenticateurl";
kony.sync.uploadURL = "uploadurl";
kony.sync.downloadURL = "downloadurl";
kony.sync.uploadContext = "uploadcontext";
kony.sync.uploadBatchContext = "uploadbatchcontext";
kony.sync.failedRowInfo = "failedrowinfo";
kony.sync.uploadSummary = [];
kony.sync.numberOfRowsUploaded = "rowsuploaded";
kony.sync.numberOfRowsInserted = "rowsinserted";
kony.sync.numberOfRowsUpdated = "rowsupdated";
kony.sync.numberOfRowsDeleted = "rowsdeleted";
kony.sync.numberOfRowsInsertedAck = "ackinsertedrows";
kony.sync.numberOfRowsUpdatedAck = "ackupdatedrows";
kony.sync.numberOfRowsDeletedAck = "ackdeletedrows";
kony.sync.numberOfRowsAcknowledged = "acktotalrows";
kony.sync.numberOfRowsFailedtoUpload = "rowsfailedtoupload";
kony.sync.pendingBatches = "pendingbatches";
kony.sync.numberOfRowsDownloaded = "batchrowsdownloaded";
kony.sync.batchContext = "batchcontext";
kony.sync.lastSyncTimestamp = "lastsynctimestamp";
kony.sync.uploadSequenceNumber = "uploadsequencenumber";
kony.sync.currentScope = "currentscope";
kony.sync.dataSource = "DataSource";
kony.sync.scopeDataSource = "ScopeDatabaseName";
kony.sync.scopeName = "ScopeName";
kony.sync.syncStrategy = "Strategy";
kony.sync.syncStrategy_OTA = "OTA_SYNC";
kony.sync.versionNumber = "1.0";
kony.sync.dbSize = 5 * 1024 * 1024;
//Pending Batchs
kony.sync.syncPendingBatchesNo = 0;
kony.sync.syncStatusColumn = "changetype";
kony.sync.syncConfigurationDBName = "SyncConfig";
kony.sync.syncConfigurationTableName = "SyncConfigTable";
kony.sync.syncConfigurationColumnDeviceIDName = "DeviceID";
kony.sync.syncConfigurationColumnInstanceIDName = "InstanceID";
kony.sync.syncConfigurationColumnVersion = "SyncVersion";
kony.sync.syncConfigurationColumnSchemaUpgradeContext = "schemaupgradecontext";
kony.sync.configVersion = "";
kony.sync.metaTableName = "konysyncMETAINFO";
kony.sync.metaTableScopeColumn = "scopename";
kony.sync.metaTableSyncTimeColumn = "lastserversynccontext";
kony.sync.metaTableUploadSyncTimeColumn = "lastserveruploadsynccontext";
kony.sync.metaTableSchemaUpgradeSyncTimeColumn = "lastschemaupgradesynccontext";
kony.sync.metaTableSyncVersionCloumn = "versionnumber";
kony.sync.metaTableSyncOrderCloumn = "replaysequencenumber";
kony.sync.metaTableLastGeneratedId = "lastgeneratedid";
kony.sync.metaTableFilterValue = "filtervalue";
kony.sync.historyTableName = "_history";
kony.sync.changeTypeColumn = "changetype";
kony.sync.dbConnection = null;
kony.sync.mainTableSyncVersionColumn = "konysyncversionnumber";
kony.sync.mainTableChangeTypeColumn = "konysyncchangetype";
kony.sync.mainTableHashSumColumn = "konysynchashsum";
kony.sync.historyTableSyncVersionColumn = "konysyncversionnumber";
kony.sync.historyTableChangeTypeColumn = "konysyncchangetype";
kony.sync.historyTableReplaySequenceColumn = "konysyncreplaysequence";
kony.sync.historyTableChangeTimeColumn = "konysyncchangetime"; // Not used as of now.
kony.sync.historyTableHashSumColumn = "konysynchashsum";
kony.sync.originalTableName = "_original";
kony.sync.originalTableChangeTypeColumn = "konysyncoriginalchangetype";
kony.sync.originalTableSyncVersionColumn = "konysyncoriginalversionnumber";
kony.sync.originalTableHashSumColumn = "konysynchashsum";
kony.sync.mergedWithEIS = "konysyncMergedWithEIS";
kony.sync.clientPKPrefix = "konysyncClient";
kony.sync.parentRelationshipMap = "_parentrelationships";
//Global SyncSession Configurations
kony.sync.isSessionInProgress = false;
kony.sync.currentScope = null;
kony.sync.deviceId = null;
kony.sync.instanceId = null;
kony.sync.originalDeviceId = null;
//Global changetype columns
kony.sync.insertColStatus = "0";
kony.sync.updateColStatus = "1";
kony.sync.deleteColStatus = "2";
kony.sync.insertColStatusDI = "90";
kony.sync.updateColStatusDU = "91";
kony.sync.deleteColStatusDD = "92";
//storeid_callback_scope = null; Not used.
kony.sync.currentSyncScopesState = {};
kony.sync.isParameter = true;
kony.sync.dbTypeSQLLite = "sqllite";
kony.sync.dbTypeSQLCE = "sqlce";
kony.sync.platformName = null;
kony.sync.hashTypeSHA256 = "SHA256";
kony.sync.pendingAckIndex = 1;
kony.sync.pendingAckResult = {};
kony.sync.pendingAckCount = 0;
kony.sync.pendingUploadIndex = 1;
kony.sync.pendingUploadResult = {};
kony.sync.pendingUploadCount = 0;
kony.sync.deferredUploadIndex = 1;
kony.sync.deferredUploadResult = {};
kony.sync.deferredUploadCount = 0;
kony.sync.rollbackCurrentScope = null;
kony.sync.onDownloadCompletion = null;
kony.sync.globalIsDownloadStarted = true;
kony.sync.globalIsUploadStarted = true;
kony.sync.globalIsUploadFailed = true;
kony.sync.isChunkingResumedPostSyncError = false;
kony.sync.onUploadCompletion = null;
kony.sync.enableBulkInsert = false;
kony.sync.enableOverride = true;
kony.sync.currentSyncReturnParams = {};
kony.sync.syncTotalBatchInserts = 0;
kony.sync.syncTotalBatchUpdates = 0;
kony.sync.syncTotalBatchDeletes = 0;
kony.sync.syncTotalInserts = 0;
kony.sync.syncTotalUpdates = 0;
kony.sync.syncTotalDeletes = 0;
kony.sync.serverInsertCount = 0;
kony.sync.serverUpdateCount = 0;
kony.sync.serverDeleteCount = 0;
kony.sync.serverInsertAckCount = 0;
kony.sync.serverUpdateAckCount = 0;
kony.sync.serverDeleteAckCount = 0;
kony.sync.serverFailedCount = 0;
kony.sync.objectLevelInfoMap = {};
//reconcile
kony.sync.reconcileBatchDeletions = "reconcilebatchdeletions";
kony.sync.reconcileBatchInsertions = "reconcilebatchinsertions";
kony.sync.reconcileBatchDownloads = "reconcilebatchdownloads";
kony.sync.reconcileTotalInsertions = "reconciletotalinsertions";
kony.sync.reconcileTotalDeletions = "reconciletotaldeletions";
kony.sync.reconcileTotalDownloads = "reconciletotaldownloads";
kony.sync.reconcileBulkGetBatchSize = "reconcilebulkgetbatchsize";
kony.sync.reconcileDownloadBatchSize = "reconciledownloadbatchsize";
kony.sync.pendingReconcileScopesWithHistoryChanges = "pendingreconcilescopeswithhistorychanges";
//reconcileglobals
kony.sync.reconcileTotalBatchDownloads = 0;
kony.sync.reconcileTotalBatchInserts = 0;
kony.sync.reconcileTotalBatchDeletes = 0;
kony.sync.reconcileTotalInserts = 0;
kony.sync.reconcileTotalDeletes = 0;
kony.sync.reconcileTotalDownloaded = 0;
kony.sync.isFirstReconcileDownload = true;
kony.sync.isFirstBulkGetReconcileDownload = true;
kony.sync.downloadReconcileClientContext = {};
kony.sync.bulkGetDownloadReconcileClientContext = {};
kony.sync.queryStore = {};
kony.sync.batchDownloadTimer = 0;
kony.sync.batchInsertionTimer = 0;
kony.sync.reconcileMaxDeleteLimit = 1000;
kony.sync.reconcileSkippedScopeName = "reconcileskippedscopename";
kony.sync.reconcilePendingObjectsInScope = "reconcilependingobjectsinscope";
kony.sync.OTAChangestobeDeleted = [];
kony.sync.PersisChangestobeDeleted = [];
kony.sync.sessionTaskUploadErrorPolicy = "uploaderrorpolicy";
kony.sync.sessionTaskUploadErrorPolicyCOE = "continueonerror";
kony.sync.sessionTaskUploadErrorPolicyAOE = "abortonerror";
//global variable to check whether reset already started or not
kony.sync.isResetInProgress = false;
kony.sync.errorInfoTransactionID = "transactionID";
kony.sync.errorInfoDatabaseError = "dbError";
//global variable to check whether sync for any scope got succeeded or not.
//If sync is not faled for any scope, then only call onsyncsuccess else onsyncerror
kony.sync.isErrorInAnyScope = false;
kony.sync.syncErrorMessage = {};
//This variable will save download request from first batch for subsequent batches
kony.sync.downloadRequest = null;
kony.sync.errorObject = null;
kony.sync.schemaUpgradeErrorObject = null;
kony.sync.enableORMValidations = true;
kony.sync.numberOfRetriesKey = "numberofretryattempts";
kony.sync.onRetry = "onretry";
kony.sync.networkTimeOutKey = "networktimeout";
kony.sync.retryErrorCodes = "retryerrorcodes";
kony.sync.retryWaitKey = "retrywaittime";
//kony.sync.numberOfRetries = 0;
kony.sync.numberOfRetriesMap = {};
kony.sync.maxParallelChunksKey = "maxparallelchunks";
kony.sync.payloadIdKey = "payloadid";
kony.sync.chunkCountKey = "chunkcount";
kony.sync.chunkNoKey = "chunknumber";
kony.sync.chunkDataKey = "chunkdata";
kony.sync.chunkSizeKey = "chunksize";
kony.sync.chunkHashSum = "checksum";
kony.sync.chunkMetaTableName = "konysyncCHUNKMETAINFO";
kony.sync.metaTablePayloadId = "payloadid";
kony.sync.metaTableChunkAck = "chunkacknowledged";
kony.sync.metaTableChunkSize = "chunksize";
kony.sync.metaTableChunkHashSum = "chunkhashsum";
kony.sync.metaTableChunkDiscarded = "chunkdiscarded";
kony.sync.metaTableChunkCount = "chunkcount";
kony.sync.chunkTableName = "konysyncCHUNKDATA";
kony.sync.chunkTableChunkData = "chunkdata";
kony.sync.chunkTableChunkId = "chunkid";
kony.sync.chunkTablePayloadId = "payloadid";
kony.sync.chunkTableTimeStamp = "timestamp";
kony.sync.chunkRequestKey = "chunkrequest";
kony.sync.pendingChunksKey = "pendingchunks";
kony.sync.chunksDownloadedKey = "chunksdownloaded";
kony.sync.onChunkStart = "onchunkstart";
kony.sync.onChunkSuccess = "onchunksuccess";
kony.sync.onChunkError = "onchunkerror";
kony.sync.chunkNotAcknowledged = 0;
kony.sync.chunkCompleteButNotAcknowledged = 1;
kony.sync.chunkCompleteAndWaitingForAck = 2;
kony.sync.chunkDiscarded = 1;
kony.sync.chunkNotDiscarded = 0;
kony.sync.trackIntermediateUpdates = true;
kony.sync.uploadcontextMap = {};
kony.sync.serverDetails = "serverDetails";
kony.sync.hostName = "hostName";
kony.sync.ipAddress = "ipAddress";
/*meta info about konysyncPENDINGUPLOADREQUESTINFO table */
kony.sync.pendingUploadTableName = "konysyncPENDINGUPLOADREQUESTINFO";
kony.sync.pendingUploadTableInsertCount = "insertcount";
kony.sync.pendingUploadTableUpdateCount = "updatecount";
kony.sync.pendingUploadTableDeleteCount = "deletecount";
kony.sync.pendingUploadTableBatchInsertCount = "batchinsertcount";
kony.sync.pendingUploadTableBatchUpdateCount = "batchupdatecount";
kony.sync.pendingUploadTableBatchDeleteCount = "batchdeletecount";
kony.sync.pendingUploadTableObjectLevelInfo = "objectlevelinfo";
kony.sync.pendingUploadTableUploadRequest = "uploadrequest";
kony.sync.pendingUploadTableUploadLimit = "uploadlimit";
kony.sync.deviceDBEncryptionKey = null;
kony.sync.deviceDBEncryptionKeyParam = "devicedbencryptionkey";
kony.sync.onSyncInitSuccessParam = "oninitsuccess";
kony.sync.onSyncInitErrorParam = "oniniterror";
kony.sync.onSyncResetSuccessParam = "onresetsuccess";
kony.sync.onSyncResetErrorParam = "onreseterror";
kony.sync.currentSyncScopeFilter = null;
kony.sync.currentSyncScopeFilterIndex = 1;
kony.sync.uploadClientContext = {};
kony.sync.downloadClientContext = {};
kony.sync.reconciledKeysKey = "reconciledprimarykeys";
kony.sync.schemaUpgradeNeeded = false;
kony.sync.schemaUpgradeContext = null;
kony.sync.schemaUpgradeDownloadPending = false;
kony.sync.omitUpload = false;
kony.sync.omitDownload = false;
kony.sync.onUpgradeQueriesDownloadStartKey = "onupgradescriptsdownloadstart";
kony.sync.onUpgradeQueriesDownloadSuccessKey = "onupgradescriptsdownloadsuccess";
kony.sync.onUpgradeQueriesDownloadErrorKey = "onupgradescriptsdownloaderror";
kony.sync.onUpgradeQueriesExecutionStartKey = "onupgradescriptsexecutionstart";
kony.sync.onUpgradeQueriesExecutionSuccessKey = "onupgradescriptsexecutionsuccess";
kony.sync.onUpgradeQueriesExecutionErrorKey = "onupgradescriptsexecutionerror";
kony.sync.onUpgradeRequiredKey = "onupgraderequired";
//Schema Upgrade Policies
kony.sync.onUpgradeActionAbort = "ABORT";
kony.sync.onUpgradeActionContinue = "CONTINUE"; //Not Implemented
kony.sync.onUpgradeActionContinueOnlyUpload = "CONTINUE_ONLY_UPLOAD"; //Not Implemented
kony.sync.onUpgradeActionUploadAbort = "UPLOAD_AND_ABORT";
kony.sync.onUpgradeActionUpgrade = "UPGRADE";
kony.sync.onUpgradeActionUploadUpgrade = "UPLOAD_AND_UPGRADE";
kony.sync.performOnlySchemaUpgrade = false;
kony.sync.onIsUpgradeRequiredSuccessKey = "isupgraderequiredsuccess";
kony.sync.onIsUpgradeRequiredErrorKey = "isupgraderequirederror";
kony.sync.onIsUpgradeRequiredStartKey = "isupgraderequiredstart";
kony.sync.onPerformUpgradeStartKey = "onperformupgradestart";
kony.sync.onPerformUpgradeSuccessKey = "onperformupgradesuccess";
kony.sync.onPerformUpgradeErrorKey = "onperformupgradeerror";
kony.sync.forceUpload = false;
kony.sync.forceUploadUpgrade = false;
kony.sync.uploadLimit = 0;
kony.sync.deviceIdentifierIOS7Key = "deviceidentifierios7";
kony.sync.isAlertEnabled = true;
kony.sync.invokeServiceFunctionKey = "invokeservicefunction";
kony.sync.authTokenKey = "authtoken";
kony.sync.sessionMap = {};
kony.sync.konySyncSessionID = "konysyncsessionid";
kony.sync.konySyncRequestNumber = "konysyncrequestnumber";
kony.sync.isSyncStopped = false;
kony.sync.onSyncStop = null;
kony.sync.httprequestsession = null;
kony.sync.DDL556to559Update = [];
kony.sync.DDL559to560Update = [];
kony.sync.DDL6xto70Update = [];
kony.sync.scopeDict = {};
kony.sync.isAppInBackground = false;
kony.sync.isPhonegap = false;
//upload cache changes
kony.sync.scope = "scope";
kony.sync.offset = "offset";
kony.sync.limit = "limit";
kony.sync.lastSequenceNumber = "lastSeqNo";
kony.sync.batchSize = "batchsize";
kony.sync.changeSet = "changeset";
kony.sync.uploadChangesLimit = "uploadLimit";
kony.sync.lastBatch = "lastBatch";
kony.sync.columns = "binarycolumns";
kony.sync.binaryMetaColumnPrefix = "blobref_";
kony.sync.blob = "binary";
kony.sync.onDemand = "ondemand";
kony.sync.always = "always";
kony.sync.ifRecordValue = "ifrecordvalue";
kony.sync.syncToDeviceField = "downloadToDeviceField";
kony.sync.inline = "Inline";
kony.sync.notSupported = "NotSupported";
kony.sync.blobRefNotFound = -1;
kony.sync.blobRefNotDefined = "NULL";
kony.sync.binaryPolicy = "downloadToDevice";
kony.sync.blobTypeBase64 = "base64";
kony.sync.blobTypeStream = "stream";
kony.sync.forceDownload = "forceDownload";
kony.sync.maxFilePercent = 100;
kony.sync.minFilePercent = 0;
kony.sync.maxRetries = 3;
kony.sync.optype = "optype";
kony.sync.comptype = "comptype";
kony.sync.openbrace = "openbrace";
kony.sync.closebrace = "closebrace";
kony.sync.queryKey = "key";
kony.sync.queryValue = "value";
kony.sync.params = "params";
kony.sync.httpHeaders = "httpheaders";
kony.sync.url = "url";
kony.sync.blobId = "blobid";
kony.sync.blobName = "blobname";
kony.sync.type = "type";
kony.sync.metadata = "metadata";
kony.sync.changetype = "changetype";
kony.sync.syncobjects = "syncobjects";
kony.sync.serverBlob = "serverBlob";
kony.sync.blobSyncScope = "scopeName";
kony.sync.clientId = "clientid";
kony.sync.moreChangesAvailable = "moreChangesAvailable";
kony.sync.requestState = "requestState";
kony.sync.currentSyncConfigKey = "currentSyncConfigParams";
kony.sync.requestType = "requestType";
kony.sync.isUpload = false;
kony.sync.isDownload = true;
kony.sync.konySyncReplaySequence = "konysyncreplaysequence";
kony.sync.SequenceNumber = "SequenceNumber";
kony.sync.sync = "sync";
kony.sync.oneToMany = "OneToMany";
kony.sync.targetObject = "TargetObject";
kony.sync.sourceAttribute = "ParentObject_Attribute";
kony.sync.targetAttribute = "ChildObject_Attribute";
kony.sync.isCleanUpJobCompleted = false;
kony.sync.onBinaryDownloadFunction = "onBinaryDownload";
kony.sync.onBinaryUploadFunction = "onBinaryUpload";
kony.sync.tracking = "syncTracking";
kony.sync.shouldDeleteBeforeSyncSession = "shouldDeleteBeforeSyncSession";
//  **************** End KonySyncGlobals.js*******************
//  **************** Start KonySyncHelper.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
//This function is used inside sync library to handle prints
kony.sync.syncPrint = function(param) {
    sync.log.trace("Entering kony.sync.syncPrint ");
    if (kony.sync.syncLibPrint) {
        kony.print(param);
    }
};
/*
--This function formats the sqllite resultset. This is temporary and should be done at platform level.
--function format_row(rowItem)
kony.sync.format_row = function(rowItem)
local rowtemp = {}
if(rowItem ~= nil)then
for key,value in pairs(rowItem) do
value = ""..value;
if(string.isnumeric(value))then
string.replace(value,".0","");
end
rowtemp[key] = string.replace(value, "'", "");
end
if ( value ~= nil ) then
string.replace(value, "'", "");
end
else
return nil;
end
return rowtemp;
end
--*/
kony.sync.getTableInfo = function(tablename) {
    sync.log.trace("Entering kony.sync.getTableInfo ");
    for (var i = 0; i < kony.sync.scopes.length; i++) {
        var scope = kony.sync.scopes[i];
        if (!kony.sync.isNullOrUndefined(scope.syncTableDic[tablename])) {
            return scope.syncTableDic[tablename];
        }
    }
    return null;
};
kony.sync.is_SQL_select = function(sql) {
    sync.log.trace("Entering kony.sync.is_SQL_select ");
    sql = kony.string.trim(sql);
    return kony.string.startsWith(sql, "select", true);
};
kony.sync.dummyerror = function(tid, err) {
    sync.log.trace("Entering kony.sync.dummyerror ");
    if (kony.sync.isNullOrUndefined(err)) {
        sync.log.debug("dummyerror");
    } else {
        sync.log.debug("dummy error --->", err);
    }
};
kony.sync.verifyAndCallClosure = function(closure, params) {
    sync.log.trace("Entering kony.sync.verifyAndCallClosure ");
    if (kony.sync.isValidFunctionType(closure)) {
        return closure(params);
    } else {
        sync.log.warn("Invalid callback type : ", closure);
    }
};
kony.sync.getArrayCount = function(tab) {
    sync.log.trace("Entering kony.sync.getArrayCount ");
    var count = 0;
    if (!kony.sync.isNullOrUndefined(tab)) {
        return tab.length;
    }
    return count;
};
kony.sync.getDeviceID = function() {
    sync.log.trace("Entering kony.sync.getDeviceID");
    if (kony.sync.deviceId !== "") {
        return kony.sync.deviceId;
    }
    var deviceInfo = kony.os.deviceInfo();
    return deviceInfo.deviceid;
};
kony.sync.getInstanceID = function() {
    sync.log.trace("Entering kony.sync.getInstanceID ");
    return kony.sync.instanceId;
};
kony.sync.getOriginalDeviceID = function() {
    sync.log.trace("Entering kony.sync.getOriginalDeviceID ");
    if (kony.sync.isNullOrUndefined(kony.sync.originalDeviceId)) {
        kony.sync.originalDeviceId = kony.os.deviceInfo().deviceid;
        return kony.os.deviceInfo().deviceid;
    } else {
        return kony.sync.originalDeviceId;
    }
};
kony.sync.removeprovisioncolumns = function(row, columns, isArray, insertNull) {
    sync.log.trace("Entering kony.sync.removeprovisioncolumns ");
    //remove the blobref_columns from the columns.
    var length = columns.length;
    var record = [];
    var i = null;
    if (!isArray) {
        record = [];
        for (i = length - 1; i >= 0; i--) {
            if (!kony.sync.isNullOrUndefined(row[columns[i].Name])) {
                record.push(row[columns[i].Name]);
            } else if (insertNull === true) {
                record.push("NULL");
            }
        }
        if (!kony.sync.isNullOrUndefined(row.konysynchashsum)) {
            record.push(row.konysynchashsum);
        }
        return record;
    } else {
        record = {};
        for (i = length - 1; i >= 0; i--) {
            if (!kony.sync.isNullOrUndefined(row[columns[i].Name])) {
                record[columns[i].Name] = row[columns[i].Name];
            } else if (insertNull === true) {
                record[columns[i].Name] = "NULL";
            }
        }
        if (!kony.sync.isNullOrUndefined(row.konysynchashsum)) {
            record.konysynchashsum = row.konysynchashsum;
        }
        return record;
    }
};
kony.sync.replaceautogeneratedPK = function(sname, synctable, values, tx, errorCallback) {
    sync.log.trace("Entering kony.sync.replaceautogeneratedPK ");
    var id = null;
    var pkTab = {};
    if (!kony.sync.isNullOrUndefined(synctable.Pk_Columns)) {
        for (var i = 0; i < synctable.Pk_Columns.length; i++) {
            var pk = synctable.Pk_Columns[i];
            if (synctable.ColumnsDic[pk].Autogenerated === "true") {
                id = kony.sync.getLastGeneratedID(sname, tx, errorCallback);
                if (id === false) {
                    return false;
                }
                id = id - 1;
                if (synctable.ColumnsDic[pk].type === "string") {
                    id = id.toString();
                }
                values[pk] = id;
                pkTab[pk] = id;
                if (!kony.sync.setLastGeneratedID(sname, id, tx, errorCallback)) {
                    return false;
                }
            } else {
                pkTab[pk] = values[pk];
            }
        }
    }
    //implemented for composite primary key
    return pkTab;
};
kony.sync.CreateCopy = function(obj) {
    sync.log.trace("Entering kony.sync.CreateCopy ");
    var copy;
    if (null == obj || "object" != typeof obj) return obj;
    if (obj instanceof Array) {
        copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            copy[i] = kony.sync.CreateCopy(obj[i]);
        }
        return copy;
    }
    if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = kony.sync.CreateCopy(obj[attr]);
        }
        return copy;
    }
};
kony.sync.getautogeneratePK = function(sname, synctable) {
    sync.log.trace("Entering kony.sync.getautogeneratePK ");
    var agPKs = [];
    if (!kony.sync.isNullOrUndefined(synctable.Pk_Columns)) {
        for (var i = 0; i < synctable.Pk_Columns.length; i++) {
            var pk = synctable.Pk_Columns[i];
            if ((synctable.ColumnsDic[pk].Autogenerated === "true")) {
                kony.table.insert(agPKs, pk);
            }
        }
    }
    return agPKs;
};
kony.sync.getDBNamefromDataSource = function(dsname) {
    sync.log.trace("Entering kony.sync.getDBNamefromDataSource ");
    sync.log.debug("validatint dsname : ", dsname);
    for (var i = 0; i < konysyncClientSyncConfig.ArrayOfDataSource.length; i++) {
        var datasource = konysyncClientSyncConfig.ArrayOfDataSource[i];
        sync.log.debug("datasource.type:" + datasource.type + ":datasource.ID:" + datasource.ID);
        if ((datasource.type === "database" && datasource.ID === dsname)) {
            return datasource.Database.DatabaseName;
        }
    }
    return null;
};
kony.sync.getAppId = function() {
    sync.log.trace("Entering kony.sync.getAppId ");
    return kony.sync.currentSyncConfigParams.appid;
};
kony.sync.getBatchSize = function() {
    sync.log.trace("Entering kony.sync.getBatchSize ");
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.batchsize)) {
        return kony.sync.currentSyncConfigParams.batchsize;
    }
    if (kony.os.deviceInfo().name === "blackberry") {
        return "50";
    } else {
        return "500";
    }
};
kony.sync.resetsyncsessionglobals = function(opName) {
    sync.log.trace("Entering kony.sync.resetsyncsessionglobals ");
    kony.sync.currentScope = null;
    kony.sync.currentSyncReturnParams = {};
    kony.sync.isSyncStopped = false;
    if (opName === "startSession") {
        kony.sync.currentSyncReturnParams[kony.sync.uploadURL] = kony.sync.getUploadURL();
        kony.sync.currentSyncReturnParams[kony.sync.downloadURL] = kony.sync.getDownloadURL();
    }
    kony.sync.currentSyncLog = [];
};
kony.sync.resetscopesessionglobals = function(CallBack) {
    sync.log.trace("Entering kony.sync.resetscopesessionglobals ");
    var isError = false;

    function clearSchemaUpgradeContext(tx) {
        sync.log.trace("Entering clearSchemaUpgradeContext");
        //resetting the schemaupgrade flag   once the download of the columns is done in memory and in db
        kony.sync.schemaUpgradeContext = null;
        var sql = "update " + kony.sync.syncConfigurationTableName + " set " + kony.sync.syncConfigurationColumnSchemaUpgradeContext + " = null";
        if (kony.sync.executeSql(tx, sql, null) === false) {
            isError = true;
            return; //error
        }
        sync.log.info("schemaupgrade context cleared successfully in memory and db");
    }

    function clearSchemaSuccessCallBack() {
        sync.log.trace("Entering clearSchemaSuccessCallBack");
        CallBack(true);
    }

    function dbErrorCallBack(errInfo) {
        sync.log.error("error in opening db connection " + JSON.stringify(errInfo));
        clearSchemaErrorCallBack(errInfo);
    }

    function clearSchemaErrorCallBack(errInfo) {
        sync.log.error("failed to clear schemaupgradeinfo in synconfigtable after dsc " + JSON.stringify(errInfo));
        kony.sync.isErrorInAnyScope = true;
        CallBack(true);
    }
    sync.log.trace("Entering kony.sync.resetscopesessionglobals ");
    kony.sync.syncPendingBatchesNo = 0;
    delete kony.sync.currentSyncReturnParams[kony.sync.batchContext];
    delete kony.sync.currentSyncReturnParams[kony.sync.uploadContext];
    if (kony.sync.currentScope === null) {
        kony.sync.currentScope = kony.sync.scopes[0]; //- Start 1st Scope Sync
        CallBack(false);
    } else {
        sync.log.debug("Scope index: ", kony.sync.currentScope.Index);
        sync.log.debug("Scope count: ", kony.sync.scopes.scopecount);
        if (kony.sync.currentScope.Index === kony.sync.scopes.scopecount - 1) {
            if (!kony.sync.isNullOrUndefined(kony.sync.schemaUpgradeContext)) {
                var dbName = kony.sync.currentScope[kony.sync.scopeDataSource];
                var conn = kony.sync.getConnectionOnly(dbName, dbName, dbErrorCallBack);
                if (conn !== null) {
                    kony.db.transaction(conn, clearSchemaUpgradeContext, clearSchemaErrorCallBack, clearSchemaSuccessCallBack);
                }
            } else CallBack(true); //Sync Complete
        } else {
            kony.sync.currentScope = kony.sync.scopes[kony.sync.currentScope.Index + 1]; //Get Next Scope
            CallBack(false);
        }
    }
};
kony.sync.resetuploadsessioglobals = function() {
    sync.log.trace("Entering kony.sync.resetuploadsessioglobals ");
    delete kony.sync.currentSyncReturnParams[kony.sync.uploadContext];
    delete kony.sync.currentSyncReturnParams[kony.sync.lastSyncTimestamp];
    delete kony.sync.currentSyncReturnParams[kony.sync.uploadSequenceNumber];
    //sync_total_inserts = 0;
    kony.sync.syncTotalInserts = 0;
    kony.sync.syncTotalUpdates = 0;
    kony.sync.syncTotalDeletes = 0;
    kony.sync.serverInsertCount = 0;
    kony.sync.serverUpdateCount = 0;
    kony.sync.serverDeleteCount = 0;
    kony.sync.serverInsertAckCount = 0;
    kony.sync.serverUpdateAckCount = 0;
    kony.sync.serverDeleteAckCount = 0;
    kony.sync.serverFailedCount = 0;
    kony.sync.uploadSummary = [];
};
kony.sync.resetbatchsessionglobals = function() {
    sync.log.trace("Entering kony.sync.resetbatchsessionglobals ");
    delete kony.sync.currentSyncReturnParams[kony.sync.batchContext];
    delete kony.sync.currentSyncReturnParams[kony.sync.uploadContext];
    delete kony.sync.currentSyncReturnParams[kony.sync.uploadSequenceNumber];
    kony.sync.serverInsertCount = 0;
    kony.sync.serverUpdateCount = 0;
    kony.sync.serverDeleteCount = 0;
    kony.sync.serverInsertAckCount = 0;
    kony.sync.serverUpdateAckCount = 0;
    kony.sync.serverDeleteAckCount = 0;
    kony.sync.serverFailedCount = 0;
    kony.sync.uploadSummary = [];
    kony.sync.objectLevelInfoMap = {};
};
kony.sync.getSyncTable = function(tablename) {
    sync.log.trace("Entering kony.sync.getSyncTable ");
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    return kony.sync.scopes[scopename].syncTableDic[tablename];
};
kony.sync.getCurrentVersionNumber = function(tbname) {
    sync.log.trace("Entering kony.sync.getCurrentVersionNumber ");
    var scopename = kony.sync.scopes.syncTableScopeDic[tbname];
    return kony.sync.currentSyncScopesState[scopename];
};
kony.sync.getBackEndDBType = function() {
    sync.log.trace("Entering kony.sync.getBackEndDBType ");
    if (kony.sync.platformName === null) {
        kony.sync.platformName = kony.os.deviceInfo().name;
    }
    if (kony.sync.platformName === "winmobile") {
        return kony.sync.dbTypeSQLCE;
    }
    return kony.sync.dbTypeSQLLite;
};
kony.sync.printScopeLog = function() {
    sync.log.trace("Entering kony.sync.printScopeLog ");
    sync.log.info("Sync complete");
    sync.log.info("----------------------------------------------------");
    for (var i = 0; i < kony.sync.currentSyncLog.length; i++) {
        var batch = kony.sync.currentSyncLog[i];
        sync.log.info("Batch No: ", i);
        sync.log.info("Batch log: ", batch);
    }
    sync.log.info("----------------------------------------------------");
};
//To generate hash
kony.sync.genHash = function(hashType, plaintext) {
    sync.log.trace("Entering kony.sync.genHash ");
    //return same in case of null/undefined plaintext
    if (kony.sync.isNull(plaintext)) {
        return plaintext;
    }
    //if hashType is callback, get the value from it
    if (kony.sync.isValidFunctionType(hashType)) {
        return hashType(plaintext);
    }
    //convert plaintext to string if not already
    plaintext = plaintext.toString();
    //apply default value in case of invalid/null/undefined hashtype
    if (kony.sync.isNull(hashType) || kony.string.equalsIgnoreCase(kony.type(hashType), "string") === false) {
        return kony.crypto.createHash("sha256", plaintext);
    }
    //return same if hashtype is none
    else if (kony.string.equalsIgnoreCase(hashType, "none") === true) {
        return plaintext;
    }
    //apply the desired hash algo
    else {
        return kony.crypto.createHash(hashType, plaintext);
    }
};
kony.sync.tonumber = function(arg) {
    sync.log.trace("Entering kony.sync.tonumber ");
    if (kony.sync.isNullOrUndefined(arg)) {
        return null;
    }
    //duplicating kony.os.toNumber in order to avoid Android platform dependency issues
    if (arguments.length !== 1) {
        throw new Error("Invalid argument to os.toNumber");
    }
    if (typeof(arg) === "number") {
        return arg;
    } else if (typeof(arg) === "string") {
        var str = arg.replace(/^\s*/, '').replace(/\s*$/, '');
        if (str === '') {
            return null;
        } else {
            var num = str - 0;
            return (isNaN(num) ? null : num);
        }
    } else {
        return null;
    }
};
kony.sync.filterNullsFromSelectResult = function(res) {
    sync.log.trace("Entering kony.sync.filterNullsFromSelectResult ");
    if (kony.sync.enableORMValidations) {
        var tableToMap = [];
        for (var j = 0; j < res.length; j++) {
            var u = res[j];
            var rowToMap = {};
            for (var k in u) {
                var v = u[k];
                if (!kony.sync.isNull(v)) {
                    rowToMap[k] = v;
                }
            }
            kony.table.insert(tableToMap, rowToMap);
        }
        return tableToMap;
    } else {
        return res;
    }
};
kony.sync.getAsyncDownloadBatchSize = function() {
    sync.log.trace("Entering kony.sync.getAsyncDownloadBatchSize ");
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.asyncbatchsize)) {
        return kony.sync.currentSyncConfigParams.asyncbatchsize;
    }
    return 50;
};
kony.sync.isApplyChangesSync = function() {
    sync.log.trace("Entering kony.sync.isApplyChangesSync ");
    var returnVal;
    returnVal = true;
    return returnVal;
};
kony.sync.getChangeTypeForUploadTrue = function(type) {
    sync.log.debug("ValueSentForChange: ", type);
    if (typeof(type) === "number") {
        type = type.toString();
    }
    if (type === "90") {
        return "0";
    }
    if (type === "91") {
        return "1";
    }
    if (type === "92") {
        return "2";
    }
    return type;
};
//Checking whether table is defined for delete after upload or not
kony.sync.checkForDeleteAfterUpload = function(tablename, scopename) {
    sync.log.trace("Entering kony.sync.checkForDeleteAfterUpload ");
    var i = null;
    var myTab = kony.sync.currentSyncConfigParams[kony.sync.removeAfterUpload];
    if (kony.sync.isNullOrUndefined(myTab)) {
        return false;
    }
    if (!kony.sync.isNullOrUndefined(scopename)) {
        if (kony.sync.isNullOrUndefined(myTab[scopename])) {
            return false;
        }
        if (myTab[scopename].length === 0) {
            return true;
        }
        for (i in myTab[scopename]) {
            if (myTab[scopename][i] === tablename) {
                return true;
            }
        }
    } else {
        for (i in myTab) {
            for (var j in myTab[i]) {
                if (myTab[i][j] === tablename) {
                    return true;
                }
            }
        }
    }
    return false;
};
//checking for false updates
kony.sync.checkForFalseUpdate = function(dbname, tbname, twcs, markForUpload, errorcallback, successcallback) {
    sync.log.trace("Entering kony.sync.checkForFalseUpdate ");
    var uploadstatus = true;
    var isError = false;
    if (markForUpload === false) {
        return true;
    } else {
        kony.table.insert(twcs, {
            key: kony.sync.historyTableChangeTypeColumn,
            value: "90",
            optype: "EQ",
            comptype: "AND"
        });
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, [kony.sync.historyTableChangeTypeColumn]);
        kony.sync.qb_from(query, tbname + "_history");
        kony.sync.qb_where(query, twcs);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var connection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback, "check for false update");
        if (connection !== null) {
            kony.sync.startTransaction(connection, transaction_callback, update_successcallback, single_transaction_error_callback, "check for false update");
        }
    }

    function transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.checkForFalseUpdate transaction_callback");
        var resultSet = kony.sync.executeSql(tx, sql, params, errorcallback);
        if (resultSet !== false) {
            var num_records = resultSet.rows.length;
            if (num_records !== 0) {
                sync.log.error("Record does not exist on server, mark it for upload before updating/deleting it");
                kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeMarkForUpload, kony.sync.getErrorMessage(kony.sync.errorCodeMarkForUpload), null));
                uploadstatus = false;
            } else {
                uploadstatus = true;
            }
        } else {
            //return;
            isError = true;
        }
    }

    function update_successcallback() {
        sync.log.trace("Entering kony.sync.checkForFalseUpdate update_successcallback");
        if (!isError && uploadstatus === true) {
            successcallback();
        }
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.checkForFalseUpdate single_transaction_error_callback");
        if (!isError) {
            sync.log.error("Transaction error occurred", "check for false update");
            kony.sync.showTransactionError(errorcallback, "check for false update");
        } else {
            sync.log.error("Transaction error occurred", kony.sync.errorObject);
            kony.sync.verifyAndCallClosure(errorcallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
};
kony.sync.checkForFalseUpdateWCS = function(dbname, tbname, twcs, markForUpload, errorcallback, successcallback) {
    sync.log.trace("Entering kony.sync.checkForFalseUpdateWCS ");
    var uploadstatus = true;
    var isError = false;
    if (markForUpload === false) {
        return true;
    }
    if (twcs !== "" && !kony.sync.isNull(twcs)) {
        twcs = twcs + " AND " + kony.sync.historyTableChangeTypeColumn + " = 90";
    } else {
        twcs = " where " + kony.sync.historyTableChangeTypeColumn + " = 90";
    }
    var sql = "select " + kony.sync.historyTableChangeTypeColumn + " from " + tbname + "_history " + twcs;
    var connection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback, "check for false update WCS");
    if (connection !== null) {
        kony.sync.startTransaction(connection, transaction_callback, update_successcallback, update_failurecallback, "check for false update WCS");
    }

    function transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.checkForFalseUpdateWCS transaction_callback");
        var resultSet = kony.sync.executeSql(tx, sql, null, errorcallback);
        if (resultSet !== false) {
            var num_records = resultSet.rows.length;
            if (num_records !== 0) {
                sync.log.error("Record does not exist on server, mark it for upload before updating/deleting it");
                kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeMarkForUpload, kony.sync.getErrorMessage(kony.sync.errorCodeMarkForUpload), null));
                uploadstatus = false;
            } else {
                uploadstatus = true;
            }
        } else {
            isError = true;
        }
    }

    function update_successcallback() {
        sync.log.trace("Entering kony.sync.checkForFalseUpdateWCS update_successcallback");
        if (!isError && uploadstatus === true) {
            successcallback();
        }
    }

    function update_failurecallback() {
        sync.log.trace("Entering kony.sync.checkForFalseUpdateWCS update_failurecallback");
        if (!isError && uploadstatus === true) {
            sync.log.error("Transaction error occurred : ", "check for false update WCS");
            kony.sync.showTransactionError(errorcallback, "check for false update WCS");
        } else {
            sync.log.error("Transaction error occurred : ", kony.sync.errorObject);
            kony.sync.verifyAndCallClosure(errorcallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
};
kony.sync.getConnection = function(dbName, displayName, transactionCallBack, successCallBack, errorCallBack) {
    sync.log.trace("Entering kony.sync.getConnection ");
    var connection = kony.sync.getConnectionOnly(dbName, displayName, errorCallBack);
    if (connection !== null) {
        kony.db.transaction(connection, transactionCallBack, errorCallBack, successCallBack);
    }
};
//This function starts a transaction given a connection
kony.sync.startTransaction = function(connection, transactionCallBack, successCallBack, errorCallBack) {
    sync.log.trace("Entering kony.sync.startTransaction ");
    kony.db.transaction(connection, transactionCallBack, errorCallBack, successCallBack);
};
kony.sync.showTransactionError = function(errorCallBack, moduleName) {
    sync.log.trace("Entering kony.sync.showTransactionError ");
    if (kony.sync.isNullOrUndefined(moduleName)) {
        moduleName = "";
    }
    sync.log.fatal(moduleName + ":" + " Db connection is null");
    kony.sync.verifyAndCallClosure(errorCallBack, kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
};
kony.sync.checkIntegrity = function(dbname, rMap, successCallback, errorCallBack) {
    sync.log.trace("Entering kony.sync.checkIntegrity ");
    if (!kony.sync.enableORMValidations) {
        kony.sync.verifyAndCallClosure(successCallback);
        return;
    }
    var status = true;
    var isError = false;
    var integrityFailedMap = null;
    var connection = kony.sync.getConnectionOnly(dbname, dbname, errorCallBack, "Checking integrity");
    if (connection !== null) {
        kony.sync.startTransaction(connection, integrityTransaction, integritySuccess, integrityFailure, "Checking Referential Integrity Constraints");
    }

    function integrityTransaction(tx) {
        sync.log.trace("Entering integrityTransaction");
        integrityFailedMap = kony.sync.checkIntegrityinTransaction(tx, rMap);
    }

    function integritySuccess() {
        sync.log.trace("Entering integritySuccess");
        var error = "";
        if (integrityFailedMap === true) {
            kony.sync.verifyAndCallClosure(successCallback);
        } else {
            for (var key in integrityFailedMap) {
                error = error + integrityFailedMap[key];
            }
            kony.sync.verifyAndCallClosure(errorCallBack, kony.sync.getErrorTable(kony.sync.errorCodeReferentialIntegrity, error));
        }
    }

    function integrityFailure() {
        sync.log.trace("Entering integrityFailure");
        if (!integrityFailedMap) {
            kony.sync.showTransactionError(errorCallBack, "Checking integrity");
        } else {
            kony.sync.verifyAndCallClosure(errorCallBack, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
};
kony.sync.checkIntegrityinTransaction_old = function(tx, rMap) {
    sync.log.trace("Entering kony.sync.checkIntegrityinTransaction ");
    var integrityFailedMap = {};
    if (!kony.sync.enableORMValidations) {
        return true;
    }
    for (var obj in rMap) {
        for (var key in rMap[obj]) {
            if (kony.sync.isNull(rMap[obj][key].targetAttributeValue)) {
                continue;
            }
            if (integrityFailedMap[rMap[obj][key].foreignKeyAttribute] === false) {
                continue;
            }
            if (rMap[obj][key].targetAttributeValue === "") {
                rMap[obj][key].targetAttributeValue = "''";
            }
            var sql = "select * from " + obj + " where " + rMap[obj][key].sourceAttribute[0] + " = " + rMap[obj][key].targetAttributeValue[0] + "";
            var resultSet = kony.sync.executeSql(tx, sql, null);
            if (resultSet !== false) {
                if (resultSet.rows.length === 0) {
                    sync.log.error("Referential Integrity Check Failed", kony.sync.getErrorTable(kony.sync.errorCodeReferentialIntegrity, kony.sync.getReferetialIntegrityerrMessg(obj, rMap[obj][key].sourceAttribute, rMap[obj][key].targetAttributeValue)));
                    if (kony.sync.isNullOrUndefined(integrityFailedMap[rMap[obj][key].foreignKeyAttribute])) {
                        integrityFailedMap[rMap[obj][key].foreignKeyAttribute] = kony.sync.getReferetialIntegrityerrMessg(obj, rMap[obj][key].sourceAttribute, rMap[obj][key].targetAttributeValue);
                    } else {
                        integrityFailedMap[rMap[obj][key].foreignKeyAttribute] = integrityFailedMap[rMap[obj][key].foreignKeyAttribute] + kony.sync.getReferetialIntegrityerrMessg(obj, rMap[obj][key].sourceAttribute, rMap[obj][key].targetAttributeValue);
                    }
                } else {
                    integrityFailedMap[rMap[obj][key].foreignKeyAttribute] = false;
                }
            } else {
                return false;
            }
        }
    }
    var logicalBreak = false;
    for (var key in integrityFailedMap) {
        if (integrityFailedMap[key] !== false) {
            logicalBreak = true;
        }
    }
    return logicalBreak === false ? true : integrityFailedMap;
};
kony.sync.checkIntegrityinTransaction = function(tx, rMap) {
    sync.log.trace("Entering kony.sync.checkIntegrityinTransactionFK ");
    var integrityFailedMap = {};
    if (!kony.sync.enableORMValidations) {
        return true;
    }
    for (var obj in rMap) {
        for (var key = 0; key < rMap[obj].length; key++) {
            var relationShipMap = rMap[obj][key];
            var whereClause = " where ";
            for (var i = 0; i < relationShipMap.targetAttributeValue.length; i++) {
                if (kony.sync.isNull(relationShipMap.targetAttributeValue[i])) {
                    continue;
                }
                if (integrityFailedMap[relationShipMap.foreignKeyAttribute[i]] === false) {
                    continue;
                }
                if (relationShipMap.targetAttributeValue[i] === "") {
                    relationShipMap.targetAttributeValue[i] = "''";
                }
                whereClause = whereClause + relationShipMap.sourceAttribute[i] + " = " + relationShipMap.targetAttributeValue[i];
                if (i != relationShipMap.targetAttributeValue.length - 1) {
                    whereClause = whereClause + " AND ";
                }
            };
            var sql = "select * from " + obj + whereClause + "";
            var resultSet = kony.sync.executeSql(tx, sql, null);
            if (resultSet !== false) {
                if (resultSet.rows.length === 0) {
                    sync.log.error("Referential Integrity Check Failed", kony.sync.getErrorTable(kony.sync.errorCodeReferentialIntegrity, kony.sync.getReferetialIntegrityerrMessg(obj, relationShipMap.sourceAttribute, relationShipMap.targetAttributeValue)));
                    integrityFailedMap[relationShipMap.foreignKeyAttribute[0]] = kony.sync.getReferetialIntegrityerrMessg(obj, relationShipMap.sourceAttribute, relationShipMap.targetAttributeValue);
                } else {
                    integrityFailedMap[relationShipMap.foreignKeyAttribute[0]] = false;
                }
            } else {
                return false;
            }
        }
    }
    var logicalBreak = false;
    for (var key in integrityFailedMap) {
        if (integrityFailedMap[key] !== false) {
            logicalBreak = true;
        }
    }
    return logicalBreak === false ? true : integrityFailedMap;
};
kony.sync.convertOrderByMapToValuesTable = function(orderByMap) {
    sync.log.trace("Entering kony.sync.convertOrderByMapToValuesTable ");
    var valuesTable = {};
    for (var i in orderByMap) {
        valuesTable[orderByMap[i].key] = orderByMap[i].key;
    }
    return valuesTable;
};
kony.sync.convertToValuesTableOrderByMap = function(orderByMap, valuesTable) {
    sync.log.trace("Entering kony.sync.convertToValuesTableOrderByMap ");
    var orderByMapFiltered = [];
    var j = 0;
    for (var i in orderByMap) {
        if (valuesTable[orderByMap[i].key] === orderByMap[i].key) {
            orderByMapFiltered[j] = orderByMap[i];
            j++;
        }
    }
    return orderByMapFiltered;
};
kony.sync.isValidFunctionType = function(closure) {
    sync.log.trace("Entering kony.sync.isValidFunctionType ");
    return kony.type(closure) === "function";
};
kony.sync.initializeScopeSettings = function(tx) {
    sync.log.trace("Entering kony.sync.initializeScopeSettings ");
    var query = kony.sync.qb_createQuery();
    var json = "{\"scopeSettings\" : {}}";
    kony.sync.qb_set(query, {
        "id": 1,
        "action": "",
        "details": json
    });
    kony.sync.qb_insert(query, "konysyncDIAGNOSTICS");
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
kony.sync.updateScopeSettings = function(tx, scopename) {
    sync.log.trace("Entering kony.sync.updateScopeSettings ");
    var resultset = kony.sync.executeSql(tx, "select * from konysyncDIAGNOSTICS");
    if (resultset === false) {
        return false;
    }
    var settings = "";
    var rowItem = null;
    if (resultset.rows.length > 0) {
        rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        settings = rowItem.details;
    } else {
        sync.log.error("Updation of Scope Settings Failed");
    }
    var table = JSON.parse(settings);
    if (kony.sync.isNullOrUndefined(table.scopeSettings[scopename])) {
        table.scopeSettings[scopename] = {
            "initialize": true
        };
    } else if (kony.sync.isNullOrUndefined(table.scopeSettings[scopename].initialize)) {
        table.scopeSettings[scopename].initialize = true;
    }
    var query = kony.sync.qb_createQuery();
    var json = JSON.stringify(table);
    kony.sync.qb_set(query, {
        "details": json
    });
    kony.sync.qb_update(query, "konysyncDIAGNOSTICS");
    kony.sync.qb_where(query, [{
        "key": "id",
        "value": 1
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
kony.sync.getScopeSettings = function(scopename, dbname, callback, errorcallback) {
    sync.log.trace("Entering kony.sync.getScopeSettings ");
    var settings = null;
    var isError = false;

    function getSettingsTransaction(tx) {
        sync.log.trace("Entering getSettingsTransaction");
        var resultset = kony.sync.executeSql(tx, "select * from konysyncDIAGNOSTICS");
        var set = "";
        var rowItem = null;
        if (resultset !== false) {
            if (resultset.rows.length > 0) {
                rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
                set = rowItem.details;
            } else {
                sync.log.error("Updation of Scope Settings Failed");
            }
        } else {
            sync.log.error("Updation of Scope Settings Failed");
            isError = true;
            return;
        }
        var table = JSON.parse(set);
        if (!kony.sync.isNullOrUndefined(table.scopeSettings[scopename])) {
            settings = table.scopeSettings[scopename];
        }
    }

    function getSettingsCompleted() {
        sync.log.trace("Entering getSettingsCompleted");
        callback(settings);
    }

    function getSettingsFailed() {
        sync.log.trace("Entering getSettingsFailed");
        kony.sync.callTransactionError(isError, errorcallback);
    }
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, getSettingsFailed, "getScopeSettings");
    if (dbconnection !== null) {
        kony.sync.startTransaction(dbconnection, getSettingsTransaction, getSettingsCompleted, getSettingsFailed);
    }
};
kony.sync.isScopeInitialized = function(scopename, dbname, callback) {
    sync.log.trace("Entering kony.sync.isScopeInitialized ");

    function localcallback(settings) {
        sync.log.trace("Entering localcallback");
        if (settings !== null) {
            if (settings.initialize === true) {
                callback(true);
            } else {
                callback(false);
            }
        } else {
            callback(false);
        }
    }

    function errorCallback(res) {
        sync.log.trace("Entering errorCallback");
        kony.sync.onDownloadCompletion(true, res);
    }
    var settings = kony.sync.getScopeSettings(scopename, dbname, localcallback, errorCallback);
};
kony.sync.setPragmaSize = function(tx) {
    sync.log.trace("Entering kony.sync.setPragmaSize ");
    return kony.sync.executeSql(tx, "PRAGMA CACHE_SIZE=50");
};
/*
The same function is present below with same  functionalities and more validations for camel cases
kony.sync.isValidJSTable = function(inputTable) {
	if (kony.sync.isNullOrUndefined(inputTable)) {
		return false;
	}
	return kony.type(inputTable) === "object" || kony.type(inputTable) === "Object" || kony.type(inputTable) === "Array";
};
*/
kony.sync.isNull = function(val) {
    sync.log.trace("Entering kony.sync.isNull ");
    if (kony.sync.isNullOrUndefined(val)) {
        return true;
    }
    val = val + "";
    return (kony.string.equalsIgnoreCase(val, "null"));
};
//returns whether a error upload policy is continueonerror or not
kony.sync.isUploadErrorPolicyCOE = function(currentScope) {
    sync.log.trace("Entering kony.sync.isUploadErrorPolicyCOE ");
    var scopename = currentScope.ScopeName;
    //Added these redundant checks to check for OTA or Persistent Sync. As proper checks 
    //have not made in earlier implementation, we are doing this to avoid any backward compatibility issues.
    if (currentScope[kony.sync.syncStrategy] === kony.sync.syncStrategy_OTA) {
        if (currentScope[kony.sync.syncStrategy] === kony.sync.syncStrategy_OTA && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks]) && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename]) && kony.string.equalsIgnoreCase(kony.sync.getString(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename][kony.sync.sessionTaskUploadErrorPolicy]), kony.sync.sessionTaskUploadErrorPolicyCOE)) {
            return true;
        }
        return false;
    } else {
        if (currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks]) && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename]) && kony.string.equalsIgnoreCase(kony.sync.getString(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename][kony.sync.sessionTaskUploadErrorPolicy]), kony.sync.sessionTaskUploadErrorPolicyCOE)) {
            return true;
        }
        return false;
    }
};
kony.sync.isEmptyString = function(val) {
    sync.log.trace("Entering kony.sync.isEmptyString ");
    if (!kony.sync.isNullOrUndefined(val) && typeof(val) === "string" && val.trim() === "") {
        return true;
    } else {
        return false;
    }
};
kony.sync.isValidNumberType = function(val) {
    sync.log.trace("Entering kony.sync.isValidNumberType ");
    if (kony.string.equalsIgnoreCase(kony.type(val), "number")) {
        return true;
    } else if (kony.string.equalsIgnoreCase(kony.type(val), "string") && null !== kony.sync.tonumber(val)) {
        return true;
    } else {
        return false;
    }
};
kony.sync.isValidBooleanType = function(val) {
    sync.log.trace("Entering kony.sync.isValidBooleanType ");
    if (kony.string.equalsIgnoreCase(kony.type(val), "boolean")) {
        return true;
    } else if (kony.string.equalsIgnoreCase(kony.type(val), "string")) {
        if (kony.string.equalsIgnoreCase(val, "false") || kony.string.equalsIgnoreCase(val, "true") || kony.string.equalsIgnoreCase(val, "0") || kony.string.equalsIgnoreCase(val, "1")) {
            return true;
        }
    } else if (kony.string.equalsIgnoreCase(kony.type(val), "number")) {
        if (val === 0 || val === 1) {
            return true;
        }
    }
    return false;
};
kony.sync.isMaliciousType = function(val) {
    sync.log.trace("Entering kony.sync.isMaliciousType ");
    if (kony.sync.isValidNumberType(val) && isNaN(val)) {
        return "NaN";
    }
    if (val === Number.POSITIVE_INFINITY || val === Number.NEGATIVE_INFINITY) {
        return "infinity";
    }
    return false;
};
kony.sync.genMaliciousTypeCheck = function(obj, errorcallback) {
    sync.log.trace("Entering kony.sync.genMaliciousTypeCheck ");
    if (!kony.sync.enableORMValidations) {
        return false;
    }
    var errorMessage = null;
    var maliciousType = null;
    if (kony.string.equalsIgnoreCase(kony.type(obj), "object") || kony.string.equalsIgnoreCase(kony.type(obj), "table")) {
        for (var i in obj) {
            maliciousType = kony.sync.isMaliciousType(obj[i]);
            if (maliciousType !== false) {
                errorMessage = kony.sync.getErrorMessage(kony.sync.errorCodeMaliciousType, i, maliciousType);
                sync.log.error("Malicious object detected", kony.sync.getErrorTable(kony.sync.errorCodeMaliciousType, errorMessage));
                kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeMaliciousType, errorMessage));
                return true;
            } else {
                if (obj[i] === undefined) {
                    obj[i] = "null";
                }
            }
        }
    } else {
        maliciousType = kony.sync.isMaliciousType(obj);
        if (maliciousType !== false) {
            errorMessage = kony.sync.getErrorMessage(kony.sync.errorCodeMaliciousType, "", maliciousType);
            sync.log.error("Malicious object detected", kony.sync.getErrorTable(kony.sync.errorCodeMaliciousType, errorMessage));
            kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeMaliciousType, errorMessage));
            return true;
        }
    }
    return false;
};
kony.sync.getBoolean = function(val) {
    sync.log.trace("Entering kony.sync.getBoolean ");
    if (kony.sync.isValidBooleanType(val)) {
        val = val + "";
        if (kony.string.equalsIgnoreCase(val, "true") || kony.string.equalsIgnoreCase(val, "1") || val === 1) {
            return true;
        } else {
            return false;
        }
    } else {
        return val;
    }
};
kony.sync.getString = function(val) {
    sync.log.trace("Entering kony.sync.getString ");
    if (kony.sync.isNull(val)) {
        return "";
    }
    return val.toString();
};
kony.sync.getUploadStatus = function(markForUpload) {
    sync.log.trace("Entering kony.sync.getUploadStatus ");
    if (markForUpload === false || markForUpload === "false") {
        return false;
    } else {
        return true;
    }
};
kony.sync.getDBName = function() {
    sync.log.trace("Entering kony.sync.getDBName ");
    var syncscopes = konysyncClientSyncConfig.ArrayOfSyncScope;
    if (syncscopes === null) {
        return null;
    }
    for (var i = 0; i < syncscopes.length; i++) {
        var scope = syncscopes[i];
        //This logic needs to be changed when we have separate DB for each scope
        if (scope[kony.sync.scopeDataSource] !== null) {
            return scope[kony.sync.scopeDataSource];
        }
    }
    return null;
};
kony.sync.mergeTable = function(toObj, frmObj) {
    sync.log.trace("Entering kony.sync.mergeTable ");
    if (!kony.sync.isValidJSTable(frmObj)) {
        return toObj;
    }
    if (!kony.sync.isValidJSTable(toObj)) {
        return frmObj;
    }
    for (var k in frmObj) {
        toObj[k] = frmObj[k];
    }
    return toObj;
};
kony.sync.pkNotFoundErrCallback = function(errorcallback, objName) {
    sync.log.trace("Entering kony.sync.pkNotFoundErrCallback ");
    sync.log.error("No data with specified primary key found in SyncObject " + objName + ".");
    errorcallback(kony.sync.getErrorTable(kony.sync.errorCodeNoDataWithPrimaryKey, kony.sync.getErrorMessage(kony.sync.errorCodeNoDataWithPrimaryKey, objName)));
};
kony.sync.skyEventObserver = function(event, args, eventFinishCallback, errorcallback, isCascade) {
    sync.log.trace("Entering kony.sync.skyEventObserver ");
    if (event !== "START") {
        if (event === "ERROR") {
            if (!kony.sync.isNull(args)) {
                if (isCascade) {
                    sky.rollbackTransaction(kony.sky.skyEmptyFunction);
                }
                var errorCode = args.ERRORCODE;
                var errorMsg = args.ERRORDESC;
                kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(errorCode, errorMsg));
            }
        }
        if (event === "FINISH") {
            kony.sync.verifyAndCallClosure(eventFinishCallback, args);
        }
    }
};
kony.sync.removeCascadeHelper_old = function(tx, srcAttribute, targetAttribute, tbname, wcs, targetObjectRemoveCascade, targetObjectName, isCascade, errorcallback, markForUpload, pkRecord, isLocal) {
    sync.log.trace("Entering kony.sync.removeCascadeHelper_old ");
    var wcsCascade = null;
    if (pkRecord === null) {
        var sqlTarget = "select " + srcAttribute + " from " + tbname + wcs;
        var resultSet = kony.sync.executeSql(tx, sqlTarget, null);
        if (resultSet === false) {
            return false;
        }
        var num_records = resultSet.rows.length;
        if (num_records === 0) {
            return true;
        }
        if (isCascade) {
            sync.log.debug("No of Records to be deleted in " + targetObjectName + " for cascade delete=" + num_records);
        }
        for (var i = 0; i <= num_records - 1; i++) {
            var record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            wcsCascade = " where " + targetAttribute + " = '" + record[srcAttribute] + "'";
            if (targetObjectRemoveCascade(tx, wcsCascade, errorcallback, markForUpload, isCascade, tbname, isLocal) === false) {
                return false;
            }
        }
    } else {
        wcsCascade = " where " + targetAttribute + " = '" + pkRecord[srcAttribute] + "'";
        return targetObjectRemoveCascade(tx, wcsCascade, errorcallback, markForUpload, isCascade, tbname, isLocal);
    }
    return true;
};
kony.sync.removeCascadeHelper = function(tx, srcAttributes, targetAttributes, tbname, wcs, targetObjectRemoveCascade, targetObjectName, isCascade, errorcallback, markForUpload, pkRecord, isLocal) {
    sync.log.trace("Entering kony.sync.removeCascadeHelper ");
    var wcsCascade = null;
    if (pkRecord === null) {
        var sqlTarget = "select ";
        var sourceAttribute = "";
        for (var i = 0; i < srcAttributes.length; i++) {
            sourceAttribute = sourceAttribute + srcAttributes[i];
            if (i != srcAttributes.length - 1) {
                sourceAttribute = sourceAttribute + ","
            }
        };
        sqlTarget = sqlTarget + sourceAttribute + " from " + tbname + wcs;
        var resultSet = kony.sync.executeSql(tx, sqlTarget, null);
        if (resultSet === false) {
            return false;
        }
        var num_records = resultSet.rows.length;
        if (num_records === 0) {
            return true;
        }
        if (isCascade) {
            sync.log.debug("No of Records to be deleted in " + targetObjectName + " for cascade delete=" + num_records);
        }
        wcsCascade = " where ";
        for (var i = 0; i <= num_records - 1; i++) {
            var record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            var srcAttributesLen = srcAttributes.length;
            for (var j = 0; j < srcAttributesLen; ++j) {
                wcsCascade = wcsCascade + targetAttributes[j] + " = '" + record[srcAttributes[j]] + "'"
                if (j != srcAttributesLen - 1) {
                    wcsCascade = wcsCascade + " and "
                }
            }
            if (i != num_records - 1) {
                wcsCascade = wcsCascade + " or ";
            }
        }
        if (targetObjectRemoveCascade(tx, wcsCascade, errorcallback, markForUpload, isCascade, tbname, isLocal) === false) {
            return false;
        }
    } else {
        wcsCascade = " where ";
        var srcAttributesLen = srcAttributes.length;
        for (var j = 0; j < srcAttributesLen; j++) {
            wcsCascade = wcsCascade + targetAttributes[j] + " = '" + pkRecord[srcAttributes[j]] + "'"
            if (j != srcAttributesLen - 1) {
                wcsCascade = wcsCascade + " and "
            }
        }
        return targetObjectRemoveCascade(tx, wcsCascade, errorcallback, markForUpload, isCascade, tbname, isLocal);
    }
    return true;
};
kony.sync.rollbackTransaction = function(tx) {
    sync.log.trace("Entering kony.sync.rollbackTransaction ");

    function dummyError() {
        sync.log.trace("Entering dummyError");
        //rollback the transaction
        return true;
    }
    //dummy statement
    kony.db.executeSql(tx, "dummy", null, dummyError);
};
//Wrapper for kony.db.executeSql
kony.sync.executeSql = function(tx, sql, params, errorCallback, rollback, opMsg) {
    // method to get table name from sql query
    function getObjectNameAndPKColName(sqlStmt) {
        var insertIgnoreCommand = "insert or ignore into";
        var deleteFromCommand = "delete from";
        var insertCommand = "insert into";
        var deleteCommand = "delete";
        var updateCommand = "update";
        var originalTable = "_original";
        var historyTable = "_history";
        var pkColumn = "";
        var tableName = "";
        var retVal = [];
        var words = sqlStmt.split(' ');
        if (sqlStmt.startsWith(insertIgnoreCommand)) {
            tableName = words[4];
        } else if (sqlStmt.startsWith(insertCommand) || sqlStmt.startsWith(deleteFromCommand)) {
            tableName = words[2];
        } else if (sqlStmt.startsWith(updateCommand)) {
            tableName = words[1];
            pkColumn = words[3];
        } else if (sqlStmt.startsWith(deleteCommand)) {
            tableName = words[1];
        }
        if (tableName.endsWith(originalTable)) {
            tableName = tableName.slice(0, tableName.lastIndexOf(originalTable));
        }
        retVal.push(tableName);
        retVal.push(pkColumn.replace(/\'/g, '').replace(/\"/g, '').replace(/=/g, '').replace(/\?/g, '').trim());
        return retVal;
    }
    // method to get reconciliation error if occured for update
    function getReconcilitaionError(sqlStatement, errorResult) {
        var sqlStmt = sqlStatement.toLowerCase().replace(/\s+/g, ' ').trim();
        if (sqlStmt.startsWith("update") && errorResult.message.toLowerCase().indexOf("unique constraint failed") >= 0) {
            var tabAndPk = getObjectNameAndPKColName(sqlStmt);
            return {
                "tableName": (tabAndPk[0]).toUpperCase(),
                "pkColumn": (tabAndPk[1]).toUpperCase(),
                "createdPK": params[1],
                "existingPK": params[0],
                "recievedPK": params[0],
            };
        } else {
            return null;
        }
    }
    sync.log.trace("Entering kony.sync.executeSql ");
    kony.sync.errorObject = null;
    if (!kony.sync.isNullOrUndefined(opMsg)) {
        sync.log.debug(opMsg);
    }
    sync.log.debug("SQL Query : ", sql);
    sync.log.debug("SQL Params : ", params);
    var result = kony.db.executeSql(tx, sql, params, localErrorCallback);
    if (result === null) {
        sync.log.error("Query execution failed: " + sql + " with params : ", params);
        return false;
    } else {
        sync.log.debug("Query execution success: " + sql + " with params : ", params);
        sync.log.debug("Result of query execution is: ", result);
        return result;
    }

    function localErrorCallback(tx, res) {
        var errorInfo = {};
        errorInfo[kony.sync.errorInfoTransactionID] = tx;
        errorInfo[kony.sync.errorInfoDatabaseError] = res;
        var recocileError = getReconcilitaionError(sql, res);
        if (recocileError) {
            errorInfo["duplicatePKError"] = recocileError;
            kony.sync.reconciliationErrorObject.push(recocileError);
        }
        sync.log.error("SQLite Error : ", res);
        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeSQLStatement, kony.sync.getErrorMessage(kony.sync.errorCodeSQLStatement), errorInfo);
        if (rollback === false) {
            return false;
        } else {
            return true;
        }
    }
};
kony.sync.callTransactionError = function(isError, errorcallback) {
    sync.log.trace("Entering kony.sync.callTransactionError ");
    kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getTransactionError(isError));
};
kony.sync.validateWhereClause = function(wcs) {
    sync.log.trace("Entering kony.sync.validateWhereClause ");
    if (!kony.sync.enableORMValidations) {
        return wcs;
    }
    if (kony.sync.isNull(wcs)) {
        return "";
    }
    wcs = kony.sync.getString(wcs);
    wcs = kony.string.trim(wcs);
    var twcs = kony.string.lower(wcs);
    if (twcs !== "") {
        // check if the where clause starts with a reserved keyword, else append "where" keyword
        if (!kony.sync.startsWithKeyword(twcs)) {
            wcs = " where " + wcs;
        }
    }
    return wcs;
};
//check whether the given data contains the key 
kony.sync.contains = function(data, key) {
    sync.log.trace("Entering kony.sync.contains ");
    //currently implementing for array only
    for (var i = 0; i < data.length; i++) {
        if (data[i] === key) {
            return true;
        }
    }
    return false;
};
kony.sync.createHash = function(hash, plaintext) {
    sync.log.trace("Entering kony.sync.createHash ");
    return kony.crypto.createHash(hash, plaintext);
};
kony.sync.getChunkDownloadURL = function() {
    sync.log.trace("Entering kony.sync.getChunkDownloadURL ");
    var server = kony.sync.getServerURL();
    return server + "downloadchunk";
};
kony.sync.getUploadBatchSize = function() {
    sync.log.trace("Entering kony.sync.getUploadBatchSize ");
    if (kony.sync.isValidNumberType(kony.sync.currentSyncConfigParams.uploadbatchsize)) {
        return kony.sync.tonumber(kony.sync.currentSyncConfigParams.uploadbatchsize);
    }
    return 50; //default batch size
};
kony.sync.isValidJSTable = function(inputTable) {
    if (kony.sync.isNullOrUndefined(inputTable)) {
        return false;
    }
    if (kony.type(inputTable) === "object" || kony.type(inputTable) === "Object" || kony.type(inputTable) === "Array" || kony.type(inputTable) === "array") {
        return true;
    } else {
        return false;
    }
};
kony.sync.deleteMapKey = function(map, key) {
    sync.log.trace("Entering kony.sync.deleteMapKey ");
    if (!kony.sync.isNull(map) && !kony.sync.isNull(key)) {
        delete map[key];
    }
};
kony.sync.getServerDetailsHostName = function(response) {
    sync.log.trace("Entering kony.sync.getServerDetailsHostName ");
    if (!kony.sync.isNullOrUndefined(response) && !kony.sync.isNullOrUndefined(response.d) && !kony.sync.isNullOrUndefined(response.d.server)) {
        return response.d.server.hostName;
    } else {
        return null;
    }
};
kony.sync.getServerDetailsIpAddress = function(response) {
    sync.log.trace("Entering kony.sync.getServerDetailsIpAddress ");
    if (!kony.sync.isNullOrUndefined(response) && !kony.sync.isNullOrUndefined(response.d) && !kony.sync.isNullOrUndefined(response.d.server)) {
        return response.d.server.ipAddress;
    } else {
        return null;
    }
};
kony.sync.addServerDetails = function(returnParams, serverResponse) {
    sync.log.trace("Entering kony.sync.addServerDetails ");
    if (!kony.sync.isNullOrUndefined(returnParams)) {
        returnParams[kony.sync.serverDetails] = {};
        returnParams[kony.sync.serverDetails][kony.sync.hostName] = kony.sync.getServerDetailsHostName(serverResponse);
        returnParams[kony.sync.serverDetails][kony.sync.ipAddress] = kony.sync.getServerDetailsIpAddress(serverResponse);
    }
};
//This function gets connection
kony.sync.getConnectionOnly = function(dbName, displayName, errorCallback, moduleName) {
    sync.log.trace("Entering kony.sync.getConnectionOnly ");
    var estimatedDBSize = 5 * 1024 * 1024;
    var connection = null;
    var version = "1.0";
    var exceptionObject = null;

    function makeEncryptedConnection() {
        sync.log.trace("Entering makeEncryptedConnection");
        if (kony.sync.deviceDBEncryptionKey === null) {
            connection = kony.db.openDatabaseSync(dbName, version, displayName, estimatedDBSize);
        } else {
            sync.log.info("Opening encrypted connection", kony.sync.deviceDBEncryptionKey);
            connection = kony.db.openDatabaseSync(dbName, version, displayName, estimatedDBSize, kony.sync.deviceDBEncryptionKey);
        }
    }
    try {
        connection = kony.db.openDatabaseSync(dbName, version, displayName, estimatedDBSize);
    } catch (e) {
        connection = null;
        exceptionObject = e;
    }
    if (connection === null) {
        if (kony.sync.isNullOrUndefined(moduleName)) {
            moduleName = "";
        } else {
            moduleName += ": ";
        }
        sync.log.fatal(moduleName + "Error in getting connection");
        kony.sync.verifyAndCallClosure(errorCallback, kony.sync.getErrorTable(kony.sync.errorCodeDbConnection, kony.sync.getErrorMessage(kony.sync.errorCodeDbConnection), exceptionObject));
    }
    return connection;
};
kony.sync.createDBEncryptionKey = function(passPhrase) {
    sync.log.trace("Entering kony.sync.createDBEncryptionKey ");
    if (kony.sync.deviceDBEncryptionKey === null && passPhrase !== null && passPhrase !== undefined && !kony.sync.isEmptyString(passPhrase)) {}
};
kony.sync.isValidFunctionType = function(closure) {
    sync.log.trace("Entering kony.sync.isValidFunctionType ");
    return kony.type(closure) === "function";
};
kony.sync.getTransactionError = function(isError) {
    sync.log.trace("Entering kony.sync.getTransactionError ");
    if (!isError) {
        sync.log.error("Transaction error occurred : ", kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        return kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null);
    } else {
        sync.log.error("Statement error occurred : ", kony.sync.errorObject);
        return kony.sync.errorObject;
    }
};
kony.sync.isNullOrUndefined = function(val) {
    if (val === null || val === undefined) {
        return true;
    } else {
        return false;
    }
};
kony.sync.formOrderByClause = function(tablename, map) {
    sync.log.trace("Entering kony.sync.formOrderByClause function");
    if (map !== null && map !== undefined) {
        var scope = kony.sync.scopes[kony.sync.scopes.syncTableScopeDic[tablename]];
        var columns = scope.syncTableDic[tablename].ColumnsDic;
        for (var k = 0; k < map.length; k++) {
            var v = map[k];
            if (!kony.sync.isValidJSTable(v)) {
                sync.log.warn("Ignoring the orderby entry " + v + " as it is not a valid js object");
                delete map[k];
                continue;
            }
            if (kony.sync.isNull(columns[v.key])) {
                sync.log.warn("Ignoring the orderby entry " + v.key + " for the SyncObject " + tablename + ". " + v.key + " is not defined as an attribute in SyncConfiguration.");
                delete map[k];
            }
        }
        //var valuestable = kony.sync.convertOrderByMapToValuesTable(map);
        //return kony.sync.convertToValuesTableOrderByMap(map,valuestable);
        return map;
    }
};
//function to check if where clause starts with a SQLite reserved keyword
kony.sync.startsWithKeyword = function(wcs) {
    sync.log.trace("Entering kony.sync.startsWithKeyword ");
    var keywordTable = ["where ", "limit ", "group ", "order ", "join "];
    for (var i = 0; i < keywordTable.length; i++) {
        if (kony.string.startsWith(wcs, keywordTable[i])) {
            return true;
        }
    }
    return false;
};
kony.sync.getChannelName = function() {
    sync.log.trace("Entering kony.sync.getChannelName ");
    var returnVal = "";
    return returnVal;
};
kony.sync.getPlatformName = function() {
    sync.log.trace("Entering kony.sync.getPlatformName ");
    var returnVal = "";
    return returnVal;
};
kony.sync.getRelationshipsForTable = function(tablename) {
    sync.log.trace("Entering kony.sync.getRelationshipsForTable for table " + tablename);
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    var scope = kony.sync.scopes[scopename];
    var relationShips = scope.syncTableDic[tablename].Relationships;
    return relationShips;
};
kony.sync.getChildRecords = function(tablename, valuesTable) {
    sync.log.trace("Entering kony.sync.getChildRecords for table " + tablename);
    var childRecords = [];
    var relationShips = kony.sync.getRelationshipsForTable(tablename);
    if (!kony.sync.isNullOrUndefined(relationShips) && relationShips.hasOwnProperty(kony.sync.oneToMany)) {
        //remove the child record from the values and add it to child records.
        for (var j = 0; j < relationShips[kony.sync.oneToMany].length; j++) {
            var childRecord = {};
            var relationshipTargetObject = relationShips[kony.sync.oneToMany][j][kony.sync.targetObject];
            //if there exists relationship target object, and values has child object which is not a null value.
            if (!kony.sync.isNullOrUndefined(relationshipTargetObject) && valuesTable.hasOwnProperty(relationshipTargetObject) && !kony.sync.isNullOrUndefined(valuesTable[relationshipTargetObject])) {
                childRecord[relationshipTargetObject] = valuesTable[relationshipTargetObject];
                childRecords.push(childRecord);
                delete valuesTable[relationshipTargetObject];
            }
        }
    }
    return childRecords;
};
kony.sync.getParentRelationshipAttributes = function(childTable, parentTable) {
    sync.log.trace("Enterting kony.sync.getParentRelationshipAttributes for child " + childTable + " and parent " + parentTable);
    if (childTable && parentTable) {
        var scopename = kony.sync.scopes.syncTableScopeDic[childTable];
        var scope = kony.sync.scopes[scopename];
        var relationShipMap = scope.syncTableDic[parentTable + kony.sync.parentRelationshipMap];
        //if there exists relationship and there are relationship attributes, return them. else return null
        if (!kony.sync.isNullOrUndefined(relationShipMap) && relationShipMap.hasOwnProperty(childTable)) {
            return relationShipMap[childTable];
        }
    }
    return null;
};
kony.sync.getPkTableFromJSON = function(valuesTable, tableName) {
    sync.log.trace("Entering kony.sync.getPkTableFromJSON for valuesTbale " + JSON.stringify(valuesTable) + " and table " + tableName);
    var pkTable = {};
    if (valuesTable && tableName) {
        var scopename = kony.sync.scopes.syncTableScopeDic[tableName];
        var scope = kony.sync.scopes[scopename];
        var pkColumns = scope.syncTableDic[tableName].Pk_Columns;
        for (var pkCount = 0; pkCount < pkColumns.length; pkCount++) {
            if (valuesTable.hasOwnProperty(pkColumns[pkCount])) {
                pkTable[pkColumns[pkCount]] = valuesTable[pkColumns[pkCount]];
                delete valuesTable[pkColumns[pkCount]];
            } else {
                //pkColumn field not found. error.
                sync.log.error("pkcolumn field " + pkColumns[pkCount] + " not found in " + JSON.stringify(valuesTable));
                return false;
            }
        }
    }
    return pkTable;
};
kony.sync.queryTable = function(tx, tablename, selectClause, whereClause, limitOffset) {
    sync.log.trace("Entering kony.sync.queryTable for table " + tablename + " and select clause " + JSON.stringify(selectClause) + " with where clause " + JSON.stringify(whereClause));
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, selectClause);
    kony.sync.qb_from(query, tablename);
    kony.sync.qb_where(query, whereClause);
    if (!kony.sync.isNullOrUndefined(limitOffset)) {
        kony.sync.qb_limitOffset(query, limitOffset, kony.sync.blobManager.ONDEMAND_FETCH_OFFSET);
    }
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    sync.log.trace("Executing query ", query, " with params ", JSON.stringify(params));
    var result_set = kony.sync.executeSql(tx, sql, params);
    return result_set;
};
kony.sync.isEmpty = function(obj) {
    sync.log.trace("Entering kony.sync.isEmpty ");
    // null and undefined are "empty"
    if (obj == null) return true;
    // Assume if it has a length property with a non-zero value
    // that that property is correct.
    if (obj.length > 0) return false;
    if (obj.length === 0) return true;
    for (var key in obj) {
        if (hasOwnProperty.call(obj, key)) return false;
    }
    return true;
};
kony.sync.getSyncTracking = function(options) {
    sync.log.trace("Entering kony.sync.getSyncTracking ");
    var synctracking = true;
    if (!kony.sync.isNullOrUndefined(options) && (typeof(options) == "object")) {
        if (!kony.sync.isNullOrUndefined(options[kony.sync.tracking])) {
            synctracking = options[kony.sync.tracking]
        }
    }
    return synctracking;
}
kony.sync.getInsertNullForFieldsMissingInPayload = function() {
        sync.log.trace("Entering kony.sync.getInsertNullForFieldsMissingInPayload ");
        if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams) && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.insertNullForFieldsMissingInPayload) && (typeof(kony.sync.currentSyncConfigParams.insertNullForFieldsMissingInPayload) === "boolean")) {
            return kony.sync.currentSyncConfigParams.insertNullForFieldsMissingInPayload;
        }
        //by default, null values should be inserted
        return true;
    }
    //  **************** End KonySyncHelper.js*******************
    //  **************** Start KonySyncInit.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
//Initializes the DB with Generated Scope
sync.init = function(on_sync_init_success, on_sync_init_error) {
    sync.log.trace("Entering sync.init ");
    if (kony.sync.isValidJSTable(on_sync_init_success) === true) {
        //new style, user called as sync.init(config)
        //upload binary listener..
        if (!kony.sync.isNullOrUndefined(on_sync_init_success[kony.sync.onBinaryUploadFunction]) && kony.sync.isValidFunctionType(on_sync_init_success[kony.sync.onBinaryUploadFunction])) {
            sync.log.trace("sync.init - registering upload binary listener..");
            kony.sync.onBinaryUpload = on_sync_init_success[kony.sync.onBinaryUploadFunction];
        }
        //download binary listener.
        if (!kony.sync.isNullOrUndefined(on_sync_init_success[kony.sync.onBinaryDownloadFunction]) && kony.sync.isValidFunctionType(on_sync_init_success[kony.sync.onBinaryDownloadFunction])) {
            sync.log.trace("sync.init - registering download binary listener..");
            kony.sync.onBinaryDownload = on_sync_init_success[kony.sync.onBinaryDownloadFunction];
        }
        on_sync_init_error = on_sync_init_success[kony.sync.onSyncInitErrorParam];
        kony.sync.createDBEncryptionKey(on_sync_init_success[kony.sync.deviceDBEncryptionKeyParam]);
        on_sync_init_success = on_sync_init_success[kony.sync.onSyncInitSuccessParam];
    }
    // Create the database from xml. It also contains the provisioning commands
    var syncscopes = konysyncClientSyncConfig.ArrayOfSyncScope;
    kony.sync.syncConfigurationDBName = konysyncClientSyncConfig.AppID;
    var isError = false;
    var dbExists = false;

    function loadDatabase() {
        sync.log.trace("Entering loadDatabase");
        var createDB = false;
        syncscopes.syncTableScopeDic = {};
        syncscopes.syncScopeBlobInfoMap = {};
        syncscopes.syncToDeviceMap = {};
        syncscopes.syncScopeRelationAttributesMap = {};
        var currentscope = null;
        var currenttemptable = null;
        sync.log.info("loading DB");

        function dbValidationCompleted() {
            sync.log.trace("Entering dbValidationCompleted");
            loadSyncScope(0);
        }

        function loadDatabaseTransaction(tx) {
            sync.log.trace("Entering loadDatabaseTransaction");
            // this is to be uncommented when we have db for each scope
            //for i, ddl in ipairs ( DDLCommands[currentscope[kony.sync.scopeName]] ) do 
            var DDLCommands = null;
            if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLCE)) {
                DDLCommands = konysyncSQLCEDDLCommands;
            } else {
                DDLCommands = konysyncSQLLiteDDLCommands;
            }
            if (!kony.sync.isNullOrUndefined(DDLCommands)) {
                for (var i = 0; i < DDLCommands.length; i++) {
                    var ddl = DDLCommands[i];
                    sync.log.debug("ddl :" + ddl);
                    if (kony.sync.executeSql(tx, ddl) === false) {
                        isError = true;
                        return;
                    }
                }
            }
            if (kony.sync.initializeScopeSettings(tx) === false) {
                isError = true;
                return;
            }
            if (kony.sync.setPragmaSize(tx) === false) {
                isError = true;
                return;
            }
        }

        function dbexistsErrorCallback() {
            sync.log.trace("Entering dbexistsErrorCallback");
            //Create DB
            createDB = true;
            sync.log.info("creating DB");
            var conn = kony.sync.getConnectionOnly(currentscope[kony.sync.scopeDataSource], currentscope[kony.sync.scopeDataSource], on_sync_init_error);
            if (conn !== null) {
                kony.sync.startTransaction(conn, loadDatabaseTransaction, dbValidationCompleted, initTransactionError);
            }
        }

        function dbexistsSuccessCallback() {
            sync.log.trace("Entering dbexistsSuccessCallback");
            loadSyncScope(0);
        }
        //for a given table getting the reverseRelationships information
        //for a child table getting the  relationship data from a parent where child is targetobject
        function getParentRelationships(currentscope, synctable) {
            sync.log.trace("Entering getParentRelationships");
            parentRelationshipMap = {};
            scopeTables = currentscope.ScopeTables;
            if (!kony.sync.isNullOrUndefined(scope.ScopeTables)) {
                tables_length = scopeTables.length;
                for (var i = 0; i < tables_length; i++) {
                    var currentTable = scopeTables[i];
                    var RelationshipAttributes = [];
                    if (!kony.sync.isNullOrUndefined(currentTable.Relationships.OneToMany)) {
                        relationships_OneToMany = currentTable.Relationships.OneToMany;
                        OneToMany_length = relationships_OneToMany.length;
                        for (var j = 0; j < OneToMany_length; j++) {
                            //var attributeMap = {};
                            currentRelationShip = relationships_OneToMany[j];
                            if (currentRelationShip.TargetObject === synctable.Name) {
                                relationshipAttributes = currentRelationShip.RelationshipAttributes;
                                relationshipAttributes_length = relationshipAttributes.length;
                                for (var k = 0; k < relationshipAttributes_length; k++) {
                                    attributes = {}
                                    attributes["ParentObject_Attribute"] = relationshipAttributes[k].SourceObject_Attribute;
                                    attributes["ChildObject_Attribute"] = relationshipAttributes[k].TargetObject_Attribute;
                                    RelationshipAttributes.push(attributes)
                                }
                            }
                        }
                    }
                    if (RelationshipAttributes.length != 0) {
                        parentRelationshipMap[currentTable.Name] = RelationshipAttributes;
                    }
                }
            }
            return parentRelationshipMap;
        }
        var j = 0;
        kony.sync.scopeDict = {};
        if (!kony.sync.isNullOrUndefined(syncscopes)) {
            for (var i = 0; i < syncscopes.length; i++) {
                var scope = syncscopes[i];
                kony.sync.scopeDict[syncscopes[i].ScopeName] = scope;
                currentscope = scope;
                syncscopes[i] = scope;
                scope.Index = i;
                scope.syncTableDic = {};
                scope.reverseRelationships = {};
                // create helper dictionaries
                if (!kony.sync.isNullOrUndefined(scope.ScopeTables)) {
                    for (var k = 0; k < scope.ScopeTables.length; k++) {
                        var syncTable = scope.ScopeTables[k];
                        scope.syncTableDic[syncTable.Name] = syncTable;
                        scope.syncTableDic[syncTable.Name + kony.sync.historyTableName] = syncTable;
                        scope.syncTableDic[syncTable.Name + kony.sync.parentRelationshipMap] = getParentRelationships(scope, syncTable);
                        //reverse relationship mapping
                        if (!kony.sync.isNullOrUndefined(syncTable.Relationships.ManyToOne)) {
                            for (j = 0; j < syncTable.Relationships.ManyToOne.length; j++) {
                                var rTable = syncTable.Relationships.ManyToOne[j].TargetObject;
                                if (kony.sync.isNullOrUndefined(scope.reverseRelationships[rTable])) {
                                    scope.reverseRelationships[rTable] = [];
                                }
                                if (!kony.sync.isNullOrUndefined(syncTable.Relationships.ManyToOne[j].RelationshipAttributes)) {
                                    var relationshipAttributes = syncTable.Relationships.ManyToOne[j].RelationshipAttributes;
                                    var attributeMap = {};
                                    attributeMap.RelationshipAttributes = [];
                                    attributeMap.TargetObject = syncTable.Name;
                                    for (var iter = 0; iter < relationshipAttributes.length; iter++) {
                                        var attributes = {};
                                        attributes["SourceObject_Attribute"] = relationshipAttributes[iter].TargetObject_Attribute;
                                        attributes["TargetObject_Attribute"] = relationshipAttributes[iter].SourceObject_Attribute;
                                        attributeMap.RelationshipAttributes.push(attributes);
                                    };
                                    scope.reverseRelationships[rTable].push(attributeMap);
                                } else {
                                    var cascade = false;
                                    if (!kony.sync.isNullOrUndefined(syncTable.Relationships.ManyToOne[j].Cascade)) cascade = syncTable.Relationships.ManyToOne[j].Cascade;
                                    scope.reverseRelationships[rTable].push({
                                        SourceObject_Attribute: syncTable.Relationships.ManyToOne[j].TargetObject_Attribute,
                                        TargetObject: syncTable.Name,
                                        TargetObject_Attribute: syncTable.Relationships.ManyToOne[j].SourceObject_Attribute,
                                        Cascade: cascade
                                    });
                                }
                            }
                        }
                        syncscopes.syncTableScopeDic[syncTable.Name] = scope.ScopeName;
                        syncscopes.syncTableScopeDic[syncTable.Name + kony.sync.historyTableName] = scope.ScopeName;
                        syncTable.ColumnsDic = {};
                        if (!kony.sync.isNullOrUndefined(syncTable.Columns)) {
                            for (j = 0; j < syncTable.Columns.length; j++) {
                                var syncColumn = syncTable.Columns[j];
                                syncTable.ColumnsDic[syncColumn.Name] = syncColumn;
                                if (syncColumn.type === kony.sync.blob) {
                                    if (kony.sync.isNullOrUndefined(syncscopes.syncScopeBlobInfoMap[syncTable.Name])) {
                                        syncscopes.syncScopeBlobInfoMap[syncTable.Name] = {};
                                        syncscopes.syncScopeBlobInfoMap[syncTable.Name][kony.sync.columns] = [];
                                    }
                                    syncscopes.syncScopeBlobInfoMap[syncTable.Name][kony.sync.columns].push(syncColumn.Name);
                                    //in case of ifrecordvalue type, map the synctodevicefield.
                                    if (syncColumn.hasOwnProperty(kony.sync.binaryPolicy) && syncColumn[kony.sync.binaryPolicy] === kony.sync.ifRecordValue) {
                                        syncscopes.syncToDeviceMap[syncTable.Name + syncColumn.Name] = syncColumn[kony.sync.syncToDeviceField];
                                    }
                                }
                            }
                        }
                        currenttemptable = syncTable.Name;
                    }
                }
                //Note This change will be undone once we have 1 DB for each scope.
                sync.log.info("*************" + "\n", scope);
                sync.log.info("\n" + "*************");
            }
        }
        kony.sync.scopes = syncscopes;
        kony.sync.scopes.scopecount = syncscopes.length;
        /*removing check for existence of 1st table as 1st table may change for dynamic schema changes
		kony.sync.single_execute_sql(currentscope[kony.sync.scopeDataSource], sqlcheckfordb + " LIMIT 1", null, dbexistsSuccessCallback, dbexistsErrorCallback);*/
        if (dbExists) {
            dbexistsSuccessCallback();
        } else {
            dbexistsErrorCallback();
        }
    }
    //Check If DB is created or not		
    function loadSyncScope(scopeindex) {
        sync.log.trace("Entering loadSyncScope");
        var addmetainfo = false;
        var scope = kony.sync.scopes[scopeindex];
        //Add scopes to MetaInfo table if not created and Initialize kony.sync.currentSyncScopesState table.	
        function loadSyncScopeTransaction(tx) {
            sync.log.trace("Entering loadSyncScopeTransaction");
            var query = null;
            var query_compile = null;
            var sql = null;
            var params = null;
            // check whether scope exists in metainfo after schema upgrade
            sql = "select * from " + kony.sync.metaTableName + " where scopename = '" + scope.ScopeName + "'";
            var resultSet = kony.sync.executeSql(tx, sql, null);
            if (resultSet === false) {
                isError = true;
                return;
            }
            if (resultSet.rows.length === 0) {
                //the scope does not exist in the metainfo table and so has to be added
                addmetainfo = true;
            }
            if (addmetainfo) {
                //Querying the database for last inserted index
                sql = "select max(id) as 'max' from " + kony.sync.metaTableName;
                var resultSet = kony.sync.executeSql(tx, sql, null);
                var metaIndex = 0;
                if (resultSet !== false) {
                    if (resultSet.rows.length > 0) {
                        var rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
                        if (!kony.sync.isNullOrUndefined(rowItem["max"])) {
                            metaIndex = rowItem["max"] + 1;
                        } else {
                            metaIndex = 0;
                        }
                    }
                }
                query = kony.sync.qb_createQuery();
                kony.sync.qb_set(query, {
                    id: "" + metaIndex,
                    filtervalue: "no filter",
                    scopename: scope.ScopeName,
                    versionnumber: 0,
                    lastserversynccontext: "",
                    lastserveruploadsynccontext: "",
                    replaysequencenumber: 0,
                    lastgeneratedid: -1
                });
                kony.sync.qb_insert(query, kony.sync.metaTableName);
                //local sql = "insert into "..kony.sync.metaTableName.." (id,scopename,versionnumber,lastserversynccontext,replaysequencenumber,lastgeneratedid) values ('"..id.."','"..scope.ScopeName.."','0','','0','-1')"
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                if (kony.sync.executeSql(tx, sql, params) === false) {
                    isError = true;
                }
                kony.sync.currentSyncScopesState[scope.ScopeName] = 0;
            } else {
                query = kony.sync.qb_createQuery();
                kony.sync.qb_select(query, [kony.sync.metaTableSyncVersionCloumn]);
                kony.sync.qb_from(query, kony.sync.metaTableName);
                kony.sync.qb_where(query, [{
                    key: kony.sync.metaTableScopeColumn,
                    value: scope.ScopeName
                }]);
                //local sql = "select "..kony.sync.metaTableSyncVersionCloumn.." from "..kony.sync.metaTableName.." where "..kony.sync.metaTableScopeColumn.."='"..scope.ScopeName.."'";
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                var resultset = kony.sync.executeSql(tx, sql, params);
                if (resultset !== false && resultset.rows.length > 0) {
                    var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
                    if (!kony.sync.isNullOrUndefined(rowItem[kony.sync.metaTableSyncVersionCloumn])) {
                        kony.sync.currentSyncScopesState[scope.ScopeName] = rowItem[kony.sync.metaTableSyncVersionCloumn];
                    } else {
                        kony.sync.isResetInProgress = false;
                        isError = true;
                    }
                } else {
                    kony.sync.isResetInProgress = false;
                    isError = true;
                }
            }
            //Check for Sync Version 5.5.6
            if (kony.sync.checkForUpdate556to559Schema(tx) === false) {
                isError = true;
            }
            //Check for Sync Version 5.5.9
            if (kony.sync.checkForUpdate559to560Schema(tx) === false) {
                isError = true;
            }
            //Check for Sync Version 6.x
            if (kony.sync.checkForUpdate6xto70Schema(tx) === false) {
                isError = true;
            }
        }

        function loadSyncScopeSuccess() {
            sync.log.trace("Entering loadSyncScopeSuccess");
            //schema changed
            if (kony.sync.configVersion !== konysyncClientSyncConfig.Version) {
                kony.sync.schemaUpgradeNeeded = true;
                //kony.sync.verifyAndCallClosure(on_sync_init_error, kony.sync.getSchemaUpgradeNeededError());
                //return;
            }
            if (isError === true) {
                kony.sync.verifyAndCallClosure(on_sync_init_error, kony.sync.getScopeLoadingFailed());
            }
            if (scopeindex !== kony.sync.scopes.length - 1) {
                loadSyncScope(scopeindex + 1);
            } else {
                checkForStaleScope(checkForStaleScopeCallback);
            }
        }

        function checkForStaleScopeCallback() {
            sync.log.trace("Entering checkForStaleScopeCallback");
            kony.sync.isResetInProgress = false;
            //before initializing the thread, perform a clean up job to remove stale records.
            if (typeof(binary) !== "undefined" && typeof(binary.util) !== "undefined" && !kony.sync.isCleanUpJobCompleted) {
                sync.log.trace("checkForStaleScopeCallback -> Initializing binary stats");
                kony.sync.initBinaryStats();
                sync.log.trace("checkForStaleScopeCallback -> trigger clean up job.");
                kony.sync.blobManager.performCleanUp(function(isError) {
                    sync.log.trace("performCleanUp callback isError " + isError);
                    if (!isError) {
                        syncInitComplete();
                    } else {
                        //error occurred in performCleanup.
                        kony.sync.verifyAndCallClosure(on_sync_init_error, kony.sync.errorObject);
                        kony.sync.errorObject = null;
                    }
                });
            } else {
                sync.log.trace("checkForStaleScopeCallback -> Do not trigger clean up job.");
                syncInitComplete();
            }
        }

        function syncInitComplete() {
            sync.log.trace("syncInitComplete...");
            kony.sync.syncInitialized = true;
            //init the onDemand polling thread
            if (typeof(binary) !== "undefined" && typeof(binary.util) !== "undefined") {
                binary.util.binaryThreadInit(kony.sync.blobManager.prepareJobs, kony.sync.blobManager.getPreparedJobs, kony.sync.blobManager.onDemandUniversalSuccessCallback, kony.sync.blobManager.onDemandUniversalErrorCallback);
                binary.util.createBlobsDir();
            }
            //init the binaryNotifier map
            kony.sync.blobManager.binaryNotifierMap = {};
            kony.sync.verifyAndCallClosure(on_sync_init_success);
        }

        function checkForStaleScope(callback) {
            sync.log.trace("Entering checkForStaleScope");
            var connection = kony.sync.getConnectionOnly(kony.sync.scopes[0][kony.sync.scopeDataSource], kony.sync.scopes[0][kony.sync.scopeDataSource], on_sync_init_error);
            if (connection !== null) {
                kony.sync.startTransaction(connection, transactionCallback, transactionSuccessCallback, initTransactionError);
            }

            function transactionCallback(tx) {
                sync.log.trace("Entering transactionCallback");
                //Create ScopeMap
                var scopeNames = "";
                for (var i = 0; i < kony.sync.scopes.length; i++) {
                    if (i !== 0) {
                        scopeNames += ",";
                    }
                    scopeNames += "'" + kony.sync.scopes[i].ScopeName + "'";
                }
                var sql = "delete from " + kony.sync.metaTableName + " where " + kony.sync.metaTableScopeColumn + " not in (" + scopeNames + ")";
                if (kony.sync.executeSql(tx, sql, null) === false) {
                    isError = true;
                }
            }

            function transactionSuccessCallback() {
                sync.log.trace("Entering transactionSuccessCallback");
                callback();
            }
        }
        var scopename = scope.ScopeName;
        syncscopes[scopename] = scope;
        var connection = kony.sync.getConnectionOnly(scope[kony.sync.scopeDataSource], scope[kony.sync.scopeDataSource], on_sync_init_error);
        if (connection !== null) {
            kony.sync.startTransaction(connection, loadSyncScopeTransaction, loadSyncScopeSuccess, initTransactionError);
        }
    }

    function generateClientDeviceID() {
        sync.log.trace("Entering generateClientDeviceID");

        function createTable() {
            sync.log.trace("Entering createTable");
            var sqltable = "create table " + kony.sync.syncConfigurationTableName + " (" + kony.sync.syncConfigurationColumnDeviceIDName + " nvarchar(4000)," + kony.sync.syncConfigurationColumnInstanceIDName + " nvarchar(4000)," + kony.sync.syncConfigurationColumnVersion + " nvarchar(4000)," + kony.sync.syncConfigurationColumnSchemaUpgradeContext + " nvarchar(4000))";
            kony.sync.single_execute_sql(kony.sync.syncConfigurationDBName, sqltable, null, createDeviceID, on_sync_init_error);
        }

        function createDeviceID() {
            sync.log.trace("Entering createDeviceID");
            kony.sync.deviceId = "";
            kony.sync.instanceId = "";
            var settable = {};
            settable[kony.sync.syncConfigurationColumnDeviceIDName] = kony.sync.deviceId;
            settable[kony.sync.syncConfigurationColumnInstanceIDName] = kony.sync.instanceId;
            kony.sync.configVersion = konysyncClientSyncConfig.Version;
            settable[kony.sync.syncConfigurationColumnVersion] = kony.sync.configVersion;
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_set(query, settable);
            kony.sync.qb_insert(query, kony.sync.syncConfigurationTableName);
            var query_compile = kony.sync.qb_compile(query);
            var sqlinsert = query_compile[0];
            var params = query_compile[1];
            kony.sync.single_execute_sql(kony.sync.syncConfigurationDBName, sqlinsert, params, loadDatabase, on_sync_init_error);
        }

        function setDeviceID(configRow) {
            sync.log.trace("Entering setDeviceID");
            dbExists = true;
            sync.log.trace("Entering setDeviceID");
            kony.sync.deviceId = configRow[kony.sync.syncConfigurationColumnDeviceIDName];
            kony.sync.instanceId = configRow[kony.sync.syncConfigurationColumnInstanceIDName];
            kony.sync.configVersion = configRow[kony.sync.syncConfigurationColumnVersion];
            loadDatabase();
        }
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, kony.sync.syncConfigurationTableName);
        kony.sync.single_execute_sql(kony.sync.syncConfigurationDBName, "select * from " + kony.sync.syncConfigurationTableName + " LIMIT 1", null, setDeviceID, createTable);
    }

    function initTransactionError() {
        sync.log.trace("Entering initTransactionError");
        kony.sync.callTransactionError(isError, on_sync_init_error);
    }
    generateClientDeviceID();
};
sync.reset = function(successcallback, errorcallback) {
    sync.log.trace("Entering sync.reset ");
    if (kony.sync.isResetInProgress) {
        sync.log.warn("Reset already in progress...");
        return;
    }
    if (kony.sync.isValidJSTable(successcallback) === true) {
        //new style, user called as sync.reset(config)
        errorcallback = successcallback[kony.sync.onSyncResetErrorParam];
        kony.sync.createDBEncryptionKey(successcallback[kony.sync.deviceDBEncryptionKeyParam]);
        successcallback = successcallback[kony.sync.onSyncResetSuccessParam];
    }
    kony.sync.isResetInProgress = true;
    kony.sync.schemaUpgradeNeeded = false;
    kony.sync.syncConfigurationDBName = konysyncClientSyncConfig.AppID;
    if (typeof(binarydata) !== "undefined") {
        sync.log.trace("sync.reset -> Reseting BinaryDataManager");
        binarydata.clearBinaryDataManagerState();
    }
    var dbList = [];
    kony.table.insert(dbList, {
        dbname: kony.sync.syncConfigurationDBName,
        tableList: [kony.sync.syncConfigurationTableName, kony.sync.chunkMetaTableName, kony.sync.chunkTableName, kony.sync.metaTableName, kony.sync.pendingUploadTableName, "konysyncDIAGNOSTICS", "konysyncBLOBSTOREMANAGER"]
    });
    if (konysyncClientSyncConfig.ArrayOfSyncScope !== null && konysyncClientSyncConfig.ArrayOfSyncScope !== undefined) {
        for (var i = 0; i < konysyncClientSyncConfig.ArrayOfSyncScope.length; i++) {
            var v = konysyncClientSyncConfig.ArrayOfSyncScope[i];
            var tab = [];
            for (var k = 0; k < v.ScopeTables.length; k++) {
                var w = v.ScopeTables[k];
                kony.table.insert(tab, w.Name);
                kony.table.insert(tab, w.Name + kony.sync.historyTableName);
                kony.table.insert(tab, w.Name + kony.sync.originalTableName);
            }
            /*if ((i === 1)) {
            	kony.table.insert(tab, kony.sync.metaTableName);
            	kony.table.insert(tab, "konysyncDIAGNOSTICS");
            }*/
            kony.table.insert(dbList, {
                dbname: v.ScopeDatabaseName,
                tableList: tab
            });
        }
    }
    kony.sync.syncDropDatabase(dbList, successcallback, errorcallback);
};
sync.rollbackPendingLocalChanges = function(successcallback, errorcallback) {
    sync.log.trace("Entering sync.rollbackPendingLocalChanges ");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return;
    }
    kony.sync.rollbackCurrentScope = null;
    kony.sync.konySyncRollBackPendingChanges(null, null, null, successcallback, errorcallback, true, 0);
};
sync.getPendingAcknowledgement = function(successcallback, errorcallback) {
    sync.log.trace("Entering sync.getPendingAcknowledgement ");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return;
    }
    kony.sync.pendingAckIndex = 0;
    kony.sync.pendingAckResult = {};
    var currentScope = kony.sync.scopes[0];
    var dbname = currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
    kony.sync.pendingAckCount = 0;
    var isError = false;

    function konysyncPendingAck_transaction(tx) {
        sync.log.trace("Entering konysyncPendingAck_transaction");

        function single_transaction_callback_local(sql, params, tbname) {
            sync.log.trace("Entering single_transaction_callback_local");
            var resultSet = kony.sync.executeSql(tx, sql, params);
            if (resultSet === false) {
                isError = true;
                return false;
            }
            var tableData = [];
            var num_records = resultSet.rows.length;
            for (var j = 0; j <= num_records - 1; j++) {
                var record = kony.db.sqlResultsetRowItem(tx, resultSet, j);
                kony.table.insert(tableData, record);
            }
            if ((num_records > 0)) {
                kony.sync.pendingAckCount = kony.sync.pendingAckCount + num_records;
                //table.insert(kony.sync.pendingAckResult,tableData);
                kony.sync.pendingAckResult[tbname] = {};
                kony.sync.pendingAckResult[tbname].count = num_records;
                kony.sync.pendingAckResult[tbname].data = tableData;
            }
        }
        if (!kony.sync.isNullOrUndefined(currentScope.ScopeTables)) {
            for (var i = 0; i < currentScope.ScopeTables.length; i++) {
                var syncTable = currentScope.ScopeTables[i];
                var tbname = syncTable.Name;
                var currentversion = kony.sync.getCurrentVersionNumber(tbname);
                var sql = "select * from " + tbname + " WHERE " + kony.sync.mainTableChangeTypeColumn + " is not null AND " + kony.sync.mainTableChangeTypeColumn + " <> -1 AND " + kony.sync.mainTableSyncVersionColumn + " <> " + currentversion + " AND " + kony.sync.mainTableChangeTypeColumn + " NOT LIKE '9%'";
                if (single_transaction_callback_local(sql, null, tbname) === false) {
                    return;
                }
            }
        }
    }

    function konysyncPendingAck_transactionSucessCallback() {
        sync.log.trace("Entering konysyncPendingAck_transactionSucessCallback");
        sync.log.info("Get Pending Acknowledgement Count = ", kony.sync.pendingAckCount);
        sync.log.info("Get Pending Acknowledgement = ", kony.sync.pendingAckResult);
        if ((kony.sync.pendingAckIndex === kony.sync.scopes.scopecount - 1)) {
            var konysyncPendingAckDic = {};
            konysyncPendingAckDic.totalCount = kony.sync.pendingAckCount;
            konysyncPendingAckDic.totalData = kony.sync.pendingAckResult;
            kony.sync.verifyAndCallClosure(successcallback, konysyncPendingAckDic);
        } else {
            kony.sync.pendingAckIndex = kony.sync.pendingAckIndex + 1;
            currentScope = kony.sync.scopes[kony.sync.pendingAckIndex];
            dbname = currentScope[kony.sync.scopeDataSource];
            dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
            if (dbconnection !== null) {
                kony.sync.startTransaction(dbconnection, konysyncPendingAck_transaction, konysyncPendingAck_transactionSucessCallback, konysyncPendingAck_transactionErrorCallback, "Get Pending Acknowledgement");
            }
        }
    }

    function konysyncPendingAck_transactionErrorCallback() {
        sync.log.trace("Entering konysyncPendingAck_transactionErrorCallback");
        kony.sync.callTransactionError(isError, errorcallback);
    }
    if (dbconnection !== null) {
        kony.sync.startTransaction(dbconnection, konysyncPendingAck_transaction, konysyncPendingAck_transactionSucessCallback, konysyncPendingAck_transactionErrorCallback, "Get Pending Acknowledgement");
    }
};
sync.getPendingUpload = function(successcallback, errorcallback) {
    sync.log.trace("Entering sync.getPendingUpload ");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return;
    }
    kony.sync.pendingUploadIndex = 0;
    kony.sync.pendingUploadResult = {};
    var currentScope = kony.sync.scopes[0];
    var dbname = currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
    kony.sync.pendingUploadCount = 0;
    var isError = false;

    function konysyncPendingUpload_transaction(tx) {
        sync.log.trace("Entering konysyncPendingUpload_transaction");

        function single_transaction_callback_local(sql, params, tbname) {
            sync.log.trace("Entering single_transaction_callback_local");
            var resultSet = kony.sync.executeSql(tx, sql, params);
            if (resultSet === false) {
                isError = false;
                return false;
            }
            var tableData = [];
            var num_records = resultSet.rows.length;
            for (var j = 0; j <= num_records - 1; j++) {
                var record = kony.db.sqlResultsetRowItem(tx, resultSet, j);
                kony.table.insert(tableData, record);
            }
            if ((num_records > 0)) {
                kony.sync.pendingUploadCount = kony.sync.pendingUploadCount + num_records;
                kony.sync.pendingUploadResult[tbname] = {};
                kony.sync.pendingUploadResult[tbname].count = num_records;
                kony.sync.pendingUploadResult[tbname].data = tableData;
            }
        }
        if (!kony.sync.isNullOrUndefined(currentScope.ScopeTables)) {
            for (var i = 0; i < currentScope.ScopeTables.length; i++) {
                var syncTable = currentScope.ScopeTables[i];
                var tbname = syncTable.Name;
                var columnsDic = currentScope.syncTableDic[tbname].Columns;
                var columns = "";
                for (var j = 0; j < columnsDic.length; j++) {
                    if (j == 0) {
                        columns = columns + columnsDic[j].Name;
                    } else {
                        columns = columns + ", " + columnsDic[j].Name;
                    }
                }
                var currentversion = kony.sync.getCurrentVersionNumber(tbname);
                var sql = "select " + columns + " from " + tbname + kony.sync.historyTableName + " WHERE " + kony.sync.mainTableChangeTypeColumn + " is not null AND " + kony.sync.mainTableChangeTypeColumn + " <> -1 AND " + kony.sync.mainTableSyncVersionColumn + " = " + currentversion + " AND " + kony.sync.mainTableChangeTypeColumn + " NOT LIKE '9%'";
                if (single_transaction_callback_local(sql, null, tbname) === false) {
                    return;
                }
            }
        }
    }

    function konysyncPendingUpload_transactionSucessCallback() {
        sync.log.trace("Entering konysyncPendingUpload_transactionSucessCallback");
        sync.log.info("Pending Uploads Count = ", kony.sync.pendingUploadCount);
        sync.log.info("Pending Uploads = ", kony.sync.pendingUploadResult);
        if ((kony.sync.pendingUploadIndex === kony.sync.scopes.scopecount - 1)) {
            var konysyncPendingUploadDic = {};
            konysyncPendingUploadDic.totalCount = kony.sync.pendingUploadCount;
            konysyncPendingUploadDic.totalData = kony.sync.pendingUploadResult;
            kony.sync.verifyAndCallClosure(successcallback, konysyncPendingUploadDic);
        } else {
            kony.sync.pendingUploadIndex = kony.sync.pendingUploadIndex + 1;
            currentScope = kony.sync.scopes[kony.sync.pendingUploadIndex];
            dbname = currentScope[kony.sync.scopeDataSource];
            dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
            if (dbconnection !== null) {
                kony.sync.startTransaction(dbconnection, konysyncPendingUpload_transaction, konysyncPendingUpload_transactionSucessCallback, transactionErrorCallback, "Get Pending Upload");
            }
        }
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        kony.sync.callTransactionError(isError, errorcallback);
    }
    if (dbconnection !== null) {
        kony.sync.startTransaction(dbconnection, konysyncPendingUpload_transaction, konysyncPendingUpload_transactionSucessCallback, transactionErrorCallback, "Get Pending Upload");
    }
};
sync.getDeferredUpload = function(successcallback, errorcallback) {
    sync.log.trace("Entering sync.getDeferredUpload ");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return;
    }
    kony.sync.deferredUploadIndex = 0;
    kony.sync.deferredUploadResult = {};
    var currentScope = kony.sync.scopes[0];
    var dbname = currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
    kony.sync.deferredUploadCount = 0;
    var isError = false;

    function konysyncDeferredUpload_transaction(tx) {
        sync.log.trace("Entering konysyncDeferredUpload_transaction");

        function single_transaction_callback_local(sql, params, tbname) {
            sync.log.trace("Entering single_transaction_callback_local");
            var resultSet = kony.sync.executeSql(tx, sql, params);
            if (resultSet === false) {
                isError = true;
                return false;
            }
            var tableData = [];
            var num_records = resultSet.rows.length;
            for (var j = 0; j <= num_records - 1; j++) {
                var record = kony.db.sqlResultsetRowItem(tx, resultSet, j);
                kony.table.insert(tableData, record);
            }
            if ((num_records > 0)) {
                kony.sync.deferredUploadCount = kony.sync.deferredUploadCount + num_records;
                kony.sync.deferredUploadResult[tbname] = {};
                kony.sync.deferredUploadResult[tbname].count = num_records;
                kony.sync.deferredUploadResult[tbname].data = tableData;
            }
        }
        if (!kony.sync.isNullOrUndefined(currentScope.ScopeTables)) {
            for (var i = 0; i < currentScope.ScopeTables.length; i++) {
                var syncTable = currentScope.ScopeTables[i];
                var tbname = syncTable.Name;
                var sql = "select * from " + tbname + " WHERE " + kony.sync.mainTableChangeTypeColumn + " is not null AND " + kony.sync.mainTableChangeTypeColumn + " <> -1 AND " + kony.sync.mainTableChangeTypeColumn + " LIKE '9%'";
                if (single_transaction_callback_local(sql, null, tbname) === false) {
                    return;
                }
            }
        }
    }

    function konysyncDeferredUpload_transactionSucessCallback() {
        sync.log.trace("Entering konysyncDeferredUpload_transactionSucessCallback");
        sync.log.info("Deferred Uploads Count = ", kony.sync.deferredUploadCount);
        sync.log.info("Deferred Uploads = ", kony.sync.deferredUploadResult);
        if ((kony.sync.deferredUploadIndex === kony.sync.scopes.scopecount - 1)) {
            var konysyncDeferredUploadDic = {};
            konysyncDeferredUploadDic.totalCount = kony.sync.deferredUploadCount;
            konysyncDeferredUploadDic.totalData = kony.sync.deferredUploadResult;
            kony.sync.verifyAndCallClosure(successcallback, konysyncDeferredUploadDic);
        } else {
            kony.sync.deferredUploadIndex = kony.sync.deferredUploadIndex + 1;
            currentScope = kony.sync.scopes[kony.sync.deferredUploadIndex];
            dbname = currentScope[kony.sync.scopeDataSource];
            dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
            if (dbconnection !== null) {
                kony.sync.startTransaction(dbconnection, konysyncDeferredUpload_transaction, konysyncDeferredUpload_transactionSucessCallback, transactionErrorCallback, "Get Deferred Upload");
            }
        }
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        kony.sync.callTransactionError(isError, errorcallback);
    }
    if (dbconnection !== null) {
        kony.sync.startTransaction(dbconnection, konysyncDeferredUpload_transaction, konysyncDeferredUpload_transactionSucessCallback, transactionErrorCallback, "Get Deferred Upload");
    }
};
sync.getAllPendingUploadInstances = function(retrieveOnlyCount, successcallback, errorcallback) {
    sync.log.trace("Entering sync.getAllPendingUploadInstances");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return;
    }
    var pendingUploadResult = {};
    pendingUploadResult.totalCount = 0;
    var dbname = kony.sync.scopes[0][kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, pendingUploadTransaction, pendingUploadTransactionErrorCallback, pendingUploadTransactionSucessCallback);
    }
    var isError = false;

    function pendingUploadTransaction(tx) {
        sync.log.trace("Entering sync.getAllPendingUploadInstances->pendingUploadTransaction");
        for (var i = 0; i < kony.sync.scopes.length; i++) {
            var currentScope = kony.sync.scopes[i];
            var scopeName = currentScope[kony.sync.scopeName];
            pendingUploadResult[scopeName] = {};
            pendingUploadResult[scopeName].count = 0;
            /*get syncversion from metatable*/
            var syncversion = 0;
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_select(query, [kony.sync.metaTableSyncVersionCloumn]);
            kony.sync.qb_from(query, kony.sync.metaTableName);
            kony.sync.qb_where(query, [{
                key: kony.sync.metaTableScopeColumn,
                value: scopeName
            }, {
                key: kony.sync.metaTableFilterValue,
                value: "no filter"
            }]);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            var resultset = kony.sync.executeSql(tx, sql, params);
            if (resultset === false) {
                isError = true;
                return;
            }
            var row = kony.db.sqlResultsetRowItem(tx, resultset, 0);
            syncversion = row[kony.sync.metaTableSyncVersionCloumn];
            for (var j = 0; !kony.sync.isNull(currentScope.ScopeTables) && j < currentScope.ScopeTables.length; j++) {
                var syncTable = currentScope.ScopeTables[j];
                //not using query builder to speedup time
                if (retrieveOnlyCount !== true) {
                    sql = "select * from  " + syncTable.Name + kony.sync.historyTableName + " where " + kony.sync.historyTableChangeTypeColumn + " NOT LIKE '9%' AND " + kony.sync.historyTableSyncVersionColumn + " = " + syncversion;
                } else {
                    sql = "select count(*) from  " + syncTable.Name + kony.sync.historyTableName + " where " + kony.sync.historyTableChangeTypeColumn + " NOT LIKE '9%' AND " + kony.sync.historyTableSyncVersionColumn + " = " + syncversion;
                }
                resultset = kony.sync.executeSql(tx, sql, null);
                if (resultset === false) {
                    isError = true;
                    return;
                }
                pendingUploadResult[scopeName][syncTable.Name] = {};
                if (retrieveOnlyCount !== true) {
                    pendingUploadResult[scopeName][syncTable.Name].count = resultset.rows.length;
                    pendingUploadResult[scopeName][syncTable.Name].data = [];
                    for (var k = 0; k < resultset.rows.length; k++) {
                        pendingUploadResult[scopeName][syncTable.Name].data[k] = kony.db.sqlResultsetRowItem(tx, resultset, k);
                    }
                } else {
                    var rowCount = kony.db.sqlResultsetRowItem(tx, resultset, 0);
                    pendingUploadResult[scopeName][syncTable.Name].count = rowCount["count(*)"];
                }
                pendingUploadResult[scopeName].count += pendingUploadResult[scopeName][syncTable.Name].count;
                pendingUploadResult.totalCount += pendingUploadResult[scopeName][syncTable.Name].count;
            }
        }
    }

    function pendingUploadTransactionErrorCallback() {
        sync.log.trace("Entering sync.getAllPendingUploadInstances->pendingUploadTransactionErrorCallback");
        kony.sync.verifyAndCallClosure(errorcallback);
    }

    function pendingUploadTransactionSucessCallback() {
        sync.log.trace("Entering sync.getAllPendingUploadInstances->pendingUploadTransactionSucessCallback");
        sync.log.info("getAllPendingUploadInstances success", pendingUploadResult);
        kony.sync.verifyAndCallClosure(successcallback, pendingUploadResult);
    }
};
kony.sync.checkForUpdate556to559Schema = function(tx) {
    sync.log.trace("Entering kony.sync.checkForUpdate556to559Schema ");
    var sql = "select count(*) from " + kony.sync.chunkTableName;
    var resultSet = kony.sync.executeSql(tx, sql, null, null, false);
    if (resultSet === false) {
        //Alter scripts for 5.5.6 to 5.5.9 DB Update 
        kony.sync.DDL556to559Update = ["ALTER TABLE " + kony.sync.metaTableName + " ADD COLUMN " + kony.sync.metaTableUploadSyncTimeColumn + " nvarchar(1000)", "CREATE TABLE " + kony.sync.pendingUploadTableName + " (" + kony.sync.metaTableScopeColumn + " nvarchar(100) not null," + kony.sync.pendingUploadTableUploadRequest + " text," + kony.sync.objectLevelInfo + " text," + kony.sync.pendingUploadTableInsertCount + " int," + kony.sync.pendingUploadTableUpdateCount + " int," + kony.sync.pendingUploadTableDeleteCount + " int," + kony.sync.pendingUploadTableBatchInsertCount + " int," + kony.sync.pendingUploadTableBatchUpdateCount + " int," + kony.sync.pendingUploadTableBatchDeleteCount + " int," + kony.sync.pendingUploadTableUploadLimit + " int,primary key (" + kony.sync.metaTableScopeColumn + "))", "CREATE TABLE " + kony.sync.chunkTableName + " (" + kony.sync.chunkTableChunkId + " int not null," + kony.sync.chunkTablePayloadId + " nvarchar(50) not null," + kony.sync.metaTableScopeColumn + " nvarchar(100) not null," + kony.sync.chunkTableChunkData + " text," + kony.sync.chunkTableTimeStamp + " nvarchar(50),primary key (" + kony.sync.chunkTableChunkId + ", " + kony.sync.chunkTablePayloadId + ", " + kony.sync.metaTableScopeColumn + "))", "CREATE TABLE " + kony.sync.chunkMetaTableName + " (" + kony.sync.chunkTablePayloadId + " nvarchar(50) not null," + kony.sync.metaTableScopeColumn + " nvarchar(100) not null," + kony.sync.metaTableChunkAck + " int," + kony.sync.metaTableChunkSize + " int," + kony.sync.metaTableChunkCount + " int," + kony.sync.metaTableChunkHashSum + " nvarchar(35)," + kony.sync.metaTableChunkDiscarded + " int,primary key (" + kony.sync.chunkTablePayloadId + ", " + kony.sync.metaTableScopeColumn + "))"];
    }
    return kony.sync.executeQueriesInTransaction(tx, kony.sync.DDL556to559Update);
};
kony.sync.checkForUpdate559to560Schema = function(tx) {
    sync.log.trace("Entering kony.sync.checkForUpdate559to560Schema ");
    var sql = "select count(" + kony.sync.metaTableSchemaUpgradeSyncTimeColumn + ") from " + kony.sync.metaTableName;
    var resultSet = kony.sync.executeSql(tx, sql, null, null, false);
    if (resultSet === false) {
        //Alter scripts for 5.5.9 to 5.6.0 DB Update 
        kony.sync.configVersion = konysyncClientSyncConfig.Version;
        kony.sync.DDL559to560Update = ["ALTER TABLE " + kony.sync.syncConfigurationTableName + " ADD COLUMN " + kony.sync.syncConfigurationColumnSchemaUpgradeContext + " nvarchar(4000)", "ALTER TABLE " + kony.sync.syncConfigurationTableName + " ADD COLUMN " + kony.sync.syncConfigurationColumnVersion + " nvarchar(4000)", "ALTER TABLE " + kony.sync.metaTableName + " ADD COLUMN " + kony.sync.metaTableSchemaUpgradeSyncTimeColumn + " nvarchar(1000)", "UPDATE " + kony.sync.syncConfigurationTableName + " SET " + kony.sync.syncConfigurationColumnVersion + " = '" + konysyncClientSyncConfig.Version + "' where rowid = 1"];
    }
    return kony.sync.executeQueriesInTransaction(tx, kony.sync.DDL559to560Update);
};
kony.sync.checkForUpdate6xto70Schema = function(tx) {
    sync.log.trace("Entering kony.sync.checkForUpdate6xto70Schema ");
    // create table named konysyncBLOBSTOREMANAGER if doesn't exist in sync DB.
    kony.sync.DDL6xto70Update = ["CREATE TABLE IF NOT EXISTS \"konysyncBLOBSTOREMANAGER\" (\"id\" integer not null,\"localPath\" text,\"tableName\"text,\"columnName\" text,\"type\" text,\"state\" integer,\"status\" integer,\"size\" integer,\"retry\" integer,\"lastUpdatedTimeStamp\" TIMESTAMP default CURRENT_TIMESTAMP,primary key (\"id\"))"];
    return kony.sync.executeQueriesInTransaction(tx, kony.sync.DDL6xto70Update);
};
/**
 * Method is used to fetch the records whose binary operation has failed
 * @param isDownload {boolean} true for download/ false for upload
 * @param tablename {String} tablename to filter binary records by tablename.
 * @param columnname {String} column name to filter binary records by binary column.
 * @param successCallback
 * @param errorCallback
 */
sync.getFailedBinaryRecords = function(isDownload, tablename, columnname, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.single_insert_execute-> main function");
    var isError = false;
    var statusResponse = [];

    function single_transaction_success_callback() {
        sync.log.trace("Entering single_transaction_success_callback");
        if (!isError) {
            sync.log.trace("kony.sync.getFailedBinaryRecords - single_transaction_success_callback...");
            kony.sync.verifyAndCallClosure(successCallback, statusResponse);
        } else {
            kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
        }
    }

    function single_transaction_failure_callback() {
        sync.log.trace("kony.sync.getFailedBinaryRecords - single_transaction_error_callback...");
        kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
    }

    function single_transaction_callback(tx) {
        sync.log.trace("kony.sync.getFailedBinaryRecords - single_transaction_callback...");
        var selectClause = [kony.sync.blobManager.id, kony.sync.blobManager.tableName, kony.sync.blobManager.columnName];
        var whereClause = [];
        var requiredState = kony.sync.blobManager.DOWNLOAD_FAILED;
        if (!isDownload) {
            requiredState = kony.sync.blobManager.UPLOAD_FAILED;
        }
        kony.table.insert(whereClause, {
            key: kony.sync.blobManager.state,
            value: requiredState,
            optype: "EQ",
            comptype: "AND"
        });
        //if tablename is passed.. add it to the where clause..
        if (!kony.sync.isNullOrUndefined(tablename)) {
            kony.table.insert(whereClause, {
                key: kony.sync.blobManager.tableName,
                value: tablename,
                optype: "EQ",
                comptype: "AND"
            });
            //if column name is passed, add it to the whereclause..
            if (!kony.sync.isNullOrUndefined(columnname)) {
                kony.table.insert(whereClause, {
                    key: kony.sync.blobManager.columnName,
                    value: columnname,
                    optype: "EQ",
                    comptype: "AND"
                });
            }
        }
        var resultset = kony.sync.queryTable(tx, kony.sync.blobStoreManagerTable, selectClause, whereClause);
        if (resultset) {
            for (var k = 0; k < resultset.rows.length; k++) {
                var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, k);
                var binaryColumnName = kony.sync.binaryMetaColumnPrefix + rowItem[kony.sync.blobManager.columnName];
                var tbname = rowItem[kony.sync.blobManager.tableName];
                var pkColumns = kony.sync.currentScope.syncTableDic[tbname].Pk_Columns;
                var blobWhereClause = [{
                    key: binaryColumnName,
                    value: rowItem[kony.sync.blobManager.id]
                }];
                var parentResultSet = kony.sync.queryTable(tx, tbname, pkColumns, blobWhereClause);
                if (!parentResultSet) {
                    return;
                }
                for (var rowCount = 0; rowCount < parentResultSet.rows.length; rowCount++) {
                    var parentRowItem = kony.db.sqlResultsetRowItem(tx, parentResultSet, rowCount);
                    var response = {};
                    for (var pkCount = 0; pkCount < pkColumns.length; pkCount++) {
                        var pkTable = {};
                        pkTable[pkColumns[pkCount]] = parentRowItem[pkColumns[pkCount]];
                    }
                    response.primaryKeys = pkTable;
                    response.tableName = tbname;
                    response.binaryColumn = rowItem[kony.sync.blobManager.columnName];
                    statusResponse.push(response);
                }
            }
        }
    }
    var dbname = kony.sync.getDBName();
    var connection = kony.sync.getConnectionOnly(dbname, dbname, errorCallback, "fetch binary failed records..");
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_failure_callback);
    }
};
/**
 * Method is used to fetch status of the binary records of given table.
 * @param tbname - name of the table.
 * @param columnName - name of the binary column
 * @param pks {JSON} - Primary keys values for the record.
 * @param successCallback - callback called upon success.
 * @param errorCallback - callback called upon error.
 */
sync.getStatusForBinary = function(tbname, columnName, pks, successCallback, errorCallback) {
    sync.log.trace("Entering sync.getStatusForBinary ");
    var statusResponse = {};
    var error;

    function single_transaction_callback(tx) {
        sync.log.trace("Entering sync.getStatusForBinary -> single_transaction_callback");
        if (kony.sync.isNullOrUndefined(pks)) {
            //null pk values are received.
            error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, pks));
            return;
        }
        var scopename = kony.sync.scopes.syncTableScopeDic[tbname];
        var scope = kony.sync.scopes[scopename];
        var pkColumns = scope.syncTableDic[tbname].Pk_Columns;
        pks = kony.sync.validatePkTable(pkColumns, pks);
        if (!kony.sync.isNullOrUndefined(pks)) {
            var blobRef = kony.sync.getBlobRef(tx, tbname, columnName, pks, errorCallback);
            statusResponse.primaryKeys = pks;
            if (blobRef === kony.sync.blobRefNotDefined || blobRef === kony.sync.blobRefNotFound) {
                statusResponse.statusCode = 0;
                statusResponse.statusMessage = "Binary record not downloaded";
            } else {
                //blob ref exists. query the blob store manager.
                var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobRef, errorCallback);
                if (blobMeta !== null && blobMeta !== false) {
                    statusResponse.statusCode = blobMeta[kony.sync.blobManager.state];
                    statusResponse.statusMessage = kony.sync.blobManager.states[statusResponse.statusCode];
                }
            }
        } else {
            //error invalid pks.
            error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, tbname));
        }
    }

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.getStatusForBinary->single_transaction_success_callback");
        if (!kony.sync.isNullOrUndefined(error)) {
            kony.sync.verifyAndCallClosure(errorCallback, error);
        } else {
            sync.log.trace("status response for the get status request ", statusResponse);
            kony.sync.verifyAndCallClosure(successCallback, statusResponse);
        }
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.getStatusForBinary->single_transaction_error_callback");
        kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
    }
    sync.log.trace("Entering kony.sync.single_binary_select_status_execute-> main function");
    if (kony.sync.isValidFunctionType(successCallback) && kony.sync.isValidFunctionType(errorCallback)) {
        if (columnName === undefined || typeof(columnName) !== "string" || tbname === undefined || typeof(tbname) !== "string") {
            var error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidColumnParams, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidColumnParams));
            kony.sync.verifyAndCallClosure(errorCallback, error);
            return;
        }
        var downloadPolicy = kony.sync.getDownloadPolicy(tbname, columnName);
        sync.log.trace("download policy for the column " + tbname + "." + columnName + " is " + downloadPolicy);
        if (downloadPolicy !== kony.sync.notSupported) {
            var dbname = kony.sync.getDBName();
            var connection = kony.sync.getConnectionOnly(dbname, dbname, errorCallback, "fetch status for binary records..");
            if (connection !== null) {
                kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
            }
        } else {
            var error = kony.sync.getErrorTable(kony.sync.errorCodeDownloadPolicyNotSupported, kony.sync.getErrorMessage(kony.sync.errorCodeDownloadPolicyNotSupported, tbname + "." + columnName));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
/**
 * Method is used to fetch Base64 string for a given record.
 * @param tbname {String} - tablename
 * @param columnName {String} - name of the binary column
 * @param pks {JSON} - Primary keys values for the record.
 * @param config {JSON} (optional) - config properties for the binary download. includes {"forceDownload": true/false}
 * @param successCallback
 * @param errorCallback
 */
sync.getBinaryBase64 = function(tbname, columnName, pks, config, successCallback, errorCallback) {
    sync.log.trace("Entering sync.getBinaryBase64....");
    var dbname = kony.sync.getDBName();
    kony.sync.single_binary_select_base64_execute(dbname, tbname, columnName, pks, config, successCallback, errorCallback);
};
/**
 * Method is used to fetch binary file for a given record
 * @param tbname {String} - tablename
 * @param columnName {String} - name of the binary column
 * @param pks {JSON} - Primary keys values for the record.
 * @param config {JSON} (optional) - config properties for the binary download. includes {"forceDownload": true/false}
 * @param successCallback
 * @param errorCallback
 */
sync.getBinaryFilepath = function(tbname, columnName, pks, config, successCallback, errorCallback) {
    sync.log.trace("Entering sync.getBinaryFilepath....");
    var dbname = kony.sync.getDBName();
    kony.sync.single_binary_select_file_execute(dbname, tbname, columnName, pks, config, successCallback, errorCallback);
};
sync.createDownloadTask = function(tableName, binaryColumnName, primaryKeyTable, config, successCallback, errorCallback) {
    sync.log.trace("Entering sync.createDownloadTask for table ", tableName, " column name ", binaryColumnName);
    var dbname = kony.sync.getDBName();
    kony.sync.createDownloadTask(dbname, tableName, binaryColumnName, primaryKeyTable, config, successCallback, errorCallback);
};
sync.startDownload = function(downloadID, successCallback, errorCallback) {
    sync.log.trace("Entering sync.startDownload for downloadID " + downloadID);
    kony.sync.startDownload(downloadID, successCallback, errorCallback);
};
sync.pauseDownload = function(downloadID, successCallback, errorCallback) {
    sync.log.trace("Entering sync.pauseDownload for downloadID " + downloadID);
    kony.sync.pauseDownload(downloadID, successCallback, errorCallback);
};
sync.resumeDownload = function(downloadID, successCallback, errorCallback) {
    sync.log.trace("Entering sync.resumeDownload for downloadID " + downloadID);
    kony.sync.resumeDownload(downloadID, successCallback, errorCallback);
};
sync.getBinaryDataFilePath = function(tableName, binaryColumnName, primaryKeyTable, successCallback, errorCallback) {
    sync.log.trace("Entering sync.getBinaryDataFilePath for tableName ", tableName, " binary column ", binaryColumnName, " with primary keys ", primaryKeyTable);
    var dbname = kony.sync.getDBName();
    kony.sync.getBinaryDataFilePath(dbname, tableName, binaryColumnName, primaryKeyTable, successCallback, errorCallback);
};
sync.getBinary = function(tableName, binaryColumnName, primaryKeyTable, config, successCallback, errorCallback) {
    sync.log.trace("Entering sync.getBinary..");
    var dbname = kony.sync.getDBName();
    kony.sync.getBinary(dbname, tableName, binaryColumnName, primaryKeyTable, config, successCallback, errorCallback);
};
//delete binary objects api.
sync.deleteBinaryObject = function(tableName, binaryColumnName, primaryKeyTable, options, successCallback, errorCallback) {
    sync.log.trace("Entering sync.deleteBinaryObject for tableName ", tableName, " binary column ", binaryColumnName, " with primary keys ", primaryKeyTable);
    var dbname = kony.sync.getDBName();
    kony.sync.deleteBinaryObject(dbname, tableName, binaryColumnName, primaryKeyTable, options, successCallback, errorCallback);
};
//  **************** End KonySyncInit.js*******************
//  **************** Start KonySyncLogger.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(kony.sync.log) === "undefined") {
    kony.sync.log = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
sync.log = {};
sync.log.trace = function(msg, params) {
    sync.log.getInstance().trace(msg, params);
};
sync.log.debug = function(msg, params) {
    sync.log.getInstance().debug(msg, params);
};
sync.log.info = function(msg, params) {
    sync.log.getInstance().info(msg, params);
};
sync.log.warn = function(msg, params) {
    sync.log.getInstance().warn(msg, params);
};
sync.log.error = function(msg, params) {
    sync.log.getInstance().error(msg, params);
};
sync.log.fatal = function(msg, params) {
    sync.log.getInstance().fatal(msg, params);
};
sync.log.loggerEngineInit = function() {
    KonySyncLoggerObj = kony.logger.createNewLogger("SYNCV1", null);
    KonySyncLoggerObj.setIndirectionLevel = 1;
};
sync.log.getInstance = function() {
        if (typeof(KonySyncLoggerObj) === 'undefined') sync.log.loggerEngineInit();
        return KonySyncLoggerObj;
    }
    //  **************** End KonySyncLogger.js*******************
    //  **************** Start KonySyncMetadata.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
// gets the time when dbname was last syced
kony.sync.getLastSynctime = function(scopename, dbname, scallback) {
    sync.log.trace("Entering kony.sync.getLastSynctime");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, kony.sync.metaTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }, {
        key: kony.sync.metaTableFilterValue,
        value: "no filter"
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    kony.sync.single_select_execute(dbname, sql, params, scallback, errorCallback);

    function errorCallback(res) {
        sync.log.error("error occurred while getting timestamp since last sync", res);
        kony.sync.onDownloadCompletion(true, res);
    }
};
// gets the time when dbname was last syced
kony.sync.getLastSynctimeForUpload = function(scopename, dbname, scallback) {
    sync.log.trace("Entering kony.sync.getLastSynctimeForUpload ");

    function callback(rows) {
        sync.log.trace("Entering callback");
        var lastSyncTime = -1;
        var result = "";
        for (var i = 0; i < rows.length; i++) {
            var v = rows[i];
            if (v[kony.sync.metaTableSyncTimeColumn] !== "") {
                var str = v[kony.sync.metaTableSyncTimeColumn];
                var temp = kony.sync.tonumber(str.split(",")[1]);
                if ((lastSyncTime === -1)) {
                    lastSyncTime = temp;
                    result = str;
                } else if ((temp < lastSyncTime)) {
                    lastSyncTime = temp;
                    result = str;
                }
            }
            sync.log.info("Last TimeStamp since Upload :", lastSyncTime);
        }
        var resulttable = {};
        if ((lastSyncTime === -1)) {
            resulttable[kony.sync.metaTableSyncTimeColumn] = "";
            scallback([resulttable]);
        } else {
            resulttable[kony.sync.metaTableSyncTimeColumn] = result;
            scallback([resulttable]);
        }
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, [kony.sync.metaTableSyncTimeColumn]);
    kony.sync.qb_from(query, kony.sync.metaTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    kony.sync.single_select_execute(dbname, sql, params, callback, errorCallback);

    function errorCallback(res) {
        sync.log.error("error occurred while getting timestamp since last upload", res);
        kony.sync.onUploadCompletion(true, res);
    }
};
// gets the time when dbname was last synced
kony.sync.getLastSynctimeFilter1 = function(scopename, filter, dbname, scallback) {
    sync.log.trace("Entering kony.sync.getLastSynctimeFilter ");

    function isDataPresent(result) {
        sync.log.info("last sync time in filter :", result);

        function getscopeindex(resultcount) {
            sync.log.trace("Entering getscopeindex");

            function calscallback() {
                var table = {};
                table[kony.sync.metaTableSyncTimeColumn] = "";
                scallback([table]);
            }
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_set(query, {
                id: resultcount.length + 1,
                filtervalue: filter,
                scopename: scopename,
                versionnumber: 0,
                lastserversynccontext: "",
                replaysequencenumber: 0,
                lastgeneratedid: -1
            });
            kony.sync.qb_insert(query, kony.sync.metaTableName);
            var query_compile2 = kony.sync.qb_compile(query);
            var sql2 = query_compile2[0];
            var params2 = query_compile2[1];
            kony.sync.single_select_execute(dbname, sql2, params2, calscallback, errorCallback);
        }
        if (result.length === 1) {
            scallback(result);
        } else {
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_select(query, null);
            kony.sync.qb_from(query, kony.sync.metaTableName);
            var query_compile3 = kony.sync.qb_compile(query);
            var sql3 = query_compile3[0];
            var params3 = query_compile3[1];
            kony.sync.single_select_execute(dbname, sql3, params3, getscopeindex, errorCallback);
        }
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, [kony.sync.metaTableSyncTimeColumn]);
    kony.sync.qb_from(query, kony.sync.metaTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }, {
        key: kony.sync.metaTableFilterValue,
        value: filter
    }]);
    var query_compile1 = kony.sync.qb_compile(query);
    var sql1 = query_compile1[0];
    var params1 = query_compile1[1];
    kony.sync.single_select_execute(dbname, sql1, params1, isDataPresent, errorCallback);

    function errorCallback(res) {
        sync.log.error("error occurred while getting time-stamp since last upload for filter", res);
        kony.sync.onDownloadCompletion(true, res);
    }
};
/* gets the time when scopename with filter was last synced */
kony.sync.getLastSynctimeFilter = function(scopename, filter, dbname, callback) {
    sync.log.trace("Entering kony.sync.getLastSynctimeFilter ");
    var connection = kony.sync.getConnectionOnly(dbname, dbname, transactionErrorCallback);
    var isError = false;
    var result = [];
    if (connection !== null) {
        kony.db.transaction(connection, transactionCallback, transactionErrorCallback, transactionSuccessCallback);
    }

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.getLastSynctimeFilter->transactionCallback");
        //search for row with filter
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, [kony.sync.metaTableSyncTimeColumn]);
        kony.sync.qb_from(query, kony.sync.metaTableName);
        kony.sync.qb_where(query, [{
            key: kony.sync.metaTableScopeColumn,
            value: scopename
        }, {
            key: kony.sync.metaTableFilterValue,
            value: filter
        }]);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params);
        if (resultSet === false) {
            isError = true;
            return;
        }
        if (resultSet.rows.length >= 1) {
            result[0] = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
        } else { //if not found, insert it
            //get the count of rows in metainfo
            resultSet = kony.sync.executeSql(tx, "select * from " + kony.sync.metaTableName, null);
            if (resultSet === false) {
                isError = true;
                return;
            }
            //insert the filter
            query = kony.sync.qb_createQuery();
            kony.sync.qb_set(query, {
                id: resultSet.rows.length + 1,
                filtervalue: filter,
                scopename: scopename,
                versionnumber: 0,
                lastserversynccontext: "",
                lastserveruploadsynccontext: "",
                replaysequencenumber: 0,
                lastgeneratedid: -1
            });
            kony.sync.qb_insert(query, kony.sync.metaTableName);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            resultSet = kony.sync.executeSql(tx, sql, params);
            if (resultSet === false) {
                isError = true;
                return;
            }
            var table = {};
            table[kony.sync.metaTableSyncTimeColumn] = "";
            result[0] = table;
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.getLastSynctimeFilter->transactionSuccessCallback");
        callback(result);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering kony.sync.getLastSynctimeFilter->transactionErrorCallback");
        kony.sync.onDownloadCompletion(true, kony.sync.getTransactionError(isError));
    }
};
// Update the meta tables with last sync time
kony.sync.setLastSyncTime = function(tx, scopename, time, tickcount) {
    sync.log.trace("Entering kony.sync.setLastSyncTime ");
    var settable = {};
    if (kony.sync.schemaUpgradeDownloadPending) {
        settable[kony.sync.metaTableSchemaUpgradeSyncTimeColumn] = tickcount;
    } else {
        settable[kony.sync.metaTableSyncTimeColumn] = tickcount;
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, kony.sync.metaTableName);
    kony.sync.qb_set(query, settable);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }, {
        key: kony.sync.metaTableFilterValue,
        value: "no filter"
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
// Update the meta tables with last sync time
kony.sync.setLastSyncTimeFilter = function(tx, scopename, filter, time, tickcount) {
    sync.log.trace("Entering kony.sync.setLastSyncTimeFilter ");
    var settable = {};
    if (kony.sync.schemaUpgradeDownloadPending) {
        settable[kony.sync.metaTableSchemaUpgradeSyncTimeColumn] = tickcount;
    } else {
        settable[kony.sync.metaTableSyncTimeColumn] = tickcount;
    }
    //settable[kony.sync.metaTableFilterValue] = filter;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, kony.sync.metaTableName);
    kony.sync.qb_set(query, settable);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }, {
        key: kony.sync.metaTableFilterValue,
        value: filter
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
//function getseqnumber (connection,scopename)
kony.sync.getseqnumber = function(connection, scopename) {
    sync.log.trace("Entering kony.sync.getseqnumber ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, [kony.sync.metaTableSyncVersionCloumn]);
    kony.sync.qb_from(query, kony.sync.metaTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    //local sql = "select "..kony.sync.metaTableSyncVersionCloumn.." from "..kony.sync.metaTableName.." where "..kony.sync.metaTableScopeColumn.." = '"..scopename.."'";
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(connection, sql, params);
    if (resultset === false) {
        return false;
    }
    var rowItem = kony.db.sqlResultsetRowItem(connection, resultset, 0);
    return rowItem;
};
kony.sync.setSeqnumber = function(scopename, dsname, uploaded, callback) {
    sync.log.trace("Entering kony.sync.setSeqnumber ");
    var isStatementError = false;

    function transactionCallback(tx) {
        sync.log.trace("Entering transactionCallback");
        var settable = {};
        settable[kony.sync.metaTableSyncVersionCloumn] = uploaded;
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_update(query, kony.sync.metaTableName);
        kony.sync.qb_set(query, settable);
        kony.sync.qb_where(query, [{
            key: kony.sync.metaTableScopeColumn,
            value: scopename
        }]);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            isStatementError = true;
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.setSeqnumber->transactionSuccessCallback");
        callback();
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering kony.sync.setSeqnumber->transactionErrorCallback");
        sync.log.error("Error occurred while setting sequence number");
        if (!isStatementError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
    var connection = kony.sync.getConnectionOnly(dsname, dsname, transactionErrorCallback);
    if (connection !== null) {
        kony.db.transaction(connection, transactionCallback, transactionErrorCallback, transactionSuccessCallback);
    }
};
kony.sync.getSyncOrder = function(scopename, tx) {
    sync.log.trace("Entering kony.sync.getSyncOrder ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, kony.sync.metaTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(tx, sql, params);
    if (resultset !== false) {
        var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        sync.log.debug("sync order value" + rowItem);
        if (!kony.sync.isNullOrUndefined(rowItem[kony.sync.metaTableSyncOrderCloumn])) {
            return kony.sync.tonumber(rowItem[kony.sync.metaTableSyncOrderCloumn]);
        } else {
            return null;
        }
    } else {
        return false;
    }
};
kony.sync.clearSyncHistory = function(dbname, tablename) {
    sync.log.trace("Entering kony.sync.clearSyncHistory ");
    var sql = "delete from " + tablename + kony.sync.historyTableName;
    var wcs = " where konysyncchangetype NOT LIKE '9%'";
    var testsql = sql + wcs;
    kony.sync.single_execute_sql(dbname, testsql, null, null);
};
kony.sync.clearSyncOriginal = function(dbname, tbname) {
    sync.log.trace("Entering kony.sync.clearSyncOriginal ");
    var sql = "delete from " + tbname + kony.sync.originalTableName;
    kony.sync.single_execute_sql(dbname, sql, null, null);
};
kony.sync.clearDataForCOE = function(tx, scopename, tablename, wcs, newwcs, changeType, pkset, seqNo, values, isError) {
    sync.log.trace("Entering kony.sync.clearDataForCOE ");
    if (kony.sync.isNullOrUndefined(pkset) && isError) {
        return false;
    }
    var whereClause = kony.sync.CreateCopy(wcs);
    var query = null;
    var query_compile = null;
    var sql = null;
    var params = null;
    //hashSum also needs to be updated to avoid conflicts.
    var hashSum = values[kony.sync.historyTableHashSumColumn];
    //update the binary to UPLOAD ACCEPTED.
    //for onDemandColumns,
    var onDemandColumns = kony.sync.getBinaryColumnsByPolicy(tablename, kony.sync.onDemand);
    sync.log.trace("onDemandColumns for " + tablename + " are " + JSON.stringify(onDemandColumns));
    var pkTable = {};
    var binaryColumns = kony.sync.getBinaryColumns(tablename);
    for (var j = 0; j < wcs.length; j++) {
        pkTable[wcs[j].key] = wcs[j].value;
    }
    if (!kony.sync.isNullOrUndefined(binaryColumns)) {
        for (var j = 0; j < binaryColumns.length; j++) {
            if (kony.sync.getDownloadPolicy(tablename, binaryColumns[j]) !== kony.sync.inline) {
                var blobRef = kony.sync.getBlobRef(tx, tablename, binaryColumns[j], pkTable, updateBlobStatusCallback);
                sync.log.trace("blobRef for pkTable " + JSON.stringify(pkTable) + " is " + blobRef);
                if (blobRef !== kony.sync.blobRefNotFound && blobRef !== kony.sync.blobRefNotDefined) {
                    //fetch the current state of the blob before upload_accepting.
                    var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobRef, updateBlobStatusCallback);
                    if (!kony.sync.isNullOrUndefined(blobMeta) && blobMeta !== false) {
                        //if the blob entry is in valid state then accept the binary for upload.
                        if (blobMeta[kony.sync.blobManager.state] === kony.sync.blobManager.NO_OPERATION) {
                            sync.log.trace("marking the blob entry for UPLOAD for blob " + JSON.stringify(blobMeta));
                            var valuesTable = {};
                            valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.UPLOAD_ACCEPTED;
                            var results = kony.sync.blobManager.updateBlobManager(tx, blobRef, valuesTable, updateBlobStatusCallback);
                            if (results === null || results === false) {
                                return 0;
                            }
                            //increment total number of upload jobs..
                            kony.sync.incrementTotalJobs(false);
                            sync.log.trace("updated the state of the blob entry to UPLOAD_ACCEPTED");
                        } else {
                            sync.log.error("binary file not in a valid state to get picked for upload. ");
                            return 0;
                        }
                    } else {
                        return 0;
                    }
                }
                //invoke the notifier..
                kony.sync.invokeBinaryNotifiers(false);
            }
        }
    }
    //in case I got client pk from server
    if (!kony.sync.isNullOrUndefined(pkset)) {
        //update original table pk with new pk from server
        query = kony.sync.qb_createQuery();
        kony.sync.qb_update(query, tablename + kony.sync.originalTableName);
        kony.sync.qb_set(query, pkset);
        kony.sync.qb_where(query, whereClause);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            return 0;
        }
        //update main table pk with new pk from server
        query = kony.sync.qb_createQuery();
        kony.sync.qb_update(query, tablename);
        kony.sync.qb_set(query, pkset);
        kony.sync.qb_where(query, whereClause);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            return 0;
        }
        //update history table pk with new pk from server
        pkset[kony.sync.historyTableHashSumColumn] = hashSum;
        query = kony.sync.qb_createQuery();
        kony.sync.qb_update(query, tablename + kony.sync.historyTableName);
        kony.sync.qb_set(query, pkset);
        kony.sync.qb_where(query, whereClause);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            return 0;
        }
        if (isError) {
            return false;
        }
        kony.sync.serverInsertAckCount = kony.sync.serverInsertAckCount + 1;
        kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInsertedAck] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInsertedAck] + 1;
        whereClause = kony.sync.CreateCopy(newwcs);
    } else if (changeType === "update") {
        //update history table hashSum for pending records
        if (!kony.sync.isNullOrUndefined(hashSum)) {
            var updateSet = {};
            updateSet[kony.sync.historyTableHashSumColumn] = hashSum;
            query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, tablename + kony.sync.historyTableName);
            kony.sync.qb_set(query, updateSet);
            kony.sync.qb_where(query, whereClause);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return 0;
            }
        }
        /*TODO: non-autogenerated insert ack is currently considered as update ack*/
        kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdatedAck] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdatedAck] + 1;
        kony.sync.serverUpdateAckCount = kony.sync.serverUpdateAckCount + 1;
    } else if (changeType === "delete") {
        kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeletedAck] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeletedAck] + 1;
        kony.sync.serverDeleteAckCount = kony.sync.serverDeleteAckCount + 1;
    }
    //TODO - throw error.
    function updateBlobStatusCallback(err) {
        sync.log.error("error in blobStoreManager update. --> clearDataForCOE " + JSON.stringify(err));
    }
    if (kony.sync.clearHistoryTable(tx, tablename, whereClause, seqNo) === false) {
        return 0;
    }
    return kony.sync.clearMainTableForRemoveAfterUpload(tx, scopename, tablename, whereClause);
};
kony.sync.clearMainTableForRemoveAfterUpload = function(tx, scopename, tablename, wcs) {
    sync.log.trace("Entering kony.sync.clearMainTableForRemoveAfterUpload ");
    var whereClause = kony.sync.CreateCopy(wcs);
    var removeAfterUpload = kony.sync.checkForDeleteAfterUpload(tablename, scopename);
    //Get records to be deleted from history table;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
    kony.sync.qb_where(query, whereClause);
    kony.sync.qb_distinct(query);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet === false) {
        return 0;
    }
    //don't remove from main and original tables if there is pending records in history table
    if (resultSet.rows.length !== 0) {
        return false;
    }
    //remove from original table
    if (kony.sync.clearOriginalTable(tx, tablename, wcs) === false) {
        return 0;
    }
    if (removeAfterUpload) {
        if (kony.sync.isNullOrUndefined(whereClause)) {
            whereClause = [];
        }
        query = kony.sync.qb_createQuery();
        kony.sync.qb_delete(query, tablename);
        kony.sync.qb_where(query, wcs);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            return 0;
        }
        return true;
    } else {
        return false;
    }
};
kony.sync.clearHistoryTable = function(tx, tablename, wcs, seqNo) {
    sync.log.trace("Entering kony.sync.clearHistoryTable ");
    var whereClause = kony.sync.CreateCopy(wcs);
    if (kony.sync.isNullOrUndefined(whereClause)) {
        whereClause = [];
    }
    if (!kony.sync.isNullOrUndefined(seqNo)) {
        kony.table.insert(whereClause, {
            key: kony.sync.historyTableReplaySequenceColumn,
            value: seqNo,
            optype: "LT_EQ"
        });
    }
    kony.table.insert(whereClause, {
        key: kony.sync.historyTableChangeTypeColumn,
        value: "9%",
        optype: "NOT LIKE"
    });
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_delete(query, tablename + kony.sync.historyTableName);
    kony.sync.qb_where(query, whereClause);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
kony.sync.getRecordsTobeDeletedFromHistoryTable = function(tx, tablename, seqNo) {
    sync.log.trace("Entering kony.sync.getRecordsTobeDeletedFromHistoryTable ");
    var whereClause = [];
    var records = false;
    kony.table.insert(whereClause, {
        key: kony.sync.historyTableReplaySequenceColumn,
        value: seqNo,
        optype: "LT_EQ"
    });
    //Get PK columns
    var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
    //Get records to be deleted from history table;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, pkColumns);
    kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
    kony.sync.qb_where(query, whereClause);
    kony.sync.qb_distinct(query);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet !== false) {
        records = [];
        var i = 0;
        for (; i < resultSet.rows.length; i++) {
            records.push(kony.db.sqlResultsetRowItem(tx, resultSet, i));
        }
        return records;
    } else {
        return false;
    }
};
kony.sync.clearOriginalTable = function(tx, tablename, wcs, seqNo) {
    sync.log.trace("Entering kony.sync.clearOriginalTable ");
    var whereClause = kony.sync.CreateCopy(wcs);
    var query = null;
    var query_compile = null;
    var sql = null;
    var params = null;
    if (!kony.sync.isNull(seqNo)) {
        whereClause = [];
        kony.table.insert(whereClause, {
            key: kony.sync.historyTableReplaySequenceColumn,
            value: seqNo,
            optype: "LT_EQ"
        });
        //Get PK columns
        var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
        //Get records to be deleted from history table;
        query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, pkColumns);
        kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
        kony.sync.qb_where(query, whereClause);
        kony.sync.qb_distinct(query);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params);
        if (resultSet === false) {
            return false;
        }
        var rowItem = null;
        var i = 0;
        var j = 0;
        var originaltbname = tablename + kony.sync.originalTableName;
        for (; i < resultSet.rows.length; i++) {
            rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            whereClause = [];
            for (j = 0; j < pkColumns.length; j++) {
                kony.table.insert(whereClause, {
                    key: pkColumns[j],
                    value: rowItem[pkColumns[j]],
                    optype: "EQ"
                });
            }
            query = kony.sync.qb_createQuery();
            kony.sync.qb_delete(query, originaltbname);
            kony.sync.qb_where(query, whereClause);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return false;
            }
        }
        return true;
    } else {
        query = kony.sync.qb_createQuery();
        kony.sync.qb_delete(query, tablename + kony.sync.originalTableName);
        if (!kony.sync.isNull(whereClause)) {
            kony.sync.qb_where(query, whereClause);
        }
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        return kony.sync.executeSql(tx, sql, params);
    }
};
//calls resets sync order for a scope if all the history tables are empty
kony.sync.updateSyncOrderForScope = function(callback) {
    sync.log.trace("Entering kony.sync.updateSyncOrderForScope ");
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var scopename = kony.sync.currentScope[kony.sync.scopeName];
    var isError = false;
    var sql = null;
    var params = null;
    var query = null;
    var query_compile = null;
    kony.sync.getConnection(dbname, dbname, myTransactionCallBack, clear_success, clear_fail);

    function myTransactionCallBack(tx) {
        sync.log.trace("Entering myTransactionCallBack");
        var recordcount = 0;
        var versionNo = kony.sync.getseqnumber(tx, scopename);
        if (!kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables)) {
            for (var i = 0; i < kony.sync.currentScope.ScopeTables.length; i++) {
                var syncTable = kony.sync.currentScope.ScopeTables[i];
                if (kony.sync.isNullOrUndefined(syncTable)) {
                    continue;
                }
                var tbname = syncTable.Name;
                query = kony.sync.qb_createQuery();
                kony.sync.qb_select(query, null);
                kony.sync.qb_from(query, tbname + kony.sync.historyTableName);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                var resultSet = kony.sync.executeSql(tx, sql, params);
                if (resultSet !== false) {
                    var num_records = resultSet.rows.length;
                    recordcount = recordcount + num_records;
                    if (num_records > 0) {
                        var versionMap = {};
                        versionMap[kony.sync.historyTableSyncVersionColumn] = versionNo.versionnumber;
                        var whereClause = [];
                        kony.table.insert(whereClause, {
                            key: kony.sync.historyTableChangeTypeColumn,
                            value: "9%",
                            optype: "NOT LIKE"
                        });
                        query = kony.sync.qb_createQuery();
                        kony.sync.qb_update(query, tbname + kony.sync.historyTableName);
                        kony.sync.qb_set(query, versionMap);
                        kony.sync.qb_where(query, whereClause);
                        query_compile = kony.sync.qb_compile(query);
                        sql = query_compile[0];
                        params = query_compile[1];
                        if (kony.sync.executeSql(tx, sql, params) === false) {
                            isError = true;
                            return;
                        }
                    }
                } else {
                    isError = true;
                    return;
                }
            }
        }
        if (recordcount === 0) {
            if (kony.sync.updateSyncOrder(tx, scopename) === false) {
                isError = true;
                return;
            }
        }
    }

    function clear_fail() {
        sync.log.trace("Entering clear_fail");
        //kony.sync.downloadFailed(isError);
        if (isError) {
            callback(kony.sync.errorCodeSQLStatement);
        } else {
            callback(kony.sync.errorCodeTransaction);
        }
    }

    function clear_success() {
        sync.log.trace("Entering clear_success");
        if (callback != null) {
            callback(0);
        }
    }
};
//resets sync order for a scope
kony.sync.updateSyncOrder = function(tx, scopename) {
    sync.log.trace("Entering kony.sync.updateSyncOrder ");
    var settable = {};
    settable[kony.sync.metaTableSyncOrderCloumn] = 0;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, kony.sync.metaTableName);
    kony.sync.qb_set(query, settable);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
kony.sync.clearSyncOrder = function(dbname, limit, serverblob, deleteLastUploadRequest, callback) {
    sync.log.trace("Entering kony.sync.clearSyncOrder ");
    var recordcount = 0;
    var isError = false;
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, clear_fail);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, clear_transaction, clear_fail, clear_success);
    }

    function clear_transaction(tx) {
        sync.log.trace("Entering clear_transaction");
        var resultSet = null;
        var query_compile = null;
        var sql = null;
        var params = null;
        //updating sync version for all records going in next batch
        if (kony.sync.updateSyncOrderForUploadBatching(tx, limit) === false) {
            isError = true;
            return;
        }
        //updating upload timestamp
        if (kony.sync.setLastSyncUploadContext(tx, kony.sync.currentScope[kony.sync.scopeName], serverblob) === false) {
            isError = true;
            return;
        }
        //delete last upload request
        if (kony.sync.deleteLastUploadRequest(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
            isError = true;
            return;
        }
        //Just returning from here, as this is getting handled in clearDataForCOE function, below code is redundant
        return;
        if (kony.sync.isUploadErrorPolicyCOE(kony.sync.currentScope)) {
            return;
        }
        if (!kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables)) {
            for (var i = 0; i < kony.sync.currentScope.ScopeTables.length; i++) {
                var syncTable = kony.sync.currentScope.ScopeTables[i];
                if (kony.sync.isNullOrUndefined(syncTable)) {
                    continue;
                }
                var tbname = syncTable.Name;
                //get whether table is marked for removeAfterUpload
                var removeAfterUpload = kony.sync.checkForDeleteAfterUpload(tbname, kony.sync.currentScope[kony.sync.scopeName]);
                //get Records To be deleted From History Table
                var records = kony.sync.getRecordsTobeDeletedFromHistoryTable(tx, tbname, limit);
                if (records === false) {
                    isError = true;
                    return;
                }
                //clearing history table
                if (kony.sync.clearHistoryTable(tx, tbname, null, limit) === false) {
                    isError = true;
                    return;
                }
                var pkColumns = kony.sync.currentScope.syncTableDic[tbname].Pk_Columns;
                for (var k = 0; k < records.length; k++) {
                    //preparing where clause
                    var whereClause = [];
                    for (var j = 0; j < pkColumns.length; j++) {
                        kony.table.insert(whereClause, {
                            key: pkColumns[j],
                            value: records[k][pkColumns[j]],
                            optype: "EQ"
                        });
                    }
                    var query = kony.sync.qb_createQuery();
                    kony.sync.qb_select(query, null);
                    kony.sync.qb_from(query, tbname + kony.sync.historyTableName);
                    kony.sync.qb_where(query, whereClause);
                    query_compile = kony.sync.qb_compile(query);
                    sql = query_compile[0];
                    params = query_compile[1];
                    resultSet = kony.sync.executeSql(tx, sql, params);
                    if (resultSet === false) {
                        isError = true;
                        return;
                    }
                    //delete records from original and main tables if there is  no pending record in history table
                    if (resultSet.rows.length === 0) {
                        query = kony.sync.qb_createQuery();
                        kony.sync.qb_delete(query, tbname + kony.sync.originalTableName);
                        kony.sync.qb_where(query, whereClause);
                        query_compile = kony.sync.qb_compile(query);
                        sql = query_compile[0];
                        params = query_compile[1];
                        if (kony.sync.executeSql(tx, sql, params) === false) {
                            isError = true;
                            return;
                        }
                        //remove value if table is marked for removeAfterUpload
                        if (removeAfterUpload) {
                            query = kony.sync.qb_createQuery();
                            kony.sync.qb_delete(query, tbname);
                            kony.sync.qb_where(query, whereClause);
                            query_compile = kony.sync.qb_compile(query);
                            sql = query_compile[0];
                            params = query_compile[1];
                            if (kony.sync.executeSql(tx, sql, params) === false) {
                                isError = true;
                                return;
                            }
                        }
                    }
                }
                //currently disabling removeafterupload for P scope
                //kony.sync.clearMainTableForRemoveAfterUpload(tx, scopename, tbname, null);
                //couting deferred uploads
                sql = "select * from " + tbname + kony.sync.historyTableName;
                resultSet = kony.sync.executeSql(tx, sql, null);
                if (resultSet === false) {
                    isError = true;
                    return;
                }
                var num_records = resultSet.rows.length;
                recordcount = recordcount + num_records;
            }
        }
        if (recordcount === 0) {
            if (kony.sync.updateSyncOrder(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
                isError = true;
            }
        }
    }

    function clear_success() {
        sync.log.trace("Entering kony.sync.clearsyncorder->clear_success");
        callback();
    }

    function clear_fail() {
        sync.log.trace("Entering kony.sync.clearsyncorder->clear_fail");
        if (!isError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
};
kony.sync.setSyncOrder = function(scopename, syncorder, tx, errorCallback) {
    sync.log.trace("Entering kony.sync.setSyncOrder ");
    var settable = {};
    settable[kony.sync.metaTableSyncOrderCloumn] = syncorder;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, kony.sync.metaTableName);
    kony.sync.qb_set(query, settable);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    //local sql = "update ".. kony.sync.metaTableName.." set "..kony.sync.metaTableSyncOrderCloumn.."="..syncorder .." where "..kony.sync.metaTableScopeColumn.." = '".. scopename .."'";
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    sync.log.debug("setting sync order", sql);
    return kony.sync.executeSql(tx, sql, params, errorCallback);
};
kony.sync.getLastGeneratedID = function(scopename, tx, errorCallback) {
    sync.log.trace("Entering kony.sync.getLastGeneratedID ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, [kony.sync.metaTableLastGeneratedId]);
    kony.sync.qb_from(query, kony.sync.metaTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    //local sql = "select "..kony.sync.metaTableLastGeneratedId.." from "..kony.sync.metaTableName.." where "..kony.sync.metaTableScopeColumn.." = '"..scopename.."'";
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    sync.log.debug("getting lastgeneratedid", sql);
    var resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset === false) {
        return false;
    }
    sync.log.debug("result", resultset);
    var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
    sync.log.debug("rowItem", rowItem);
    if (!kony.sync.isNullOrUndefined(rowItem[kony.sync.metaTableLastGeneratedId])) {
        return rowItem[kony.sync.metaTableLastGeneratedId];
    } else {
        //It should never come here
        sync.log.fatal("Last Generated ID is null");
        return false;
    }
};
kony.sync.setLastGeneratedID = function(scopename, lastgeneratedid, tx, errorCallback) {
    sync.log.trace("Entering kony.sync.setLastGeneratedID ");
    var settable = {};
    settable[kony.sync.metaTableLastGeneratedId] = lastgeneratedid;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, kony.sync.metaTableName);
    kony.sync.qb_set(query, settable);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    //local sql = "update ".. kony.sync.metaTableName.." set "..kony.sync.metaTableLastGeneratedId.."="..lastgeneratedid .." where "..kony.sync.metaTableScopeColumn.." = '".. scopename .."'";
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    sync.log.debug("setting sync order", sql);
    return kony.sync.executeSql(tx, sql, params, errorCallback);
};
//  **************** End KonySyncMetadata.js*******************
//  **************** Start KonySyncORMAPI.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
kony.sync.updateByPK = function(tbname, dbname, relationshipMap, pks, valuestable, successcallback, errorcallback, markForUpload, wcs) {
    sync.log.trace("Entering kony.sync.updateByPK -> main function");
    var isSuccess = true;
    var pkNotFound = false;
    var isRefIntegrityError = false;
    var isMarkForuploadInvalid = false;
    var updateResult = null;
    var errObject = null;
    var twcs = [];
    twcs = kony.sync.CreateCopy(wcs);

    function single_execute_sql_transaction(tx) {
        sync.log.trace("Entering kony.sync.updateByPK -> single_execute_sql_transaction ");
        var record = "";
        if (kony.sync.enableORMValidations) {
            record = kony.sync.getOriginalRow(tx, tbname, wcs, errorcallback);
            if (record === false) {
                isSuccess = false;
                return;
            }
        }
        if (null !== record || !kony.sync.enableORMValidations) {
            errObject = kony.sync.checkIntegrityinTransaction(tx, relationshipMap);
            if (errObject === false) {
                isSuccess = false;
                return;
            } else if (errObject !== true) {
                isSuccess = false;
                isRefIntegrityError = true;
                kony.sync.rollbackTransaction(tx);
                return;
            } else {
                var blobMap = {};
                if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
                    var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
                    for (var i = 0; i < binaryColumns.length; i++) {
                        if (!kony.sync.isNullOrUndefined(valuestable[binaryColumns[i]]) && valuestable[binaryColumns[i]].length > 0) blobMap[binaryColumns[i]] = valuestable[binaryColumns[i]];
                        delete valuestable[binaryColumns[i]];
                    }
                }
                updateResult = kony.sync.update(tx, tbname, valuestable, wcs, markForUpload, errorcallback);
                if (updateResult === false) {
                    isSuccess = false;
                } else if (updateResult === kony.sync.errorCodeInvalidMarkForUploadValue) {
                    isMarkForuploadInvalid = true;
                    isSuccess = false;
                } else {
                    if (Object.keys(blobMap).length > 0) {
                        var blobStoreIndices = kony.sync.blobstore_update(tx, tbname, blobMap, wcs, false, errorcallback);
                        if (!kony.sync.isNullOrUndefined(blobStoreIndices)) {
                            if (Object.keys(blobStoreIndices).length > 0) {
                                var results = kony.sync.blobManager.updateParentWithBlobReference(tx, tbname, blobStoreIndices, wcs, errorcallback);
                                if (results === false || results === null) {
                                    isSuccess = false;
                                }
                            }
                        } else {
                            isSuccess = false;
                        }
                    }
                }
            }
        } else {
            pkNotFound = true;
        }
    }

    function single_transactionErrorCallback() {
        sync.log.error("Entering kony.sync.updatebyPK->single_transactionErrorCallback ");
        if (isSuccess) {
            kony.sync.showTransactionError(errorcallback);
        } else if (isRefIntegrityError === true) {
            kony.sync.verifyAndCallClosure(errorcallback, errObject);
        } else {
            kony.sync.verifyAndCallClosure(errorcallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }

    function single_execute_sql_transactionSucessCallback() {
        sync.log.trace("Entering kony.sync.updateByPK->single_execute_sql_transactionSucessCallback -> isSuccess -> " + isSuccess);
        if (pkNotFound === true) {
            kony.sync.pkNotFoundErrCallback(errorcallback, tbname);
            return;
        } else if (isMarkForuploadInvalid) {
            errorcallback(kony.sync.getErrorTable(kony.sync.errorCodeInvalidMarkForUploadValue, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidMarkForUploadValue, tbname)));
        } else if (isSuccess === false) {
            kony.sync.pkNotFoundErrCallback(errorcallback, tbname);
            return;
        } else {
            kony.sync.verifyAndCallClosure(successcallback, {
                rowsupdated: 1
            });
        }
    }
    try {
        var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
        if (dbconnection !== null) {
            kony.sync.startTransaction(dbconnection, single_execute_sql_transaction, single_execute_sql_transactionSucessCallback, single_transactionErrorCallback, "Single Execute");
        }
    } catch (e) {
        sync.log.error("Unknown error occurred during update", e);
        kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorUnknown, kony.sync.getErrorMessage(kony.sync.errorUnknown, "Rollback", e), null));
    }
};
kony.sync.checkForFalseUpdateInTransaction = function(tx, dbname, tbname, twcs, markForUpload, errorcallback) {
    sync.log.trace("Entering kony.sync.checkForFalseUpdate ");
    if (kony.sync.getUploadStatus(markForUpload)) {
        return true;
    } else {
        kony.table.insert(twcs, {
            key: kony.sync.historyTableChangeTypeColumn,
            value: "90",
            optype: "EQ",
            comptype: "AND"
        });
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, [kony.sync.historyTableChangeTypeColumn]);
        kony.sync.qb_from(query, tbname + "_history");
        kony.sync.qb_where(query, twcs);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params, errorcallback);
        if ((resultSet !== false)) {
            var num_records = resultSet.rows.length;
            if (num_records !== 0) {
                sync.log.error("Record does not exist on server, mark it for upload before updating/deleting it");
                return kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeMarkForUpload, kony.sync.getErrorMessage(kony.sync.errorCodeMarkForUpload), null));
            }
        } else {
            return false;
        }
        return true;
    }
};
//  **************** End KonySyncORMAPI.js*******************
//  **************** Start konySyncQueryBuilder.js*******************
//-------------------------Sample Query Table for reference----------------------------
//sqlquery={
//	["schemaname"] = "",
//	["tablename"]= "",
//	["operationtype"] = "" { Insert, Select, Update, Delete, Custom },
//	["orderbyclause"]="",
//	["topclause"]="",
//  ["isPurge"]=true/false This condition will make insert statement to insert ignore.
//	["purgeValues"] = "";
//	multiple conditions
//	["conditions"]={
//		{
//			["key"]=""
//			["value"]=""
//			["optype"]="" { EQ, NOT_EQ, GT, GT_EQ, LT, LT_EQ, LIKE, JOIN }	 
//			["comptype"]="" { AND, OR }
//			["binary"]="" {true,false}
//		},
//		{
//			["key"]=""
//			["value"]=""
//			["optype"]=""
//			["value"]=""
//		}
//	},
//	["fields"]={
//		"c1","c2","c3"		
//	},
//	["colvals"]={
//		{
//			["key"]="cname"
//			["value"]="vname"
//		},
//		{
//			["key"]="cname"
//			["value"]="vname"
//		}
//	}
//}
//function qb_createQuery()
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.qb_createQuery = function() {
    sync.log.trace("Entering kony.sync.qb_createQuery ");
    return {
        topclause: "",
        distinctclause: "",
        orderbyclause: "",
        colvals: [],
        conditions: [],
        paramindex: 0
    };
};
kony.sync.qb_where = function(query, conditions) {
    sync.log.trace("Entering kony.sync.qb_where ");
    if (kony.sync.isNullOrUndefined(conditions)) {
        return;
    }
    for (var i = 0; i < conditions.length; i++) {
        var cond = conditions[i];
        var condition = {};
        if (kony.sync.isNullOrUndefined(cond.optype)) {
            cond.optype = "EQ";
        }
        if (kony.sync.isNullOrUndefined(cond.comptype)) {
            cond.comptype = "AND";
        }
        condition.key = cond.key;
        condition.optype = cond.optype;
        condition.value = cond.value;
        condition.comptype = cond.comptype;
        condition.openbrace = cond.openbrace;
        condition.closebrace = cond.closebrace;
        kony.table.insert(query.conditions, condition);
    }
};
kony.sync.qb_insert = function(query, tablename) {
    sync.log.trace("Entering kony.sync.qb_insert ");
    query.operationtype = "insert";
    query.tablename = tablename;
};
kony.sync.qb_purgeInsert = function(query, tablename, values) {
    sync.log.trace("Entering kony.sync.qb_purgeInsert ");
    query.operationtype = "insert";
    query.tablename = tablename;
    query.isPurge = true;
    if (kony.sync.isNullOrUndefined(kony.sync.queryStore[tablename + "purgeInsert"])) {
        kony.sync.qb_set(query, values);
    } else {
        query.purgeValues = values;
    }
};
kony.sync.qb_delete = function(query, tablename) {
    sync.log.trace("Entering kony.sync.qb_delete ");
    query.operationtype = "delete";
    query.tablename = tablename;
};
kony.sync.qb_update = function(query, tablename) {
    sync.log.trace("Entering kony.sync.qb_update ");
    query.operationtype = "update";
    query.tablename = tablename;
};
kony.sync.qb_select = function(query, fields) {
    sync.log.trace("Entering kony.sync.qb_select ");
    query.operationtype = "select";
    query.fields = fields;
};
kony.sync.qb_from = function(query, tablename) {
    sync.log.trace("Entering kony.sync.qb_from ");
    query.tablename = tablename;
};
kony.sync.qb_set = function(query, tabcolval) {
    sync.log.trace("Entering kony.sync.qb_set ");
    for (var key in tabcolval) {
        if (typeof(tabcolval[key]) != "function") {
            var value = tabcolval[key];
            if (!kony.sync.isNullOrUndefined(value)) {
                var colval = [];
                colval.key = key;
                colval.value = value;
                kony.table.insert(query.colvals, colval);
            }
        }
    }
};
kony.sync.qb_top = function(query, topno) {
    sync.log.trace("Entering kony.sync.qb_top ");
    query.topclause = " Top " + topno + " ";
};
kony.sync.qb_orderBy = function(query, orderByMap) {
    sync.log.trace("Entering kony.sync.qb_orderBy ");
    var orderByClause = "";
    if (!kony.sync.isNullOrUndefined(orderByMap)) {
        orderByClause = " order by ";
        var j = 0;
        for (var i in orderByMap) {
            if (j === 0) {
                orderByClause = orderByClause + " \"" + orderByMap[i].key + "\"";
                j++;
            } else {
                orderByClause = orderByClause + ",\"" + orderByMap[i].key + "\"";
            }
            if (orderByMap[i].sortType === "desc") {
                orderByClause = orderByClause + " desc";
            }
        }
    }
    query.orderbyclause = orderByClause;
};
kony.sync.qb_distinct = function(query) {
    sync.log.trace("Entering kony.sync.qb_distinct ");
    query.distinctclause = " distinct ";
};
kony.sync.qb_orderby1 = function(query, colname, isasec) {
    sync.log.trace("Entering kony.sync.qb_orderby1 ");
    if ((isasec)) {
        query.orderbyclause = " order by \"" + colname + "\"";
    } else {
        query.orderbyclause = " order by \"" + colname + "\" desc ";
    }
};
kony.sync.qb_createParam = function(pkey, query, pval, params) {
    sync.log.trace("Entering kony.sync.qb_createParam ");
    if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLLite)) {
        kony.table.insert(params, pval);
        return "?";
    } else if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLCE)) {
        query.paramindex = query.paramindex + 1;
        var param = "@" + pkey + query.paramindex;
        params[param] = pval;
        return param;
    }
};
kony.sync.qb_getupdatedfields = function(query) {
    sync.log.trace("Entering kony.sync.qb_getupdatedfields ");
    var updateStr = "";
    for (var i = 0; i < query.colvals; i++) {
        var v = query.colvals[i];
        if (i === 0) {
            updateStr = " set ";
        }
        if (v.value === "nil") {
            updateStr = updateStr + " \"" + v.key + "\"=" + "null";
        } else {
            updateStr = updateStr + " \"" + v.key + "\"=" + "'" + v.value + "'";
        }
        if (i < query.colvals.length - 1) {
            updateStr = updateStr + ",";
        }
    }
    return updateStr;
};
kony.sync.qb_getparamupdatedfields = function(query) {
    sync.log.trace("Entering kony.sync.qb_getparamupdatedfields ");
    var updateStr = "";
    var params = [];
    for (var i = 0; i < query.colvals.length; i++) {
        var v = query.colvals[i];
        if (i === 0) {
            updateStr = " set ";
        }
        if ((v.value === "nil")) {
            updateStr = updateStr + " \"" + v.key + "\"=" + "null";
        } else {
            var param = kony.sync.qb_createParam(v.key, query, v.value, params);
            updateStr = updateStr + " \"" + v.key + "\"=" + param;
        }
        if (i < query.colvals.length - 1) {
            updateStr = updateStr + ",";
        }
    }
    return [updateStr, params];
};
kony.sync.qb_getfieldstring = function(query) {
    sync.log.trace("Entering kony.sync.qb_getfieldstring ");
    var retstr = "";
    if (!kony.sync.isNullOrUndefined(query.fields)) {
        for (var i = 0; i < query.fields.length; i++) {
            var field = query.fields[i];
            retstr = retstr + field;
            if (query.fields.length - 1 !== i) {
                retstr = retstr + ",";
            }
        }
        return retstr;
    } else {
        return "*";
    }
};
kony.sync.qb_getoperatorString = function(optype, isnull) {
    sync.log.trace("Entering kony.sync.qb_getoperatorString ");
    if ((optype === "EQ")) {
        if ((isnull)) {
            return " is ";
        } else {
            return " = ";
        }
    } else if ((optype === "NOT_EQ")) {
        if ((isnull)) {
            return " is not ";
        } else {
            if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLCE)) {
                return " !== ";
            } else if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLLite)) {
                return " <> ";
            }
        }
    } else if ((optype === "GT")) {
        return " > ";
    } else if ((optype === "GT_EQ")) {
        return " >= ";
    } else if ((optype === "LT")) {
        return " < ";
    } else if ((optype === "LT_EQ")) {
        return " <= ";
    } else if ((optype === "LIKE")) {
        return " LIKE ";
    } else if ((optype === "NOT LIKE")) {
        return " NOT LIKE ";
    } else {
        return "";
    }
    return "MARS";
};
kony.sync.qb_getcompstring = function(comptype) {
    sync.log.trace("Entering kony.sync.qb_getcompstring ");
    if ((comptype === "AND")) {
        return " AND ";
    } else if ((comptype === "OR")) {
        return " OR ";
    } else {
        return "";
    }
};
kony.sync.qb_getwhereclause = function(query) {
    sync.log.trace("Entering kony.sync.qb_getwhereclause ");
    var retstr = "";
    if (!kony.sync.isNullOrUndefined(query.conditions)) {
        for (var i = 0; i < query.conditions.length; i++) {
            var condition = query.conditions[i];
            if (i === 0) {
                retstr = " WHERE ";
            }
            var conditionString = "";
            if ((condition.value === "nil")) {
                conditionString = "\"" + condition.key + "\" " + kony.sync.qb_getoperatorString(condition.optype, true) + "null";
            } else {
                conditionString = "\"" + condition.key + "\" " + kony.sync.qb_getoperatorString(condition.optype, false) + "'" + condition.value + "' ";
            }
            if (condition.openbrace === true) {
                conditionString = " ( " + conditionString;
            }
            if (condition.closebrace === true) {
                conditionString = conditionString + ")";
            }
            retstr = retstr + conditionString;
            if (i !== query.conditions.length - 1) {
                retstr = retstr + kony.sync.qb_getcompstring(condition.comptype);
            }
        }
    }
    return retstr;
};
kony.sync.qb_getparamwhereclause = function(query) {
    sync.log.trace("Entering kony.sync.qb_getparamwhereclause ");
    var retstr = "";
    var params = [];
    if (!kony.sync.isNullOrUndefined(query.conditions)) {
        for (var i = 0; i < query.conditions.length; i++) {
            var condition = query.conditions[i];
            if (i === 0) {
                retstr = " WHERE ";
            }
            var conditionString = "";
            if ((condition.value === "nil")) {
                conditionString = condition.key + kony.sync.qb_getoperatorString(condition.optype, true) + "null";
            } else {
                var param = kony.sync.qb_createParam(condition.key, query, condition.value, params);
                conditionString = condition.key + kony.sync.qb_getoperatorString(condition.optype, false) + param;
            }
            if (condition.openbrace === true) {
                conditionString = " ( " + conditionString;
            }
            if (condition.closebrace === true) {
                conditionString = conditionString + ")";
            }
            retstr = retstr + conditionString;
            if (i !== query.conditions.length - 1) {
                retstr = retstr + kony.sync.qb_getcompstring(condition.comptype);
            }
        }
    }
    return [retstr, params];
};
kony.sync.qb_getinsertcolums = function(query) {
    sync.log.trace("Entering kony.sync.qb_getinsertcolums ");
    var retstr = "(";
    var numCols = query.colvals.length;
    var count = 0;
    if (numCols === 0) {
        return "";
    }
    if (!kony.sync.isNullOrUndefined(query.colvals)) {
        for (var i = 0; i < query.colvals.length; i++) {
            var colval = query.colvals[i];
            count = count + 1;
            retstr = retstr + "\"" + colval.key + "\"";
            if ((count !== numCols)) {
                retstr = retstr + ",";
            }
        }
    }
    retstr = retstr + ")";
    return retstr;
};
kony.sync.qb_getinsertvalues = function(query) {
    sync.log.trace("Entering kony.sync.qb_getinsertvalues ");
    var retstr = "(";
    var numCols = query.colvals.length;
    if (numCols === 0) {
        return "";
    }
    if (!kony.sync.isNullOrUndefined(query.colvals)) {
        for (var i = 0; i < query.colvals.length; i++) {
            var colval = query.colvals[i];
            var value = "";
            if ((colval === "nil")) {
                value = "NULL";
            } else {
                value = "'" + colval.value + "'";
            }
            retstr = retstr + value;
            if ((i !== numCols)) {
                retstr = retstr + ",";
            }
        }
    }
    retstr = retstr + ")";
    return retstr;
};
kony.sync.qb_getparaminsertvalues = function(query) {
    sync.log.trace("Entering kony.sync.qb_getparaminsertvalues ");
    var retstr = "(";
    var params = [];
    var numCols = query.colvals.length;
    if (numCols === 0) {
        return "";
    }
    if (!kony.sync.isNullOrUndefined(query.colvals)) {
        for (var i = 0; i < query.colvals.length; i++) {
            var colval = query.colvals[i];
            var value = "";
            if ((colval === "nil")) {
                value = "NULL";
            } else {
                var param = kony.sync.qb_createParam(colval.key, query, colval.value, params);
                value = param;
            }
            retstr = retstr + value;
            if (i !== numCols - 1) {
                retstr = retstr + ",";
            }
        }
    }
    retstr = retstr + ")";
    return [retstr, params];
};
kony.sync.qb_gettablename = function(query) {
    sync.log.trace("Entering kony.sync.qb_gettablename ");
    return query.tablename;
};
//lmit and offset  for select
kony.sync.qb_limitOffset = function(query, limit, offset) {
    sync.log.trace("Entering kony.sync.qb_limitOffset ");
    if (!kony.sync.isNullOrUndefined(limit)) {
        if (kony.sync.isNullOrUndefined(offset)) {
            offset = 0;
        }
        if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLLite)) {
            query.limit = limit;
            query.offset = offset;
        }
    }
};
kony.sync.qb_compile = function(query) {
    sync.log.trace("Entering kony.sync.qb_compile ");
    var params = null;
    var sql = null;
    var wctable = null;
    var wc = null;
    var ret = null;
    if ((kony.sync.isParameter)) {
        ret = "";
        if ((query.operationtype === "insert")) {
            var insertstring = "";
            insertstring = "insert or ignore into ";
            if (query.isPurge === true) {
                if (!kony.sync.isNullOrUndefined(kony.sync.queryStore[query.tablename + "purgeInsert"])) {
                    return [kony.sync.queryStore[query.tablename + "purgeInsert"], query.purgeValues];
                }
            }
            var itable = kony.sync.qb_getparaminsertvalues(query);
            var iv = itable[0];
            params = itable[1];
            sql = insertstring + "\"" + kony.sync.qb_gettablename(query) + "\"" + kony.sync.qb_getinsertcolums(query) + " values " + iv;
            if (query.isPurge === true) {
                kony.sync.queryStore[query.tablename + "purgeInsert"] = sql;
            }
            return [sql, params];
        } else if ((query.operationtype === "select")) {
            wctable = kony.sync.qb_getparamwhereclause(query);
            wc = wctable[0];
            params = wctable[1];
            sql = "select " + query.distinctclause + query.topclause + kony.sync.qb_getfieldstring(query) + " from \"" + kony.sync.qb_gettablename(query) + "\"" + wc + query.orderbyclause;
            if (!kony.sync.isNullOrUndefined(query.limit)) {
                sql += " limit " + query.limit + " offset " + query.offset;
            }
            return [sql, params];
        } else if ((query.operationtype === "update")) {
            wctable = kony.sync.qb_getparamwhereclause(query);
            wc = wctable[0];
            var wparams = wctable[1];
            var uftable = kony.sync.qb_getparamupdatedfields(query);
            var uf = uftable[0];
            var uparams = uftable[1];
            sql = "Update \"" + kony.sync.qb_gettablename(query) + "\" " + uf + " " + wc;
            for (var i = 0; i < wparams.length; i++) {
                uparams.push(wparams[i]);
            }
            params = uparams;
            //kony.sync.syncPrint("update sql : " + sql);
            //kony.sync.syncPrint("update params : " + params);
            return [sql, params];
        } else if ((query.operationtype === "delete")) {
            wctable = kony.sync.qb_getparamwhereclause(query);
            wc = wctable[0];
            params = wctable[1];
            sql = "delete from \"" + kony.sync.qb_gettablename(query) + "\" " + wc;
            return [sql, params];
        }
    } else {
        ret = "";
        if ((query.operationtype === "select")) {
            sql = "select " + query.distinctclause + query.topclause + kony.sync.qb_getfieldstring(query) + " from \"" + kony.sync.qb_gettablename(query) + "\"" + kony.sync.qb_getwhereclause(query) + query.orderbyclause;
            return sql;
        } else if ((query.operationtype === "update")) {
            return "Update \"" + kony.sync.qb_gettablename(query) + "\" " + kony.sync.qb_getupdatedfields(query) + " " + kony.sync.qb_getwhereclause(query);
        } else if ((query.operationtype === "insert")) {
            return "insert into \"" + kony.sync.qb_gettablename(query) + "\"" + kony.sync.qb_getinsertcolums(query) + " values " + kony.sync.qb_getinsertvalues(query);
        } else if ((query.operationtype === "delete")) {
            return "delete from \"" + kony.sync.qb_gettablename(query) + "\" " + kony.sync.qb_getwhereclause(query);
        }
    }
};
//  **************** End konySyncQueryBuilder.js*******************
//  **************** Start konySyncQueryProvider.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.single_execute_sql = function(dsname, sqlstatement, params, result_successcallback, result_errorcallback) {
    sync.log.trace("Entering kony.sync.single_execute_sql-> main function");
    var single_execute_sql_result = null;
    var dbname = dsname;
    var isError = false;

    function single_execute_sql_transaction(tx) {
        sync.log.trace("Entering single_execute_sql_transaction");
        var resultset = kony.sync.executeSql(tx, sqlstatement, params, result_errorcallback);
        if (resultset !== false) {
            if (!(kony.sync.isNullOrUndefined(resultset.rows)) && resultset.rows.length > 0) {
                single_execute_sql_result = kony.db.sqlResultsetRowItem(tx, resultset, 0);
            }
        } else {
            isError = true;
        }
    }

    function single_execute_sql_transactionSucessCallback() {
        sync.log.trace("Entering kony.sync.single_execute_sql->single_execute_sql_transactionSucessCallback");
        if (!isError) {
            kony.sync.verifyAndCallClosure(result_successcallback, single_execute_sql_result);
        }
    }

    function single_execute_sql_transactionErrorCallback() {
        sync.log.error("Entering kony.sync.single_execute_sql->single_execute_sql_transactionErrorCallback");
        if (!isError) {
            kony.sync.verifyAndCallClosure(result_errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.verifyAndCallClosure(result_errorcallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, result_errorcallback);
    if (dbconnection !== null) {
        kony.sync.startTransaction(dbconnection, single_execute_sql_transaction, single_execute_sql_transactionSucessCallback, single_execute_sql_transactionErrorCallback, "Single Execute");
    }
};
kony.sync.single_select_execute = function(dsname, sql, params, success_callback, error_callback) {
    sync.log.trace("Entering kony.sync.single_select_execute ");
    var callback_result = [];
    var dbname = dsname;
    var isError = false;

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.single_select_execute->single_transaction_success_callback");
        if (!isError) {
            kony.sync.verifyAndCallClosure(success_callback, callback_result);
        }
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.single_select_execute->single_transaction_error_callback");
        if (!isError) {
            kony.sync.showTransactionError(error_callback);
        } else {
            sync.log.error("Entering kony.sync.single_select_execute->single_transaction_error_callback :", kony.sync.errorObject);
            kony.sync.verifyAndCallClosure(error_callback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.single_select_execute->single_transaction_callback");
        var resultSet = kony.sync.executeSql(tx, sql, params, error_callback);
        if (resultSet !== false) {
            if ((kony.sync.is_SQL_select(sql))) {
                var num_records = resultSet.rows.length;
                sync.log.debug("Single Select no of records:", num_records);
                for (var i = 0; i <= num_records - 1; i++) {
                    var record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
                    kony.table.insert(callback_result, record);
                }
            }
        } else {
            isError = true;
        }
    }
    var connection = kony.sync.getConnectionOnly(dbname, dbname, error_callback);
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
    }
};
kony.sync.single_binary_select_ondemand_execute = function(dsname, tbname, columnName, pks, config, blobType, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.single_binary_select_ondemand_execute ");
    var response = {};
    var error = null;

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.single_select_execute_binary_onDemand->single_select_binary_transaction_success");
        if (error) {
            sync.log.trace("Invoking error callback - single_binary_select_ondemand_execute");
            kony.sync.verifyAndCallClosure(errorCallback, response);
        } else if (Object.keys(response).length > 0) {
            sync.log.trace("Invoking success callback - single_binary_select_ondemand_execute");
            kony.sync.verifyAndCallClosure(successCallback, response);
        } else {
            sync.log.trace("No response from getBlobOnDemand. Downloading binaries in background.")
        }
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.single_select_execute_binary_onDemand->single_select_binary_transaction_failed");
        kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        var scopename = kony.sync.scopes.syncTableScopeDic[tbname];
        var scope = kony.sync.scopes[scopename];
        var pkColumns = scope.syncTableDic[tbname].Pk_Columns;
        //validate whether we get all pks in the pk table.
        pks = kony.sync.validatePkTable(pkColumns, pks);
        sync.log.trace("after validation pks are " + JSON.stringify(pks));
        if (!kony.sync.isNullOrUndefined(pks)) {
            var blobRef = kony.sync.getBlobRef(tx, tbname, columnName, pks, errorCallback);
            sync.log.trace(kony.sync.binaryMetaColumnPrefix + columnName + " value is " + blobRef);
            if (!kony.sync.isNullOrUndefined(blobRef)) {
                if (blobRef === kony.sync.blobRefNotFound) {
                    //blobref is not found.
                    sync.log.trace("blobref not found.");
                    response.pkTable = pks;
                    if (blobType === kony.sync.BlobType.BASE64) {
                        response.base64 = null;
                    } else {
                        response.filePath = null;
                    }
                } else {
                    //check if there is any context info.
                    var blobContext = kony.sync.getBlobContext(tx, tbname, columnName, pks, errorCallback);
                    if (blobRef === kony.sync.blobRefNotDefined) {
                        if (blobContext !== kony.sync.blobRefNotDefined) {
                            //trigger download..
                            sync.log.trace("blobref not defined. triggering download");
                            var fetchBinaryResponse = kony.sync.blobManager.getBlobOnDemand(tx, kony.sync.blobRefNotDefined, blobType, tbname, columnName, config, pks, successCallback, errorCallback);
                            if (!kony.sync.isNullOrUndefined(fetchBinaryResponse)) {
                                if (fetchBinaryResponse.hasOwnProperty("errorCode")) {
                                    sync.log.trace("Received error response from getBlobOnDemand");
                                    error = fetchBinaryResponse;
                                } else {
                                    sync.log.trace("Received success response from getBlobONDemand");
                                    response = fetchBinaryResponse;
                                }
                            }
                        } else {
                            sync.log.info("no context available for download.");
                            response.pkTable = pks;
                            if (blobType === kony.sync.BlobType.BASE64) {
                                response.base64 = null;
                            } else {
                                response.filePath = null;
                            }
                        }
                    } else {
                        //fetch from blob store manager.
                        sync.log.trace("blobref defined. fetching from blobStoreManager table");
                        var fetchBinaryResponse = kony.sync.blobManager.getBlobOnDemand(tx, blobRef, blobType, tbname, columnName, config, pks, successCallback, errorCallback);
                        if (!kony.sync.isNullOrUndefined(fetchBinaryResponse)) {
                            if (fetchBinaryResponse.hasOwnProperty("errorCode")) {
                                sync.log.trace("Received error response from getBlobOnDemand");
                                error = fetchBinaryResponse;
                            } else {
                                sync.log.trace("Received success response from getBlobOnDemand");
                                response = fetchBinaryResponse;
                            }
                        }
                    }
                }
            }
        } else {
            //error invalid pks.
            error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, tbname));
        }
    }
    var connection = kony.sync.getConnectionOnly(dsname, dsname, errorCallback);
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
    }
};
kony.sync.single_binary_select_inline_execute = function(dsname, tbname, columnName, pks, config, blobType, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.single_binary_select_inline_execute ");
    var response = {};
    var error = null;

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.single_binary_select_inline_execute->single_transaction_success_callback");
        if (error) {
            kony.sync.verifyAndCallClosure(errorCallback, response);
        } else if (Object.keys(response).length > 0) {
            kony.sync.verifyAndCallClosure(successCallback, response);
        }
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.single_binary_select_inline_execute->single_transaction_error_callback");
        kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        var scopename = kony.sync.scopes.syncTableScopeDic[tbname];
        var scope = kony.sync.scopes[scopename];
        var pkColumns = scope.syncTableDic[tbname].Pk_Columns;
        //validate whether we get all pks in the pk table.
        pks = kony.sync.validatePkTable(pkColumns, pks);
        if (!kony.sync.isNullOrUndefined(pks)) {
            var blobRef = kony.sync.getBlobRef(tx, tbname, columnName, pks, errorCallback);
            if (!kony.sync.isNullOrUndefined(blobRef)) {
                if (blobRef === -1) {
                    //No record exists with given pks.
                    response.pkTable = pks;
                    if (blobType === kony.sync.BlobType.BASE64) {
                        response.base64 = null;
                    } else {
                        response.filePath = null;
                    }
                } else {
                    //fetch from blob store manager.
                    var fetchBinaryResponse = kony.sync.blobManager.getBlobInline(tx, blobRef, blobType, tbname, columnName, config, pks, successCallback, errorCallback);
                    if (!kony.sync.isNullOrUndefined(fetchBinaryResponse)) {
                        if (fetchBinaryResponse.hasOwnProperty("errorCode")) {
                            error = fetchBinaryResponse;
                        } else {
                            response = fetchBinaryResponse;
                        }
                    }
                }
            } else {
                //blob doesn't exist for given record.
                response.pkTable = pks;
                if (blobType === kony.sync.BlobType.BASE64) {
                    response.base64 = null;
                } else {
                    response.filePath = null;
                }
            }
        } else {
            //error invalid pks.
            error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, tbname));
        }
    }
    if (kony.sync.isBinaryColumn(tbname, columnName) !== -1) {
        var connection = kony.sync.getConnectionOnly(dsname, dsname, errorCallback);
        if (connection !== null) {
            kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
        }
    } else {
        //not a binary column. return empty object.
        sync.log.warn("Request column is not a binary column. Empty response is sent");
        kony.sync.verifyAndCallClosure(successCallback, response);
    }
};
kony.sync.single_binary_select_execute = function(dsname, tbname, columnName, pks, config, blobType, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.single_binary_select_execute ");
    if (kony.sync.isValidFunctionType(successCallback) && kony.sync.isValidFunctionType(errorCallback)) {
        if (columnName === undefined || typeof(columnName) !== "string" || tbname === undefined || typeof(tbname) !== "string") {
            var error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidColumnParams, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidColumnParams));
            kony.sync.verifyAndCallClosure(errorCallback, error);
            return;
        }
        var downloadPolicy = kony.sync.getDownloadPolicy(tbname, columnName);
        sync.log.trace("download policy for the column " + tbname + "." + columnName + " is " + downloadPolicy);
        if (downloadPolicy !== kony.sync.notSupported) {
            if (downloadPolicy !== kony.sync.inline) {
                kony.sync.single_binary_select_ondemand_execute(dsname, tbname, columnName, pks, config, blobType, successCallback, errorCallback);
            } else {
                //call inline base64 fetch.
                kony.sync.single_binary_select_inline_execute(dsname, tbname, columnName, pks, config, blobType, successCallback, errorCallback);
            }
        } else {
            var error = kony.sync.getErrorTable(kony.sync.errorCodeDownloadPolicyNotSupported, kony.sync.getErrorMessage(kony.sync.errorCodeDownloadPolicyNotSupported, tbname + "." + columnName));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
kony.sync.single_binary_select_base64_execute = function(dsname, tbname, columnName, pks, config, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.single_binary_select_base64_execute-> main function");
    kony.sync.single_binary_select_execute(dsname, tbname, columnName, pks, config, kony.sync.BlobType.BASE64, successCallback, errorCallback);
};
kony.sync.single_binary_select_file_execute = function(dsname, tbname, columnName, pks, config, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.single_binary_select_file_execute-> main function");
    kony.sync.single_binary_select_execute(dsname, tbname, columnName, pks, config, kony.sync.BlobType.FILE, successCallback, errorCallback);
};
/**
 * API is used to fetch stats of binary.. (state, status, error, lastUpdatedTimeStamp)
 * @param tbname
 * @param columnName
 * @param wc
 * @param successCallback
 * @param errorCallback
 */
kony.sync.insert_execute = function(tx, tbname, values, childRecordsArray, error_callback, markForUpload, response, options) {
    sync.log.trace("Entering kony.sync.insert_execute ");
    var callback_result;
    sync.log.trace("Entering kony.sync.insert_execute");
    //remove the binary values.
    var blobMap = {};
    if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
        for (var i = 0; i < binaryColumns.length; i++) {
            if (!kony.sync.isNullOrUndefined(values[binaryColumns[i]]) && values[binaryColumns[i]].length > 0) blobMap[binaryColumns[i]] = values[binaryColumns[i]];
            delete values[binaryColumns[i]];
            //keeping the blob ref as NULL.
            values[kony.sync.binaryMetaColumnPrefix + binaryColumns[i]] = kony.sync.blobRefNotDefined;
        }
    }
    sync.log.trace("removed blob values from the record " + JSON.stringify(values));
    //check if pk_columns for autogenerated - false do not have not null values.
    var tableinfo = kony.sync.getTableInfo(tbname);
    if (kony.sync.isNullOrUndefined(tableinfo)) {
        //invalid table name sent.
        sync.log.error("invalid table name sent for insert operation " + tbname);
        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeInvalidTableName, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidTableName, tbname));
        return false;
    }
    if (!kony.sync.isNullOrUndefined(tableinfo.Pk_Columns)) {
        for (var j = 0; j < tableinfo.Pk_Columns.length; j++) {
            var pkKey = tableinfo.Pk_Columns[j];
            if (tableinfo.ColumnsDic[pkKey].Autogenerated === "false" && kony.sync.isNullOrUndefined(values[pkKey])) {
                //received null for a non auto-generated pk.
                sync.log.error("received null for pk column " + pkKey);
                kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeNullPrimaryKeyValue, kony.sync.getErrorMessage(kony.sync.errorCodeNullPrimaryKeyValue, pkKey));
                return false;
            }
        }
    }
    //CallBack_result contains AutoGenerated PK in hash ({id = value})
    callback_result = kony.sync.insert(tx, tbname, values, error_callback, markForUpload, options);
    if (response.hasOwnProperty(tbname)) {
        //it is a child record. update the array.
        response[tbname].push(callback_result);
    } else {
        response = callback_result;
    }
    if (callback_result === false || kony.sync.isNullOrUndefined(callback_result)) {
        sync.log.error("error in inserting record into " + tbname);
        if (kony.sync.errorObject !== null && kony.sync.errorObject.errorInfo !== null) {
            var errorInfo = kony.sync.errorObject.errorInfo;
            if (errorInfo.dbError && errorInfo.dbError.message) {
                var dbErrorMessage = errorInfo.dbError.message;
                var columnNameWithTable = (dbErrorMessage.split(": ")[1]).split(" ")[0]; //columnNameWithTable = "tableName.columnName"
                var columnName = columnNameWithTable.slice(tbname.length + 1, columnNameWithTable.length); //columnName = "columnName"
                if (dbErrorMessage.search("UNIQUE constraint failed") === 0) {
                    //error message simiar to "UNIQUE constraint failed: tableName.columnName (code 1555)"
                    //checking for columnName in Pk_columns
                    if (tableinfo.Pk_Columns.indexOf(columnName) >= 0) {
                        //columnName is a Primary Key
                        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeDuplicatePrimaryKey, kony.sync.getErrorMessage(kony.sync.errorCodeDuplicatePrimaryKey, tbname, columnName), errorInfo);
                    } else {
                        //columnName is a Unique Key
                        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeDuplicateUniqueKey, kony.sync.getErrorMessage(kony.sync.errorCodeDuplicateUniqueKey, tbname, columnName), errorInfo);
                    }
                } else if (dbErrorMessage.search("NOT NULL constraint failed") === 0) {
                    kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeMandatoryAttribute, kony.sync.getErrorMessage(kony.sync.errorCodeMandatoryAttribute, tbname, columnName), errorInfo);
                }
            }
        }
        return false;
    } else {
        sync.log.trace("inserted into " + tbname + " with result " + JSON.stringify(callback_result));
        //if insert is successful create rows in blobstore manager for the binary columns.
        if (Object.keys(blobMap).length > 0) {
            var blobStoreIndices = kony.sync.blobstore_insert(tx, tbname, blobMap, error_callback);
            sync.log.trace("inserted blobMap into the blobStoreManager. response is " + JSON.stringify(blobStoreIndices));
            if (blobStoreIndices && Object.keys(blobStoreIndices).length > 0) {
                //update the parent table with blob references.
                var wcs = [];
                for (var key in callback_result) {
                    var wc = {};
                    wc.key = key;
                    wc.value = callback_result[key];
                    wcs.push(wc);
                }
                var resultset = kony.sync.blobManager.updateParentWithBlobReference(tx, tbname, blobStoreIndices, wcs, error_callback);
                sync.log.trace("updating the blob reference in the table " + tbname);
                if (resultset === false || kony.sync.isNullOrUndefined(resultset)) {
                    sync.log.error("error in updating table " + tbname + " with blob references..");
                    return false;
                }
            } else {
                sync.log.error("error in inserting blob data ");
                return false;
            }
        }
    }
    //check for child records.
    if (childRecordsArray.length > 0) {
        sync.log.trace("There are child records... Inserting them");
        for (var k = 0; k < childRecordsArray.length; k++) {
            var childRecordObject = childRecordsArray[k];
            //child records are json objects with childTable name as key.
            for (var table in childRecordObject) {
                if (!response.hasOwnProperty(table)) {
                    response[table] = [];
                }
                //child records are expected to be arary.
                sync.log.trace("inserting child record in table " + table);
                if (childRecordObject[table] instanceof Array) {
                    for (var childRecordsCount = 0; childRecordsCount < childRecordObject[table].length; childRecordsCount++) {
                        //before inserting child records, first remove the nested child records
                        var childRecordToBeInserted = childRecordObject[table][childRecordsCount];
                        var nestedChildRecords = kony.sync.getChildRecords(table, childRecordToBeInserted);
                        sync.log.trace("child records for " + table + " are " + JSON.stringify(nestedChildRecords));
                        //getting the relationship attributes
                        var parentRelationAttributes = kony.sync.getParentRelationshipAttributes(tbname, table);
                        sync.log.trace("parentRelationAttributes for " + tbname + " and " + table + " are " + JSON.stringify(parentRelationAttributes));
                        //adding the values from the generated primary keys.
                        if (!kony.sync.isNullOrUndefined(parentRelationAttributes)) {
                            for (var count in parentRelationAttributes) {
                                var relationAttribute = parentRelationAttributes[count];
                                //check if callback has mapping source attribute
                                if (callback_result.hasOwnProperty(relationAttribute[kony.sync.sourceAttribute]) && !kony.sync.isNullOrUndefined(callback_result[relationAttribute[kony.sync.sourceAttribute]])) {
                                    childRecordToBeInserted[relationAttribute[kony.sync.targetAttribute]] = callback_result[relationAttribute[kony.sync.sourceAttribute]];
                                } else if (values.hasOwnProperty(relationAttribute[kony.sync.sourceAttribute]) && !kony.sync.isNullOrUndefined(values[relationAttribute[kony.sync.sourceAttribute]])) {
                                    childRecordToBeInserted[relationAttribute[kony.sync.targetAttribute]] = values[relationAttribute[kony.sync.sourceAttribute]];
                                } else {
                                    //no mapping source attribute found.
                                    kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeParentMappingAttributeNotFound, kony.sync.getErrorMessage(kony.sync.errorCodeParentMappingAttributeNotFound, relationAttribute[kony.sync.sourceAttribute]));
                                    sync.log.error("no mapping source attribute found from values sent.." + tbname);
                                    return false;
                                }
                            }
                        }
                        var childResponse = {};
                        var childRecordInsertResult = kony.sync.insert_execute(tx, table, childRecordToBeInserted, nestedChildRecords, error_callback, markForUpload, childResponse, options);
                        if (childRecordInsertResult === false || kony.sync.isNullOrUndefined(childRecordInsertResult)) {
                            sync.log.error("error in inserting record " + JSON.stringify(childRecordToBeInserted));
                            return false;
                        }
                        if (response.hasOwnProperty(table)) {
                            response[table].push(childRecordInsertResult);
                        }
                        sync.log.trace("after inserting record in " + table + " response is " + JSON.stringify(childRecordInsertResult));
                    }
                } else {
                    kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeChildObjectShouldBeArray, kony.sync.getErrorMessage(kony.sync.errorCodeChildObjectShouldBeArray));
                    sync.log.error("improper format for sending child objects. ");
                    return false;
                }
            }
        }
    }
    sync.log.trace("callback_result returning for table " + tbname + " is " + JSON.stringify(callback_result));
    return callback_result;
};
kony.sync.update_execute = function(tx, tbname, values, childRecordsArray, wc, isBatch, markForUpload, primaryKey, error_callback, options) {
    sync.log.trace("Entering kony.sync.update_execute ");
    var callback_result;
    var blobMap = {};
    if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
        for (var i = 0; i < binaryColumns.length; i++) {
            if (!kony.sync.isNullOrUndefined(values[binaryColumns[i]]) && values[binaryColumns[i]].length > 0) blobMap[binaryColumns[i]] = values[binaryColumns[i]];
            delete values[binaryColumns[i]];
        }
    }
    if (isBatch === true) {
        callback_result = kony.sync.updateBatch(tx, tbname, values, wc, markForUpload, primaryKey, options);
    } else {
        callback_result = kony.sync.update(tx, tbname, values, wc, markForUpload, options);
    }
    if (callback_result === false || kony.sync.isNullOrUndefined(callback_result)) {
        return false;
    } else {
        if (Object.keys(blobMap).length > 0) {
            var blobStoreIndices = kony.sync.blobstore_update(tx, tbname, blobMap, wc, isBatch, error_callback);
            if (blobStoreIndices && Object.keys(blobStoreIndices).length > 0) {
                var results = kony.sync.blobManager.updateParentWithBlobReference(tx, tbname, blobStoreIndices, wc, error_callback);
                if (results === false || results === null) {
                    sync.log.error("error in updating parent table with blob reference..");
                    return false;
                }
            } else {
                sync.log.error("Null returned from blobstore_update.");
                return false;
            }
        }
        //check for the child records.
        if (childRecordsArray.length > 0) {
            for (var k = 0; k < childRecordsArray.length; k++) {
                var childRecordObject = childRecordsArray[k];
                for (var table in childRecordObject) {
                    sync.log.trace("updating child record in table " + table);
                    if (childRecordObject[table] instanceof Array) {
                        for (var childRecordsCount = 0; childRecordsCount < childRecordObject[table].length; childRecordsCount++) {
                            //first remove nested childrecords from the values table.
                            var childRecordToBeUpdated = childRecordObject[table][childRecordsCount];
                            var nestedChildRecords = kony.sync.getChildRecords(table, childRecordToBeUpdated);
                            sync.log.trace("child records for " + table + " are " + JSON.stringify(nestedChildRecords));
                            //get pkTable from the childRecord.
                            var pkTable = kony.sync.getPkTableFromJSON(childRecordToBeUpdated, table);
                            sync.log.trace("pkTable for the table " + table + " is " + JSON.stringify(pkTable));
                            if (pkTable && Object.keys(pkTable).length > 0) {
                                //create a whereclause from pkTable.
                                var whereClause = [];
                                for (var key in pkTable) {
                                    if (!kony.sync.isNullOrUndefined(pkTable[key])) {
                                        var child_wc = {};
                                        child_wc.key = key;
                                        child_wc.value = pkTable[key];
                                        child_wc.comptype = "AND";
                                        whereClause.push(child_wc);
                                    } else {
                                        //null send as pkValue. throw error
                                        sync.log.error("received null for pk column " + pkTable[key]);
                                        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeNullPrimaryKeyValue, kony.sync.getErrorMessage(kony.sync.errorCodeNullPrimaryKeyValue, pkTable[key]));
                                        return false;
                                    }
                                }
                                if (whereClause.length > 0) {
                                    var childRecordUpdateResult = kony.sync.update_execute(tx, table, childRecordToBeUpdated, nestedChildRecords, whereClause, isBatch, markForUpload, primaryKey, error_callback, options);
                                    if (childRecordUpdateResult === false || kony.sync.isNullOrUndefined(childRecordUpdateResult)) {
                                        sync.log.error("error in updating record " + JSON.stringify(childRecordUpdateResult));
                                        return false;
                                    }
                                    sync.log.trace("after updating record in " + table + " response is " + JSON.stringify(childRecordUpdateResult));
                                }
                            } else {
                                kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, table));
                                sync.log.error("invalid pks send for update of record in " + table);
                                return false;
                            }
                        }
                    } else {
                        sync.log.error("improper format for sending child objects. ");
                        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeChildObjectShouldBeArray, kony.sync.getErrorMessage(kony.sync.errorCodeChildObjectShouldBeArray));
                        return false;
                    }
                }
            }
        }
    }
    return callback_result;
};
kony.sync.single_insert_execute = function(dsname, tbname, values, success_callback, error_callback, markForUpload, options) {
    sync.log.trace("Entering kony.sync.single_insert_execute-> main function");
    var callback_result = [];
    var dbname = dsname;

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.single_insert_execute->single_transaction_success_callback");
        if (callback_result) {
            kony.sync.verifyAndCallClosure(success_callback, callback_result);
        } else {
            single_transaction_failure_callback()
        }
    }

    function single_transaction_failure_callback() {
        sync.log.error("Entering kony.sync.single_insert_execute->single_transaction_failure_callback");
        sync.log.error("Entering kony.sync.single_insert_execute->single_transaction_failure_callback : ", kony.sync.errorObject);
        kony.sync.verifyAndCallClosure(error_callback, kony.sync.errorObject);
        kony.sync.errorObject = null;
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        //from the values table, remove the child table records if exists.
        var childRecordsArray = kony.sync.getChildRecords(tbname, values);
        var response = {};
        callback_result = kony.sync.insert_execute(tx, tbname, values, childRecordsArray, error_callback, markForUpload, response, options);
        if (kony.sync.isNullOrUndefined(callback_result) || callback_result === false) {
            sync.log.error("single_insert_execute -> single_transaction_callback rolling back changes");
            try {
                kony.sync.rollbackTransaction(tx);
            } catch (err) {
                sync.log.error("single_insert_execute - error in rollbackTransaction ", err);
            }
        }
        sync.log.info("response from insert operation " + JSON.stringify(callback_result));
    }
    var connection = kony.sync.getConnectionOnly(dbname, dbname, error_callback);
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_failure_callback);
    }
};
kony.sync.single_update_execute = function(dsname, tbname, values, wc, success_callback, error_callback, isBatch, markForUpload, primaryKey, options) {
    sync.log.trace("Entering kony.sync.single_update_execute ");
    var callback_result = {};
    var dbname = dsname;

    function single_transaction_success_callback() {
        sync.log.trace("Entering single_transaction_success_callback");
        if (callback_result === false) {
            single_transaction_error_callback();
        } else {
            sync.log.trace("Entering kony.sync.single_update_execute->single_transaction_success_callback ");
            kony.sync.verifyAndCallClosure(success_callback, callback_result);
        }
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.single_update_execute->single_transaction_error_callback");
        sync.log.error("Entering kony.sync.single_update_execute->single_transaction_error_callback :", kony.sync.errorObject);
        kony.sync.verifyAndCallClosure(error_callback, kony.sync.errorObject);
        kony.sync.errorObject = null;
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.single_update_execute->single_transaction_callback");
        //from the values table, remove the child table records if exists.
        var childRecordsArray = kony.sync.getChildRecords(tbname, values);
        //(tx, tbname, values,childRecordsArray, wc, isBatch, markForUpload, primaryKey , error_callback)
        callback_result = kony.sync.update_execute(tx, tbname, values, childRecordsArray, wc, isBatch, markForUpload, primaryKey, error_callback, options);
        if (kony.sync.isNullOrUndefined(callback_result) || callback_result === false) {
            sync.log.error("single_update_execute -> single_transaction_callback rolling back changes");
            try {
                kony.sync.rollbackTransaction(tx);
            } catch (err) {
                sync.log.error("single_insert_execute - error in rollbackTransaction ", err);
            }
        }
        sync.log.info("response from update operation " + JSON.stringify(callback_result));
    }
    var connection = kony.sync.getConnectionOnly(dbname, dbname, error_callback, "Single Update Execute");
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback, "Single Update Execute");
    }
};
kony.sync.delete_execute = function(tx, tbname, wc, isBatch, isLocal, markForUpload, error_callback, options) {
    sync.log.trace("Entering kony.sync.delete_execute ");
    //get records satisfying given where clause for tbname.
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tbname);
    kony.sync.qb_where(query, wc);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var result_set = kony.sync.executeSql(tx, sql, params, error_callback);
    if (result_set !== null && result_set !== false) {
        //get child relationships for the tbname.
        var relationships = kony.sync.getRelationshipsForTable(tbname);
        sync.log.trace("delete_execute relationships for tbname " + tbname + " are " + JSON.stringify(relationships));
        if (!kony.sync.isNullOrUndefined(relationships) && !kony.sync.isNullOrUndefined(relationships[kony.sync.oneToMany])) {
            sync.log.trace("tbname " + tbname + " has oneToMany relationships");
            var oneToManyRelationships = relationships[kony.sync.oneToMany];
            for (var j = 0; j < oneToManyRelationships.length; j++) {
                //get the target object and delete.
                var relationshipTargetObject = oneToManyRelationships[j][kony.sync.targetObject];
                sync.log.trace("target object on oneToMany relation for " + tbname + " is " + relationshipTargetObject);
                //fetch the source-target mapping for the one-many relation.
                var parentRelationAttributes = kony.sync.getParentRelationshipAttributes(tbname, relationshipTargetObject);
                sync.log.trace("parentRelationAttributes for " + tbname + " and " + relationshipTargetObject + " are " + JSON.stringify(parentRelationAttributes));
                //parse through the result_Set and create where clause for the childs to get deleted.
                if (parentRelationAttributes) {
                    for (var k = 0; k < result_set.rows.length; k++) {
                        //creating a where clause to delete childs as well.
                        var whereClause = [];
                        for (var count in parentRelationAttributes) {
                            var relationAttribute = parentRelationAttributes[count];
                            var rowItem = kony.db.sqlResultsetRowItem(tx, result_set, k);
                            if (!kony.sync.isNullOrUndefined(rowItem[relationAttribute[kony.sync.sourceAttribute]])) {
                                var child_wc = {};
                                child_wc.key = relationAttribute[kony.sync.targetAttribute];
                                child_wc.value = rowItem[relationAttribute[kony.sync.sourceAttribute]];
                                whereClause.push(child_wc);
                            }
                        }
                        sync.log.trace("whereClause for deleting in tbname " + relationshipTargetObject + " is " + JSON.stringify(whereClause));
                        //delete the child first before deleting the parent.
                        if (whereClause.length > 0) {
                            var childRecordDeleteResult = kony.sync.delete_execute(tx, relationshipTargetObject, whereClause, isBatch, isLocal, markForUpload, error_callback, options);
                            if (childRecordDeleteResult === null || childRecordDeleteResult === false) {
                                return false;
                            }
                        } else {
                            //no child records to delete..
                            sync.log.trace("For table " + tbname + " no child records to delete...");
                        }
                    }
                }
            }
        }
        //delete the record once, childs are deleted.
        var callback_result;
        var isBlobDeleted = kony.sync.blobstore_delete(tx, tbname, wc, isBatch, function(err) {
            sync.log.error("kony.sync.delete_exeucte - error in deleting blob values for the table " + tbname);
        });
        sync.log.trace("kony.sync.delete_execute - result from blobstore_delete is " + isBlobDeleted);
        if (isBlobDeleted) {
            if (isBatch === true) {
                callback_result = kony.sync.deleteBatch(tx, tbname, wc, isLocal, markForUpload, error_callback, options);
            } else {
                callback_result = kony.sync.remove(tx, tbname, wc, isLocal, markForUpload, error_callback, options);
            }
        }
        if (callback_result === false) {
            sync.log.error("kony.sync.delete_execute - error in deletion of records in tbname " + tbname);
            return false;
        }
        return callback_result;
    }
    sync.log.error("kony.sync.delete_execute - error in sql select operation on the table " + tbname);
    return false;
};
kony.sync.single_delete_execute = function(dsname, tbname, wc, success_callback, error_callback, isBatch, isLocal, markForUpload, options) {
    sync.log.trace("Entering kony.sync.single_delete_execute-> main function");
    var callback_result = [];
    var dbname = dsname;
    var isError = false;

    function single_transaction_success_callback() {
        sync.log.trace("Entering single_transaction_success_callback");
        if (callback_result === false) {
            single_transaction_error_callback();
        } else {
            sync.log.trace("Entering kony.sync.single_delete_execute->single_transaction_success_callback ");
            kony.sync.verifyAndCallClosure(success_callback, callback_result);
        }
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.single_delete_execute->single_transaction_callback");
        callback_result = kony.sync.delete_execute(tx, tbname, wc, isBatch, isLocal, markForUpload, error_callback, options);
        if (kony.sync.isNullOrUndefined(callback_result) || callback_result === false) {
            sync.log.error("single_delete_execute -> single_transaction_callback rolling back changes");
            try {
                kony.sync.rollbackTransaction(tx);
            } catch (err) {
                sync.log.error("single_insert_execute - error in rollbackTransaction ", err);
            }
        }
        sync.log.info("response from delete operation " + JSON.stringify(callback_result));
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.single_delete_execute->single_transaction_error_callback");
        sync.log.error("Entering kony.sync.single_delete_execute->single_transaction_error_callback :", kony.sync.errorObject);
        kony.sync.verifyAndCallClosure(error_callback, kony.sync.errorObject);
        kony.sync.errorObject = null;
    }
    var connection = kony.sync.getConnectionOnly(dbname, dbname, error_callback, "Single Delete Execute");
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback, "Single Delete Execute");
    }
};
kony.sync.massInsert = function(dsname, tbname, valuesArray, successCallback, errorCallback, markForUpload) {
    sync.log.trace("Entering kony.sync.massInsert-> main function");
    var callbackResult = [];
    var dbname = dsname;

    function massInsertTransactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.massInsert->massInsertTransactionSuccessCallback");
        kony.sync.verifyAndCallClosure(successCallback, callbackResult);
    }

    function massInsertTransactionErrorCallback() {
        sync.log.error("Entering kony.sync.massInsert->massInsertTransactionErrorCallback");
        kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
    }

    function massInsertTransactionCallback(tx) {
        sync.log.trace("Entering kony.sync.massInsert->massInsertTransactionCallback");
        //CallBack_result contains AutoGenerated PK in hash ({id = value})
        for (var i = 0; i < valuesArray.length; i++) {
            callbackResult.push(kony.sync.insert(tx, tbname, valuesArray[i], null, markForUpload));
        }
    }
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    kony.sync.startTransaction(connection, massInsertTransactionCallback, massInsertTransactionSuccessCallback, massInsertTransactionErrorCallback);
};
kony.sync.massUpdate = function(dbname, tbname, inputArray, successCallback, errorCallback, markForUpload, primaryKey) {
    sync.log.trace("Entering  kony.sync.massUpdate");
    var callbackResultTemp;
    var callbackResult = 0;
    var isError = false;
    var connection = kony.sync.getConnectionOnly(dbname, dbname, errorCallback);
    if (connection !== null) {
        kony.sync.startTransaction(connection, transactioncallback, transactionSuccessCallback, transactionErrorCallback);
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.massUpdate-> transactionSuccessCallback");
        if (!isError) {
            kony.sync.verifyAndCallClosure(successCallback, {
                rowsUpdated: callbackResult
            });
        }
    }

    function transactioncallback(tx) {
        sync.log.trace("Entering kony.sync.massUpdate-> transactioncallback");
        for (var i = 0; i < inputArray.length; i++) {
            callbackResultTemp = kony.sync.updateBatch(tx, tbname, inputArray[i].changeSet, inputArray[i].whereClause, markForUpload, primaryKey);
            if (callbackResultTemp === false) {
                isError = true;
                return;
            }
            callbackResult += callbackResultTemp.rowsupdated;
        }
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        if (!isError) {
            kony.sync.showTransactionError(errorCallback, "Sync Mass Update");
        } else {
            sync.log.error("Entering kony.sync.massUpdate->transactionErrorCallback :", kony.sync.errorObject);
            kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
};
/*This method will open a transaction and then executes the array of queries*/
kony.sync.executeQueries = function(queries, callback) {
    sync.log.trace("Entering kony.sync.executeQueries");
    if (kony.sync.isNullOrUndefined(queries)) {
        kony.sync.verifyAndCallClosure(callback, true);
        return;
    }
    var dbname = kony.sync.scopes[0][kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    var isError = false;
    if (connection !== null) {
        kony.sync.startTransaction(connection, transactioncallback, transactionSuccessCallback, transactionErrorCallback);
    }

    function transactioncallback(tx) {
        sync.log.trace("Entering transactioncallback");
        for (var i = 0; i < queries.length; i++) {
            if (kony.sync.executeSql(tx, queries[i], null) === false) {
                isError = true;
                return;
            }
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering transactionSuccessCallback");
        kony.sync.verifyAndCallClosure(callback, false);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        kony.sync.verifyAndCallClosure(callback, true, kony.sync.getTransactionError(isError));
    }
};
/*This method will execute the array of queries provided the transaction is already open*/
kony.sync.executeQueriesInTransaction = function(tx, queries) {
    sync.log.trace("Entering kony.sync.executeQueriesInTransaction");
    if (kony.sync.isNullOrUndefined(queries)) {
        return true;
    }
    for (var i = 0; i < queries.length; i++) {
        if (kony.sync.executeSql(tx, queries[i], null) === false) {
            return false;
        }
    }
    return true;
};
//this API is for developers who want to execute custom sql SELECT queries
sync.executeSelectQuery = function(query, successcallback, errorcallback) {
    sync.log.trace("Entering sync.executeSelectQuery -> main function");
    var dbname = kony.sync.getDBName();
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    var resultItems = [];
    var isError = false;
    if (connection !== null) {
        kony.sync.startTransaction(connection, executeSelectQueryTransactionCallback, executeSelectQuerySuccessCallback, executeSelectQueryErrorCallback);
    }

    function executeSelectQueryTransactionCallback(tx) {
        sync.log.trace("Entering sync.executeSelectQuery -> transaction callback");
        var resultSet = kony.sync.executeSql(tx, query, null);
        if (resultSet === false) {
            isError = true;
            return;
        }
        // Adding a null check as in some cases resultSet is not null but it does not contains rows.
        if (!kony.sync.isNullOrUndefined(resultSet) && resultSet.rows) {
            for (var i = 0; i < resultSet.rows.length; i++) {
                resultItems[i] = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            }
        }
    }

    function executeSelectQuerySuccessCallback() {
        sync.log.trace("Entering sync.executeSelectQuery -> success callback");
        kony.sync.verifyAndCallClosure(successcallback, resultItems);
    }

    function executeSelectQueryErrorCallback() {
        sync.log.trace("Entering sync.executeSelectQuery -> error callback");
        kony.sync.callTransactionError(isError, errorcallback);
    }
};
//  **************** End konySyncQueryProvider.js*******************
//  **************** End konySyncQueryProvider.js*******************
//  **************** Start KonySyncReset.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.scopeReset = function(scopename, successcallback, failurecallback) {
    sync.log.trace("Entering kony.sync.scopeReset->main function");
    var currentScope = kony.sync.scopes[scopename];
    var dbname = kony.sync.getDBName();
    var isStatementError = false;
    var exceptionMessage = null;
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, failurecallback);
    if (dbconnection !== null) {
        kony.sync.startTransaction(dbconnection, ScopeResetTransaction, ScopeResetSuccess, ScopeResetFailure);
    }

    function ScopeResetTransaction(tx) {
        sync.log.trace("Entering kony.sync.scopeReset->transaction function");
        try {
            if (!kony.sync.isNullOrUndefined(currentScope.ScopeTables)) {
                for (var i = 0; i < currentScope.ScopeTables.length; i++) {
                    var syncTable = currentScope.ScopeTables[i];
                    var tbname = syncTable.Name;
                    if (!kony.sync.deleteTable(tx, tbname)) {
                        isStatementError = true;
                        break;
                    }
                }
            }
        } catch (e) {
            exceptionMessage = e;
            throw ("");
        }
        if (!kony.sync.resetMetaTableForScope(tx, scopename)) {
            isStatementError = true;
        }
    }

    function ScopeResetSuccess() {
        sync.log.trace("Entering kony.sync.scopeReset->success callback function");
        kony.sync.verifyAndCallClosure(successcallback, "Scope Reset Successful");
    }

    function ScopeResetFailure() {
        sync.log.error("Entering kony.sync.scopeReset->failure callback function");
        if (isStatementError) {
            kony.sync.verifyAndCallClosure(failurecallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        } else {
            if (exceptionMessage !== null) {
                kony.sync.verifyAndCallClosure(failurecallback, kony.sync.getErrorTable(kony.sync.errorUnknown, kony.sync.getErrorMessage(kony.sync.errorUnknown, "Scope Reset", exceptionMessage), null));
            } else {
                kony.sync.showTransactionError(failurecallback, "Scope Reset");
            }
        }
    }
};
kony.sync.deleteTable = function(tx, tbname) {
    sync.log.trace("Entering kony.sync.deleteTable function");
    if (kony.sync.deleteTableHelper(tx, tbname + kony.sync.historyTableName) === false) {
        return false;
    }
    if (kony.sync.deleteTableHelper(tx, tbname + kony.sync.originalTableName) === false) {
        return false;
    }
    if (kony.sync.deleteTableHelper(tx, tbname) === false) {
        return false;
    }
    return true;
};
kony.sync.deleteTableHelper = function(tx, tbname) {
    sync.log.trace("Entering kony.sync.deleteTableHelper function");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_delete(query, tbname);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
kony.sync.resetMetaTableForScope = function(tx, scopeName) {
    sync.log.trace("Entering kony.sync.resetMetaTableForScope function");
    var query = kony.sync.qb_createQuery();
    var wcs = [];
    kony.sync.qb_set(query, {
        versionnumber: 0,
        lastserversynccontext: "",
        replaysequencenumber: 0,
        lastgeneratedid: -1
    });
    kony.table.insert(wcs, {
        key: kony.sync.metaTableScopeColumn,
        value: scopeName,
        optype: "EQ"
    });
    kony.sync.qb_where(query, wcs);
    kony.sync.qb_update(query, kony.sync.metaTableName);
    //local sql = "insert into "..kony.sync.metaTableName.." (id,scopename,versionnumber,lastserversynccontext,replaysequencenumber,lastgeneratedid) values ('"..id.."','"..scope.ScopeName.."','0','','0','-1')"
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
//  **************** End KonySyncReset.js*******************
//  **************** Start KonySyncRetryHelper.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
//Repetitively calls a service until number of attempts
kony.sync.retryServiceCall = function(url, result, infoObj, retryCount, callback, params) {
    sync.log.trace("Entering kony.sync.retryServiceCall");
    sync.log.error("Error while hitting " + url + " : ", result);
    sync.log.info("Retrying[" + retryCount + " retries left] ....");
    if (kony.sync.isSyncStopped) {
        kony.sync.stopSyncSession();
        return;
    }
    var params1 = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onRetry], {
        "request": params,
        "errorResponse": result,
        "retryCount": (kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey] - retryCount)
    });
    if (!kony.sync.isNullOrUndefined(params1)) {
        params = params1;
    }
    var retryWait = 1; //default retry time is 1 second
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.retryWaitKey])) {
        retryWait = kony.sync.tonumber(kony.sync.currentSyncConfigParams[kony.sync.retryWaitKey]);
    }
    sync.log.trace("kony.sync.retryServiceCall, retryWait is: " + retryWait);
    if (!kony.sync.isAppInBackground) {
        kony.timer.schedule("syncRetryTimer", retryTimerCallback, retryWait, false);
    } else {
        retryTimerCallback();
    }

    function downloadNetworkCallbackStatus(status, callResult, info) {
        sync.log.trace("Entering downloadNetworkCallbackStatus");
        if (status === 400) {
            sync.log.trace("Entering kony.sync.retryServiceCall->downloadNetworkCallbackStatus");
            //fallback when opstatus < 0
            if (result.opstatus < 0) {
                sync.log.info("Got result.opstatus:" + result.opstatus + " and result.errcode:" + result.errcode + "setting errcode to opstatus");
                result.opstatus = result.errcode;
            }
            if (retryCount > 0 && kony.sync.checkForRetryErrorCodes(callResult.opstatus)) {
                retryCount--;
                kony.sync.retryServiceCall(url, callResult, info, retryCount, callback, params);
            } else {
                callback(callResult, info, retryCount);
            }
        } else if (status === 300) {
            sync.log.warn("kony.sync.retryServiceCall->downloadNetworkCallbackStatus, Got status 300 i.e.  Network call Cancelled.");
            if (kony.sync.checkForRetryOnNetworkCancel(url, info) === true) {
                if (retryCount > 0) {
                    retryCount--;
                    sync.log.debug("kony.sync.retryServiceCall->downloadNetworkCallbackStatus, Retrying the network call for status 300 ");
                    if (kony.sync.isNullOrUndefined(callResult)) {
                        callResult = kony.sync.getNetworkCancelError();
                    }
                    kony.sync.retryServiceCall(url, callResult, info, retryCount, callback, params);
                } else {
                    sync.log.error("kony.sync.retryServiceCall->downloadNetworkCallbackStatus, All retries exhausted, now raising Network Cancel Error.");
                    callback(kony.sync.getNetworkCancelError(), info, retryCount);
                }
            } else {
                sync.log.error("kony.sync.retryServiceCall->downloadNetworkCallbackStatus, raising Network Cancel Error ");
                callback(kony.sync.getNetworkCancelError(), info, retryCount);
            }
        }
    }

    function retryTimerCallback() {
        sync.log.trace("Entering kony.sync.retryServiceCall->retryTimerCallback");
        kony.sync.invokeServiceAsync(url, params, downloadNetworkCallbackStatus, infoObj);
    }
};
//Checks whether an error code is eligible for retry or not
kony.sync.checkForRetryErrorCodes = function(key) {
    sync.log.trace("Entering kony.sync.checkForRetryErrorCodes, for key: " + key);
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.retryErrorCodes])) {
        return kony.sync.contains(kony.sync.currentSyncConfigParams[kony.sync.retryErrorCodes], key);
    } else {
        return kony.sync.contains([1000, 1013, 1014, 1015], key);
    }
};
kony.sync.eligibleForRetry = function(opstatus, info) {
    sync.log.trace("Entering kony.sync.eligibleForRetry");
    return !kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey]) && info > 0 && kony.sync.checkForRetryErrorCodes(opstatus);
};
kony.sync.checkForRetryOnNetworkCancel = function(url, info) {
        sync.log.info("Entering kony.sync.checkForRetryOnNetworkCancel ,   url:  " + url + ", and info is: " + info);
        if (kony.sync.getDownloadURL() === url || kony.sync.getChunkDownloadURL() === url) {
            return true;
        }
        if (!kony.sync.isNullOrUndefined(info) && !kony.sync.isNullOrUndefined(info.retryOnNetworkCancel)) {
            return info.retryOnNetworkCancel;
        }
        return false;
    }
    //  **************** End KonySyncRetryHelper.js*******************
    //  **************** Start KonySyncRollBack.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.konySyncRollBackPendingChanges = function(tbname, dbname, wcs, successcallback, errorcallback, isGlobal, count) {
    sync.log.trace("Entering kony.sync.konySyncRollBackPendingChanges-> main function");
    var isSuccess = true;
    var totalRows = 0;
    var pkNotFound = false;
    var isStatementError = false;

    function single_execute_sql_transaction(tx) {
        sync.log.trace("Entering kony.sync.konySyncRollBackPendingChanges->single_execute_sql_transaction ");
        if (isGlobal === true) {
            totalRows = kony.sync.konySyncRollBackGlobal(tx, errorcallback);
            isSuccess = totalRows === false ? false : true;
        } else if (!kony.sync.isNullOrUndefined(wcs)) {
            totalRows = kony.sync.konySyncRollBackRow(tx, tbname, wcs, errorcallback);
            if (totalRows === null) {
                pkNotFound = true;
                isSuccess = false;
            } else if (totalRows === false) {
                isStatementError = true;
                isSuccess = false;
            } else {
                isSuccess = true;
                totalRows = 1;
            }
        } else {
            totalRows = kony.sync.konySyncRollBackTable(tx, tbname, errorcallback);
            isSuccess = totalRows === false ? false : true;
        }
    }

    function single_transactionErrorCallback() {
        sync.log.error("Entering kony.sync.konySyncRollBackPendingChanges->single_transactionErrorCallback ");
        if (isSuccess) {
            kony.sync.showTransactionError(errorcallback);
        } else {
            sync.log.error("Entering kony.sync.konySyncRollBackPendingChanges->single_transactionErrorCallback : ", kony.sync.errorObject);
            kony.sync.verifyAndCallClosure(errorcallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }

    function single_execute_sql_transactionSucessCallback() {
        sync.log.trace("Entering kony.sync.konySyncRollBackPendingChanges->single_execute_sql_transactionSucessCallback ");
        if (pkNotFound === true) {
            kony.sync.verifyAndCallClosure(errorcallback);
            return;
        }
        if (isGlobal === true) {
            if (kony.sync.isNull(count)) {
                count = 0;
            }
            count += totalRows;
            if (kony.sync.rollbackCurrentScope.Index === kony.sync.scopes.scopecount - 1) {
                kony.sync.verifyAndCallClosure(successcallback, {
                    rowsrolledback: count
                });
            } else {
                kony.sync.rollbackCurrentScope = kony.sync.scopes[kony.sync.rollbackCurrentScope.Index + 1];
                kony.sync.konySyncRollBackPendingChanges(null, null, null, successcallback, errorcallback, true, count);
            }
        } else {
            kony.sync.verifyAndCallClosure(successcallback, {
                rowsrolledback: totalRows
            });
        }
    }
    try {
        if (isGlobal === true) {
            if (kony.sync.isNullOrUndefined(kony.sync.rollbackCurrentScope)) {
                kony.sync.rollbackCurrentScope = kony.sync.scopes[0];
                sync.log.info("RollBacking Global with Scope name : " + kony.sync.rollbackCurrentScope[kony.sync.scopeName] + " and with DBName : " + kony.sync.rollbackCurrentScope[kony.sync.scopeDataSource]);
            }
            dbname = kony.sync.rollbackCurrentScope[kony.sync.scopeDataSource];
        }
        var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
        if (dbconnection !== null) {
            kony.sync.startTransaction(dbconnection, single_execute_sql_transaction, single_execute_sql_transactionSucessCallback, single_transactionErrorCallback, "Single Execute");
        }
    } catch (e) {
        sync.log.error("Unknown error occurred during rollback", e);
        kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorUnknown, kony.sync.getErrorMessage(kony.sync.errorUnknown, "Rollback", e), null));
    }
};
kony.sync.konySyncRollBackTable = function(tx, tbname, errorcallback) {
    sync.log.trace("Entering kony.sync.konySyncRollBackTable");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tbname + kony.sync.originalTableName);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(tx, sql, params, errorcallback);
    if (resultset === false) {
        return false;
    }
    var num_records = resultset.rows.length;
    sync.log.debug("Number of records to rollback in " + tbname + "=" + num_records);
    for (var i = 0; i <= num_records - 1; i++) {
        var record = kony.db.sqlResultsetRowItem(tx, resultset, i);
        var tableinfo = kony.sync.getTableInfo(tbname);
        var wcs = [];
        if (!kony.sync.isNullOrUndefined(tableinfo.Pk_Columns)) {
            for (var j = 0; j < tableinfo.Pk_Columns.length; j++) {
                var pk = tableinfo.Pk_Columns[j];
                var wc = {};
                wc.key = pk;
                wc.value = record[pk];
                kony.table.insert(wcs, wc);
            }
        }
        sync.log.debug("Rollbacking Record with Primary Key :", wcs);
        if (!kony.sync.konysyncRollBackOriginal(tx, tbname, record, wcs, errorcallback)) {
            return false;
        }
    }
    return num_records;
};
kony.sync.konySyncRollBackGlobal = function(tx) {
    sync.log.trace("Entering kony.sync.konySyncRollBackGlobal");
    var noOfScopes = kony.sync.scopes.length;
    for (var i = 0; i < noOfScopes; i++) {
        var scope = kony.sync.scopes[i];
        var totalRows = 0;
        if (!kony.sync.isNullOrUndefined(scope.ScopeTables)) {
            for (var j = 0; j < scope.ScopeTables.length; j++) {
                var syncTable = scope.ScopeTables[j];
                sync.log.debug("Rollbacking Table :" + syncTable.Name);
                var rows = kony.sync.konySyncRollBackTable(tx, syncTable.Name);
                if (rows === false) {
                    return false;
                } else {
                    totalRows += rows;
                }
            }
        }
    }
    return totalRows;
};
kony.sync.konySyncRollBackRow = function(tx, tbname, wcs, errorcallback) {
    sync.log.trace("Entering kony.sync.konySyncRollBackRow");
    var record = kony.sync.getOriginalRow(tx, tbname + kony.sync.originalTableName, wcs, errorcallback);
    if (null !== record && false !== record) {
        return kony.sync.konysyncRollBackOriginal(tx, tbname, record, wcs);
    } else {
        return record;
    }
};
kony.sync.konysyncRollBackOriginal = function(tx, tbname, values, wcs, errorcallback) {
    sync.log.trace("Entering kony.sync.konysyncRollBackOriginal");
    var originalchangetype = values[kony.sync.originalTableChangeTypeColumn] + "";
    //delete the blob reference if exists.
    var isBlobDeleted = kony.sync.blobstore_delete(tx, tbname, wcs, false, function(err) {
        sync.log.error("kony.sync.konysyncRollBackOriginal - error in deleting blob values for the table " + tbname);
    });
    if (isBlobDeleted) {
        //add NULL to blobref columns..
        sync.log.trace("kony.sync.konysyncRollBackOriginal - adding NULL values to blob ref columns for table " + tbname);
        if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
            var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
            sync.log.trace("binary columns for tbname " + tbname + " are " + JSON.stringify(binaryColumns));
            for (var i = 0; i < binaryColumns.length; i++) {
                values[kony.sync.binaryMetaColumnPrefix + binaryColumns[i]] = kony.sync.blobRefNotDefined;
            }
        }
        if (kony.sync.isrowexists(tx, tbname, wcs)) {
            sync.log.trace("kony.sync.konysyncRollBackOriginal isrowexists = true");
            if ((originalchangetype === kony.sync.insertColStatus) || (originalchangetype === kony.sync.insertColStatusDI)) {
                sync.log.trace("kony.sync.konysyncRollBackOriginal - original change type is insert for values ", values);
                if (!kony.sync.removeEx(tx, tbname, wcs, null, errorcallback)) {
                    return false;
                }
            } else if ((originalchangetype === kony.sync.updateColStatus) || (originalchangetype === kony.sync.updateColStatusDU)) {
                //Revert to original values.
                sync.log.trace("kony.sync.konysyncRollBackOriginal - original change type is update for values ", values);
                values[kony.sync.mainTableChangeTypeColumn] = "-1";
                values[kony.sync.mainTableSyncVersionColumn] = values[kony.sync.originalTableSyncVersionColumn];
                values[kony.sync.originalTableChangeTypeColumn] = null;
                values[kony.sync.originalTableSyncVersionColumn] = null;
                if (!kony.sync.updateEx(tx, tbname, values, wcs, errorcallback)) {
                    return false;
                }
            } else if ((originalchangetype === kony.sync.deleteColStatus) || (originalchangetype === kony.sync.deleteColStatusDD)) {
                //delete the row which has been inserted/updated with old values.
                sync.log.trace("kony.sync.konysyncRollBackOriginal - original change type is delete for values ", values);
                if (!kony.sync.removeEx(tx, tbname, wcs, null, errorcallback)) {
                    return false;
                }
                //Insert the row which has been deleted with old values.
                values[kony.sync.mainTableChangeTypeColumn] = "-1";
                values[kony.sync.mainTableSyncVersionColumn] = values[kony.sync.originalTableSyncVersionColumn];
                values[kony.sync.mainTableHashSumColumn] = values[kony.sync.originalTableHashSumColumn];
                values[kony.sync.originalTableChangeTypeColumn] = null;
                values[kony.sync.originalTableSyncVersionColumn] = null;
                if (!kony.sync.insertEx(tx, tbname, values, wcs, errorcallback)) {
                    return false;
                }
            }
        } else {
            /*if ((originalchangetype === kony.sync.insertColStatus)) {
             //Need not handle this case. Because inserted record has been deleted. So, it is already rollbacked.
             } else*/
            sync.log.trace("kony.sync.konysyncRollBackOriginal - isrowexists false");
            if ((originalchangetype === kony.sync.updateColStatus) || (originalchangetype === kony.sync.updateColStatusDU)) {
                //Insert the row which has been updated and deleted with old values.
                sync.log.trace("kony.sync.konysyncRollBackOriginal - original change type is update for values ", values);
                values[kony.sync.mainTableChangeTypeColumn] = "-1";
                values[kony.sync.mainTableSyncVersionColumn] = values[kony.sync.originalTableSyncVersionColumn];
                values[kony.sync.originalTableChangeTypeColumn] = null;
                values[kony.sync.originalTableSyncVersionColumn] = null;
                //kony.sync.insertEx(tx, tbname, values);
                if (!kony.sync.insertEx(tx, tbname, values, null, errorcallback)) {
                    return false;
                }
            } else if ((originalchangetype === kony.sync.deleteColStatus) || (originalchangetype === kony.sync.deleteColStatusDD)) {
                //Insert the row which has been deleted with old values.
                sync.log.trace("kony.sync.konysyncRollBackOriginal - original change type is delete for values ", values);
                values[kony.sync.mainTableChangeTypeColumn] = "-1";
                values[kony.sync.mainTableSyncVersionColumn] = values[kony.sync.originalTableSyncVersionColumn];
                values[kony.sync.originalTableChangeTypeColumn] = null;
                values[kony.sync.originalTableSyncVersionColumn] = null;
                if (!kony.sync.insertEx(tx, tbname, values, null, errorcallback)) {
                    return false;
                }
            }
        }
        if (!kony.sync.konySyncRollBackDeleteRow(tx, tbname, wcs, errorcallback)) {
            return false;
        }
        return true;
    } else {
        sync.log.error("kony.sync.konysyncRollBackOriginal error in deleting blob data for table " + tbname);
        return false;
    }
}
kony.sync.konySyncRollBackDeleteRow = function(tx, tbname, wcs, errorcallback) {
    sync.log.trace("Entering kony.sync.konySyncRollBackDeleteRow");
    sync.log.debug("Deleting States in Original Tables with Primary Key : ", wcs);
    if (kony.sync.removeEx(tx, tbname + kony.sync.originalTableName, wcs, errorcallback) === false) {
        return false;
    }
    if (kony.sync.removeEx(tx, tbname + kony.sync.historyTableName, wcs, errorcallback) === false) {
        return false;
    }
    return true;
};
//  **************** End KonySyncRollBack.js*******************
//  **************** Start KonySyncSchemaUpgrade.js*******************
/* This methods calls upgrade schema service and executes the scripts" */
kony.sync.upgradeSchema = function(callback) {
    sync.log.trace("Entering kony.sync.upgradeSchema ");
    sync.log.info("Calling upgradeSchema service...");
    var contextParams = {};
    contextParams.oldApplicationVersion = kony.sync.configVersion;
    contextParams.newApplicationVersion = konysyncClientSyncConfig.Version;
    var schemaUpgrade = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeRequiredKey], contextParams);
    if (schemaUpgrade === kony.sync.onUpgradeActionUploadUpgrade) {
        kony.sync.omitDownload = true;
        kony.sync.forceUploadUpgrade = true;
        kony.sync.currentScope = null;
        kony.sync.schemaUpgradeErrorObject = upgradeRequiredCallback;
        kony.sync.syncStartSession();
    } else { //(schemaUpgrade === kony.sync.onUpgradeActionUpgrade) //default policy
        upgradeRequiredCallback();
    }

    function upgradeRequiredCallback() {
        sync.log.trace("Entering upgradeRequiredCallback");
        kony.sync.callSchemaUpgradeService(schemaUpgradeCallback);
    }

    function schemaUpgradeCallback(serverResponse) {
        sync.log.trace("Entering schemaUpgradeCallback");
        if (!kony.sync.isNullOrUndefined(serverResponse.opstatus) && serverResponse.opstatus != 0) {
            sync.log.error("Schema Upgrade Response : ", serverResponse);
            if (!kony.sync.isNullOrUndefined(serverResponse.d)) {
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesDownloadErrorKey], kony.sync.getServerError(serverResponse.d));
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse.d));
            } else {
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesDownloadErrorKey], kony.sync.getServerError(serverResponse));
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse));
            }
            kony.sync.isSessionInProgress = false;
            kony.sync.httprequestsinglesession = false;
            return;
        } else if (kony.sync.isNullOrUndefined(serverResponse.d)) {
            kony.sync.isSessionInProgress = false;
            kony.sync.httprequestsinglesession = false;
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesDownloadErrorKey], kony.sync.getServerError(serverResponse));
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse));
            return;
        }
        if (serverResponse.d.error === "true") {
            sync.log.error("Schema Upgrade Response : ", serverResponse);
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesDownloadErrorKey], kony.sync.getServerError(serverResponse.d));
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse.d));
            kony.sync.isSessionInProgress = false;
            kony.sync.httprequestsinglesession = false;
            return;
        }
        kony.sync.addServerDetails(kony.sync.currentSyncReturnParams, serverResponse);
        if (serverResponse.d.upgradeavailable === "false") {
            callback(false);
            return;
        }
        //fetch alter scripts
        var queries = [];
        if (!kony.sync.isNullOrUndefined(serverResponse.d.script)) {
            for (var i = 0; i < serverResponse.d.script.length; i++) {
                queries.push(serverResponse.d.script[i].sql);
            }
            kony.sync.schemaUpgradeContext = serverResponse.d.upgradecontext;
        }
        kony.sync.currentSyncReturnParams.upgradeScripts = queries;
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesDownloadSuccessKey], kony.sync.currentSyncReturnParams);
        delete kony.sync.currentSyncReturnParams.upgradeScripts;
        var myQueries = null;
        myQueries = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesExecutionStartKey], {
            upgradeScripts: queries
        });
        if (!kony.sync.isNullOrUndefined(myQueries)) {
            queries = myQueries;
        }
        kony.sync.executeUpdateSchemaQueries(queries, kony.sync.schemaUpgradeContext, executeQueriesCallback, serverResponse.d.newapplicationversion);
    }

    function executeQueriesCallback(isError, errorInfo) {
        sync.log.trace("Entering executeQueriesCallback");
        if (isError) {
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesExecutionErrorKey], errorInfo);
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], errorInfo);
        } else {
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesExecutionSuccessKey]);
            kony.sync.schemaUpgradeNeeded = false; //do not call schema upgrade service again
            kony.sync.omitUpload = true; //only download
            kony.sync.schemaUpgradeDownloadPending = true;
            kony.sync.resetsyncsessionglobals();
            callback(true);
        }
    }
};
/*This method will be called in case of server notifies schema upgrade*/
kony.sync.onSchemaUpgradeErrorFromServer = function(msg) {
    sync.log.trace("Entering kony.sync.onSchemaUpgradeErrorFromServer ");
    /*	var contextParams = {};
    	contextParams.oldVersion = msg.oldApplicationVersion;
    	contextParams.newVersion = msg.newApplicationVersion;
    	contextParams.isMandatory = msg.mandatoryupgrade;*/
    var schemaUpgrade = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeRequiredKey], msg);
    if (schemaUpgrade === kony.sync.onUpgradeActionUploadAbort) {
        //Upload and then Abort Sync Process
        kony.sync.omitDownload = true;
        kony.sync.forceUpload = true;
        kony.sync.resetsyncsessionglobals();
        kony.sync.schemaUpgradeErrorObject = msg;
        kony.sync.syncStartSession();
    } else { //(schemaUpgrade === kony.sync.onUpgradeActionAbort) --default policy
        //Abort Sync Process
        kony.sync.validateScopeSession(true, msg);
    }
    /*else if (schemaUpgrade === kony.sync.onUpgradeActionContinue) {
		//Upgrade first and then continue with normal Sync Process
		//kony.sync.upgradeSchema(kony.sync.syncStartSession);
	} else if (schemaUpgrade === kony.sync.onUpgradeActionContinueOnlyUpload) {
		//Upload first, then upgrade and then continue with normal Sync Process
		kony.sync.omitDownload = true;
		kony.sync.schemaUpgradeNeeded = true;
		kony.sync.validateScopeSession();
	}*/
};
/*This method will execute upgrade scripts, syncconfig table with upgradecontext
and metainfo table with 0,0"*/
kony.sync.executeUpdateSchemaQueries = function(queries, upgradeContext, callback, appVersion) {
    sync.log.trace("Entering kony.sync.executeUpdateSchemaQueries");
    if (kony.sync.isNullOrUndefined(queries)) {
        kony.sync.verifyAndCallClosure(callback, true);
        return;
    }
    var dbname = kony.sync.scopes[0][kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    var isError = false;
    if (connection !== null) {
        kony.sync.startTransaction(connection, transactioncallback, transactionSuccessCallback, transactionErrorCallback);
    }

    function transactioncallback(tx) {
        sync.log.trace("Entering transactioncallback");
        /*Execute alter scripts*/
        if (kony.sync.executeQueriesInTransaction(tx, queries) === false) {
            isError = true;
            return;
        }
        /*update syncconfig table with upgradecontext*/
        var sql = "update " + kony.sync.syncConfigurationTableName + " set " + kony.sync.syncConfigurationColumnSchemaUpgradeContext + " = '" + upgradeContext + "'";
        if (kony.sync.executeSql(tx, sql, null) === false) {
            isError = true;
            return;
        }
        /*upgrade schemaupgradesynccontext in metatable to "0,0" to indicate that download for new columns is pending*/
        sql = "update " + kony.sync.metaTableName + " set " + kony.sync.metaTableSchemaUpgradeSyncTimeColumn + " = '0,0' where " + kony.sync.metaTableSyncTimeColumn + " <> '' and " + kony.sync.metaTableSyncTimeColumn + " is not null";
        if (kony.sync.executeSql(tx, sql, null) === false) {
            isError = true;
            return;
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering transactionSuccessCallback");
        kony.sync.configVersion = appVersion;
        kony.sync.currentSyncConfigParams.appVersion = kony.sync.configVersion;
        callback(false);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        callback(true, kony.sync.getTransactionError(isError));
    }
};
/*This function marks download of data after schema upgrade complete for that particular scope*/
kony.sync.setSchemaUpgradeDownloadComplete = function(tx, scopename) {
    sync.log.trace("Entering kony.sync.setSchemaUpgradeDownloadComplete ");
    if (kony.sync.schemaUpgradeDownloadPending) {
        var sql = "update " + kony.sync.metaTableName + " set " + kony.sync.metaTableSchemaUpgradeSyncTimeColumn + " = '' where " + kony.sync.metaTableScopeColumn + " = '" + scopename + "'";
        if (kony.sync.executeSql(tx, sql, null) === false) {
            return false;
        }
    }
    return true;
};
/*This method checks if download for schema upgrade is pending for any of the scopes*/
kony.sync.isDownloadPendingForSchemaUpgrade = function(callback) {
    sync.log.trace("Entering kony.sync.isDownloadPendingForSchemaUpgrade");
    var dbname = kony.sync.scopes[0][kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    var isError = false;
    var pendingDownload = false;
    if (connection !== null) {
        kony.sync.startTransaction(connection, transactioncallback, transactionSuccessCallback, transactionErrorCallback);
    }

    function transactioncallback(tx) {
        sync.log.trace("Entering transactioncallback");
        var sql = "select count(*) from " + kony.sync.metaTableName + " where " + kony.sync.metaTableSchemaUpgradeSyncTimeColumn + " = '0,0'";
        var resultset = kony.sync.executeSql(tx, sql, null);
        if (resultset === false) {
            isError = true;
            return;
        }
        var rowCount = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        if (rowCount["count(*)"] > 0) {
            pendingDownload = true;
        }
        sql = "select * from " + kony.sync.syncConfigurationTableName;
        resultset = kony.sync.executeSql(tx, sql, null);
        if (resultset === false) {
            isError = true;
            return;
        }
        var rowitem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        kony.sync.schemaUpgradeContext = rowitem[kony.sync.syncConfigurationColumnSchemaUpgradeContext];
        kony.sync.configVersion = rowitem[kony.sync.syncConfigurationColumnVersion];
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering transactionSuccessCallback");
        callback(false, null, pendingDownload);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        kony.sync.verifyAndCallClosure(callback, true, kony.sync.getTransactionError(isError));
    }
};
sync.performUpgrade = function(config) {
    sync.log.trace("Entering kony.sync.performUpgrade");
    if (kony.sync.validateSyncConfigParams("performUpgrade", config) === false) {
        return;
    }
    kony.sync.verifyAndCallClosure(config[kony.sync.onPerformUpgradeStartKey]);
    config[kony.sync.onSyncError] = config[kony.sync.onPerformUpgradeErrorKey];
    config[kony.sync.onSyncSuccess] = config[kony.sync.onPerformUpgradeSuccessKey];
    if (kony.sync.preProcessSyncConfig("performUpgrade", config, config[kony.sync.onSyncError]) === false) {
        return;
    }
    kony.sync.isDownloadPendingForSchemaUpgrade(isDownloadPendingForSchemaUpgradeCallback);

    function isDownloadPendingForSchemaUpgradeCallback(isError, errorObject, pending) {
        sync.log.trace("Entering isDownloadPendingForSchemaUpgradeCallback");
        if (isError) {
            kony.sync.isSessionInProgress = false; // closing the session
            kony.sync.httprequestsinglesession = false;
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], errorObject);
        } else {
            kony.sync.performOnlySchemaUpgrade = true;
            if (pending) {
                kony.sync.omitUpload = true; //only download
                kony.sync.schemaUpgradeDownloadPending = true;
                kony.sync.syncStartSession(); //download pending for already done schema upgrade
            } else {
                kony.sync.upgradeSchema(upgradeSchemaCallback); //download the scripts and upgrade
            }
        }
    }

    function upgradeSchemaCallback(upgrade) {
        sync.log.trace("Entering upgradeSchemaCallback");
        if (upgrade) {
            kony.sync.syncStartSession(); //download initial data for new columns
        } else {
            kony.sync.isSessionInProgress = false; // closing the session
            kony.sync.httprequestsinglesession = false;
            kony.sync.currentSyncReturnParams.upgradeRequired = false;
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onPerformUpgradeSuccessKey], kony.sync.currentSyncReturnParams);
            delete kony.sync.currentSyncReturnParams.upgradeRequired;
        }
    }
};
sync.isUpgradeRequired = function(config) {
    sync.log.trace("Entering kony.sync.isUpgradeRequired");
    if (kony.sync.validateSyncConfigParams("isUpgradeRequired", config) === false) {
        return;
    }
    if (kony.sync.preProcessSyncConfig("isUpgradeRequired", config, config[kony.sync.onIsUpgradeRequiredErrorKey], false) === false) {
        return;
    }
    kony.sync.areSyncConfigVersionDifferent(areSyncConfigVersionDifferentCallback);

    function areSyncConfigVersionDifferentCallback(isError, errorObject, isDifferent) {
        sync.log.trace("Entering areSyncConfigVersionDifferentCallback");
        if (isError) {
            kony.sync.verifyAndCallClosure(config[kony.sync.onIsUpgradeRequiredErrorKey], errorObject);
        } else {
            if (isDifferent) {
                kony.sync.verifyAndCallClosure(config[kony.sync.onIsUpgradeRequiredSuccessKey], {
                    upgradeRequired: true
                });
            } else {
                config[kony.sync.onUpgradeQueriesDownloadStartKey] = config[kony.sync.onIsUpgradeRequiredStartKey];
                kony.sync.callSchemaUpgradeService(schemaUpgradeCallback, false);
            }
        }
    }

    function schemaUpgradeCallback(serverResponse) {
        sync.log.trace("Entering schemaUpgradeCallback");
        if (!kony.sync.isNullOrUndefined(serverResponse.opstatus) && serverResponse.opstatus != 0) {
            sync.log.error("Schema Upgrade Response : ", serverResponse);
            if (!kony.sync.isNullOrUndefined(serverResponse.d)) {
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onIsUpgradeRequiredErrorKey], kony.sync.getServerError(serverResponse.d));
            } else {
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onIsUpgradeRequiredErrorKey], kony.sync.getServerError(serverResponse));
            }
            return;
        } else if (kony.sync.isNullOrUndefined(serverResponse.d)) {
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onIsUpgradeRequiredErrorKey], kony.sync.getServerError(serverResponse));
            return;
        }
        if (serverResponse.d.error === "true") {
            sync.log.error("Schema Upgrade Response : ", serverResponse);
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onIsUpgradeRequiredErrorKey], kony.sync.getServerError(serverResponse.d));
            return;
        }
        var returnParams = {};
        kony.sync.addServerDetails(returnParams, serverResponse);
        returnParams.upgradeRequired = serverResponse.d.upgradeavailable === "true" ? true : false;
        kony.sync.verifyAndCallClosure(config[kony.sync.onIsUpgradeRequiredSuccessKey], returnParams);
    }
};
kony.sync.areSyncConfigVersionDifferent = function(callback) {
    sync.log.trace("Entering kony.sync.areSyncConfigVersionDifferent ");
    var dbname = kony.sync.scopes[0][kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    var isError = false;
    var isDifferent = false;
    if (connection !== null) {
        kony.sync.startTransaction(connection, transactioncallback, transactionSuccessCallback, transactionErrorCallback);
    }

    function transactioncallback(tx) {
        sync.log.trace("Entering transactioncallback");
        var sql = "select * from " + kony.sync.syncConfigurationTableName;
        var resultset = kony.sync.executeSql(tx, sql, null);
        if (resultset === false) {
            isError = true;
            return;
        }
        var dbSyncConfigVersion = kony.db.sqlResultsetRowItem(tx, resultset, 0)[kony.sync.syncConfigurationColumnVersion];
        if (dbSyncConfigVersion !== konysyncClientSyncConfig.Version) {
            isDifferent = true;
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering transactionSuccessCallback");
        callback(false, null, isDifferent);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        callback(true, kony.sync.getTransactionError(isError));
    }
};
kony.sync.isSchemaUpgradeTimeStampEmpty = function(val) {
    sync.log.trace("Entering kony.sync.isSchemaUpgradeTimeStampEmpty ");
    if (val === "" || val === "0,0" || kony.sync.isNullOrUndefined(val)) {
        return true;
    } else {
        return false;
    }
};
//  **************** End KonySyncSchemaUpgrade.js*******************
//  **************** Start konySyncServiceProvider.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.konyDownloadChanges = function(serverblob, scope, downloadNetworkCallback, isInitialized, schemaUpgradeServerblob) {
    sync.log.trace("Entering kony.sync.konyDownloadChanges ");
    if (kony.sync.isSyncStopped) {
        kony.sync.stopSyncSession();
        return;
    }
    var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];

    function downloadNetworkCallbackStatus(status, result) {
        sync.log.trace("Entering downloadNetworkCallbackStatus");
        if (status === 400) {
            sync.log.trace("Entering kony.sync.konyDownloadChanges->downloadNetworkCallbackStatus");
            //fallback when opstatus < 0
            if (result.opstatus < 0) {
                sync.log.info("Got result.opstatus:" + result.opstatus + " and result.errcode:" + result.errcode + "setting errcode to opstatus");
                result.opstatus = result.errcode;
            }
            if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                retries--;
                kony.sync.retryServiceCall(kony.sync.getDownloadURL(), result, null, retries, checkForChunking, params);
            } else {
                if (kony.sync.eligibleForChunking(result)) {
                    kony.sync.startChunking(kony.sync.getChunkDownloadURL(), params, result, downloadNetworkCallback);
                } else {
                    kony.sync.setSessionID(result);
                    downloadNetworkCallback(result);
                }
            }
        } else if (status === 300) {
            sync.log.warn("Got status 300 for Download, Network call Cancelled.");
            if (!kony.sync.isNullOrUndefined(retries) && (retries > 0)) {
                retries--;
                var infoObj = {};
                infoObj.retryOnNetworkCancel = true;
                sync.log.debug("Retrying the network call for status 300 ");
                if (kony.sync.isNullOrUndefined(result)) {
                    result = kony.sync.getNetworkCancelError();
                }
                kony.sync.retryServiceCall(kony.sync.getDownloadURL(), result, infoObj, retries, checkForChunking, params);
            } else {
                downloadNetworkCallback(kony.sync.getNetworkCancelError());
            }
        }
    }

    function checkForChunking(result, info, retry) {
        sync.log.trace("Entering kony.sync.konyDownloadChanges->checkForChunking");
        retries = retry;
        downloadNetworkCallbackStatus(400, result, info);
    }
    if (kony.sync.isNullOrUndefined(serverblob)) {
        serverblob = "";
    }
    var params = {};
    //check for pending chunks
    kony.sync.checkForChunkingBeforeDownload(serverblob, normaldownloadCallback, downloadNetworkCallback, schemaUpgradeServerblob);

    function normaldownloadCallback(payloadId) {
        sync.log.trace("Entering kony.sync.konyDownloadChanges->normaldownloadCallback");
        var jsonContext = null;
        if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncScopeFilter)) {
            var scopejsonfilter = {
                "d": {
                    Filters: kony.sync.currentSyncScopeFilter
                }
            };
            jsonContext = JSON.stringify(scopejsonfilter);
        }
        if (isInitialized === false) {
            kony.sync.downloadClientContext.InitialSync = "true";
        } else {
            delete kony.sync.downloadClientContext.InitialSync;
        }
        params.clientcontext = kony.sync.downloadClientContext;
        kony.sync.commonServiceParams(params);
        params.context = jsonContext;
        params.enablebatching = "true";
        params.batchsize = kony.sync.getBatchSize();
        if (kony.sync.schemaUpgradeDownloadPending) {
            params.tickcount = schemaUpgradeServerblob;
            params.uppertickcount = serverblob;
            if (!kony.sync.isNullOrUndefined(kony.sync.schemaUpgradeContext)) {
                params.upgradecontext = kony.sync.schemaUpgradeContext;
            }
        } else {
            params.tickcount = serverblob;
        }
        params.scopename = kony.sync.currentScope[kony.sync.scopeName];
        params.strategy = kony.sync.currentScope[kony.sync.syncStrategy];
        params.instanceid = kony.sync.getInstanceID();
        params.clientid = kony.sync.getDeviceID();
        params.appVersion = kony.sync.currentSyncConfigParams.appVersion;
        params[kony.sync.chunkSizeKey] = kony.sync.getChunkSize();
        //include payloadid if it is not null
        if (!kony.sync.isNull(payloadId)) {
            params.deletechunkpayloadid = payloadId;
        }
        if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
            params.httpconfig = {
                timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
            };
        }
        if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks]) && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][kony.sync.currentScope[kony.sync.scopeName]])) {
            params[kony.sync.sessionTaskUploadErrorPolicy] = kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][kony.sync.currentScope[kony.sync.scopeName]][kony.sync.sessionTaskUploadErrorPolicy];
        }
        var paramsToSend = null;
        var currentSyncReturnParamsTemp = kony.sync.currentSyncReturnParams;
        currentSyncReturnParamsTemp.downloadRequest = params;
        kony.sync.deleteMapKey(currentSyncReturnParamsTemp, kony.sync.serverDetails);
        if (kony.sync.globalIsDownloadStarted || kony.sync.isChunkingResumedPostSyncError) {
            paramsToSend = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onDownloadStart], currentSyncReturnParamsTemp);
            kony.sync.globalIsDownloadStarted = false;
            kony.sync.isChunkingResumedPostSyncError = false;
            if (!kony.sync.isNullOrUndefined(paramsToSend)) {
                params = paramsToSend;
                kony.sync.downloadClientContext = params.clientcontext;
            }
        }
        currentSyncReturnParamsTemp.downloadRequest = params;
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onBatchProcessingStart], kony.sync.currentSyncReturnParams);
        if (paramsToSend != null) {
            params = paramsToSend;
            kony.sync.downloadClientContext = params.clientcontext;
        }
        currentSyncReturnParamsTemp = null;
        paramsToSend = null;
        params.clientcontext = JSON.stringify(kony.sync.downloadClientContext);
        sync.log.info("Hitting the service with URL " + kony.sync.getDownloadURL(), params);
        kony.sync.invokeServiceAsync(kony.sync.getDownloadURL(), params, downloadNetworkCallbackStatus, null);
    }
};
kony.sync.konyUploadChanges = function(changes, uploadNetworkcallback, lastBatch, lastjson) {
    sync.log.trace("Entering kony.sync.konyUploadChanges");
    if (kony.sync.isSyncStopped) {
        kony.sync.stopSyncSession();
        return;
    }
    var results1 = [];
    var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
    var jsonLua = null;
    var json = null;

    function uploadNetworkCallbackStatus(status, result, info) {
        sync.log.trace("Entering uploadNetworkCallbackStatus");
        if (status === 400) {
            sync.log.trace("Entering kony.sync.konyUploadChanges->uploadNetworkCallbackStatus");
            //fallback when opstatus < 0
            if (result.opstatus < 0) {
                sync.log.info("Got result.opstatus:" + result.opstatus + " and result.errcode:" + result.errcode + "setting errcode to opstatus");
                result.opstatus = result.errcode;
            }
            if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                retries--;
                kony.sync.retryServiceCall(kony.sync.getUploadURL(), result, info, retries, retryCallback, params);
            } else {
                kony.sync.setSessionID(result);
                uploadNetworkcallback(result, json);
                results1 = null;
                jsonLua = null;
            }
        } else if (status === 300) {
            uploadNetworkcallback(kony.sync.getNetworkCancelError(), json);
        }
    }

    function retryCallback(result, info, retry) {
        sync.log.trace("Entering kony.sync.konyUploadChanges->retryCallback");
        retries = retry;
        uploadNetworkCallbackStatus(400, result);
    }
    if (lastjson === null) {
        if (!kony.sync.isNullOrUndefined(changes.tables)) {
            for (var i = 0; i < changes.tables.length; i++) {
                var tableChange = changes.tables[i];
                var tableName = tableChange.tableName;
                if (!kony.sync.isNullOrUndefined(tableChange.changes)) {
                    for (var j = 0; j < tableChange.changes.length; j++) {
                        var rowChange = tableChange.changes[j];
                        if (kony.sync.isNullOrUndefined(rowChange.syncConflict)) {
                            rowChange.syncConflict = "";
                        }
                        var result = {
                            metadata: {
                                type: tableName,
                                uri: changes.uri,
                                changetype: rowChange.changeType,
                                syncConflict: rowChange.syncConflict
                            }
                        };
                        if (!kony.sync.isNullOrUndefined(rowChange.fields)) {
                            var fcount = kony.sync.getArrayCount(rowChange.fields);
                            for (var k = 0; k < fcount; k++) {
                                if (rowChange.fields[k] !== "ServerId" && rowChange.fields[k] !== "UpdateId") {
                                    result[rowChange.fields[k]] = rowChange.values[k];
                                }
                            }
                        }
                        results1.push(result);
                    }
                }
            }
        }
        var moreChangesAvailable = null;
        if (lastBatch === true) {
            moreChangesAvailable = false;
        } else {
            moreChangesAvailable = true;
        }
        jsonLua = {
            d: {
                results: results1,
                sync: "not implemented",
                scopeName: changes.scopeName,
                serverBlob: changes.serverblob,
                clientid: changes.clientid,
                SequenceNumber: changes.SequenceNumber,
                moreChangesAvailable: moreChangesAvailable
            }
        };
        json = JSON.stringify(jsonLua);
    } else {
        json = lastjson;
    }
    var params = {};
    kony.sync.commonServiceParams(params);
    params.UploadRequest = json;
    params.scopename = kony.sync.currentScope[kony.sync.scopeName];
    params.strategy = kony.sync.currentScope[kony.sync.syncStrategy];
    params.instanceid = kony.sync.getInstanceID();
    params.clientid = kony.sync.getDeviceID();
    params.appVersion = kony.sync.currentSyncConfigParams.appVersion;
    if (kony.sync.forceUpload || kony.sync.forceUploadUpgrade) {
        params.usehistoryconfig = "true";
    }
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks]) && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][kony.sync.currentScope[kony.sync.scopeName]])) {
        params[kony.sync.sessionTaskUploadErrorPolicy] = kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][kony.sync.currentScope[kony.sync.scopeName]][kony.sync.sessionTaskUploadErrorPolicy];
    }
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
        params.httpconfig = {
            timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
        };
    }
    params.clientcontext = kony.sync.uploadClientContext;
    var paramsToSend = null;
    var currentSyncReturnParamsTemp = kony.sync.currentSyncReturnParams;
    currentSyncReturnParamsTemp.uploadRequest = params;
    kony.sync.deleteMapKey(currentSyncReturnParamsTemp, kony.sync.serverDetails);
    if (kony.sync.isUploadStarted) {
        paramsToSend = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUploadStart], currentSyncReturnParamsTemp);
        if (paramsToSend != null) {
            params = paramsToSend;
            kony.sync.uploadClientContext = params.clientcontext;
        }
        kony.sync.isUploadStarted = false;
    }
    currentSyncReturnParamsTemp.uploadRequest = params;
    paramsToSend = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUploadBatchStart], currentSyncReturnParamsTemp);
    if (!kony.sync.isNullOrUndefined(paramsToSend)) {
        params = paramsToSend;
        kony.sync.uploadClientContext = params.clientcontext;
    }
    params.clientcontext = JSON.stringify(kony.sync.uploadClientContext);
    currentSyncReturnParamsTemp = null;
    paramsToSend = null;
    sync.log.info("Hitting the service with URL : " + kony.sync.getUploadURL(), params);
    kony.sync.invokeServiceAsync(kony.sync.getUploadURL(), params, uploadNetworkCallbackStatus, null);
};
kony.sync.konyRegisterDevice = function(registerDeviceCallback) {
    sync.log.trace("Entering kony.sync.konyRegisterDevice");
    if (kony.sync.isSyncStopped) {
        kony.sync.stopSyncSession();
        return;
    }
    var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];

    function registerDeviceCallbackStatus(status, result) {
        sync.log.trace("Entering registerDeviceCallbackStatus");
        if (status === 400) {
            sync.log.trace("Entering kony.sync.konyRegisterDevice->registerDeviceCallbackStatus");
            //fallback when opstatus < 0
            if (result.opstatus < 0) {
                sync.log.info("Got result.opstatus:" + result.opstatus + " and result.errcode:" + result.errcode + "setting errcode to opstatus");
                result.opstatus = result.errcode;
            }
            if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                retries--;
                kony.sync.retryServiceCall(kony.sync.getRegisterDeviceURL(), result, null, retries, retryCallback, params);
            } else {
                kony.sync.setSessionID(result);
                registerDeviceCallback(result);
            }
        } else if (status === 300) {
            registerDeviceCallback(kony.sync.getNetworkCancelError());
        }
    }

    function retryCallback(result, info, retry) {
        sync.log.trace("Entering kony.sync.konyRegisterDevice->retryCallback");
        retries = retry;
        registerDeviceCallbackStatus(400, result, info);
    }
    var params = {};
    kony.sync.commonServiceParams(params);
    params.os = kony.os.deviceInfo().name;
    params.model = kony.os.deviceInfo().model;
    params.version = kony.os.deviceInfo().version + "";
    params.deviceID = kony.sync.getDeviceID();
    params.userAgent = kony.os.userAgent();
    params.channel = kony.sync.getChannelName();
    params.platform = kony.sync.getPlatformName();
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
        params.httpconfig = {
            timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
        };
    }
    sync.log.info("Hitting the service with URL :" + kony.sync.getRegisterDeviceURL(), params);
    kony.sync.invokeServiceAsync(kony.sync.getRegisterDeviceURL(), params, registerDeviceCallbackStatus, null);
};
kony.sync.callSchemaUpgradeService = function(schemaUpgradeCallback, scriptsRequired) {
    sync.log.trace("Entering kony.sync.callSchemaUpgradeService");
    if (kony.sync.isSyncStopped) {
        kony.sync.stopSyncSession();
        return;
    }
    var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];

    function schemaUpgradeServiceStatus(status, result) {
        sync.log.trace("Entering schemaUpgradeServiceStatus");
        if (status === 400) {
            sync.log.trace("Entering kony.sync.callSchemaUpgradeService->schemaUpgradeServiceStatus");
            //fallback when opstatus < 0
            if (result.opstatus < 0) {
                sync.log.info("Got result.opstatus:" + result.opstatus + " and result.errcode:" + result.errcode + "setting errcode to opstatus");
                result.opstatus = result.errcode;
            }
            if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                retries--;
                kony.sync.retryServiceCall(kony.sync.getSchemaUpgradeURL(), result, null, retries, retryCallback, params);
            } else {
                kony.sync.setSessionID(result);
                schemaUpgradeCallback(result);
            }
        }
    }

    function retryCallback(result, info, retry) {
        sync.log.trace("Entering kony.sync.callSchemaUpgradeService->retryCallback");
        retries = retry;
        schemaUpgradeServiceStatus(400, result, info);
    }
    var params = {};
    kony.sync.commonServiceParams(params);
    params.clientid = kony.sync.getDeviceID();
    params.appversion = konysyncClientSyncConfig.Version;
    params.dbversion = kony.sync.configVersion;
    params.scriptsrequired = (scriptsRequired === false) ? "false" : "true";
    var paramsToSend = null;
    paramsToSend = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesDownloadStartKey], params);
    if (!kony.sync.isNullOrUndefined(paramsToSend)) {
        params = paramsToSend;
    }
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
        params.httpconfig = {
            timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
        };
    }
    sync.log.info("Hitting the service with URL :" + kony.sync.getSchemaUpgradeURL(), params);
    kony.sync.invokeServiceAsync(kony.sync.getSchemaUpgradeURL(), params, schemaUpgradeServiceStatus, null);
};
kony.sync.getServerURL = function() {
    sync.log.trace("Entering kony.sync.getServerURL ");
    if (!kony.sync.isNullOrUndefined(kony.sdk.getCurrentInstance()) && !kony.sync.isNullOrUndefined(kony.sdk.getCurrentInstance().sync) && !kony.sync.isNullOrUndefined(kony.sdk.getCurrentInstance().sync.url)) {
        sync.log.trace("Fetching sync url from mbaas-sdk service docs instance");
        return kony.sdk.getCurrentInstance().sync.url + "/";
    }
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.serverurl)) {
        return kony.sync.currentSyncConfigParams.serverurl;
    }
    var server = "";
    if (kony.sync.currentSyncConfigParams.issecure === true) {
        server = "https://" + kony.sync.currentSyncConfigParams.serverhost;
    } else {
        server = "http://" + kony.sync.currentSyncConfigParams.serverhost;
    }
    if (kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.serverport)) {
        server = server + ":80";
    } else if (kony.sync.currentSyncConfigParams.serverport !== "") {
        server = server + ":" + kony.sync.currentSyncConfigParams.serverport;
    }
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.authTokenKey])) {
        return server + "/syncservice/api/v1/" + kony.sync.getAppId() + "/";
    } else {
        return server + "/syncservice/resources/";
    }
};
kony.sync.getUploadURL = function() {
    sync.log.trace("Entering kony.sync.getUploadURL ");
    var server = kony.sync.getServerURL();
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.uploadwebcontext)) {
        return server + kony.sync.currentSyncConfigParams.uploadwebcontext;
    }
    return server + "upload";
};
kony.sync.getDownloadURL = function() {
    sync.log.trace("Entering kony.sync.getDownloadURL ");
    var server = kony.sync.getServerURL();
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.downloadwebcontext)) {
        return server + kony.sync.currentSyncConfigParams.downloadwebcontext;
    }
    return server + "download";
};
kony.sync.getRegisterDeviceURL = function() {
    sync.log.trace("Entering kony.sync.getRegisterDeviceURL ");
    var server = kony.sync.getServerURL();
    return server + "registerdevice";
};
kony.sync.getSchemaUpgradeURL = function() {
    sync.log.trace("Entering kony.sync.getSchemaUpgradeURL ");
    var server = kony.sync.getServerURL();
    return server + "upgrade";
};
kony.sync.httprequest = null;
kony.sync.httprequestsinglesession = false;
//IF user passes his own function instead of using kony.net.invokeServiceAsync
//this is how it would be called.
kony.sync.invokeServiceAsync = function(url, params, callback, context) {
    sync.log.trace("Entering kony.sync.invokeServiceAsync ");
    if (kony.sync.isMbaasEnabled) {
        kony.sdk.claimsRefresh(claimsRefreshSuccessCallBack, claimsRefreshFailureCallBack);

        function claimsRefreshSuccessCallBack() {
            sync.log.trace("Entering claimsRefreshSuccessCallBack");
            if (params && params.httpheaders) {
                var currentClaimToken = kony.sdk.getCurrentInstance().currentClaimToken;
                if (kony.sync.currentSyncConfigParams[kony.sync.authTokenKey] != currentClaimToken) {
                    kony.sync.currentSyncConfigParams[kony.sync.authTokenKey] = currentClaimToken;
                }
                params.httpheaders["X-Kony-Authorization"] = currentClaimToken;
                invokeServiceAsyncHelper(url, params, callback, context);
            }
        }

        function claimsRefreshFailureCallBack(res) {
            sync.log.trace("Entering claimsRefreshFailureCallBack");
            callback(400, res, context);
        }
    } else {
        invokeServiceAsyncHelper(url, params, callback, context);
    }

    function invokeServiceAsyncHelper(url, params, callback, context) {
        sync.log.info("Entering invokeServiceAsyncHelper");
        if (kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.invokeServiceFunctionKey])) {
            var deviceInfo = kony.os.deviceInfo();
            var timeoutValue = 0;
            var paramsHttpheaders = null;
            if (kony.sync.isPhonegap) {
                kony.net.invokeServiceAsync(url, params, callback, context);
            } else {
                if (!kony.net.isNetworkAvailable(constants.NETWORK_TYPE_ANY)) {
                    var response = {
                        'opstatus': 1011,
                        'errmsg': "Device has no WIFI or mobile connectivity. Please try the operation after establishing connectivity."
                    };
                    callback(400, response, context);
                    return;
                }
                var paramsTable = new kony.net.FormData();
                for (var key in params) {
                    if (!kony.sync.isNull(params[key])) {
                        if (key.toLowerCase() === "httpheaders") {
                            paramsHttpheaders = params[key];
                            continue;
                        }
                        if (key.toLowerCase() === "httpconfig") {
                            timeoutValue = kony.sync.tonumber(params[key]["timeout"]);
                            continue;
                        }
                        paramsTable.append((key), (params[key]));
                    }
                }

                function appendGlobalHeaders(headers) {
                    sync.log.trace("Entering appendGlobalHeaders ");
                    var sdkInstance = kony.sdk.getCurrentInstance();
                    if (sdkInstance) {
                        var globalHeaders = sdkInstance.getGlobalRequestParams(sdkInstance.globalRequestParamType.headers);
                        if (!kony.sdk.isNullOrUndefined(globalHeaders)) {
                            if (kony.sdk.isNullOrUndefined(headers)) {
                                headers = {};
                            }
                            for (var obj in globalHeaders) {
                                if (kony.sdk.isNullOrUndefined(headers[obj])) {
                                    headers[obj] = globalHeaders[obj];
                                }
                            }
                        }
                    }
                };

                function createNewHttpRequest(sessionid, paramsHttpheaders, localRequestCallback, url, timeoutValue) {
                    sync.log.info("Entering createNewHttpRequest");
                    var httprequest = null;
                    httprequest = (sessionid === null) ? new kony.net.HttpRequest() : new kony.net.HttpRequest(sessionid);
                    if (timeoutValue > 0) {
                        httprequest.timeout = timeoutValue * 1000;
                    }
                    httprequest.onReadyStateChange = localRequestCallback;
                    httprequest.open(constants.HTTP_METHOD_POST, url);
                    if (paramsHttpheaders !== null) {
                        for (var key in paramsHttpheaders) {
                            httprequest.setRequestHeader(key, paramsHttpheaders[key]);
                        }
                    }
                    var isContentTypeAvailable = false;
                    if (typeof(paramsHttpheaders) !== 'undefined' && paramsHttpheaders !== null) {
                        //check for content-type case insensitive
                        for (var header in paramsHttpheaders) {
                            if (header !== null && header !== 'undefined') {
                                if (header.toLowerCase() === "content-type") isContentTypeAvailable = true
                            }
                        }
                        if (!isContentTypeAvailable) {
                            httprequest.setRequestHeader("Content-Type", "application/json");
                        }
                    }
                    return httprequest;
                };
                appendGlobalHeaders(paramsHttpheaders);
                var httprequest = kony.sync.httprequest;
                httprequest = createNewHttpRequest(null, paramsHttpheaders, localRequestCallback, url, timeoutValue);
                httprequest.send(paramsTable);
            }
        } else {
            kony.sync.currentSyncConfigParams[kony.sync.invokeServiceFunctionKey](url, params, callback, context);
        }

        function localRequestCallback(httprequest) {
            sync.log.trace("Entering localRequestCallback");
            var readyState = Number(httprequest.readyState.toString());
            var status = Number(httprequest.status.toString());
            var localresponse = {};
            if (readyState == 4) {
                kony.sdk.setLogLevelFromServerResponse(httprequest.getAllResponseHeaders()); //
                if (status == 200) {
                    if (kony.sync.isNullOrUndefined(httprequest.response)) {
                        localresponse = {
                            'opstatus': 1012
                        };
                    } else {
                        localresponse = httprequest.response;
                    }
                } else {
                    localresponse = {
                        'opstatus': 1012
                    };
                }
                callback(400, localresponse, context);
            }
        }
    } //end of invokeServiceAsyncHelper
};
kony.sync.commonServiceParams = function(params) {
    sync.log.trace("Entering kony.sync.commonServiceParams ");
    var httpheaders = {};
    if (!(kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams)) && !(kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.userid)) && !(kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.password))) {
        params.userid = kony.sync.currentSyncConfigParams.userid;
        params.password = kony.sync.genHash(kony.sync.currentSyncConfigParams[kony.sync.passwordHashingAlgo], kony.sync.currentSyncConfigParams.password);
    }
    if (!kony.sync.isNullOrUndefined(kony.sdk.getCurrentInstance()) && !kony.sync.isNullOrUndefined(kony.sdk.getCurrentInstance().currentClaimToken)) {
        sync.log.trace("mbaas sdk instance is alive so adding current claims token");
        if (!kony.sync.isMbaasEnabled) {
            kony.sync.isMbaasEnabled = true;
        }
        httpheaders["X-Kony-Authorization"] = kony.sdk.getCurrentInstance().currentClaimToken;
    } else if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams)) {
        if (kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.authTokenKey])) {
            sync.log.trace("Neither Mbaas sdk instance and sync config auth token are not there, so adding userid, password and appid instead of token");
            params.AppID = kony.sync.getAppId();
        } else {
            if (!kony.sync.isMbaasEnabled) {
                kony.sync.isMbaasEnabled = true;
            }
            params.AppID = kony.sync.getAppId();
            httpheaders["X-Kony-Authorization"] = kony.sync.currentSyncConfigParams[kony.sync.authTokenKey];
        }
    }
    if (!kony.sync.isNullOrUndefined(kony.sync.sessionMap[kony.sync.konySyncSessionID]) && !kony.sync.isNullOrUndefined(kony.sync.sessionMap[kony.sync.konySyncRequestNumber])) {
        params.konysyncsessionid = kony.sync.sessionMap[kony.sync.konySyncSessionID];
        params.konysyncrequestnumber = kony.sync.sessionMap[kony.sync.konySyncRequestNumber];
    }
    httpheaders["Content-Type"] = "application/json";
    params.httpheaders = httpheaders;
};
kony.sync.setSessionID = function(response) {
    if (!kony.sync.isNullOrUndefined(response.d) && !kony.sync.isNullOrUndefined(response.d.__session)) {
        kony.sync.sessionMap[kony.sync.konySyncSessionID] = response.d.__session.id;
        kony.sync.sessionMap[kony.sync.konySyncRequestNumber] = response.d.__session.requestnumber;
    }
};
kony.sync.resetSessionVars = function() {
    sync.log.trace("Entering kony.sync.resetSessionVars ");
    kony.sync.sessionMap = {};
};
kony.sync.getDownloadBinaryURL = function() {
    sync.log.trace("Entering kony.sync.getDownloadBinaryURL ");
    var server = kony.sync.getServerURL();
    sync.log.trace("server url created -> kony.sync.getDownloadBinaryURL " + server);
    return server + "downloadBinary";
};
kony.sync.getUploadBinaryURL = function() {
        sync.log.trace("Entering kony.sync.getUploadBinaryURL ");
        var server = kony.sync.getServerURL();
        sync.log.trace("server url created -> kony.sync.getUploadBinaryURL " + server);
        return server + "uploadBinary";
    }
    //  **************** End konySyncServiceProvider.js*******************
    //  **************** Start KonySyncSkyLib.js*******************
kony.sky = {};
//Sky Constants
kony.sky.EventStart = "START";
kony.sky.EventFinish = "FINISH";
kony.sky.EventError = "ERROR";
kony.sky.ConfigParamServer = "SERVER";
kony.sky.ConfigParamPort = "PORT";
kony.sky.ConfigParamProfile = "PROFILE";
kony.sky.ConfigParamSslDisabledProtocols = "SSLDISABLEDPROTOCOLS";
kony.sky.ConfigParamUsewifi = "USEWIFI";
kony.sky.ConfigParamUser = "USER";
kony.sky.ConfigParamPasswd = "PASSWORD";
kony.sky.BBPlatform = "blackberry";
kony.sky.TrueStr = "TRUE";
kony.sky.BBPlatformName = "blackberry";
kony.sky.ConfigParamConnMode = "CONNECTIONMODE";
kony.sky.startSkyCallback = "onSkyStart";
kony.sky.startIdentifyCallback = "onIndentifyStart";
kony.sky.successIdentifyCallback = "onIndentifySuccess";
kony.sky.errorIdentifyCallback = "onIndentifyError";
kony.sky.errorSkyCallback = "onSkyError";
kony.sky.startSessionCallback = "onSessionStart";
kony.sky.successSessionCallback = "onSessionSuccess";
kony.sky.errorSessionCallback = "onSessionError";
kony.sky.successSkyCallback = "onSkySuccess";
kony.sky.errorCode = "errorCode";
kony.sky.errorMessage = "errorMessage";
//provision callback methods
kony.sky.startProvisionCallback = "onProvisionStart";
kony.sky.successProvisionCallback = "onProvisionSuccess";
kony.sky.errorProvisionCallback = "onProvisionError";
//reset callback methods
kony.sky.startResetCallback = "onResetStart";
kony.sky.successResetCallback = "onResetSuccess";
kony.sky.errorResetCallback = "onResetError";
//stop callback methods
kony.sky.startStopCallback = "onStopStart";
kony.sky.successStopCallback = "onStopSuccess";
kony.sky.errorStopCallback = "onStopError";
//dataobject upload callback methods
kony.sky.startUploadCallback = "onUploadStart";
kony.sky.successUploadCallback = "onUploadSuccess";
kony.sky.errorUploadCallback = "onUploadError";
//transaction
kony.sky.startTransactionCallback = "onStartTransaction";
kony.sky.successTransactionCallback = "onSuccessTransaction";
kony.sky.parentTableInfo = "parentTable";
kony.sky.provisionSkySync = function(config) {
    sync.log.trace("Entering kony.sky.provisionSkySync ");
    var isProvisioned = sky.isProvisioned();
    sync.log.info("SkySync engine provisioned status : ", isProvisioned);
    if (config[kony.sky.ConfigParamServer] === null || config[kony.sky.ConfigParamServer] === "" || config[kony.sky.ConfigParamPort] === null || config[kony.sky.ConfigParamPort] === "" || config[kony.sky.ConfigParamProfile] === null || config[kony.sky.ConfigParamProfile] === "") {
        var params = {};
        params[kony.sky.errorCode] = "7101";
        params[kony.sky.errorMessage] = kony.sky.errorMessageForCode(params[kony.sky.errorCode]);
        kony.sync.verifyAndCallClosure(config[kony.sky.errorProvisionCallback], params);
        return;
    }
    if (!isProvisioned) {
        var inputParam = {};
        inputParam[kony.sky.ConfigParamServer] = config[kony.sky.ConfigParamServer];
        inputParam[kony.sky.ConfigParamPort] = config[kony.sky.ConfigParamPort];
        inputParam[kony.sky.ConfigParamProfile] = config[kony.sky.ConfigParamProfile];
        if (!kony.sync.isNull(config[kony.sky.ConfigParamPasswd])) {
            inputParam[kony.sky.ConfigParamPasswd] = config[kony.sky.ConfigParamPasswd];
        }
        if (!kony.sync.isNull(config[kony.sky.ConfigParamUser])) {
            inputParam[kony.sky.ConfigParamUser] = config[kony.sky.ConfigParamUser];
        }
        if (!kony.sync.isNull(config[kony.sky.ConfigParamUsewifi])) {
            inputParam[kony.sky.ConfigParamUsewifi] = config[kony.sky.ConfigParamUsewifi];
        }
        if (!kony.sync.isNull(config[kony.sky.ConfigParamConnMode])) {
            inputParam[kony.sky.ConfigParamConnMode] = config[kony.sky.ConfigParamConnMode];
        }
        if (!kony.sync.isNull(config[kony.sky.ConfigParamSslDisabledProtocols])) {
            inputParam[kony.sky.ConfigParamSslDisabledProtocols] = config[kony.sky.ConfigParamSslDisabledProtocols];
        }
        sky.provision(inputParam, provisionSkySyncCallback);
    } else {
        kony.sync.verifyAndCallClosure(config[kony.sky.successProvisionCallback], null);
    }

    function provisionSkySyncCallback(event, args) {
        sync.log.trace("Entering provisionSkySyncCallback");
        if ((event !== kony.sky.EventStart)) {
            if ((event === kony.sky.EventError)) {
                if ((args !== null)) {
                    var params = {};
                    params[kony.sky.errorCode] = args.ERRORCODE;
                    params[kony.sky.errorMessage] = args.ERRORDESC;
                    kony.sync.verifyAndCallClosure(config[kony.sky.errorProvisionCallback], params);
                }
            }
            if ((event === kony.sky.EventFinish)) {
                kony.sync.verifyAndCallClosure(config[kony.sky.successProvisionCallback], null);
            }
        } else {
            kony.sync.verifyAndCallClosure(config[kony.sky.startProvisionCallback], null);
        }
    }
};
kony.sky.startSkySyncSession = function(config) {
    sync.log.trace("Entering kony.sky.startSkySyncSession ");
    var isIdentified = sky.isIdentified();
    if (config[kony.sky.ConfigParamUser] === null || config[kony.sky.ConfigParamPasswd] === null) {
        var params = {};
        params[kony.sky.errorCode] = "7101";
        params[kony.sky.errorMessage] = kony.sky.errorMessageForCode(params[kony.sky.errorCode]);
        kony.sync.verifyAndCallClosure(config[kony.sky.errorSkyCallback], params);
        return;
    }
    kony.sync.verifyAndCallClosure(config[kony.sky.startSkyCallback], null);
    if (!isIdentified) {
        var identifyParams = {};
        identifyParams[kony.sky.ConfigParamUser] = config[kony.sky.ConfigParamUser];
        identifyParams[kony.sky.ConfigParamPasswd] = config[kony.sky.ConfigParamPasswd];
        if (!kony.sync.isNull(config[kony.sky.ConfigParamUsewifi])) {
            identifyParams[kony.sky.ConfigParamUsewifi] = config[kony.sky.ConfigParamUsewifi];
        }
        if (!kony.sync.isNull(config[kony.sky.ConfigParamConnMode])) {
            identifyParams[kony.sky.ConfigParamConnMode] = config[kony.sky.ConfigParamConnMode];
        }
        if (!kony.sync.isNull(config[kony.sky.ConfigParamSslDisabledProtocols])) {
            identifyParams[kony.sky.ConfigParamSslDisabledProtocols] = config[kony.sky.ConfigParamSslDisabledProtocols];
        }
        sky.identify(identifyParams, false, identifySkySyncCallback);
    } else {
        identifySkySyncCallback(kony.sky.EventFinish, []);
    }

    function identifySkySyncCallback(event, args) {
        sync.log.trace("Entering identifySkySyncCallback");
        if (event !== kony.sky.EventStart) {
            if (event === kony.sky.EventError) {
                if ((args !== null)) {
                    var params = {};
                    params[kony.sky.errorCode] = args.ERRORCODE;
                    params[kony.sky.errorMessage] = args.ERRORDESC;
                    kony.sync.verifyAndCallClosure(config[kony.sky.errorIdentifyCallback], params);
                }
            }
            if (event === kony.sky.EventFinish) {
                kony.sync.verifyAndCallClosure(config[kony.sky.successIdentifyCallback], null);
                startSkySync();
            }
        } else {
            kony.sync.verifyAndCallClosure(config[kony.sky.startIdentifyCallback], null);
        }
    }

    function startSkySync() {
        sync.log.trace("Entering startSkySync ");
        var isStarted = sky.isStarted();
        sync.log.info("SkySync server status : ", isStarted);
        kony.sync.verifyAndCallClosure(config[kony.sky.startSessionCallback], null);
        if ((!isStarted)) {
            sky.start(startSkySyncCallback);
        } else {
            startSkySyncCallback(kony.sky.EventFinish, []);
        }
    }

    function startSkySyncCallback(event, args) {
        sync.log.trace("Entering startSkySyncCallback");
        if (event !== kony.sky.EventStart) {
            if (event === kony.sky.EventError) {
                if ((args !== null)) {
                    var params = {};
                    params[kony.sky.errorCode] = args.ERRORCODE;
                    params[kony.sky.errorMessage] = args.ERRORDESC;
                    kony.sync.verifyAndCallClosure(config[kony.sky.errorSessionCallback], params);
                }
            }
            if (event === kony.sky.EventFinish) {
                sync.log.info("SkySync server started Successful");
                kony.sync.verifyAndCallClosure(config[kony.sky.successSessionCallback], null);
                kony.sync.verifyAndCallClosure(config[kony.sky.successSkyCallback], null);
            }
        }
    }
};
kony.sky.skyEmptyFunction = function() {
    sync.log.trace("Entering kony.sky.skyEmptyFunction ");
};
kony.sky.getSkyGuiID = function() {
    sync.log.trace("Entering kony.sky.getSkyGuiID ");
    var serviceId = sky.getParameter("SERVERID");
    var currendate = kony.os.date("mm/dd/yyyy");
    var currtime = kony.sky.replaceColon(kony.os.time());
    var datevalue = currendate.split("/");
    var resultDate = datevalue[2] + datevalue[0] + datevalue[1] + currtime;
    var GUID = serviceId + "-" + resultDate;
    return GUID;
};
kony.sky.replaceColon = function(currtime) {
    sync.log.trace("Entering kony.sky.replaceColon ");
    if (kony.string.containsChars(currtime, [":"])) {
        currtime = currtime.replace(":", "");
        currtime = kony.sky.replaceColon(currtime);
    }
    return currtime;
};
kony.sky.generatePKTable = function(pk) {
    sync.log.trace("Entering kony.sky.generatePKTable ");
    var i = 0;
    var pks = [];
    for (var j in pk) {
        var v = pk[j];
        if (!kony.sync.isNull(v.key)) {
            pks[i] = v.key + " = " + v.value;
        } else {
            pks[i] = j + " = " + v;
        }
        i = i + 1;
    }
    return pks;
};
kony.sky.buildConditionSet = function(srchByTargetAttribute, targetKey) {
    sync.log.trace("Entering kony.sky.buildConditionSet ");
    var conditionSet = [];
    conditionSet[0] = srchByTargetAttribute + " = " + targetKey;
    return conditionSet;
};
kony.sky.beginTransaction = function(config) {
    sync.log.trace("Entering kony.sky.beginTransaction ");
    sky.beginTransaction(config[kony.sky.successTransactionCallback]);
};
kony.sky.commitTransaction = function(config) {
    sync.log.trace("Entering kony.sky.commitTransaction ");
    sky.commitTransaction(config[kony.sky.successTransactionCallback]);
};
kony.sky.rollbackTransaction = function(config) {
    sync.log.trace("Entering kony.sky.rollbackTransaction ");
    sky.rollbackTransaction(config[kony.sky.successTransactionCallback]);
};
kony.sky.resetSkyEngine = function(config) {
    sync.log.trace("Entering kony.sky.resetSkyEngine ");

    function resetCallback(event, args) {
        sync.log.trace("Entering resetCallback");
        if ((event !== kony.sky.EventStart)) {
            if ((event === kony.sky.EventError)) {
                if ((args !== null)) {
                    var params = {};
                    params[kony.sky.errorCode] = args.ERRORCODE;
                    params[kony.sky.errorMessage] = args.ERRORDESC;
                    kony.sync.verifyAndCallClosure(config[kony.sky.errorResetCallback], params);
                }
            }
            if ((event === kony.sky.EventFinish)) {
                kony.sync.verifyAndCallClosure(config[kony.sky.successResetCallback], null);
            }
        } else {
            kony.sync.verifyAndCallClosure(config[kony.sky.startResetCallback], null);
        }
    }
    sky.reset(resetCallback);
};
kony.sky.stopSkyEngine = function(config) {
    sync.log.trace("Entering kony.sky.stopSkyEngine ");

    function stopCallback(event, args) {
        sync.log.trace("Entering stopCallback");
        if ((event !== kony.sky.EventStart)) {
            if ((event === kony.sky.EventError)) {
                if ((args !== null)) {
                    var params = {};
                    params[kony.sky.errorCode] = args.ERRORCODE;
                    params[kony.sky.errorMessage] = args.ERRORDESC;
                    kony.sync.verifyAndCallClosure(config[kony.sky.errorStopCallback], params);
                }
            }
            if ((event === kony.sky.EventFinish)) {
                if (sky.isStarted()) {
                    sky.stop(stopCallback);
                } else {
                    kony.sync.verifyAndCallClosure(config[kony.sky.successStopCallback], null);
                }
            }
        } else {
            kony.sync.verifyAndCallClosure(config[kony.sky.startStopCallback], null);
        }
    }
    if (sky.isStarted()) {
        sky.stop(stopCallback);
    } else {
        kony.sync.verifyAndCallClosure(config[kony.sky.successStopCallback], null);
    }
};
kony.sky.errorMessageForCode = function(errorCode) {
    sync.log.trace("Entering kony.sky.errorMessageForCode ");
    var statusMsgTable = {};
    statusMsgTable["-1002"] = "ERROR_ALREADY_IDENTIFIED";
    statusMsgTable["-1003"] = "ERROR_ALREADY_PROVISIONED";
    statusMsgTable["-1004"] = "ERROR_BAD_CONDITION_SET";
    statusMsgTable["-1005"] = "ERROR_BLACKLISTED";
    statusMsgTable["-1006"] = "ERROR_CONFIGURATION";
    statusMsgTable["-1007"] = "ERROR_DATA_OBJECT_NOT_FOUND";
    statusMsgTable["-1008"] = "ERROR_DUPLICATE_ITEM";
    statusMsgTable["-1009"] = "ERROR_ENCRYPTION_HANDSHAKE";
    statusMsgTable["-1010"] = "ERROR_ENCRYPTION_MISMATCH";
    statusMsgTable["-1001"] = "ERROR_GENERAL_FAILURE";
    statusMsgTable["-1011"] = "ERROR_HOST_IF_SETUP_ERROR";
    statusMsgTable["-1012"] = "ERROR_HOST_NOT_AVAILABLE";
    statusMsgTable["-1013"] = "ERROR_IDENTITY_FAILURE";
    statusMsgTable["-1014"] = "ERROR_INVALID_PARAMETER";
    statusMsgTable["-1015"] = "ERROR_IS_STARTED";
    statusMsgTable["-1016"] = "ERROR_MEAP_IS_DISABLED";
    statusMsgTable["-1017"] = "ERROR_NO_CONFIGURATION";
    statusMsgTable["-1018"] = "ERROR_NO_INSTANCES_SELECTED";
    statusMsgTable["-1019"] = "ERROR_NOT_IDENTIFIED";
    statusMsgTable["-1020"] = "ERROR_NOT_PROVISIONED";
    statusMsgTable["-1021"] = "ERROR_NOT_RUNNING";
    statusMsgTable["-1022"] = "ERROR_PROFILE_DEACTIVATED";
    statusMsgTable["-1023"] = "ERROR_PROFILE_NOT_FOUND";
    statusMsgTable["-1024"] = "ERROR_RETRY";
    statusMsgTable["-1025"] = "ERROR_TABLE_NOT_FOUND";
    statusMsgTable["-1026"] = "ERROR_UNCAUGHT_EXCEPTION";
    statusMsgTable["-1027"] = "ERROR_USER_NOT_FOUND";
    statusMsgTable["7101"] = "MISSING ATTRIBUTES FOR SKY";
    var errMsg = "";
    if (statusMsgTable[errorCode] === null) {
        errMsg = "Some unknown error";
    } else {
        errMsg = statusMsgTable[errorCode];
    }
    return errMsg;
};
kony.sky.buildSkyOrderByMap = function(orderByMap) {
    sync.log.trace("Entering kony.sky.buildSkyOrderByMap ");
    var i = 0;
    var ordering = [];
    for (var j in orderByMap) {
        var v = orderByMap[j];
        var sortType = v.sortType;
        var orderBy = (v.key).toString();
        if (sortType === "desc") {
            orderBy = orderBy + " D*";
        } else {
            orderBy = orderBy + " *";
        }
        ordering[i] = orderBy;
        i = i + 1;
    }
    return ordering;
};
skySync = {
    init: kony.sky.provisionSkySync,
    startSession: kony.sky.startSkySyncSession,
    reset: kony.sky.resetSkyEngine,
    stop: kony.sky.stopSkyEngine,
    beginTransaction: kony.sky.beginTransaction,
    rollbackTransaction: kony.sky.rollbackTransaction,
    commitTransaction: kony.sky.commitTransaction,
    //	quiesce : kony.sky.quiesce,
    //unquiesce : kony.sky.unquiesce
};
//  **************** End KonySyncSkyLib.js*******************
//  **************** Start KonySyncUpload.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
kony.sync.syncUploadChanges = function(sname, dsname, onCompletion) {
    sync.log.trace("Entering kony.sync.syncUploadChanges ");
    kony.sync.onUploadCompletion = onCompletion;
    kony.sync.resetuploadsessioglobals();
    kony.sync.objectLevelInfoMap = {};
    kony.sync.OTAChangestobeDeleted = [];
    kony.sync.uploadcontextMap = {};
    kony.sync.getLastSyncUploadContext(sname, dsname, kony.sync.syncUploadChangesForBatch);
};
kony.sync.createClone = function(obj) {
    sync.log.trace("Entering kony.sync.createClone ");
    var copy;
    if (null == obj || "object" != typeof obj) return obj;
    if (obj instanceof Array) {
        copy = [];
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = kony.sync.createClone(obj[attr]);
        }
        return copy;
    }
    if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = kony.sync.createClone(obj[attr]);
        }
        return copy;
    }
}
kony.sync.syncUploadChangesForBatch = function(rowItem, previousUpload, limit) {
    sync.log.trace("Entering kony.sync.syncUploadChangesForBatch");
    var batchSize = kony.sync.getUploadBatchSize();
    var offset = 0;
    var serverblob1 = rowItem[kony.sync.metaTableUploadSyncTimeColumn];
    var lastSeqNo = rowItem[kony.sync.metaTableSyncOrderCloumn];
    //previousUpload = "";//temporary -- to be removed while handling duplicate row issue
    sync.log.info("Current Scope Server Time Stamp", serverblob1);
    kony.sync.currentSyncReturnParams[kony.sync.lastSyncTimestamp] = serverblob1;
    kony.sync.currentSyncReturnParams[kony.sync.uploadSequenceNumber] = kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName];
    var firstBatch = false;
    var lastBatch = false;
    var isError = false;
    var changeset = {
        clientid: kony.sync.getDeviceID(),
        SequenceNumber: kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName],
        serverblob: serverblob1,
        scopeName: kony.sync.currentScope[kony.sync.scopeName],
        uri: kony.sync.currentScope[kony.sync.scopeDataSource],
        totalChanges: 0,
        tables: []
    };

    function updateSyncOrderForDeferredRows(tx, limit) {
        sync.log.trace("Entering kony.sync.updateSyncOrderForDeferredRows");
        if (kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables)) {
            return true;
        }
        for (var i = 0; i < kony.sync.currentScope.ScopeTables.length; i++) {
            var syncTable = kony.sync.currentScope.ScopeTables[i];
            if (kony.sync.isNullOrUndefined(syncTable)) {
                continue;
            }
            var tablename = syncTable.Name;
            var settable = {};
            settable[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName];
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, tablename + kony.sync.historyTableName);
            kony.sync.qb_set(query, settable);
            kony.sync.qb_where(query, [{
                key: kony.sync.historyTableReplaySequenceColumn,
                value: limit,
                optype: "LT"
            }]);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return false;
            }
        }
        return true;
    }

    function uploadAllTransaction(tx) {
        sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->uploadAllTransaction");
        //get offset for the 1st batch
        if (kony.sync.isNull(limit) || previousUpload === "*") {
            if ((previousUpload == "*") && !kony.sync.isNull(limit)) {
                if (updateSyncOrderForDeferredRows(tx, limit) === false) {
                    isError = true;
                }
            }
            offset = kony.sync.getSmallestSequenceNumber(tx);
            if (offset === false) {
                isError = true;
                return;
            }
            if (previousUpload !== "*") {
                firstBatch = true; //If not resuming after sending duplicate row
            } else {
                previousUpload = "";
            }
        }
        //otherwise increase it by limit + 1
        else {
            offset = limit + 1;
        }
        limit = offset + batchSize - 1;
        var uploadCache = {};
        if (offset !== -1) {
            kony.sync.syncTotalBatchInserts = 0;
            kony.sync.syncTotalBatchUpdates = 0;
            kony.sync.syncTotalBatchDeletes = 0;
            var scopeName = kony.sync.currentScope[kony.sync.scopeName];
            var changeSetCopy = kony.sync.createClone(changeset);
            uploadCache[kony.sync.scope] = scopeName;
            uploadCache[kony.sync.offset] = offset;
            uploadCache[kony.sync.limit] = limit;
            uploadCache[kony.sync.changeSet] = JSON.stringify(changeSetCopy);
            uploadCache[kony.sync.lastSequenceNumber] = lastSeqNo;
            uploadCache[kony.sync.batchSize] = batchSize;
            //updating the offset in case of kony.sync.getBatchChanges is not able to get records in 1st attempt
            limit = kony.sync.getBatchChanges(tx, kony.sync.currentScope, offset, limit, changeset, lastSeqNo, batchSize);
            if (limit === false) {
                isError = true;
                return;
            }
            kony.sync.syncTotalInserts += kony.sync.syncTotalBatchInserts;
            kony.sync.syncTotalUpdates += kony.sync.syncTotalBatchUpdates;
            kony.sync.syncTotalDeletes += kony.sync.syncTotalBatchDeletes;
        }
        if (limit >= lastSeqNo) {
            lastBatch = true;
        }
        if (offset !== -1) {
            uploadCache[kony.sync.lastBatch] = lastBatch;
            uploadCache[kony.sync.uploadChangesLimit] = kony.sync.uploadLimit;
            cacheLastUploadRequest(tx, uploadCache);
        }
    }

    function cacheLastUploadRequest(tx, uploadCache) {
        sync.log.trace("Entering cacheLastUploadRequest");
        if (changeset.totalChanges > 0) {
            var scopeName = kony.sync.currentScope[kony.sync.scopeName]
            var lastRequest = kony.sync.checkForPendingUpload(tx, scopeName);
            if (lastRequest != "") {
                return;
            }
            var contextInfo = {};
            contextInfo[kony.sync.metaTableScopeColumn] = scopeName;
            contextInfo[kony.sync.pendingUploadTableInsertCount] = kony.sync.syncTotalInserts;
            contextInfo[kony.sync.pendingUploadTableUpdateCount] = kony.sync.syncTotalUpdates;
            contextInfo[kony.sync.pendingUploadTableDeleteCount] = kony.sync.syncTotalDeletes;
            contextInfo[kony.sync.pendingUploadTableBatchInsertCount] = kony.sync.syncTotalBatchInserts;
            contextInfo[kony.sync.pendingUploadTableBatchUpdateCount] = kony.sync.syncTotalBatchUpdates;
            contextInfo[kony.sync.pendingUploadTableBatchDeleteCount] = kony.sync.syncTotalBatchDeletes;
            contextInfo[kony.sync.pendingUploadTableObjectLevelInfo] = JSON.stringify(kony.sync.objectLevelInfoMap);
            contextInfo[kony.sync.pendingUploadTableUploadRequest] = JSON.stringify(uploadCache);
            contextInfo[kony.sync.pendingUploadTableUploadLimit] = kony.sync.uploadLimit;
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_insert(query, kony.sync.pendingUploadTableName);
            kony.sync.qb_set(query, contextInfo);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            var resultSet = kony.sync.executeSql(tx, sql, params);
            if (resultSet === false) {
                isError = true;
            }
        }
    }

    function uploadTransactionSuccess() {
        sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->uploadTransactionSuccess");
        if (changeset.totalChanges > 0 || previousUpload !== "") {
            if (firstBatch) {
                //kony.sync.deleteMapKey(kony.sync.currentSyncReturnParams, kony.sync.serverDetails);
                //kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUploadStart], kony.sync.currentSyncReturnParams);
                kony.sync.isUploadStarted = true;
            }
            //kony.sync.konyUploadChanges(changeset, uploadAllTransactionSuccess, lastBatch);
            if (previousUpload === "") {
                kony.sync.konyUploadChanges(changeset, uploadAllTransactionSuccess, lastBatch, null);
            } else {
                kony.sync.konyUploadChanges(null, uploadAllTransactionSuccess, null, changeset);
            }
        } else {
            if (firstBatch) { //nothing to upload, hence skip it
                kony.sync.uploadCompleted();
            } else { //upload batch processing finished
                kony.sync.currentSyncReturnParams[kony.sync.uploadContext] = kony.sync.uploadcontextMap;
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUploadSuccess], kony.sync.currentSyncReturnParams);
                kony.sync.currentSyncReturnParams[kony.sync.uploadContext] = {};
                kony.sync.uploadcontextMap = {};
                kony.sync.onUploadCompletion(false, null);
            }
        }
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->transactionErrorCallback");
        if (!isError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }

    function uploadAllTransactionSuccess(otaServerChanges, oldJson) {
        sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->uploadAllTransactionSuccess");
        sync.log.info("Upload response:", otaServerChanges);
        if (!kony.sync.isNullOrUndefined(otaServerChanges.opstatus) && otaServerChanges.opstatus != 0) {
            if (!kony.sync.isNullOrUndefined(otaServerChanges.d)) {
                kony.sync.deleteLastUploadRequestWithNewTransaction(deleteLastUploadRequestCallback);
            } else {
                addLastUploadRequestCallback();
            }
            return;
        } else if (kony.sync.isNullOrUndefined(otaServerChanges.d)) {
            if (kony.sync.isSyncStopped) {
                sync.log.debug("sync stopped in kony.sync.syncUploadChangesForBatch->uploadAllTransactionSuccess");
                kony.sync.stopSyncSession();
                return;
            }
            kony.sync.onUploadCompletion(true, kony.sync.getServerError(otaServerChanges.d));
            return;
        }

        function addLastUploadRequestCallback() {
            sync.log.trace("Entering addLastUploadRequestCallback");
            if (kony.sync.isSyncStopped) {
                sync.log.debug("sync stopped in kony.sync.syncUploadChangesForBatch->addLastUploadRequestCallback");
                kony.sync.stopSyncSession();
                return;
            }
            sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->addLastUploadRequestCallback");
            kony.sync.onUploadCompletion(true, kony.sync.getServerError(otaServerChanges.d));
        }
        if (otaServerChanges.d.error === "false") {
            if (!kony.sync.isNullOrUndefined(otaServerChanges.d.__sync) && !kony.sync.isNullOrUndefined(otaServerChanges.d.__sync.serverblob)) {
                rowItem[kony.sync.metaTableUploadSyncTimeColumn] = otaServerChanges.d.__sync.serverblob;
                kony.sync.currentSyncReturnParams[kony.sync.serverDetails] = {};
                kony.sync.currentSyncReturnParams[kony.sync.serverDetails][kony.sync.hostName] = kony.sync.getServerDetailsHostName(otaServerChanges);
                kony.sync.currentSyncReturnParams[kony.sync.serverDetails][kony.sync.ipAddress] = kony.sync.getServerDetailsIpAddress(otaServerChanges);
                //setSequenceNumberForUploadResponse(limit);
                if (kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA) {
                    kony.sync.clearSyncOrder(kony.sync.currentScope[kony.sync.scopeDataSource], limit, rowItem[kony.sync.metaTableUploadSyncTimeColumn], true, setSeqNoWrapper);
                } else {
                    kony.sync.setOTAUploadResponse(otaServerChanges, setSeqNoWrapper, limit);
                }
            } else {
                addLastUploadRequestCallback();
            }
        } else {
            kony.sync.deleteLastUploadRequestWithNewTransaction(deleteLastUploadRequestCallback);
            return;
        }

        function deleteLastUploadRequestCallback() {
            sync.log.trace("Entering deleteLastUploadRequestCallback");
            if (kony.sync.isSyncStopped) {
                sync.log.debug("sync stopped in kony.sync.syncUploadChangesForBatch->deleteLastUploadRequestCallback");
                kony.sync.stopSyncSession();
                return;
            }
            kony.sync.onUploadCompletion(true, kony.sync.getServerError(otaServerChanges.d));
        }

        function setSequenceNumberForUploadResponse(limit) {
            sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->setSequenceNumberForUploadResponse");
            if (kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA) {
                setSeqNoWrapper();
            } else {
                kony.sync.setOTAUploadResponse(otaServerChanges, setSeqNoWrapper, limit);
            }
        }

        function setSeqNoWrapper() {
            sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->setSeqNoWrapper");
            kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName] = kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName] + 1;
            kony.sync.setSeqnumber(kony.sync.currentScope.ScopeName, kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName], setSeqNoCallback);
        }

        function setSeqNoCallback() {
            sync.log.trace("Entering setSeqNoCallback");
            if (kony.sync.isSyncStopped) {
                sync.log.debug("sync stopped in uploadAllTransactionSuccess -> setSeqNoCallback");
                kony.sync.stopSyncSession();
                return;
            }
            sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->setSeqNoCallback");
            kony.sync.uploadcontextMap[kony.sync.numberOfRowsUploaded] = kony.sync.syncTotalInserts + kony.sync.syncTotalUpdates + kony.sync.syncTotalDeletes;
            kony.sync.uploadcontextMap[kony.sync.numberOfRowsInserted] = kony.sync.syncTotalInserts;
            kony.sync.uploadcontextMap[kony.sync.numberOfRowsUpdated] = kony.sync.syncTotalUpdates;
            kony.sync.uploadcontextMap[kony.sync.numberOfRowsDeleted] = kony.sync.syncTotalDeletes;
            var uploadBatchContextMap = {};
            uploadBatchContextMap[kony.sync.numberOfRowsUploaded] = kony.sync.syncTotalBatchInserts + kony.sync.syncTotalBatchUpdates + kony.sync.syncTotalBatchDeletes;
            uploadBatchContextMap[kony.sync.numberOfRowsInserted] = kony.sync.syncTotalBatchInserts;
            uploadBatchContextMap[kony.sync.numberOfRowsUpdated] = kony.sync.syncTotalBatchUpdates;
            uploadBatchContextMap[kony.sync.numberOfRowsDeleted] = kony.sync.syncTotalBatchDeletes;
            uploadBatchContextMap[kony.sync.serverDetails] = {};
            uploadBatchContextMap[kony.sync.serverDetails][kony.sync.hostName] = kony.sync.getServerDetailsHostName(otaServerChanges);
            uploadBatchContextMap[kony.sync.serverDetails][kony.sync.ipAddress] = kony.sync.getServerDetailsIpAddress(otaServerChanges);
            if (kony.sync.currentScope[kony.sync.syncStrategy] === kony.sync.syncStrategy_OTA) {
                kony.sync.uploadcontextMap[kony.sync.objectLevelInfo] = kony.sync.objectLevelInfoMap;
                kony.sync.uploadcontextMap[kony.sync.numberOfRowsAcknowledged] = kony.sync.serverInsertAckCount + kony.sync.serverUpdateAckCount + kony.sync.serverDeleteAckCount;
                kony.sync.uploadcontextMap[kony.sync.numberOfRowsInsertedAck] = kony.sync.serverInsertAckCount;
                kony.sync.uploadcontextMap[kony.sync.numberOfRowsUpdatedAck] = kony.sync.serverUpdateAckCount;
                kony.sync.uploadcontextMap[kony.sync.numberOfRowsDeletedAck] = kony.sync.serverDeleteAckCount;
                kony.sync.uploadcontextMap[kony.sync.failedRowInfo] = kony.sync.uploadSummary;
                kony.sync.uploadcontextMap[kony.sync.numberOfRowsFailedtoUpload] = kony.sync.serverFailedCount;
            }
            var uploadBatchParams = {};
            uploadBatchParams[kony.sync.uploadContext] = kony.sync.uploadcontextMap;
            uploadBatchParams[kony.sync.uploadBatchContext] = uploadBatchContextMap;
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUploadBatchSuccess], uploadBatchParams);
            //clearing variables before calling 2nd batch
            otaServerChanges = null;
            uploadBatchParams = null;
            uploadBatchContextMap = null;
            changeset = null;
            firstBatch = null;
            lastBatch = null;
            batchSize = null;
            offset = null;
            serverblob1 = null;
            //call upload batching recursively
            kony.sync.syncUploadChangesForBatch(rowItem, previousUpload !== "" ? "*" : "", limit);
        }
    }
    if (previousUpload === "" || previousUpload === "*") {
        var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
        var connection = kony.sync.getConnectionOnly(dbname, dbname, kony.sync.syncUploadFailed);
        if (connection !== null) {
            kony.db.transaction(connection, uploadAllTransaction, transactionErrorCallback, uploadTransactionSuccess);
        }
    } else {
        changeset = previousUpload[kony.sync.pendingUploadTableUploadRequest];
        try {
            kony.sync.objectLevelInfoMap = JSON.parse(previousUpload[kony.sync.pendingUploadTableObjectLevelInfo]);
        } catch (e) {
            sync.log.error("Error occurred while re-framing last persisted upload request:" + e);
            kony.sync.onUploadCompletion(true, kony.sync.getErrorTable(kony.sync.errorCodeParseError, kony.sync.getErrorMessage(kony.sync.errorCodeParseError, previousUpload[kony.sync.pendingUploadTableObjectLevelInfo], e)));
            return;
        }
        changeset = previousUpload[kony.sync.pendingUploadTableUploadRequest];
        kony.sync.syncTotalInserts = previousUpload[kony.sync.pendingUploadTableInsertCount];
        kony.sync.syncTotalUpdates = previousUpload[kony.sync.pendingUploadTableUpdateCount];
        kony.sync.syncTotalDeletes = previousUpload[kony.sync.pendingUploadTableDeleteCount];
        kony.sync.syncTotalBatchInserts = previousUpload[kony.sync.pendingUploadTableBatchInsertCount];
        kony.sync.syncTotalBatchUpdates = previousUpload[kony.sync.pendingUploadTableBatchUpdateCount];
        kony.sync.syncTotalBatchDeletes = previousUpload[kony.sync.pendingUploadTableBatchDeleteCount];
        limit = previousUpload[kony.sync.pendingUploadTableUploadLimit];
        firstBatch = true;
        uploadTransactionSuccess();
    }
};
kony.sync.setOTAUploadResponse = function(serverChanges, callback, limit) {
    sync.log.trace("Entering kony.sync.setOTAUploadResponse");
    var isError = false;
    if (!kony.sync.isNullOrUndefined(serverChanges.d) && !kony.sync.isNullOrUndefined(serverChanges.d.results)) {
        for (var i = 0; i < serverChanges.d.results.length; i++) {
            kony.sync.OTAChangestobeDeleted.push(serverChanges.d.results[i]);
        }
    }

    function setOTAUploadResponseTransaction(tx) {
        sync.log.trace("Entering kony.sync.setOTAUploadResponse->setOTAUploadResponseTransaction");
        if (!kony.sync.isNullOrUndefined(limit)) {
            //updating sync version for all records going in next batch
            if (kony.sync.updateSyncOrderForUploadBatching(tx, limit) === false) {
                isError = true;
                return;
            }
            var serverblob = serverChanges.d.__sync.serverblob;
            //updating upload timestamp
            if (kony.sync.setLastSyncUploadContext(tx, kony.sync.currentScope[kony.sync.scopeName], serverblob) === false) {
                isError = true;
                return;
            }
        }
        //apply response to DB for the uploaded items.
        isError = kony.sync.applyChanges(tx, kony.sync.currentScope, serverChanges, kony.sync.gPolicy);
        sync.log.trace("kony.sync.setOTAUploadResponse->After kony.sync.applyChanges and isError = " + isError);
        if (isError) {
            sync.log.trace("kony.sync.setOTAUploadResponse-> isError = true;  lastUploadRequest will not be deleted from the storage.");
            return;
        }
        //delete last upload request
        if (kony.sync.deleteLastUploadRequest(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
            isError = true;
            return;
        }
    }

    function setOTAUploadResponseTransactionSuccess() {
        sync.log.trace("Entering kony.sync.setOTAUploadResponse->setOTAUploadResponseTransactionSuccess");
        callback();
    }

    function setOTAUploadResponseTransactionFailure() {
        sync.log.trace("Entering kony.sync.setOTAUploadResponse->setOTAUploadResponseTransactionFailure");
        if (!isError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname, kony.sync.syncUploadFailed);
    if (connection !== null) {
        kony.db.transaction(connection, setOTAUploadResponseTransaction, setOTAUploadResponseTransactionFailure, setOTAUploadResponseTransactionSuccess);
    }
};
kony.sync.syncUploadFailed = function(connection) {
    sync.log.trace("Entering kony.sync.syncUploadFailed");
    kony.sync.onUploadCompletion(true, JSON.stringify(connection));
    sync.log.error("Upload Failed", connection);
};
//To get smallest sequence number from all history tables of a scope
kony.sync.getSmallestSequenceNumber = function(tx) {
    sync.log.trace("Entering kony.sync.getSmallestSequenceNumber");
    if (kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables)) {
        return -1;
    }
    var seqNo = -1; //initialize sequence number
    for (var i = 0; i < kony.sync.currentScope.ScopeTables.length; i++) {
        var syncTable = kony.sync.currentScope.ScopeTables[i];
        //not using query builder to speedup sync time
        var sql = "select min(" + kony.sync.historyTableReplaySequenceColumn + ") from " + syncTable.Name + kony.sync.historyTableName + " where " + kony.sync.historyTableChangeTypeColumn + " NOT LIKE '9%' AND " + kony.sync.historyTableSyncVersionColumn + " = " + kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName];
        var resultset = kony.sync.executeSql(tx, sql, null);
        if (resultset === false) {
            return false; //error occurred while executing query
        }
        var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        var seqNoFromTable = kony.sync.tonumber(rowItem["min(" + kony.sync.historyTableReplaySequenceColumn + ")"]);
        seqNo = (seqNo === -1 || seqNoFromTable < seqNo) && seqNoFromTable !== null ? seqNoFromTable : seqNo;
    }
    return seqNo;
};
kony.sync.getBatchChanges = function(tx, scope, offset, limit, changeset, lastSeqNo, batchSize) {
    sync.log.trace("Entering kony.sync.getBatchChanges");
    var tc = null;
    var continueGettingChanges = true;
    kony.sync.uploadLimit = 0;
    var tempUploadLimit;
    var tableDictionary = {}; //dictionary to get index of a table in changeset
    var tableDictionarySize = 0;
    var replaySequenceDictionary = [];
    var dummyReplaySequenceNumber = -1 * batchSize;
    do {
        for (var i = 0; !kony.sync.isNull(kony.sync.currentScope.ScopeTables) && i < kony.sync.currentScope.ScopeTables.length; i++) {
            var syncTable = kony.sync.currentScope.ScopeTables[i];
            if (kony.sync.isNullOrUndefined(kony.sync.objectLevelInfoMap[syncTable.Name])) {
                kony.sync.objectLevelInfoMap[syncTable.Name] = {};
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUploaded] = 0;
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsInserted] = 0;
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUpdated] = 0;
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsDeleted] = 0;
                if ((kony.sync.currentScope[kony.sync.syncStrategy] === kony.sync.syncStrategy_OTA)) {
                    kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsInsertedAck] = 0;
                    kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUpdatedAck] = 0;
                    kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsDeletedAck] = 0;
                    kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsAcknowledged] = 0;
                    kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsFailedtoUpload] = 0;
                }
            }
            if (kony.sync.currentScope.isHierarchical === true) {
                tableDictionary[syncTable.Name] = i;
                tableDictionarySize++;
            }
            tc = null;
            if (kony.sync.isNullOrUndefined(changeset.tables[i])) {
                tc = {
                    tableName: syncTable.Name,
                    changes: []
                };
                changeset.tables[i] = tc;
            } else {
                tc = changeset.tables[i];
            }
            var fields = [];
            if (!kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables[i].Columns)) {
                for (var j = 0; j < kony.sync.currentScope.ScopeTables[i].Columns.length; j++) {
                    var col = kony.sync.currentScope.ScopeTables[i].Columns[j];
                    kony.table.insert(fields, col.Name);
                }
            }
            kony.table.insert(fields, kony.sync.historyTableChangeTypeColumn);
            kony.table.insert(fields, kony.sync.historyTableReplaySequenceColumn);
            kony.table.insert(fields, kony.sync.historyTableSyncVersionColumn);
            kony.table.insert(fields, kony.sync.historyTableHashSumColumn);
            //not using query builder to speedup sync time
            var sql = "select * from " + syncTable.Name + kony.sync.historyTableName + " where " + kony.sync.historyTableChangeTypeColumn + " NOT LIKE '9%' AND " + kony.sync.historyTableSyncVersionColumn + " = " + kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName] + " AND " + kony.sync.historyTableReplaySequenceColumn + " between " + offset + " AND " + limit;
            var resultset = kony.sync.executeSql(tx, sql, null);
            if (resultset === false) {
                return false;
            }
            prepareChangeSet(tx, resultset);
            sync.log.info("changes for " + syncTable.Name + ":", changeset.tables[i].changes);
            sql = "select max(" + kony.sync.historyTableReplaySequenceColumn + ") from " + syncTable.Name + kony.sync.historyTableName + " where " + kony.sync.historyTableChangeTypeColumn + " NOT LIKE '9%' AND " + kony.sync.historyTableSyncVersionColumn + " = " + kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName] + " AND " + kony.sync.historyTableReplaySequenceColumn + " between " + offset + " AND " + limit;
            resultset = kony.sync.executeSql(tx, sql, null);
            if (resultset === false) {
                return false;
            }
            tempUploadLimit = kony.db.sqlResultsetRowItem(tx, resultset, 0)["max(" + kony.sync.historyTableReplaySequenceColumn + ")"];
            if (tempUploadLimit !== null && tempUploadLimit > kony.sync.uploadLimit) {
                kony.sync.uploadLimit = tempUploadLimit;
            }
            if (changeset.totalChanges === batchSize) {
                break; //got all changes
            }
        }
        if (changeset.totalChanges < batchSize && limit < lastSeqNo) {
            offset = limit + 1;
            limit += batchSize - changeset.totalChanges;
        } else {
            if (kony.sync.currentScope.isHierarchical === true) {
                function createDummyChangeSet(parentTableName, row) {
                    sync.log.trace("Creating Dummy ChangeSet Record");
                    var changesetIndex = tableDictionary[parentTableName];
                    tc = null;
                    //getting the actual table
                    if (kony.sync.isNullOrUndefined(changeset.tables[changesetIndex])) {
                        tc = {
                            tableName: parentTableName,
                            changes: []
                        };
                        changeset.tables[changesetIndex] = tc;
                    } else {
                        tc = changeset.tables[changesetIndex];
                    }
                    var changeType = row[kony.sync.historyTableChangeTypeColumn] + "";
                    var rc = {
                        fields: [],
                        values: []
                    };
                    syncTable = kony.sync.currentScope.syncTableDic[parentTableName];
                    if (!kony.sync.isNullOrUndefined(syncTable.Columns)) {
                        for (var x = 0; x < syncTable.Columns.length; x++) {
                            var column = syncTable.Columns[x];
                            if (kony.sync.isNullOrUndefined(row[column.Name])) {
                                kony.table.insert(rc.fields, column.Name);
                                kony.table.insert(rc.values, "null");
                            }
                        }
                    }
                    row[kony.sync.mainTableChangeTypeColumn] = 1;
                    row[kony.sync.historyTableChangeTimeColumn] = null;
                    row[kony.sync.mainTableHashSumColumn] = null;
                    for (var key in row) {
                        if (key !== kony.sync.syncStatusColumn) {
                            kony.table.insert(rc.fields, key);
                            kony.table.insert(rc.values, row[key]);
                        }
                    }
                    rc.changeType = "update";
                    //creating metainfo if it doesnot exist
                    if (kony.sync.isNullOrUndefined(kony.sync.objectLevelInfoMap[parentTableName])) {
                        kony.sync.objectLevelInfoMap[parentTableName] = {};
                        kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsUploaded] = 0;
                        kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsInserted] = 0;
                        kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsUpdated] = 0;
                        kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsDeleted] = 0;
                        if ((kony.sync.currentScope[kony.sync.syncStrategy] === kony.sync.syncStrategy_OTA)) {
                            kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsInsertedAck] = 0;
                            kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsUpdatedAck] = 0;
                            kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsDeletedAck] = 0;
                            kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsAcknowledged] = 0;
                            kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsFailedtoUpload] = 0;
                        }
                    }
                    kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsUpdated] = kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsUpdated] + 1;
                    kony.sync.syncTotalBatchUpdates += 1;
                    sync.log.info("adding the dummy record metadata to batchchangeset metadata");
                    kony.table.insert(rc.fields, kony.sync.historyTableReplaySequenceColumn);
                    kony.table.insert(rc.values, dummyReplaySequenceNumber);
                    //giving dummy replay sequence number for the record and sending it as update
                    dummyReplaySequenceNumber++;
                    sync.log.info("updated dummy replay sequence number " + dummyReplaySequenceNumber);
                    //finally adding the record to the changeset
                    sync.log.info("inserted the record into the change set " + JSON.stringify(rc));
                    kony.table.insert(tc.changes, rc);
                    sync.log.info("changeset of table " + parentTableName + " " + JSON.stringify(tc.changes));
                    //return the index of newly inserted record
                    return (tc.changes.length - 1);
                }

                function isEmptyObject(object) {
                    for (var key in object) {
                        return false;
                    }
                    return true;
                }

                function fetchParentFromMainTable(parentTableName, childRecord, childTableName) {
                    sync.log.trace("entering into fetch parent from main table");
                    wherecondition = [];
                    //getting the parents of the child table
                    parentRelationshipMap = kony.sync.currentScope.syncTableDic[childTableName + kony.sync.parentRelationshipMap];
                    childTable = kony.sync.currentScope.syncTableDic[childTableName];
                    var childValues = childRecord.values;
                    if (parentRelationshipMap[parentTableName]) { //checking whether child is a part of any onetomany relationship of parent
                        var relationshipAttributes = parentRelationshipMap[parentTableName];
                        for (var k = 0; k < relationshipAttributes.length; k++) {
                            relationshipAttribute = relationshipAttributes[k];
                            var columnName = relationshipAttribute["ParentObject_Attribute"];
                            var childColumnName = relationshipAttribute["ChildObject_Attribute"];
                            childFieldIndex = getFieldsIndex(childRecord.fields, childColumnName);
                            kony.table.insert(wherecondition, {
                                key: columnName,
                                value: childValues[childFieldIndex]
                            });
                        }
                    } else {
                        ManyToOne = childTable.Relationships.ManyToOne;
                        if (!kony.sync.isNullOrUndefined(ManyToOne)) {
                            for (var k = 0; k < ManyToOne.length; k++) {
                                var currentRelation = ManyToOne[k];
                                if (currentRelation.TargetObject == parentTableName) {
                                    var relationshipAttributes = currentRelation.RelationshipAttributes;
                                    for (var j = 0; j < relationshipAttributes.length; j++) {
                                        var columnName = relationshipAttributes[j].TargetObject_Attribute;
                                        var childColumnName = relationshipAttributes[j].SourceObject_Attribute;
                                        childFieldIndex = getFieldsIndex(childRecord.fields, childColumnName);
                                        kony.table.insert(wherecondition, {
                                            key: columnName,
                                            value: childValues[childFieldIndex]
                                        });
                                    };
                                }
                            }
                        }
                    }
                    if (wherecondition.length != 0) {
                        //fetchParentFromMainTable
                        query = kony.sync.qb_createQuery();
                        kony.sync.qb_select(query, null);
                        kony.sync.qb_from(query, parentTableName);
                        kony.sync.qb_where(query, wherecondition);
                        query_compile = kony.sync.qb_compile(query);
                        sql = query_compile[0];
                        params = query_compile[1];
                        resultset = kony.sync.executeSql(tx, sql, params);
                        if (resultset.rows.length >= 1) {
                            var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
                            parentRecordIndex = createDummyChangeSet(parentTableName, rowItem);
                            sync.log.info("index of the dummy record in the changeset corrrespoding to the " + parentTableName + " is " + parentRecordIndex);
                            return parentRecordIndex; //actual index according to zero based indexing
                        } else {
                            sync.log.error("no records in  :" + parentTableName + " with a child in " + childTableName);
                            return -1;
                        }
                    } else {
                        sync.log.error("Invalid Operation is defined for table :" + childTable + " with operations to" + parentTable);
                        return -1;
                    }
                }

                function checkInChangeSet(parentTableName, childRecord, childTableName) {
                    sync.log.trace("entering into checkInChangeSet function ");
                    var parentColumns = [];
                    var childColumns = [];
                    sync.log.info("check in changeset for parent " + parentTableName + " with child " + childTableName);
                    parentRelationshipMap = kony.sync.currentScope.syncTableDic[childTableName + kony.sync.parentRelationshipMap];
                    if (parentRelationshipMap[parentTableName]) { //checking whether child is a part of any onetomany relationship of parent
                        var relationshipAttributes = parentRelationshipMap[parentTableName];
                        var relationshipAttributes_length = relationshipAttributes.length;
                        for (var k = 0; k < relationshipAttributes_length; k++) {
                            relationshipAttribute = relationshipAttributes[k];
                            var columnName = relationshipAttribute["ParentObject_Attribute"];
                            var childColumnName = relationshipAttribute["ChildObject_Attribute"];
                            parentColumns.push(columnName);
                            childColumns.push(childColumnName);
                        }
                    } else {
                        ManyToOne = childTable.Relationships.ManyToOne;
                        if (!kony.sync.isNullOrUndefined(ManyToOne)) {
                            for (var k = 0; k < ManyToOne.length; k++) {
                                currentRelation = ManyToOne[k];
                                if (currentRelation.TargetObject == parentTableName) {
                                    var relationshipAttributes = currentRelation.RelationshipAttributes;
                                    for (var j = 0; j < relationshipAttributes.length; j++) {
                                        var columnName = relationshipAttributes[j].TargetObject_Attribute;
                                        var childColumnName = relationshipAttributes[j].SourceObject_Attribute;
                                        parentColumns.push(columnName);
                                        childColumns.push(childColumnName);
                                    }
                                }
                            }
                        }
                    }
                    if (kony.sync.isNullOrUndefined(tableDictionary[parentTableName])) return false;
                    var changeSetIndex = tableDictionary[parentTableName]; //index in changeset
                    var records = changeset.tables[changeSetIndex].changes; //child object changeset
                    for (var j = 0; j < records.length; j++) {
                        parentRecord = records[j]; //parent records
                        var matchCount = 0;
                        var parentValues = parentRecord.values;
                        var childValues = childRecord.values;
                        for (var k = 0; k < parentColumns.length; k++) {
                            parentFieldIndex = getFieldsIndex(parentRecord.fields, parentColumns[k]);
                            childFieldIndex = getFieldsIndex(childRecord.fields, childColumns[k]);
                            if (parentValues[parentFieldIndex] != childValues[childFieldIndex]) {
                                break;
                            }
                            matchCount++;
                        }
                        if (matchCount == parentColumns.length) {
                            sync.log.info("record found in changeset for parent " + parentTableName + " with child " + childTableName);
                            return true;
                        }
                    }
                    return false;
                }

                function getFieldsIndex(fields, columnName) { //helper function
                    for (var k = 0; k < fields.length; k++) {
                        if (fields[k] === columnName) return k; //fieldIndex
                    }
                    sync.log.error("error in changeSet record creation: no " + columnName + " found in fields");
                }

                function fetchAndAddParents(parentTableName, childRecord, childTableName) {
                    sync.log.trace("entering into fetchAndAddParents");
                    //checking whether this parentTable is a part of changesetdictionary
                    if (tableDictionary[parentTableName] === undefined) {
                        tableDictionary[parentTableName] = tableDictionarySize; //for the changeset
                        tableDictionarySize++;
                    }
                    parentRecordIndex = fetchParentFromMainTable(parentTableName, childRecord, childTableName);
                    if (parentRecordIndex == -1) {
                        sync.log.error("improper relationships defined for " + parentTableName);
                        return -1; //
                    }
                    var tablesIndex = tableDictionary[parentTableName];
                    var parentRecord = changeset.tables[tablesIndex].changes[parentRecordIndex];
                    var parentTable = kony.sync.currentScope.syncTableDic[parentTableName];
                    //hierarchial upload operations  metadata
                    var parentTableOperations = parentTable.InputOperations;
                    if (parentTableOperations === undefined) return; //no operations defined for the parent
                    var parentRecordChangeType = parentRecord.changeType;
                    var currentOperation = parentTableOperations[parentRecordChangeType];
                    if (currentOperation === undefined) return; //no operation defined with this change type
                    var parentTableNames = currentOperation.Parents;
                    var childTableNames = currentOperation.Children;
                    if (isRoot(currentOperation) === false) { //not root
                        if (parentTableNames != undefined) {
                            for (var i = 0; i < parentTableNames.length; i++) {
                                //to avoid sending a record which is already in changeset
                                if (checkInChangeSet(parentTableNames[i], parentRecord, parentTableName) === false) {
                                    parentRecordIndex = fetchAndAddParents(parentTableNames[i], parentRecord, parentTableName);
                                }
                            }
                        }
                    }
                    sync.log.info("mark all the child records in the changeSet");
                    //mark all the children in the changeset
                    if (childTableNames != undefined) {
                        for (var i = 0; i < childTableNames.length; i++) {
                            markChildRecords(childRelationInfo[parentTableName], parentRecord, parentTableName, childTableNames[i]);
                        }
                    }
                }

                function markChildRecords(childRelation, parentRecord, parentTableName, childTableName) {
                    sync.log.trace("entering into markChildRecords function");
                    changeSetIndex = tableDictionary[childTableName]; //index in changeset
                    if (changeSetIndex === undefined) {
                        sync.log.info("no child records found in the change set to mark");
                        //when the childRecords are no there at all in changeset they wont be present in tabledictionary
                        return;
                    }
                    var records = changeset.tables[changeSetIndex].changes; //child object changeset
                    // not putting a null check as changes is an array
                    for (var j = 0; j < records.length; j++) {
                        var parentColumns = childRelation[childTableName].parentColumns;
                        var childColumns = childRelation[childTableName].childColumns;
                        childRecord = records[j]; //child records
                        var matchCount = 0;
                        var parentValues = parentRecord.values;
                        var childValues = childRecord.values;
                        for (var k = 0; k < parentColumns.length; k++) {
                            parentFieldIndex = getFieldsIndex(parentRecord.fields, parentColumns[k]);
                            childFieldIndex = getFieldsIndex(childRecord.fields, childColumns[k]);
                            if (parentValues[parentFieldIndex] != childValues[childFieldIndex]) {
                                break;
                            }
                            matchCount++;
                        }
                        if (matchCount == parentColumns.length) {
                            if (childRecord.visitedParents === undefined) childRecord.visitedParents = [];
                            sync.log.info("child record found in changeset with parent " + parentTableName + " and child " + childTableName);
                            childRecord.visitedParents.push(parentTableName);
                        }
                    }
                }

                function getChildRelationsInfo(currentTableName) {
                    sync.log.trace("entering into getChildRelationsInfo ");
                    var childRelation = {};
                    // dictionary for relationships,need to optimise
                    currentTable = kony.sync.currentScope.syncTableDic[currentTableName];
                    OneToMany = currentTable.Relationships.OneToMany;
                    if (!kony.sync.isNullOrUndefined(currentTable.Relationships.OneToMany)) {
                        for (var j = 0; j < OneToMany.length; j++) {
                            var currentRelation = OneToMany[j];
                            if (childRelation[currentRelation.TargetObject] === undefined) {
                                childRelation[currentRelation.TargetObject] = {};
                                childRelation[currentRelation.TargetObject].parentColumns = [];
                                childRelation[currentRelation.TargetObject].childColumns = [];
                            }
                            RelationshipAttributes = currentRelation.RelationshipAttributes;
                            for (var k = 0; k < RelationshipAttributes.length; k++) {
                                childRelation[currentRelation.TargetObject].parentColumns.push(RelationshipAttributes[k].SourceObject_Attribute);
                                childRelation[currentRelation.TargetObject].childColumns.push(RelationshipAttributes[k].TargetObject_Attribute);
                            }
                        }
                    }
                    reverseRelationships = kony.sync.currentScope.reverseRelationships[currentTableName];
                    if (!kony.sync.isNullOrUndefined(reverseRelationships)) {
                        for (var k = 0; k < reverseRelationships.length; k++) {
                            var currentRelation = reverseRelationships[k]
                            if (childRelation[currentRelation.TargetObject] === undefined) {
                                childRelation[currentRelation.TargetObject] = {};
                                childRelation[currentRelation.TargetObject].parentColumns = [];
                                childRelation[currentRelation.TargetObject].childColumns = [];
                            }
                            relationshipAttributes = currentRelation.RelationshipAttributes;
                            for (var j = 0; j < relationshipAttributes.length; j++) {
                                childRelation[currentRelation.TargetObject].parentColumns.push(relationshipAttributes[j].SourceObject_Attribute);
                                childRelation[currentRelation.TargetObject].childColumns.push(relationshipAttributes[j].TargetObject_Attribute);
                            }
                        }
                    }
                    return childRelation;
                }
                //entry point here
                childRelationInfo = {};
                scopeTables = kony.sync.currentScope.ScopeTables;
                for (var j = 0; j < scopeTables.length; j++) {
                    childRelationInfo[scopeTables[j].Name] = getChildRelationsInfo(scopeTables[j].Name);
                }
                //comparator function to sort dictionary
                function compare(a, b) {
                    if (a.konysyncreplaysequence < b.konysyncreplaysequence) return -1;
                    if (a.konysyncreplaysequence > b.konysyncreplaysequence) return 1;
                    return 0;
                }
                sync.log.info("sorting the dictionary of changeset metadata w.r.t konyreplaysequence");
                //sorting the dictionary of changeset metadata w.r.t konyreplaysequence
                replaySequenceDictionary.sort(compare);
                //Parent-child heirarchy upload Algoritm starts here ......
                for (var j = 0; j < replaySequenceDictionary.length; j++) {
                    var replaySequenceValue = replaySequenceDictionary[j];
                    var changeSetIndex = replaySequenceValue.changeSetIndex;
                    var syncTableName = replaySequenceValue.syncTableName;
                    var tableIndex = tableDictionary[syncTableName];
                    var currentRecord = changeset.tables[tableIndex].changes[changeSetIndex];
                    var changeType = currentRecord.changeType;
                    if (kony.sync.currentScope.syncTableDic[syncTableName].InputOperations === undefined) {
                        sync.log.info("no operation defined for " + syncTableName + " table");
                        continue; //no operation defined for this table
                    }
                    var operations = kony.sync.currentScope.syncTableDic[syncTableName].InputOperations;
                    var currentOperation = operations[changeType];
                    if (currentOperation === undefined) {
                        sync.log.info("no operation defined for " + syncTableName + " table with changetype " + changeType);
                        continue; //no operation with this change type defined for this table
                    }
                    var childTableNames = currentOperation.Children;
                    if (isRoot(currentOperation) === false) {
                        var parentsTable = kony.sync.createClone(currentOperation.Parents);
                        if (parentsTable === undefined) {
                            sync.log.info("no parents defined for " + syncTableName + " table with changetype " + changeType);
                            continue; //no parents defined for a child
                        }
                        if (currentRecord.visitedParents === undefined) {
                            currentRecord.visitedParents = [];
                        }
                        //getting the parents that are not visited
                        for (var k = 0; k < currentRecord.visitedParents.length; k++) {
                            var index = parentsTable.indexOf(currentRecord.visitedParents[k]);
                            if (index > -1) {
                                parentsTable.splice(index, 1);
                            } else {
                                sync.log.error("operations not defined properly for " + syncTableName);
                            }
                        }
                        for (var k = 0; k < parentsTable.length; k++) {
                            sync.log.info("fetch parent records  of " + currentRecord + " tablename " + syncTableName + "  with parent " + parentsTable[k]);
                            parentRecord = fetchAndAddParents(parentsTable[k], currentRecord, syncTableName);
                        }
                    }
                    //mark all the children in the changeset
                    if (childTableNames != undefined) {
                        for (var k = 0; k < childTableNames.length; k++) {
                            sync.log.info("mark child records of " + syncTableName + " for child " + childTableNames[k]);
                            markChildRecords(childRelationInfo[syncTableName], currentRecord, syncTableName, childTableNames[k]);
                        }
                    }
                }

                function isRoot(currentOperation) {
                    sync.log.trace("entering into isRoot");
                    if (currentOperation.isRoot != undefined) {
                        isRootFlag = currentOperation.isRoot[0];
                        if (isRootFlag === "true") return true;
                    }
                    return false;
                }
            }
            continueGettingChanges = false;
        }
    } while (continueGettingChanges);

    function prepareChangeSet(tx, resultset) {
        sync.log.trace("Entering kony.sync.getBatchChanges->prepareChangeSet");
        var len = resultset.rows.length;
        for (var k = 0; k < len; k++) {
            var row = kony.db.sqlResultsetRowItem(tx, resultset, k);
            if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[syncTable.Name])) {
                populateBinaryData(tx, row);
            }
            var changeType = row[kony.sync.historyTableChangeTypeColumn] + "";
            if (kony.sync.currentScope.isHierarchical === true) {
                var replaySequenceMap = {};
                replaySequenceMap["syncTableName"] = syncTable.Name;
                replaySequenceMap["changeSetIndex"] = k;
                replaySequenceMap["konysyncreplaysequence"] = row[kony.sync.historyTableReplaySequenceColumn];
                replaySequenceDictionary.push(replaySequenceMap); //need to check
            }
            var rc = {
                fields: [],
                values: []
            };
            if (changeType === kony.sync.insertColStatus) {
                rc.changeType = "insert";
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsInserted] = kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsInserted] + 1;
                kony.sync.syncTotalBatchInserts += 1;
            } else if (changeType === kony.sync.updateColStatus) {
                rc.changeType = "update";
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUpdated] = kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUpdated] + 1;
                kony.sync.syncTotalBatchUpdates += 1;
            } else if (changeType === kony.sync.deleteColStatus) {
                rc.changeType = "delete";
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsDeleted] = kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsDeleted] + 1;
                kony.sync.syncTotalBatchDeletes += 1;
            }
            //for all the missing columns, insert null.
            if (!kony.sync.isNullOrUndefined(syncTable.Columns)) {
                for (var x = 0; x < syncTable.Columns.length; x++) {
                    var column = syncTable.Columns[x];
                    if (kony.sync.isNullOrUndefined(row[column.Name])) {
                        if (column.Name.indexOf(kony.sync.binaryMetaColumnPrefix) !== 0 && column.type !== kony.sync.blob) {
                            kony.table.insert(rc.fields, column.Name);
                            kony.table.insert(rc.values, "null");
                        }
                    }
                }
            }
            for (var key in row) {
                if (key !== kony.sync.syncStatusColumn) {
                    kony.table.insert(rc.fields, key);
                    kony.table.insert(rc.values, row[key]);
                }
            }
            kony.table.insert(tc.changes, rc);
        }
        changeset.totalChanges = changeset.totalChanges + len;
        kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUploaded] = kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsInserted] + kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUpdated] + kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsDeleted];
    }

    function populateBinaryData(tx, row) {
        sync.log.trace("Entering populateBinaryData");
        var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[syncTable.Name][kony.sync.columns];
        var binaryColumnName = null;
        var binaryMetaFieldKey = null;
        for (var i = 0; i < binaryColumns.length; i++) {
            binaryColumnName = binaryColumns[i];
            var downloadPolicy = kony.sync.getDownloadPolicy(syncTable.Name, binaryColumnName);
            if (downloadPolicy !== kony.sync.inline) {
                delete row[binaryColumnName];
                binaryMetaFieldKey = kony.sync.binaryMetaColumnPrefix + binaryColumnName;
                delete row[binaryMetaFieldKey];
            }
            //Add the columns with inline downloadpolicy.
            else if (downloadPolicy === kony.sync.inline) {
                binaryMetaFieldKey = kony.sync.binaryMetaColumnPrefix + binaryColumnName;
                var blobIndex = row[binaryMetaFieldKey];
                //If the record has any binary data..
                if (blobIndex && blobIndex !== kony.sync.blobRefNotFound && blobIndex !== kony.sync.blobRefNotDefined) {
                    //get the state of the blob. if is in stable, then only push.
                    var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobIndex, function(err) {
                        kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
                    });
                    if (blobMeta[kony.sync.blobManager.state] === kony.sync.blobManager.NO_OPERATION && blobMeta[kony.sync.blobManager.status] === 100) {
                        //file exists. upload.
                        var base64String = binary.util.getBase64FromFiles([blobMeta[kony.sync.blobManager.localPath]]);
                        if (base64String[0].length > 0) {
                            row[binaryColumnName] = base64String[0];
                        } else {
                            //FILE Doesn't exist.
                            var valuesTable = {};
                            valuesTable.state = kony.sync.blobManager.FILE_DOESNOT_EXIST;
                            var resultset = kony.sync.blobManager.updateBlobManager(tx, blobIndex, valuesTable, function(err) {
                                kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
                            });
                            if (resultset !== null && resultset !== false) {
                                kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeBlobFileDoesnotExist, kony.sync.getErrorMessage(kony.sync.errorCodeBlobFileDoesnotExist), null));
                            }
                            delete row[binaryMetaFieldKey];
                        }
                    } else {
                        //file is in invalid state.
                        //TODO-throw error..blob in invalid state..
                        kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeBlobInvalidState, kony.sync.getErrorMessage(kony.sync.errorCodeBlobInvalidState), null));
                    }
                }
            }
        }

        function errorCallback(error) {
            sync.log.trace(" error occured while fetching blob ");
        }
    }
    sync.log.info("Total number of changes to be uploaded = ", changeset.totalChanges);
    return limit;
};
//This will update syncorder for Pending uploads
kony.sync.updateSyncOrderForUploadBatching = function(tx, limit) {
    sync.log.trace("Entering kony.sync.updateSyncOrderForUploadBatching");
    if (kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables)) {
        return true;
    }
    for (var i = 0; i < kony.sync.currentScope.ScopeTables.length; i++) {
        var syncTable = kony.sync.currentScope.ScopeTables[i];
        if (kony.sync.isNullOrUndefined(syncTable)) {
            continue;
        }
        var tablename = syncTable.Name;
        var settable = {};
        settable[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName] + 1;
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_update(query, tablename + kony.sync.historyTableName);
        kony.sync.qb_set(query, settable);
        kony.sync.qb_where(query, [{
            key: kony.sync.historyTableReplaySequenceColumn,
            value: limit,
            optype: "GT"
        }]);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            return false;
        }
    }
    return true;
};
//This method reconciles Foreign key relationships in case of autogenerated pk
kony.sync.reconcileForeignKey = function(tx, setClause, whereClause, tablename) {
    sync.log.trace("Entering kony.sync.reconcileForeignKey");
    //Forward Relationships(OneToMany) reconcilation
    var OTM = kony.sync.currentScope.syncTableDic[tablename].Relationships.OneToMany;
    if (kony.sync.reconcileForeignKeyForRelationShip(tx, setClause, whereClause, tablename, OTM) === false) {
        return false;
    }
    //Forward Relationships(OneToOne) reconcilation
    var OTO = kony.sync.currentScope.syncTableDic[tablename].Relationships.OneToOne;
    if (kony.sync.reconcileForeignKeyForRelationShip(tx, setClause, whereClause, tablename, OTO) === false) {
        return false;
    }
    //Reverse Relationships(ManyToOne) reconcilation
    var MTO = kony.sync.currentScope.reverseRelationships[tablename];
    return kony.sync.reconcileForeignKeyForRelationShip(tx, setClause, whereClause, tablename, MTO);
};
kony.sync.reconcileForeignKeyForRelationShip = function(tx, setClause, whereClause, tablename, relationshipSet) {
    sync.log.trace("Entering kony.sync.reconcileForeignKeyForRelationShip");
    if (!kony.sync.isNullOrUndefined(relationshipSet)) {
        for (var i = 0; i < relationshipSet.length; i++) {
            sync.log.info("Reconciling relationships for object " + tablename + " with relationship ", relationshipSet[i]);
            var setC = {};
            var tbname = relationshipSet[i].TargetObject;
            var wcs = [];
            if (!kony.sync.isNullOrUndefined(relationshipSet[i].RelationshipAttributes)) {
                var relationshipAttributes = relationshipSet[i].RelationshipAttributes;
                for (var j = 0; j < relationshipAttributes.length; j++) {
                    if (!kony.sync.isNullOrUndefined(setClause[relationshipAttributes[j].SourceObject_Attribute])) {
                        setC[relationshipAttributes[j].TargetObject_Attribute] = setClause[relationshipAttributes[j].SourceObject_Attribute];
                    }
                }
                for (var j = 0; j < whereClause.length; j++) {
                    for (var k = 0; k < relationshipAttributes.length; k++) {
                        if (whereClause[j].key === relationshipAttributes[k].SourceObject_Attribute) {
                            wcs.push({
                                key: relationshipAttributes[k].TargetObject_Attribute,
                                value: whereClause[j].value
                            });
                        }
                    }
                }
            } else if (!kony.sync.isNullOrUndefined(setClause[relationshipSet[i].SourceObject_Attribute])) {
                setC = {};
                setC[relationshipSet[i].TargetObject_Attribute] = setClause[relationshipSet[i].SourceObject_Attribute];
                tbname = relationshipSet[i].TargetObject;
                wcs = [];
                for (var j = 0; j < whereClause.length; j++) {
                    if (whereClause[j].key === relationshipSet[i].SourceObject_Attribute) {
                        wcs[0] = {
                            key: relationshipSet[i].TargetObject_Attribute,
                            value: whereClause[j].value
                        };
                        break;
                    }
                }
            }
            if (kony.sync.isEmpty(setC)) {
                return;
            }
            //update main foreign table
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, tbname);
            kony.sync.qb_set(query, setC);
            kony.sync.qb_where(query, wcs);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return false;
            }
            //update history foreign table
            kony.sync.qb_update(query, tbname + kony.sync.historyTableName);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return false;
            }
            //update original foreign table
            kony.sync.qb_update(query, tbname + kony.sync.originalTableName);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return false;
            }
        }
    }
};
kony.sync.checkForPendingUpload = function(tx, scopename) {
    sync.log.trace("Entering kony.sync.checkForPendingUpload");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, kony.sync.pendingUploadTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet === false) {
        return false;
    }
    if (resultSet.rows.length === 0) {
        return "";
    } else {
        return kony.db.sqlResultsetRowItem(tx, resultSet, 0);
    }
};
kony.sync.getUploadRequest = function(changes, lastBatch) {
    sync.log.trace("Entering kony.sync.getUploadRequest ");
    var totalChanges = [];
    if (!kony.sync.isNullOrUndefined(changes.tables)) {
        for (var i = 0; i < changes.tables.length; i++) {
            var tableChange = changes.tables[i];
            var tableName = tableChange.tableName;
            if (!kony.sync.isNullOrUndefined(tableChange.changes)) {
                for (var j = 0; j < tableChange.changes.length; j++) {
                    var rowChange = tableChange.changes[j];
                    if (kony.sync.isNullOrUndefined(rowChange.syncConflict)) {
                        rowChange.syncConflict = "";
                    }
                    var result = {
                        metadata: {
                            type: tableName,
                            uri: changes.uri,
                            changetype: rowChange.changeType,
                            syncConflict: rowChange.syncConflict
                        }
                    };
                    if (!kony.sync.isNullOrUndefined(rowChange.fields)) {
                        var fcount = kony.sync.getArrayCount(rowChange.fields);
                        for (var k = 0; k < fcount; k++) {
                            if (rowChange.fields[k] !== "ServerId" && rowChange.fields[k] !== "UpdateId") {
                                result[rowChange.fields[k]] = rowChange.values[k];
                            }
                        }
                    }
                    totalChanges.push(result);
                }
            }
        }
    }
    var moreChangesAvailable = null;
    if (lastBatch === true) {
        moreChangesAvailable = false;
    } else {
        moreChangesAvailable = true;
    }
    var jsonLua = {
        d: {
            results: totalChanges,
            sync: "not implemented",
            scopeName: changes.scopeName,
            serverBlob: changes.serverblob,
            clientid: changes.clientid,
            SequenceNumber: changes.SequenceNumber,
            moreChangesAvailable: moreChangesAvailable
        }
    };
    return JSON.stringify(jsonLua);
}
kony.sync.getLastSyncUploadContext = function(scopename, dbname, scallback) {
    sync.log.trace("Entering kony.sync.getLastSyncUploadContext");
    var uploadContext = null;
    var pendingUploads = null;
    var isError = false;

    function transactionCallback(tx) {
        sync.log.trace("Entering transactionCallback");
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, kony.sync.metaTableName);
        kony.sync.qb_where(query, [{
            key: kony.sync.metaTableScopeColumn,
            value: scopename
        }, {
            key: kony.sync.metaTableFilterValue,
            value: "no filter"
        }]);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params);
        if (resultSet === false) {
            isError = true;
            return;
        }
        pendingUploads = kony.sync.checkForPendingUpload(tx, scopename);
        if (pendingUploads === false) {
            return;
        }
        if (pendingUploads) {
            if (pendingUploads.uploadrequest) {
                var uploadrequest = JSON.parse(pendingUploads.uploadrequest);
                var scopeName = uploadrequest[kony.sync.scope];
                var cachedCurrentScope = kony.sync.scopes[scopeName];
                var cachedOffset = uploadrequest[kony.sync.offset];
                var cachedLimit = uploadrequest[kony.sync.limit];
                var cachedLastSeqNo = uploadrequest[kony.sync.lastSequenceNumber];
                var cachedBatchSize = uploadrequest[kony.sync.batchSize];
                var cacheChangeSet = JSON.parse(uploadrequest[kony.sync.changeSet]);
                var cacheUploadLimit = uploadrequest[kony.sync.uploadChangesLimit];
                kony.sync.getBatchChanges(tx, cachedCurrentScope, cachedOffset, cacheUploadLimit, cacheChangeSet, cachedLastSeqNo, cachedBatchSize);
                var cacheLastBatch = uploadrequest[kony.sync.lastBatch];
                pendingUploads[kony.sync.pendingUploadTableUploadRequest] = kony.sync.getUploadRequest(cacheChangeSet, cacheLastBatch);
            }
        }
        if (resultSet.rows.length === 0) {
            return "";
        } else {
            uploadContext = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering transactionSuccessCallback");
        scallback(uploadContext, pendingUploads);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering kony.sync.setOTAUploadResponse->setOTAUploadResponseTransactionFailure");
        if (!isError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
    var connection = kony.sync.getConnectionOnly(dbname, dbname, transactionErrorCallback);
    if (connection !== null) {
        kony.db.transaction(connection, transactionCallback, transactionErrorCallback, transactionSuccessCallback);
    }
};
kony.sync.setLastSyncUploadContext = function(tx, scopename, serverblob) {
    sync.log.trace("Entering kony.sync.setLastSyncUploadContext");
    var settable = {};
    settable[kony.sync.metaTableUploadSyncTimeColumn] = serverblob;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, kony.sync.metaTableName);
    kony.sync.qb_set(query, settable);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }, {
        key: kony.sync.metaTableFilterValue,
        value: "no filter"
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    if (kony.sync.executeSql(tx, sql, params) === false) {
        return false;
    }
};
kony.sync.addLastUploadRequest = function(json, scopename, limit, callback) {
    sync.log.trace("Entering kony.sync.addLastUploadRequest");
    var isError = false;

    function transactionCallback(tx) {
        sync.log.trace("Entering transactionCallback");
        //check whether failed upload request is already logged
        var lastRequest = kony.sync.checkForPendingUpload(tx, scopename);
        //return if query failed, should go to error callback
        if (lastRequest === false) {
            return;
        }
        //return if request already logged, should go to success callback
        if (lastRequest !== "") {
            return;
        }
        var settable = {};
        settable[kony.sync.metaTableScopeColumn] = scopename;
        settable[kony.sync.pendingUploadTableInsertCount] = kony.sync.syncTotalInserts;
        settable[kony.sync.pendingUploadTableUpdateCount] = kony.sync.syncTotalUpdates;
        settable[kony.sync.pendingUploadTableDeleteCount] = kony.sync.syncTotalDeletes;
        settable[kony.sync.pendingUploadTableBatchInsertCount] = kony.sync.syncTotalBatchInserts;
        settable[kony.sync.pendingUploadTableBatchUpdateCount] = kony.sync.syncTotalBatchUpdates;
        settable[kony.sync.pendingUploadTableBatchDeleteCount] = kony.sync.syncTotalBatchDeletes;
        settable[kony.sync.pendingUploadTableObjectLevelInfo] = JSON.stringify(kony.sync.objectLevelInfoMap);
        settable[kony.sync.pendingUploadTableUploadRequest] = json;
        settable[kony.sync.pendingUploadTableUploadLimit] = limit;
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_insert(query, kony.sync.pendingUploadTableName);
        kony.sync.qb_set(query, settable);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params);
        if (resultSet === false) {
            isError = true;
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.addLastUploadRequest->transactionSuccessCallback");
        callback(true);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering kony.sync.addLastUploadRequest->transactionErrorCallback");
        if (!isError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname, transactionErrorCallback);
    if (connection !== null) {
        kony.db.transaction(connection, transactionCallback, transactionErrorCallback, transactionSuccessCallback);
    }
};
kony.sync.deleteLastUploadRequest = function(tx, scopename) {
    sync.log.trace("Entering kony.sync.deleteLastUploadRequest");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_delete(query, kony.sync.pendingUploadTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    if (kony.sync.executeSql(tx, sql, params) === false) {
        return false;
    }
    return true;
};
kony.sync.deleteLastUploadRequestWithNewTransaction = function(callback) {
    sync.log.trace("Entering kony.sync.deleteLastUploadRequestWithNewTransaction");
    var isError = false;

    function transactionCallback(tx) {
        sync.log.trace("Entering transactionCallback");
        if (kony.sync.deleteLastUploadRequest(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
            isError = true;
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.deleteLastUploadRequestWithNewTransaction->transactionSuccessCallback");
        callback(true);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering kony.sync.deleteLastUploadRequestWithNewTransaction->transactionErrorCallback");
        if (!isError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname, transactionErrorCallback);
    if (connection !== null) {
        kony.db.transaction(connection, transactionCallback, transactionErrorCallback, transactionSuccessCallback);
    }
};
//  **************** End KonySyncUpload.js*******************
//  **************** Start KonySyncValidations.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
kony.sync.attributeValidation = function(valuestable, tablename, errorcallback, isInsert) {
    sync.log.trace("kony.sync.attributeValidation ", valuestable);
    if (!kony.sync.enableORMValidations) {
        return true;
    }
    if (valuestable != null) {
        var scope = kony.sync.scopes[kony.sync.scopes.syncTableScopeDic[tablename]];
        var columns = scope.syncTableDic[tablename].ColumnsDic;
        kony.sync.filterAttributes(valuestable, columns, tablename, isInsert);
        var expectedType = null;
        var expectedLength = null;
        var jsType = null;
        for (var key in columns) {
            expectedType = columns[key].type;
            expectedLength = columns[key].Length;
            jsType = kony.sync.getJSType(expectedType);
            //Type validation
            sync.log.debug("kony.sync.attributeValidation:Starting Type Validations");
            if (jsType === "number" || jsType === "boolean") {
                if (!kony.sync.isEmptyString(valuestable[key])) {
                    if (!kony.sync.isNull(valuestable[key]) && jsType === "number" && !kony.sync.isValidNumberType(valuestable[key])) {
                        sync.log.error("Invalid data type for the attribute " + key + " in " + tablename + ".\nExpected:\"" + expectedType + "\"\nActual:\"" + kony.type(valuestable[key]) + "\"");
                        errorcallback(kony.sync.getErrorTable(kony.sync.errorCodeInvalidDataType, kony.sync.getInvalidDataTypeMsg(tablename, key, expectedType, kony.type(valuestable[key]))));
                        return false;
                    }
                    if (!kony.sync.isNull(valuestable[key]) && jsType === "boolean" && !kony.sync.isValidBooleanType(valuestable[key])) {
                        sync.log.error("Invalid data type for the attribute " + key + " in " + tablename + ".\nExpected:\"" + expectedType + "\"\nActual:\"" + kony.type(valuestable[key]) + "\"");
                        errorcallback(kony.sync.getErrorTable(kony.sync.errorCodeInvalidDataType, kony.sync.getInvalidDataTypeMsg(tablename, key, expectedType, kony.type(valuestable[key]))));
                        return false;
                    }
                } else {
                    valuestable[key] = "null";
                }
            }
            sync.log.debug("kony.sync.attributeValidation:Type Validations done");
            //Malicious type validation
            sync.log.debug("kony.sync.attributeValidation:Starting Malicious Validations");
            if (jsType === "number" || typeof(valuestable[key]) === "number") {
                var maliciousType = kony.sync.isMaliciousType(valuestable[key]);
                if (maliciousType !== false) {
                    var errorMessage = kony.sync.getErrorMessage(kony.sync.errorCodeMaliciousType, key, maliciousType);
                    sync.log.error("Malicious object detected", kony.sync.getErrorTable(kony.sync.errorCodeMaliciousType, errorMessage));
                    kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeMaliciousType, errorMessage));
                    return false;
                }
            }
            sync.log.debug("kony.sync.attributeValidation:Malicious Validations done");
            //Length Validation
            sync.log.debug("kony.sync.attributeValidation:Starting Length Validations");
            if (jsType === "string") {
                if (kony.sync.validateLength(tablename, key, valuestable[key], expectedLength, errorcallback) === false) {
                    return false;
                }
            }
            sync.log.debug("kony.sync.attributeValidation:Length Validations done");
            //Mandatory Attribute Validation
            sync.log.debug("kony.sync.attributeValidation:Starting Mandatory Attribute Validations");
            // if(columns[key].IsNullable === false && !(columns[key].Autogenerated === "true") && !(isInsert===false && columns[key].IsPrimaryKey===true)){
            // if(kony.sync.validateMandatoryColumns(tablename, key, valuestable[key], errorcallback)===false){
            // return false;
            // }
            // }
            if (isInsert) {
                //check all mandatory attributes
                if (columns[key].IsNullable === false) {
                    if (columns[key].Autogenerated !== "true") {
                        if (kony.sync.validateMandatoryColumns(tablename, key, valuestable[key], errorcallback) === false) {
                            return false;
                        }
                    }
                }
            } else {
                //check mandatory attributes only if they are defined
                if (columns[key].IsNullable === false) {
                    if (columns[key].Autogenerated !== "true") {
                        if (typeof(valuestable[key]) !== "undefined") {
                            if (kony.sync.validateMandatoryColumns(tablename, key, valuestable[key], errorcallback) === false) {
                                return false;
                            }
                        }
                    }
                }
            }
            sync.log.debug("kony.sync.attributeValidation:Mandatory Attribute Validations done");
        }
    }
    return true;
};
kony.sync.filterAttributes = function(valuestable, attributeTable, tablename, isInsert) {
    sync.log.trace("Entering kony.sync.filterAttributes ");
    for (var k in valuestable) {
        if (kony.sync.isNull(attributeTable[k])) {
            sync.log.warn("Ignoring the attribute " + k + " for the SyncObject " + tablename + ". " + k + " is not defined as an attribute in SyncConfiguration.");
            delete valuestable[k];
        } else if (attributeTable[k].IsPrimaryKey) {
            if (isInsert === false) {
                sync.log.warn("Ignoring the primary key " + k + " for the SyncObject  " + tablename + ". Primary Key should not be the part of the attributes to be updated in the local device database.");
                delete valuestable[k];
            } else if (attributeTable[k].Autogenerated === "true") {
                sync.log.warn("Ignoring the auto-generated primary key " + k + " for the SyncObject " + tablename + ". Auto-generated Primary Key should not be the part of the attributes to be inserted in the local device database.");
                delete valuestable[k];
            }
        }
    }
};
kony.sync.getJSType = function(myType) {
    sync.log.trace("Entering kony.sync.getJSType ");
    myType = myType.toLowerCase();
    var stringTypes = {
        "string": true,
        "character": true,
        "java.lang.String": true,
        "char": true
    };
    var numberTypes = {
        "int": true,
        "double": true,
        "float": true,
        "long": true,
        "short": true,
        "integer": true,
        "big_decimal": true,
        "byte": true,
        "big_integer": true
    };
    var booleanTypes = {
        "boolean": true,
        "yes_no": true
    };
    if (stringTypes[myType] === true) {
        return "string";
    }
    if (numberTypes[myType] === true) {
        return "number";
    }
    if (booleanTypes[myType] === true) {
        return "boolean";
    }
    return null;
};
kony.sync.validateLength = function(tablename, colname, colvalue, length, errorcallback) {
    sync.log.trace("Entering kony.sync.validateLength ");
    if (!kony.sync.isNull(colvalue) && kony.string.equalsIgnoreCase(kony.type(colvalue), "string") && kony.string.len(colvalue) > length) {
        sync.log.error("Length exceeds the limit for the attribute " + colname + " in " + tablename + ".\nExpected:\'" + length + "\'\nActual:\'" + kony.string.len(colvalue) + "\'");
        kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeLengthValidationFailed, kony.sync.getValidateLengthErrMsg(tablename, colname, length, kony.string.len(colvalue))));
        return false;
    }
    return true;
};
kony.sync.validateMandatoryColumns = function(tablename, colname, colvalue, errorcallback) {
    sync.log.trace("Entering Address.validateNullInsert function");
    if (kony.sync.isNull(colvalue)) {
        sync.log.error("Mandatory attribute " + colname + " is missing for the SyncObject" + tablename + ".");
        errorcallback(kony.sync.getErrorTable(kony.sync.errorCodeMandatoryAttribute, kony.sync.getErrorMessage(kony.sync.errorCodeMandatoryAttribute, tablename, colname)));
        return false;
    }
    return true;
};
kony.sync.isSyncInitialized = function(errorcallback) {
    sync.log.trace("Entering kony.sync.isSyncInitialized");
    if (!kony.sync.syncInitialized) {
        sync.log.error("Please initialize sync by calling sync.init");
        kony.sync.alert("Please initialize sync by calling sync.init");
        kony.sync.verifyAndCallClosure(errorcallback, {});
        return false;
    }
    return true;
};
kony.sync.validateInput = function(input, objectName, ormType, errorcallback) {
    sync.log.trace("Entering kony.sync.validateInput");
    if (ormType === "create") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "updateByPk") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 2)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
            if (!kony.sync.validateInputField(objectName, ormType, input[1], "object", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "update") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 2)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "string", errorcallback)) {
                return false;
            }
            if (!kony.sync.validateInputField(objectName, ormType, input[1], "object", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "getCount") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "string", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "createAll") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "object", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "updateAll") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "object", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "deleteByPK") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "remove") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "string", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "removeDeviceInstanceByPK") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "getAllDetailsByPK") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "find") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "string", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "markForUploadbyPK") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "markForUpload") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "string", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "rollbackPendingLocalChangesByPK") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "relationship") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    }
    return true;
};
kony.sync.validatePrimaryKeyField = function(objName, opType, inputAttribute, errorcallback) {
    sync.log.trace("Entering kony.sync.validatePrimaryKeyField");
    if (kony.sync.isNullOrUndefined(inputAttribute)) {
        kony.sync.verifyAndCallClosure(errorcallback, "Argument type mismatch found for operation:" + objName + ".  Expected 'integer, string or object ' Actual null or undefined '");
        kony.sync.alert("Argument type mismatch found for operation:" + objName + ".  Expected 'integer, string or object' Actual 'null or undefined'");
        return false;
    }
    var actualType = typeof(inputAttribute);
    if (!(actualType === "number" || actualType === "string" || actualType === "object")) {
        kony.sync.verifyAndCallClosure(errorcallback, "Argument type mismatch found for Primary Key in operation:" + objName + ".  Expected 'integer, string or object' Actual '" + actualType + "'");
        kony.sync.alert("Argument type mismatch found for operation:" + objName + ".  Expected 'integer, string or object' Actual '" + actualType + "'");
        return false;
    }
    return true;
};
kony.sync.validateInputField = function(objName, opType, inputAttribute, expectedType, errorcallback) {
    sync.log.trace("Entering kony.sync.validateInputField");
    if (kony.sync.isNullOrUndefined(inputAttribute)) {
        kony.sync.verifyAndCallClosure(errorcallback, "Argument type mismatch found for operation:" + objName + ".  Expected '" + expectedType + "' Actual 'null or undefined '");
        kony.sync.alert("Argument type mismatch found for operation:" + objName + ".  Expected '" + expectedType + "' Actual 'null or undefined'");
        return false;
    }
    var actualType = typeof(inputAttribute);
    if (actualType !== expectedType) {
        kony.sync.verifyAndCallClosure(errorcallback, "Argument type mismatch found for operation:" + objName + ".  Expected '" + expectedType + "' Actual '" + actualType + "'");
        kony.sync.alert("Argument type mismatch found for operation:" + objName + ".  Expected '" + expectedType + "' Actual '" + actualType + "'");
        return false;
    }
    return true;
};
kony.sync.validateArgumentLength = function(objName, ormType, actualLength, expectedLength) {
    sync.log.trace("Entering kony.sync.validateArgumentLength");
    if (actualLength < expectedLength) {
        kony.sync.alert("Insufficient number of arguments passed for operation: " + objName);
        return false;
    }
    return true;
};
kony.sync.alert = function(msg) {
    sync.log.trace("Entering kony.sync.alert ");
    if (kony.sync.isAlertEnabled) {
        alert(msg);
    } else {
        sync.log.warn(msg);
    }
};
//  **************** End KonySyncValidations.js*******************
//FP Appended actions_for_KroninTest1.js-----------------------------------------------------------
//actions.js file
//FP Appended annotationsUtil.js-----------------------------------------------------------
/*! KonyVisualizerV8420 2019-06-14 */

var createComment=function(e,t){var m={};t?(m.createdById=t.user_guid,m.createdBy=t.first_name+" "+t.last_name,m.createdByEmail=t.primary_email):(m.createdById=null,m.createdBy="Anonymous",m.createdByEmail=null);var n=generateCommentId();return m.commentId=n,m.label=e.label||"",m.createdOn=(new Date).getTime(),m.lastModifiedTime=m.createdOn,m.active=1,m.widgetId=e.widgetId,m.formId=e.formId,m.channel=e.channel,m.comment=e.comment,m},createRequirement=function(e,t){var m=createComment(e,t);return m.requirementId=m.commentId,m.body=e.body,delete m.commentId,m},updateComment=function(e,t,m){var n=e.commentId,r=e.widgetId,a=m.comments[r];if(void 0!==a[n]){var d=t?t.user_guid:null;if(!a[n].createdById&&d)e.createdById=d,e.createdBy=t.first_name+" "+t.last_name,e.createdByEmail=t.primary_email,e.createdOn=(new Date).getTime();else if(d&&d!=a[n].createdById)return m;e.active=Number(e.active),e.lastModifiedTime=(new Date).getTime(),a[n]=e,m.comments[r]=a}return m},updateRequirement=function(e,t,m){var n=e.widgetId,r=e.requirementId;return e.active=Number(e.active),e.lastModifiedTime=Number(e.lastModifiedTime),m.requirements[n][r]=e,m},generateCommentId=function(){return"xxxx-xxxx-xxxx-xxxx-xxxx-xxxx".replace(/[xy]/g,function(e){var t=16*Math.random()|0;return("x"==e?t:3&t|8).toString(16)})},getCommentParam=function(e){return{guid:e.commentId,created_on:Number(e.createdOn),created_by_guid:e.createdById,created_by:e.createdBy,created_by_email:e.createdByEmail,modified_on:Number(e.lastModifiedTime),comment:e.comment,comment_src:"undefined"!=typeof module&&module.exports?COMMENT_SRC_APP.VIZ:COMMENT_SRC_APP.FP,active:e.active}},getNoteParam=function(e){return{guid:e.noteGuid,widget_id:e.widgetId,form_id:e.formId,form_channel:e.channel,created_on:Number(e.createdOn),modified_on:Number(e.modifiedOn),active:e.active}},formatComment=function(e){return{commentId:e.guid,widgetId:e.widget_id,formId:e.form_id,createdOn:new Date(e.created_on).getTime(),createdById:e.created_by_guid,createdBy:e.created_by,createdByEmail:e.created_by_email,lastModifiedTime:new Date(e.modified_on).getTime(),comment:e.comment,commentSrc:e.comment_src,active:e.active,channel:e.form_channel}},filterRequirements=function(e){return e.filter(function(e){return 2===e.type})},annotationsUtil={createComment:createComment,updateComment:updateComment,generateCommentId:generateCommentId,getCommentParam:getCommentParam,getNoteParam:getNoteParam,formatComment:formatComment,createRequirement:createRequirement,updateRequirement:updateRequirement,filterRequirements:filterRequirements},COMMENT_SRC_APP={FP:"functional preview",VIZ:"visualizer"},COMMENT_TYPE={COMMENT:1,REQUIREMENT:2};"undefined"!=typeof module&&module.exports&&(module.exports=annotationsUtil);
//FP Appended application.js-----------------------------------------------------------
kony.visualizer = {};
kony.visualizer.actions = {};

function displayMWError() {
    kony.ui.Alert("Middleware Error ", null, "error", null, null);
};

function displaySessionError() {
    kony.ui.Alert("Session Expired .. Please re-login", null, "error", null, null);
};

function displayError(code, msg) {
    // Commented for SWA: kony.ui.Alert("Error Code: "..code .." Message: " ..msg,null,"error",null,null);
    kony.ui.Alert(code + "- " + msg, null, "error", null, null);
};
var mergeHeaders = function(httpHeaders, globalHeaders) {
    for (var attrName in globalHeaders) {
        httpHeaders[attrName] = globalHeaders[attrName];
    }
    return httpHeaders;
};

function appmiddlewareinvokerasync(inputParam, callBack) {
    var url = appConfig.url;
    var sessionIdKey = "cacheid";
    inputParam.appID = appConfig.appId;
    inputParam.appver = appConfig.appVersion;
    inputParam["channel"] = "wap";
    inputParam["platform"] = kony.os.deviceInfo().name;
    inputParam[sessionIdKey] = sessionID;
    if (globalhttpheaders) {
        if (inputParam["httpheaders"]) {
            inputParam.httpheaders = mergeHeaders(inputParam.httpheaders, globalhttpheaders);
        } else {
            inputParam.httpheaders = globalhttpheaders;
        };
    };
    var connHandle = _invokeServiceAsyncForMF_(url, inputParam, callBack);
    return connHandle;
};

function appmiddlewaresecureinvokerasync(inputParam, callBack) {
    var url = appConfig.secureurl;
    var sessionIdKey = "cacheid";
    inputParam.appID = appConfig.appId;
    inputParam.appver = appConfig.appVersion;
    inputParam["channel"] = "wap";
    inputParam["platform"] = kony.os.deviceInfo().name;
    inputParam[sessionIdKey] = sessionID;
    if (globalhttpheaders) {
        if (inputParam["httpheaders"]) {
            inputParam.httpheaders = mergeHeaders(inputParam.httpheaders, globalhttpheaders);
        } else {
            inputParam["httpheaders"] = globalhttpheaders;
        };
    };
    var connHandle = _invokeServiceAsyncForMF_(url, inputParam, callBack);
    return connHandle;
};

function mfgetidentityservice(idProviderName) {
    var currentInstance = kony.sdk.getCurrentInstance();
    if (!currentInstance) {
        throw new Exception("INIT_FAILURE", "Please call init before getting identity provider");
    }
    return currentInstance.getIdentityService(idProviderName);
};
/**
 * @function mfidentityserviceinvoker
 * @description Invokes identity service
 * @public
 * @param {string} idProviderName
 * @param {object} params {userid : <userid>, password : <password>, browserWidget : <browserwidget>, operation : "login/logout"}
 * and other optional params like callerID and custom params in case of custom provider.
 * @param {function} successCallback
 * @param {function} failureCallback
 */
function mfidentityserviceinvoker(idProviderName, params, successCallback, failureCallback) {
    var authorizationClient = mfgetidentityservice(idProviderName);
    kony.print("Invoking identity service " + idProviderName + " through Kony Fabric.");
    if (!params.operation || params.operation == "login") {
        authorizationClient.login(params, successCallback, failureCallback);
    } else {
        authorizationClient.logout(successCallback, failureCallback, params);
    }
};

function mfintegrationsecureinvokerasync(inputParam, serviceID, operationID, callBack) {
    var url = appConfig.secureurl;
    var sessionIdKey = "cacheid";
    inputParam.appID = appConfig.appId;
    inputParam.appver = appConfig.appVersion;
    inputParam["channel"] = "wap";
    inputParam["platform"] = kony.os.deviceInfo().name;
    inputParam[sessionIdKey] = sessionID;
    if (globalhttpheaders) {
        if (inputParam["httpheaders"]) {
            inputParam.httpheaders = mergeHeaders(inputParam.httpheaders, globalhttpheaders);
        } else {
            inputParam["httpheaders"] = mergeHeaders({}, globalhttpheaders);
        };
    };
    kony.print("Async : Invoking service through Kony Fabric with url : " + url + " service id : " + serviceID + " operationid : " + operationID + "\n input params" + JSON.stringify(inputParam));
    if (kony.mbaas) {
        kony.mbaas.invokeMbaasServiceFromKonyStudio(url, inputParam, serviceID, operationID, callBack);
    } else {
        alert("Unable to find the Kony Fabric SDK for KonyStudio. Please download the SDK from the Kony Cloud Console and add as module to the Kony Project.");
    }
};

function mfintegrationsecureinvokersync(inputParam, serviceID, operationID) {
    var url = appConfig.secureurl;
    var sessionIdKey = "cacheid";
    var resulttable;
    inputParam.appID = appConfig.appId;
    inputParam.appver = appConfig.appVersion;
    inputParam["channel"] = "wap";
    inputParam["platform"] = kony.os.deviceInfo().name;
    inputParam[sessionIdKey] = sessionID;
    if (globalhttpheaders) {
        if (inputParam["httpheaders"]) {
            inputParam.httpheaders = mergeHeaders(inputParam.httpheaders, globalhttpheaders);
        } else {
            inputParam["httpheaders"] = mergeHeaders({}, globalhttpheaders);
        };
    };
    kony.print("Invoking service through Kony Fabric with url : " + url + " service id : " + serviceID + " operationid : " + operationID + "\n input params" + JSON.stringify(inputParam));
    if (kony.mbaas) {
        resulttable = kony.mbaas.invokeMbaasServiceFromKonyStudioSync(url, inputParam, serviceID, operationID);
        kony.print("Result table for service id : " + serviceID + " operationid : " + operationID + " : " + JSON.stringify(resulttable));
    } else {
        alert("Unable to find the Kony Fabric SDK for KonyStudio. Please download the SDK from the Kony Cloud Console and add as module to the Kony Project.");
    }
    return resulttable;
};
/*
   Sample invocation code
   var inputparam = {};
   inputparam.options = {
       "access": "online",
       "CRUD_TYPE": "get",//get/create..
       "odataurl": "$filter=UserId eq xxx",
       "data" : {a:1,b:2}//in case of create/update
   };
*/
function mfobjectsecureinvokerasync(inputParam, serviceID, objectID, callBack) {
    var options = {
        "access": inputParam.options.access
    };
    var serviceObj = kony.sdk.getCurrentInstance().getObjectService(serviceID, options);
    var CRUD_TYPE = inputParam.options.CRUD_TYPE;
    switch (CRUD_TYPE) {
        case 'get':
            var dataObject = new kony.sdk.dto.DataObject(objectID);
            var headers = inputParam.httpheaders || {};
            if (inputParam.options && inputParam.options.odataurl) dataObject.setOdataUrl(inputParam.options.odataurl.toString());
            options = {
                "dataObject": dataObject,
                "headers": headers
            };
            serviceObj.fetch(options, callBack, callBack);
            break;
        case 'create':
            var dataObject = new kony.sdk.dto.DataObject(objectID);
            var headers = inputParam.httpheaders || {};
            var data = inputParam.options && inputParam.options.data || {};
            var key;
            for (key in data) {
                dataObject.addField(key, data[key]);
            }
            options = {
                "dataObject": dataObject,
                "headers": headers
            };
            serviceObj.create(options, callBack, callBack);
            break;
        case 'update':
            var dataObject = new kony.sdk.dto.DataObject(objectID);
            var headers = inputParam.httpheaders || {};
            var data = inputParam.options && inputParam.options.data || {};
            var key;
            for (key in data) {
                dataObject.addField(key, data[key]);
            }
            options = {
                "dataObject": dataObject,
                "headers": headers
            };
            serviceObj.update(options, callBack, callBack);
            break;
        case 'partialupdate':
            var dataObject = new kony.sdk.dto.DataObject(objectID);
            var headers = inputParam.httpheaders || {};
            var data = inputParam.options && inputParam.options.data || {};
            var key;
            for (key in data) {
                dataObject.addField(key, data[key]);
            }
            options = {
                "dataObject": dataObject,
                "headers": headers
            };
            serviceObj.partialUpdate(options, callBack, callBack);
            break;
        case 'delete':
            var dataObject = new kony.sdk.dto.DataObject(objectID);
            var headers = inputParam.httpheaders || {};
            var data = inputParam.options && inputParam.options.data || {};
            var key;
            for (key in data) {
                dataObject.addField(key, data[key]);
            }
            options = {
                "dataObject": dataObject,
                "headers": headers
            };
            serviceObj.deleteRecord(options, callBack, callBack);
            break;
        default:
    }
};

function callAppMenu() {
    applicationController = require("applicationController");
    var appMenu = [
        ["appmenuitemid1", "Item 1", "option1.png", applicationController.appmenuseq, {}],
        ["appmenuitemid2", "Item 2", "option2.png", applicationController.appmenuseq, {}],
        ["appmenuitemid3", "Item 3", "option3.png", applicationController.appmenuseq, {}],
        ["appmenuitemid4", "Item 4", "option4.png", applicationController.appmenuseq, {}]
    ];
    kony.application.createAppMenu("sampAppMenu", appMenu, "", "");
    kony.application.setCurrentAppMenu("sampAppMenu");
};

function makeCall(eventobject) {
    kony.phone.dial(eventobject.text);
};

function initializeGlobalVariables() {};
kony.visualizer.toBoolean = function(output) {
    try {
        if (typeof output === "string") {
            if (output && output.toLowerCase() === "true") {
                output = true;
            } else {
                output = false;
            }
        } else if (typeof output === "number") {
            output = Boolean(output);
        }
    } catch (e) {
        kony.print('Error while converting the value to boolean datatype: ' + e);
    }
    return output;
};
kony.visualizer.toNumber = function(output) {
    try {
        if (typeof output === "string") {
            if (!output || isNaN(Number(output))) {
                kony.print('The value [' + output + '] after data type conversion is not a number(NaN)');
            } else {
                output = Number(output);
            }
        } else if (typeof output === "boolean") {
            output = Number(output);
        }
    } catch (e) {
        kony.print('Error while converting the value to number datatype: ' + e);
    }
    return output;
};
/**
 * Util to return value of the widget property with the {propertyName}
 * @param {Object/String} output
 * @param {String} propertyName
 * @returns {Object/String} - Returns value of {propertyName} if present, else it returns {output} as it is.
 */
kony.visualizer.getPropertyValue = function(output, propertyName) {
    if (typeof output === "object") {
        if (output.hasOwnProperty(propertyName)) {
            return output[propertyName];
        } else {
            kony.print(JSON.stringify(output) + ' does not have ' + propertyName + ' property');
        }
    }
    return output;
};
/*
	This API is used to merge User controller and controller action of Form.
 */
kony.visualizer.mixinControllerActions = function(controller, controllerActions) {
    for (var i = 0; i < controllerActions.length; i++) {
        var actions = require(controllerActions[i]);
        for (var key in actions) {
            /*If the user has defined action in formController then that takes priority 
            	over the action generated in controllerActions.
            	Example: onNavigate
            */
            if (typeof controller[key] === "undefined") {
                controller[key] = actions[key];
            }
        }
    }
    return controller;
};
kony.visualizer.i18nKeyObject = {
    "text": "i18n_text",
    "placeholder": "i18n_placeholder",
    "tabName": "i18n_tabName",
    "leftSideText": "i18n_leftSideText",
    "rightSideText": "i18n_rightSideText"
};
kony.visualizer.getI18nAttrb = function(property) {
    return kony.visualizer.i18nKeyObject[property];
};
//To set the passthrough properties at constructor level
function extendConfig(config, controllerConfig, id) {
    var __extendOverrides__ = function(config, currentOverrides, isTopLevelSrc) {
        Object.keys(currentOverrides).forEach(function(property) {
            var FLEX_PROPS_SANS_ZINDEX = ["left", "right", "top", "bottom", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "centerX", "centerY"];
            /*If height is preferred,
                For autogrowmode supported widgets, set autogrowmode and delete height from config.
                For other widgets, delete height from config.
            */
            if (property === "autogrowMode" && isTopLevelSrc) {
                delete config["height"];
                config[property] = currentOverrides[property];
            } else if (FLEX_PROPS_SANS_ZINDEX.indexOf(property) !== -1 && isTopLevelSrc) {
                if (currentOverrides[property] == 'viz.val_cleared' || (property === "height" && currentOverrides.hasOwnProperty(property) && currentOverrides[property] == kony.flex.USE_PREFFERED_SIZE)) {
                    delete config[property];
                } else {
                    config[property] = currentOverrides[property];
                }
            } else if (config[kony.visualizer.getI18nAttrb(property)] && isTopLevelSrc) {
                delete config[kony.visualizer.getI18nAttrb(property)];
                config[property] = currentOverrides[property];
            } else {
                config[property] = currentOverrides[property];
            }
        });
    };
    var __parseComponentId__ = function(wgtOverrideId) {
        //sample wgtOverrideId: "comp2.comp1.btnId"
        var parentIdArr = wgtOverrideId.split('.');
        return {
            rootId: parentIdArr.splice(0, 1)[0],
            childId: parentIdArr.join(".")
        };
    };
    var widgetsOverrides = (controllerConfig && controllerConfig.overrides);
    for (var wgtOverrides in widgetsOverrides) {
        var currentOverrides = widgetsOverrides[wgtOverrides];
        var idObj = __parseComponentId__(wgtOverrides);
        var rootId = idObj.rootId;
        var childId = idObj.childId;
        if (rootId === id) {
            if (config.overrides && childId) {
                if (config.overrides[childId]) {
                    __extendOverrides__(config.overrides[childId], currentOverrides);
                } else {
                    config.overrides[childId] = currentOverrides;
                }
            } else {
                //isTopLevelSrc is to indicate that this is the root source widget (without any nesting)
                var isTopLevelSrc = true;
                __extendOverrides__(config, currentOverrides, isTopLevelSrc);
            }
        }
    }
    return config;
};
//FP Appended appskins.js-----------------------------------------------------------
function skinsInit() {
    defBtnFocus = "defBtnFocus";
    defBtnNormal = "defBtnNormal";
    defLabel = "defLabel";
    sknLblDescription = "sknLblDescription";
    sknLblRowHeading = "sknLblRowHeading";
    sknLblStrip = "sknLblStrip";
    sknLblTimeStamp = "sknLblTimeStamp";
    sknSampleRowTemplate = "sknSampleRowTemplate";
    sknSampleSectionHeaderTemplate = "sknSampleSectionHeaderTemplate";
    sknSectionHeaderLabelSkin = "sknSectionHeaderLabelSkin";
    slDynamicNotificationForm = "slDynamicNotificationForm";
    slForm = "slForm";
    slPopup = "slPopup";
    slStaticNotificationForm = "slStaticNotificationForm";
    slTitleBar = "slTitleBar";
    slWatchForm = "slWatchForm";
};
//FP Appended fpas.js-----------------------------------------------------------
/*! KonyVisualizerV8420 2019-06-14 */

var __getDSObjIdForAnnotation__=function(t){return t.proj_guid+"_annotations_"+t.channel},__readAnnotationFromDataStore__=function(t){var n=__getDSObjIdForAnnotation__(t);if(kony.store.getItem(n)&&Object.keys(kony.store.getItem(n)).length>0){var o=kony.store.getItem(n);if(o[t.annotation_id])return o[t.annotation_id]}return null},__writeAnnotationToDataStore__=function(t,n){var o=__getDSObjIdForAnnotation__(t);if(kony.store.getItem(o)&&Object.keys(kony.store.getItem(o)).length>0){var e=kony.store.getItem(o);null!=n&&(e[t.annotation_id]=n),kony.store.setItem(o,e)}else{e={};null!=n&&(e[t.annotation_id]=n),kony.store.setItem(o,e)}},__addOrAppendAnnotationTODS__=function(t,n,o){var e=n,a=kony.ds.read("kvsession")[0].userDetails,_=t.annotation_id;function r(n){var o=annotationsUtil.createComment(e,a),_=o.commentId;return n.comments[e.widgetId]||(n.comments[e.widgetId]={}),n.comments[e.widgetId][_]=o,__writeAnnotationToDataStore__(t,n),n}e.widgetId=_,e.formId=_;try{var i=null;if(null!==__readAnnotationFromDataStore__(t)){var d=__readAnnotationFromDataStore__(t);e.channel=t.channel,i=r(d)}else e.channel=t.channel,i=r({widgetId:_,active:1,comments:{}});o({status:400,error:null,data:i})}catch(t){o({status:200,err:t,data:null})}},__deleteCommentFROMDS__=function(t,n,o){n.active=0,__updateCommentTODS__(t,n,o)},__updateCommentTODS__=function(t,n,o){var e=kony.ds.read("kvsession")[0].userDetails;try{if(null!==__readAnnotationFromDataStore__(t)){var a=__readAnnotationFromDataStore__(t);a=annotationsUtil.updateComment(n,e,a),__writeAnnotationToDataStore__(t,a),o({status:400,error:null,data:a})}}catch(t){o({status:200,err:t,data:null})}},__openAnnotation__=function(t,n){null!==__readAnnotationFromDataStore__(t)?n({status:400,data:__readAnnotationFromDataStore__(t)}):n({status:200,data:null})},fpas={addOrAppendAnnotationTODS:__addOrAppendAnnotationTODS__,updateCommentTODS:__updateCommentTODS__,deleteCommentFROMDS:__deleteCommentFROMDS__,openAnnotation:__openAnnotation__,readAnnotationFromDataStore:__readAnnotationFromDataStore__,writeAnnotationToDataStore:__writeAnnotationToDataStore__};
//FP Appended fpnotes.js-----------------------------------------------------------
/*! KonyVisualizerV8420 2019-06-14 */

var iterationStartTime,platformName=kony.os.deviceInfo().name.toLowerCase(),isWindows=!1;"windows"!=platformName&&"windowsphone"!=platformName||(isWindows=!0);var __getAuthHeader__=function(t,n){var e=new KOAuth(null,null,notesDBURLs.consumerKey,notesDBURLs.consumerSecret,KOAuth._constants.VERSION_1_0,"",KOAuth._constants.SIGNATURE_SHA1),o=kony.ds.read("acc_token"),i=null,r=null;if(null!=o&&void 0!=o){i=o[0].oauth_access_token,r=o[0].oauth_access_token_secret;var a={},s=e._prepareParameters(i,r,t,n,null),c=e._buildAuthorizationHeaders(s);for(var d in a[KOAuth._constants.HTTP_AUTHORIZATION_HEADER]=c,e._headers)e._headers.hasOwnProperty(d)&&(a[d]=e._headers[d]);return kony.print("@@@@@@HEADER PARAMS: "+JSON.stringify(a)),a}},__updateNotesToRemoteDB__=function(t,n){var e,o=__getDSObjIdForAnnotation__(t),i={};kony.store.getItem(o)&&(i=kony.store.getItem(o));var r,a=0;for(e in t.callbackFP=n,t.annotationMapSize=Object.keys(i).length,i)r=i[e],iterationStartTime=new Date,processAnnotation(r,t,++a);0==Object.keys(i).length&&n({status:200})},__cloneObject__=function(t){if(null==t||"object"!=typeof t)return t;var n=t.constructor();for(var e in t)t.hasOwnProperty(e)&&(n[e]=t[e]);return n},processAnnotation=function(t,n,e){try{function o(o){kony.print(t.widgetId+" : Syncing annotation was completed!");var i=n.dsObjID;if(kony.print("SYNCED OR NOT FLAG IS : "+o),o&&(t.synced_on=iterationStartTime.getTime()),kony.store.getItem(i)&&Object.keys(kony.store.getItem(i)).length>0){var r=kony.store.getItem(i);null!=t&&(r[t.widgetId]=t)}kony.store.setItem(i,r),e!=n.annotationMapSize&&0!=n.annotationMapSize||(kony.print("DONE UPDATING COMMENTS TO DB"),n.callbackFP({status:200}))}n.dsObjID=__getDSObjIdForAnnotation__(n),t.id=t.widgetId,t.channel=n.channel,processNote(t,n,function(e,i){kony.print("In callback for notes1"),i?(kony.print("In callback for notes2"),t.noteGuid=i,processComments(t,n,o)):o(!1)})}catch(t){kony.print("Error occurred during syncing annotation. Error: "+t+"!")}},processNote=function(t,n,e){t.noteGuid&&delete t.noteGuid;var o=__cloneObject__(t);o.formId=o.widgetId=o.id,o.createdOn=(new Date).getTime(),o.modifiedOn=o.createdOn;var i=getNoteParam(o);kony.print("NOTE PARAM BEING SENT"+JSON.stringify(i));var r=notesDBURLs.prototypeBase+notesDBURLs.prototypeApi+"/accounts/"+n.acc_guid+"/project/"+n.proj_guid+"/notes";var a=__getAuthHeader__("POST",r);checkPlatformsForInvokeService(r,{method:"post",timeout:100},a,JSON.stringify(i),function(t,n){if(400==t){if(null==n||void 0==n)return;if(kony.print("MetaInfo resulttable FOR NOTES "+JSON.stringify(n)),"errmsg"in n)kony.print("Unable to reach host."),e(n.errmsg,null);else if("status"in n&&(kony.print("status : "+JSON.stringify(t)),200==n.status.code&&"result"in n)){var o=(isWindows?n.httpResponse.headers.Location:n.httpresponse.headers.Location).split("/"),i=o[o.length-1];e(null,i)}}},null)},findNewOrUpdatedComments=function(t,n){var e,o={};for(e in t){var i,r=t[e];for(i in r){var a=r[i];kony.print("validateComment(commentObj) : "+validateComment(a)),kony.print("annotation.synced_on"+n.synced_on),kony.print("new Date(commentObj.lastModifiedTime) :"+new Date(a.lastModifiedTime)),kony.print("new Date(annotation.synced_on) :"+new Date(n.synced_on)),validateComment(a)&&(!n.synced_on||new Date(a.lastModifiedTime)>new Date(n.synced_on))&&(o[i]=a)}}return kony.print("updates: "+JSON.stringify(o)),o},processComments=function(t,n,e){kony.print(n.dsObjID+">>"+t.widgetId,"Processing comments");var o=t.comments,i=findNewOrUpdatedComments(o,t),r=Object.keys(i);if(0==r.length)kony.print(n.dsObjID+">>"+t.widgetId,"No new comments found."),e(!0);else{var a=r.length,s=[];function c(t,n){var o;(a--,t&&(kony.print("PUSHING FAILED COMMENT"+t),s.push(t)),0==a)&&(o=!(s.length>0),e(o))}r.forEach(function(e){var o=i[e];saveNewComment(t,n,o,c)})}},saveNewComment=function(t,n,e,o){try{kony.print(n.dsObjID+">>"+t.widgetId,"Saving new comment.");e=getCommentParam(e);kony.print("NOTE GUID FOR COMMENT"+t.noteGuid);var i=notesDBURLs.prototypeBase+notesDBURLs.prototypeApi+"/accounts/"+n.acc_guid+"/project/"+n.proj_guid+"/notes/"+t.noteGuid+"/comment";var r=__getAuthHeader__("POST",i);checkPlatformsForInvokeService(i,{method:"post",timeout:100},r,JSON.stringify(e),function(t,n){if(400==t){if(null==n||void 0==n)return;kony.print("MetaInfo resulttable FOR COMMENTS "+JSON.stringify(n)),"errmsg"in n?(kony.print("Unable to reach host."),kony.print("FAILED TO PUSH THE COMMENT : "+e.comment),o(e.guid)):"status"in n&&200==n.status.code&&"result"in n&&(kony.print("PUSHED THE COMMENT SUCCESSFULLY : "+e.comment),o(null))}},null)}catch(t){o(e.guid)}},validateComment=function(t){return t.commentId&&t.createdOn&&t.createdById&&t.createdBy&&t.createdByEmail&&t.lastModifiedTime&&t.comment&&"Anonymous"!=t.createdBy},__fetchNotesFromRemoteDB__=function(t,n){var e,o,i=t.annotation_id,r=[],a=t.proj_guid+"_lastPullTime";function s(t,n){var e=(n=formatComment(n)).widgetId;t.comments[e]||(t.comments[e]={});var o=t.comments[e];return o[n.commentId]=n,t.synced_on=(new Date).getTime(),t.comments[e]=o,t}kony.store.getItem(a)&&kony.store.getItem(a).length>0&&(e=kony.store.getItem(a)[0].updated_since||1),kony.print("FETCHING PROJECT PARAMS"+JSON.stringify(t)),o=e?notesDBURLs.prototypeBase+notesDBURLs.prototypeApi+"/accounts/"+t.acc_guid+"/project/"+t.proj_guid+"/channel/"+t.channel+"/comments/"+e:notesDBURLs.prototypeBase+notesDBURLs.prototypeApi+"/accounts/"+t.acc_guid+"/project/"+t.proj_guid+"/channel/"+t.channel+"/comments/",kony.print("FETCHING COMMENTS");var c=__getAuthHeader__("GET",o);if(isWindows){var d=new Date(1970,1,1);c["if-modified-since"]=d.toUTCString()}kony.net.invokeServiceAsync(o,{httpconfig:{method:"get",timeout:100},httpheaders:c},function(o,c){var d=__cloneObject__(t),m=__getDSObjIdForAnnotation__(d),u={};if(kony.store.getItem(m)&&(u=kony.store.getItem(m)),400==o){if(null==c||void 0==c)return;if(kony.print("MetaInfo resulttable "+JSON.stringify(c)),"errmsg"in c)kony.print("Unable to reach host."),n({status:500,error:"Could not reach the host"});else if("status"in c&&200==c.status.code&&"result"in c){var l,p=c.result;for(l in p){var _=p[l];kony.print("New COMMENT "+JSON.stringify(_)),d.annotation_id=_.widget_id,d.channel=_.channel,r.push(new Date(_.db_sync_time).getTime()),null!=u[d.annotation_id]&&void 0!=u[d.annotation_id]?null!=(y=s(y=u[d.annotation_id],_))&&(u[d.annotation_id]=y):null!=(y=s({widgetId:d.annotation_id,active:1,comments:{}},_))&&(u[d.annotation_id]=y)}}}if(kony.store.setItem(m,u),r.length>0&&(e=Math.max.apply(Math,r),kony.print("updated_since TIME STAMP"+e)),kony.store.setItem(a,[{updated_since:e}]),t.annotation_id=i,null!==fpas.readAnnotationFromDataStore(t)){var y=fpas.readAnnotationFromDataStore(t);n({status:200,data:y})}else n({status:500,error:"Could not read annotation from Data store"})},null)},fpnotes={updateNotesToRemoteDB:__updateNotesToRemoteDB__,fetchNotesFromRemoteDB:__fetchNotesFromRemoteDB__},checkPlatformsForInvokeService=function(t,n,e,o,i,r){isWindows?(kony.print("Calling Windows network service"),kony.print("body : "+JSON.stringify(o)),kony.print("headers : "+JSON.stringify(e)),kony.net.invokeServiceAsync2(t,{httpconfig:n,httpheaders:e,json:o},i,r)):(kony.print("Calling Non-windows network service"),kony.net.invokeServiceAsync(t,{httpconfig:n,httpheaders:e,json:o},i,r))};
//FP Appended fpnotes_config.js-----------------------------------------------------------
var notesDBURLs = {"accountsBase":"https://api.kony.com","accountsBaseUI":"https://manage.kony.com","accountsApi":"/api/v1_0","prototypeBase":"https://visualization.kony.com","prototypeApi":"/api/v1_0","documentation":"http://docs.kony.com/KonyLibrary/#welcome_visualizer.htm","consumerKey":"3eae78bc2e5537c49a8aac73425a8d8b0bd5a7da","consumerSecret":"ba6772b0022491e128835dc75111f4e82b0097fb"};

//FP Appended konyOauth.js-----------------------------------------------------------
/*
 * Kony OAuth Client to perform OAuth authentication/authorization with any given OAuth server (ver 1.0 or 2.0)
 * @Dev : Aasim Kumar Sokal
 * Integrated with Netflix implementation of OAuth.
 * 
 * Copyright 2013 Kony Inc.
 */

KOAuth._constants = {
	"VERSION_1_0" : "1.0A",
    "ENCODING" : "UTF-8",
    "FORM_ENCODED" : "application/x-www-form-urlencoded",
    "HTTP_AUTHORIZATION_HEADER" : "Authorization",
    "OAUTH_CONSUMER_KEY" : "oauth_consumer_key",
    "OAUTH_TOKEN" : "oauth_token",
    "OAUTH_TOKEN_SECRET" : "oauth_token_secret",
    "OAUTH_SIGNATURE_METHOD" : "oauth_signature_method",
    "OAUTH_SIGNATURE" : "oauth_signature",
    "OAUTH_TIMESTAMP" : "oauth_timestamp",
    "OAUTH_NONCE" : "oauth_nonce",
    "OAUTH_VERSION" : "oauth_version",
    "OAUTH_CALLBACK" : "oauth_callback",
    "OAUTH_VERIFIER" : "oauth_verifier",
    "HTTP_CONTENT_TYPE" : "Content-Type",
    "SIGNATURE_PLAINTEXT" : "PLAINTEXT",
    "SIGNATURE_SHA1" : "HMAC-SHA1"
};

function KOAuth(requestUrl, accessUrl, consumerKey, consumerSecret, version, authorize_callback, signatureMethod, customHeaders) {
	this._requestUrl = requestUrl;
	this._accessUrl = accessUrl;
	this._consumerKey = consumerKey;
	this._consumerSecret = this._encodeData(consumerSecret);
	this._version = version;

	if (authorize_callback === undefined) {
		this._authorize_callback = "oob";
	} else {
    	this._authorize_callback = authorize_callback;
  	}

  	if (signatureMethod != KOAuth._constants.SIGNATURE_PLAINTEXT && signatureMethod != KOAuth._constants.SIGNATURE_SHA1)
    	throw new Error("Un-supported signature method: " + signatureMethod)
  		this._signatureMethod = signatureMethod;
  	this._headers = customHeaders || {
    	"Accept" : "*/*",
    	"Connection" : "close",
    	"User-Agent" : "Kony authentication",
    	"preview_type" : "native"
  	}
  	this._clientOptions = this._defaultClientOptions = {
    	"requestTokenHttpMethod" : "POST",
   		"accessTokenHttpMethod" : "POST"
  	};
  	this._oauthParameterSeperator = ",";
};

KOAuth.prototype.getOAuthRequestToken = function(callback) {
  	this._performSecureRequest(null, null, this._clientOptions.requestTokenHttpMethod, this._requestUrl, null, null, null,
								    function(error, data, response) {
								      if (error)
								        	callback(error);
								      else {
								        	var results = _parseQuerystring(data);
								        	var oauth_token = results[KOAuth._constants.OAUTH_TOKEN];
								        	var oauth_token_secret = results[KOAuth._constants.OAUTH_TOKEN_SECRET];
								        	delete results[KOAuth._constants.OAUTH_TOKEN];
								        	delete results[KOAuth._constants.OAUTH_TOKEN_SECRET];
								        	callback(null, oauth_token, oauth_token_secret, results);
								      }
								    });
}

KOAuth.prototype.getOAuthTokenAuthorized = function(oauth_token, oauth_token_secret, url, extra_params, callback) {
  	this._performSecureRequest(oauth_token, oauth_token_secret, this._clientOptions.requestTokenHttpMethod, url, extra_params,null, null, 
			    					function(error, data, response) {
								      if (error)
								        callback(error);
								      else {
								        callback(null, 'SUCCESS');
								      }
								    });
}

KOAuth.prototype.getOAuthAccessToken = function(oauth_token,
    oauth_token_secret, oauth_verifier, callback) {
  	var extraParams = {};
  	if (typeof oauth_verifier == "function") {
    	callback = oauth_verifier;
  	} else {
    	extraParams.oauth_verifier = oauth_verifier;
  	}
  	this._performSecureRequest(oauth_token, oauth_token_secret, this._clientOptions.accessTokenHttpMethod, this._accessUrl, extraParams, null, null,
							    function(error, data, response) {
							      if (error)
							        callback(error);
							      else {
							        var results = _parseQuerystring(data);
							        var oauth_access_token = results[KOAuth._constants.OAUTH_TOKEN];
							        delete results[KOAuth._constants.OAUTH_TOKEN];
							        var oauth_access_token_secret = results[KOAuth._constants.OAUTH_TOKEN_SECRET];
							        delete results[KOAuth._constants.OAUTH_TOKEN_SECRET];
							        callback(null, oauth_access_token,
							            oauth_access_token_secret, results);
							      }
							    });
}

KOAuth.prototype.getSecureData = function(url, method, oauth_token, oauth_token_secret, callback) {
  this._performSecureRequest(oauth_token, oauth_token_secret, method, url,null, null, null,
							   function(error, data, response) {
							      if (error)
							        callback(error);
							      else {
							        callback(null, data, response);
							      }
							    });
}

KOAuth.prototype._performSecureRequest = function(oauth_token, oauth_token_secret, method, url, extra_params, post_body, post_content_type, callback) {
	var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, extra_params);
  	if (!post_content_type) {
    	post_content_type = KOAuth._constants.FORM_ENCODED;
  	}

  	var headers = {};
  	var authorization = this._buildAuthorizationHeaders(orderedParameters);
  	kony.print("Final build " + authorization);
  	headers[KOAuth._constants.HTTP_AUTHORIZATION_HEADER] = authorization;

  	for ( var key in this._headers) {
    	if (this._headers.hasOwnProperty(key)) {
      		headers[key] = this._headers[key];
    	}
  	}

  // Filter out any passed extra_params that are really to do with OAuth
  	for ( var key in extra_params) {
    	if (key.substring(0, 6) == "oauth_") {
      		delete extra_params[key];
    	}
  	}
  	var async = false;
	if(method == 'GET') {
	 req_method = constants.HTTP_METHOD_GET;
	 async = true;
	}
	else req_method = constants.HTTP_METHOD_POST;

  	if ((method == "POST" || method == "PUT") && (post_body == null && extra_params != null)) {
    	post_body = this._paramStringify(extra_params).replace(/\!/g, "%21").replace(/\'/g, "%27").replace(/\(/g, "%28").replace(/\)/g,"%29").replace(/\*/g, "%2A");
  	}
  	headers[KOAuth._constants.HTTP_CONTENT_TYPE] = post_content_type;

  	kony.print("Headers Used " + JSON.stringify(headers));
  
	 
	
	if((kony.os.deviceInfo().name).toLowerCase() == "android")
		nativelogin.nativecreaterequest(url);
	else{		
	 	var request = new kony.net.HttpRequest(); 
	 	request.timeout = 5000; 
	 	request.open(req_method, url, async); 	 	
	}
	  
 	var response = "";
 	if((kony.os.deviceInfo().name).toLowerCase() != "android") { 	
     	request.onReadyStateChange = function() {
     	kony.print("statusText = " + this.statusText + " Number  " + this.status);
     	if(this.statusText == "server error"){
 			errorMsgFP("Unable to reach host.");
 			return;
     	 }
 	   	if (this.readyState == constants.HTTP_READY_STATE_DONE) {
        	kony.print("Status = " + this.statusText + " Number  " + this.status);
        	kony.print("RESPONSE HEADERS " + JSON.stringify(request.getAllResponseHeaders()));
			response = this.response;			
		 	kony.print("JS Received response1 " + JSON.stringify(response));
		 	if(response != null){
			  	var response1 = _parseQuerystring("" + response);
			  	kony.print("JS Received Data  " + JSON.stringify(response1));
			  	if (this.status >= 200 && this.status <= 299) {
			  		kony.print("SUCCESS CODE ");
			    	callback(null, response, response);
			  	} else {
			  		kony.print("FAILURE CODE");
			    	callback(response, response, response);
			  	}
			}
		}
    	}
    	
 	}
	
  	for ( var key in headers) {
	  if((kony.os.deviceInfo().name).toLowerCase() == "android")
	     nativelogin.nativesetrequesthdr(key, headers[key]);
	   else
		 request.setRequestHeader(key, headers[key]);
	   
  	}
  
  	if ((method == "POST" || method == "PUT") && post_body != null && post_body != "") {
      	kony.print("Sending Form Data " + post_body);
      	if((kony.os.deviceInfo().name).toLowerCase() == "android")
	 		response = nativelogin.nativesenddata(post_body);
        else{
      	  	var post_body = new kony.net.FormData();        
	      	post_body.append("primary_email", encodeURIComponent(extra_params["primary_email"]));
	      	post_body.append("password", encodeURIComponent(extra_params["password"]));
	        request.send(post_body);
    	}
  	} else {
	   if((kony.os.deviceInfo().name).toLowerCase() == "android")
			response = nativelogin.nativesenddata(null);   		
	   else{
	   		request.send();	   		
	   }
  	}
  	
  if((kony.os.deviceInfo().name).toLowerCase() == "android"){
	  kony.print("JS Received response1 " + response);
	  var response1 = _parseQuerystring("" + response);
	  var aIdx = response.indexOf('&');
	  response = response.substring(aIdx + 1, response.length);
	  kony.print("JS Received Data  " + JSON.stringify(response1));
	  if (response1.status >= 200 && response1.status <= 299) {
	  	kony.print("SUCCESS CODE ");
	    callback(null, response, response);
	  } else {
	  	kony.print("FAILURE CODE");
	      callback(response, response, response);
	  }
  }
}

var _addUrlPath = function(url, path) {
  	var uri = url;
  	if (url.substring(url.length - 1, url.length) == '/') {
    	if (path.substring(0, 1) == '/') {
      		uri = url + path.substring(1, path.length);
    	} else {
      		uri = url + path;
    	}
  	} else {
    	if (path.substring(0, 1) == '/') {
     	 	uri = url + path;
    	} else {
      		uri = url + '/' + path;
    	}
  	}
  	return uri;
};

var _addToURL = function(url, parameters) {
  	newURL = url;
  	if (parameters != null) {
    	var toAdd = OAuth.formEncode(parameters);
    	if (toAdd.length > 0) {
      	var q = url.indexOf('?');
      	if (q < 0)
        	newURL += '?';
      	else
        	newURL += '&';
      	newURL += toAdd;
    	}
  	}
 	 return newURL;
};

var _parseURL = function(url) {
  	var idx = url.indexOf('?');
  	if (idx > 0) {
    	var queryString = url.substring(idx + 1);
    	var params = _parseQuerystring(queryString);
  	}
  	return params;
};

var _parseQuerystring = function(queryString) {
  	var params = {}, queries, temp, i, l;
  	queries = queryString.split("&");
  	for (i = 0, l = queries.length; i < l; i++) {
    	temp = queries[i].split('=');
    	params[temp[0]] = temp[1];
  	}
  	return params;
};

KOAuth.prototype._paramStringify = function(parameters) {
  	var form = "";
  	var list = parameters;// OAuth.getParameterList(parameters);
  	for ( var p in parameters) {
    	if (form != "")
      		form += '&';
    	form += this._encodeData(p) + '=' + this._encodeData(list[p]);
  	}
  	return form;
};

var _formEncode = function(parameters) {
  	var form = "";
  	var list = parameters;// OAuth.getParameterList(parameters);
  	for ( var p = 0; p < list.length; ++p) {
    	var value = list[p][1];
    	if (value == null)
      		value = "";
    	if (form != "")
      	form += '&';
    	form += _encodeData(list[p][0]) + '=' + _encodeData(value);
  	}
  	return form;
};

KOAuth.prototype._encodeData = function(toEncode) {
  	if (toEncode == null || toEncode == "")
    	return ""
  	else {
    	var result = encodeURIComponent(toEncode);
    // Fix the mismatch between OAuth's RFC3986's and Javascript's beliefs
    // in what is right and wrong ;)
    	return result.replace(/\!/g, "%21").replace(/\'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
  	}
}
KOAuth.prototype._prepareParameters = function(oauth_token, oauth_token_secret, method, url, extra_params) {
  	var accessor = {
    	consumerSecret : this._consumerSecret,
    	consumerKey : this._consumerKey,
    	token : oauth_token,
    	tokenSecret : oauth_token_secret
  	};

  	var message = {
    	action : url,
    	method : method,
    	parameters : []
  	};

  	message.parameters.push([ KOAuth._constants.OAUTH_TIMESTAMP, "" ]);
  	message.parameters.push([ KOAuth._constants.OAUTH_NONCE, "" ]);
  	message.parameters.push([ KOAuth._constants.OAUTH_VERSION, this._version ]);
  	message.parameters.push([ KOAuth._constants.OAUTH_SIGNATURE_METHOD, this._signatureMethod ]);
  	message.parameters.push([ KOAuth._constants.OAUTH_CONSUMER_KEY, this._consumerKey ]);

  	if (oauth_token) {
    	message.parameters.push([ KOAuth._constants.OAUTH_TOKEN, oauth_token ]);
  	}

  	if (extra_params) {
    	for ( var key in extra_params) {
      		message.parameters[key] = extra_params[key];
    	}
  	}
  	var extraParameters = _parseURL(url);
  	if (extraParameters) {
    	var key2;
    	for ( var key in extraParameters) {
     		var value = extraParameters[key];
      		if (typeof value == "object") {
        	// TODO: This probably should be recursive
        		for (key2 in value) {
          			message.parameters[key + "[" + key2 + "]"] = value[key2];
        		}
      		} else {
        		message.parameters[key] = value;
      		}
    	}
  	}
  	OAuth.setTimestampAndNonce(message);
 	OAuth.completeRequest(message, accessor);
  	var parameterMap = OAuth.getParameterMap(message.parameters);
  	// kony.print("Head seed " + JSON.stringify(parameterMap));
  	return parameterMap;
}

KOAuth.prototype._parseURL = function(toEncode) {
  	if (toEncode == null || toEncode == "")
    	return ""
  	else {
    	var result = encodeURIComponent(toEncode);
    	// Fix the mismatch between OAuth's RFC3986's and Javascript's beliefs
    	// in what is right and wrong ;)
    	return result.replace(/\!/g, "%21").replace(/\'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
  	}
}

KOAuth.prototype._decodeData = function(toDecode) {
  	if (toDecode != null) {
    	toDecode = toDecode.replace(/\+/g, " ");
  	}
  	return decodeURIComponent(toDecode);
}

// build the OAuth request authorization header
KOAuth.prototype._buildAuthorizationHeaders = function(orderedParameters) {
  	var authHeader = "OAuth ";
  	for ( var p in orderedParameters) {
    	if (p.substring(0, 6) == "oauth_") {
      	authHeader += "" + this._encodeData(p) + "=\""
          	+ this._encodeData(orderedParameters[p]) + "\"" + ",";
    	}
  	}
  	authHeader = authHeader.substring(0, authHeader.length
      	- this._oauthParameterSeperator.length);
  	return authHeader;
}

//FP Appended kony_sdk.js-----------------------------------------------------------
 /*
  * kony-sdk-ide Version 8.4.0
  */
 /**
  * Kony namespace
  * @namespace kony
  */
 if (typeof(kony) === "undefined") {
     kony = {};
 }
 /**
  * Constructor for creating the kony client instance.
  * @class
  * @classdesc kony Class
  * @memberof kony
  */
 kony.sdk = function() {
     var currentObj = this;
     this.mainRef = {};
     var clientParams = {};
     this.tokens = {};
     this.currentClaimToken = null;
     this.globalRequestParams = {
         "headers": {},
         "queryparams": {},
         "bodyparams": {}
     };
     var userId = "";
     this.integrityCustomSecurityKey = null;
     this.reportingheaders_allowed = false;
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && typeof(kony.setUserID) === 'function') {
         var userIDflagGet = kony.ds.read("userIDFromLicenseFlag");
         if (kony.sdk.isNullOrUndefined(userIDflagGet)) {
             var userIDflagSet = [];
             userIDflagSet.push("false");
             kony.ds.save(userIDflagSet, "userIDFromLicenseFlag");
         }
     }
     if (kony.internal && kony.internal.sdk && kony.internal.sdk.Services) {
         this.internalSdkObject = new kony.internal.sdk.Services();
     }
     this.getUserId = function() {
         return userId;
     };
     this.setCurrentUserId = function(newUserID) {
         userId = newUserID;
     };
     this.getSessionId = function() {
         if (!konyRef.sessionId) {
             var sessionId = kony.ds.read(kony.sdk.constants.KONYUUID);
             if (sessionId) {
                 konyRef.sessionId = sessionId[0];
             } else {
                 kony.sdk.logsdk.error("Session id is not available");
                 konyRef.sessionId = "";
             }
         }
         return konyRef.sessionId;
     };
     this.setSessionId = function(newSessionId) {
         konyRef.sessionId = newSessionId;
     };
     this.setClientParams = function(clientParamsMap) {
         clientParams = clientParamsMap;
     };
     this.getClientParams = function() {
         return clientParams;
     };
     this.globalRequestParamType = {
         headers: "headers",
         queryParams: "queryparams",
         bodyParams: "bodyparams"
     };
     this.getGlobalRequestParams = function(paramType) {
         kony.sdk.logsdk.trace("Entering getGlobalRequestParams");
         if (kony.sdk.isNullOrUndefined(paramType)) {
             return currentObj.globalRequestParams;
         } else if (paramType === currentObj.globalRequestParamType.headers) {
             return currentObj.globalRequestParams.headers;
         } else if (paramType === currentObj.globalRequestParamType.queryParams) {
             return currentObj.globalRequestParams.queryparams;
         } else if (paramType === currentObj.globalRequestParamType.bodyParams) {
             return currentObj.globalRequestParams.bodyparams;
         }
     };
     this.setGlobalRequestParam = function(paramName, paramValue, paramType) {
         kony.sdk.logsdk.trace("Entering setGlobalRequestParam");
         if (typeof(paramName) === 'string' && typeof(paramValue) === 'string' && typeof(paramType) === 'string') {
             if (paramType === currentObj.globalRequestParamType.headers) {
                 currentObj.globalRequestParams.headers[paramName] = paramValue;
             } else if (paramType === currentObj.globalRequestParamType.queryParams) {
                 currentObj.globalRequestParams.queryparams[paramName] = paramValue;
             } else if (paramType === currentObj.globalRequestParamType.bodyParams) {
                 currentObj.globalRequestParams.bodyparams[paramName] = paramValue;
             }
         }
     };
     this.removeGlobalRequestParam = function(paramName, paramType) {
         kony.sdk.logsdk.trace("Entering removeGlobalRequestParam");
         if (typeof(paramName) === 'string' && typeof(paramType) === 'string') {
             if (paramType.toLowerCase() === currentObj.globalRequestParamType.headers && !kony.sdk.isNullOrUndefined(currentObj.globalRequestParams.headers[paramName])) {
                 delete currentObj.globalRequestParams.headers[paramName];
             } else if (paramType.toLowerCase() === currentObj.globalRequestParamType.queryParams && !kony.sdk.isNullOrUndefined(currentObj.globalRequestParams.queryparams[paramName])) {
                 delete currentObj.globalRequestParams.queryparams[paramName];
             } else if (paramType.toLowerCase() === currentObj.globalRequestParamType.bodyParams && !kony.sdk.isNullOrUndefined(currentObj.globalRequestParams.bodyparams[paramName])) {
                 delete currentObj.globalRequestParams.bodyparams[paramName];
             }
         }
     };
     this.resetGlobalRequestParams = function() {
         kony.sdk.logsdk.trace("Entering resetGlobalRequestParams");
         currentObj.globalRequestParams = {
             "headers": {},
             "queryparams": {},
             "bodyparams": {}
         };
     };
     this.appendGlobalHeaders = function(headers) {
         kony.sdk.logsdk.trace("Entering appendGlobalHeaders");
         var globalHeaders = currentObj.getGlobalRequestParams(currentObj.globalRequestParamType.headers);
         if (!kony.sdk.isNullOrUndefined(globalHeaders)) {
             if (kony.sdk.isNullOrUndefined(headers)) {
                 headers = {};
             }
             for (var obj in globalHeaders) {
                 if (kony.sdk.isNullOrUndefined(headers[obj])) {
                     headers[obj] = globalHeaders[obj];
                 }
             }
         }
     };
     this.appendGlobalBodyParams = function(params) {
         kony.sdk.logsdk.trace("Entering appendGlobalBodyParams");
         var globalBodyParams = currentObj.getGlobalRequestParams(currentObj.globalRequestParamType.bodyParams);
         if (!kony.sdk.isNullOrUndefined(globalBodyParams)) {
             if (kony.sdk.isNullOrUndefined(params)) {
                 params = {};
             }
             for (var obj in globalBodyParams) {
                 if (kony.sdk.isNullOrUndefined(params[obj])) {
                     params[obj] = globalBodyParams[obj];
                 }
             }
         }
     };
     this.appendGlobalQueryParams = function(url) {
         kony.sdk.logsdk.trace("Entering appendGlobalQueryParams");
         var globalQueryParams = currentObj.getGlobalRequestParams(currentObj.globalRequestParamType.queryParams);
         if (!kony.sdk.isNullOrUndefined(globalQueryParams) && Object.keys(globalQueryParams).length !== 0) {
             if (url.indexOf("?") < 0) {
                 url = url + "?" + kony.sdk.util.objectToQueryParams(globalQueryParams);
             } else {
                 url = url + "&" + kony.sdk.util.objectToQueryParams(globalQueryParams);
             }
         }
         return url;
     };
     this.appendGlobalParams = function(url, headers, params) {
         kony.sdk.logsdk.trace("Entering appendGlobalParams");
         currentObj.appendGlobalHeaders(headers);
         currentObj.appendGlobalBodyParams(params);
         return currentObj.appendGlobalQueryParams(url);
     };
     this.setAppSecurityKey = function(customSalt) {
         if (!kony.sdk.isNullOrUndefined(customSalt) && typeof customSalt === 'string') {
             this.integrityCustomSecurityKey = customSalt;
             return true;
         } else {
             var errorObj = {};
             errorObj[kony.sdk.constants.ERR_CODE] = kony.sdk.errorcodes.invalid_security_key;
             errorObj[kony.sdk.constants.ERR_MSG] = kony.sdk.errormessages.invalid_security_key;
             kony.sdk.logsdk.error(kony.sdk.errormessages.invalid_security_key);
             return errorObj;
         }
     };
 };
 kony.mbaas = kony.sdk;
 kony.sdk.isDebugEnabled = true;
 kony.sdk.isInitialized = false;
 kony.sdk.currentInstance = null;
 kony.sdk.isLicenseUrlAvailable = true;
 kony.sdk.constants = kony.sdk.constants || {};
 kony.sdk.version = "8.4.0";
 kony.sdk.logsdk = new konySdkLogger();
 kony.sdk.syncService = null;
 kony.sdk.dataStore = kony.sdk.dataStore || new konyDataStore();
 kony.sdk.skipAnonymousCall = false;
 kony.sdk.getDefaultInstance = function() {
     return kony.sdk.currentInstance;
 };
 // This is to be deprecated with getDefaultInstance
 kony.sdk.getCurrentInstance = function() {
     return kony.sdk.currentInstance;
 };
 // This is to be set by client to skip anonymous login calls.
 kony.sdk.skipAnonymousLoginCall = function(state) {
     // If enabled then client can only access public integration services.
     // If disabled then client can access protected integration services.
     // To access private client needs to get authenticated by an identity service.
     kony.sdk.skipAnonymousCall = state;
 };
 kony.sdk.claimsRefresh = function(callback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.claimsRefresh");
     var konyRef = kony.sdk.getCurrentInstance();
     var networkProvider = new konyNetworkProvider();
     var loginWithAnonymousProvider = function(successCallback, failureCallback) {
         var identityObject = konyRef.getIdentityService("$anonymousProvider");
         identityObject.login(null, function(res) {
             successCallback();
         }, function(res) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(res));
         });
     };
     if (konyRef.currentClaimToken === null) {
         kony.sdk.logsdk.warn("claims Token is Unavialable");
         if (konyRef.isAnonymousProvider) {
             loginWithAnonymousProvider(callback, failureCallback);
         } else {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getNullClaimsTokenErrObj());
         }
     } else if (konyRef.claimTokenExpiry && new Date().getTime() > konyRef.claimTokenExpiry) {
         if (konyRef.isAnonymousProvider) {
             loginWithAnonymousProvider(callback, failureCallback);
         } else {
             kony.sdk.fetchClaimsTokenFromServer(false, callback, failureCallback);
         }
     } else {
         callback();
     }
 };
 kony.sdk.claimsAndProviderTokenRefresh = function(callback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.claimsAndProviderTokenRefresh");
     kony.sdk.fetchClaimsTokenFromServer(true, callback, failureCallback);
 };
 /**
  * Checks for the etag in the response data. Gets the service doc & caches it if etag is updated.
  * @param data{JSON} response data from claimsRefresh or login.
  * @param callback{function} callback to be invoked.
  */
 function getLatestServiceDocIfAvailable(data, callback) {
     //Disabling this for phonegap and plain-js as there is not concept of auto-init there
     if (kony.sdk.getSdkType() !== kony.sdk.constants.SDK_TYPE_IDE) {
         kony.sdk.verifyAndCallClosure(callback);
         return;
     }
     var currentETag = kony.sdk.dataStore.getItem("etagID");
     var serverETag = data.service_doc_etag;
     if (!kony.sdk.isNullOrUndefined(serverETag) && (kony.sdk.isNullOrUndefined(currentETag) || currentETag != serverETag)) {
         kony.sdk.logsdk.info("Service doc update found.");
         var networkProvider = new konyNetworkProvider();
         var _serviceUrl = stripTrailingCharacter(konyRef.rec.url, "/") + "/appconfig";
         var headers = {};
         headers[kony.sdk.constants.APP_KEY_HEADER] = konyRef.mainRef.appKey;
         headers[kony.sdk.constants.APP_SECRET_HEADER] = konyRef.mainRef.appSecret;
         headers["X-HTTP-Method-Override"] = "GET";
         populateHeaderWithFabricAppVersion(headers);
         networkProvider.post(_serviceUrl, null, headers, function(successResponse) {
             kony.sdk.dataStore.setItem("etagID", serverETag);
             kony.sdk.logsdk.debug("Update done. Current version = " + currentETag + " Updated to " + serverETag);
             kony.sdk.dataStore.setItem(appConfig.appId + "_mobileFabricServiceDoc", JSON.stringify(successResponse));
             kony.sdk.verifyAndCallClosure(callback);
         }, function(failureResponse) {
             kony.sdk.logsdk.error("Refresh of serviceDoc failed:" + JSON.stringify(failureResponse));
             kony.sdk.verifyAndCallClosure(callback);
         });
     } else {
         kony.sdk.verifyAndCallClosure(callback);
     }
 }
 kony.sdk.fetchClaimsTokenFromServer = function(isBackendTokenRefreshRequired, callback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.fetchClaimsTokenFromServer");
     var konyRef = kony.sdk.getCurrentInstance();
     var networkProvider = new konyNetworkProvider();
     kony.sdk.logsdk.debug("claims token has expired. fetching new token and isBackendTokenRefreshRequired :", isBackendTokenRefreshRequired);
     var _serviceUrl = stripTrailingCharacter(konyRef.rec.url, "/");
     var _url = _serviceUrl + "/claims";
     if (isBackendTokenRefreshRequired) {
         _url = _url + "?refresh=true";
     }
     kony.sdk.logsdk.debug("service url is " + _url);
     if (konyRef.currentRefreshToken === null) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getNullRefreshTokenErrObj());
     } else {
         var headers = {};
         headers[kony.sdk.constants.AUTHORIZATION_HEADER] = konyRef.currentRefreshToken;
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         networkProvider.post(_url, {}, headers, function(tokens) {
             kony.sdk.logsdk.trace("refresh success..acquiring new tokens");
             var response = kony.sdk.processClaimsSuccessResponse(tokens, konyRef, false);

             function serviceDocCallback() {
                 kony.sdk.verifyAndCallClosure(callback, response);
             }
             getLatestServiceDocIfAvailable(tokens, serviceDocCallback);
         }, function(data) {
             kony.sdk.logsdk.error("failed to acquire refresh token", data);
             kony.sdk.processClaimsErrorResponse(data, konyRef, true, failureCallback);
         });
     }
 };
 kony.sdk.processClaimsSuccessResponse = function(data, konyRef, isAsync, callBack) {
     kony.sdk.logsdk.trace("Entering kony.sdk.processClaimsSuccessResponse");
     data = kony.sdk.formatSuccessResponse(data);
     konyRef.currentClaimToken = data.claims_token.value;
     konyRef.claimTokenExpiry = data.claims_token.exp;
     konyRef.currentRefreshToken = data.refresh_token;
     kony.logger.setClaimsToken();
     //if offline login enabled then updating the claimstoken in the store
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_NATIVE && kony.sdk.getPlatformName() !== kony.sdk.constants.PLATFORM_WINDOWS) {
         if (kony.sdk.offline.isOfflineEnabled && kony.sdk.offline.isOfflineEnabled == true) {
             kony.sdk.offline.updateAuthToken(data);
         }
         if (kony.sdk.offline.persistToken || kony.sdk.util.isPersistentLoginResponseEnabled()) {
             kony.sdk.offline.updatePersistedToken(data);
         }
     }
     if (!isAsync) {
         return {
             "message": "success"
         };
     } else if (callBack) {
         callBack();
     }
 };
 kony.sdk.processClaimsErrorResponse = function(data, konyRef, isAsync, callBack) {
     kony.sdk.logsdk.trace("Entering kony.sdk.processClaimsErrorResponse");
     /*reset the claims token*/
     konyRef.currentClaimToken = null;
     konyRef.claimTokenExpiry = null;
     konyRef.currentRefreshToken = null;
     //setting the anonymous provider as true to access the public protected urls without any issue
     konyRef.isAnonymousProvider = true;
     if (!isAsync) {
         return kony.sdk.error.getAuthErrObj(data);
     } else if (callBack) {
         kony.sdk.verifyAndCallClosure(callBack, kony.sdk.error.getAuthErrObj(data));
     }
 };
 /**
  * Init success callback method.
  * @callback initSuccessCallback
  * @param {json} mainRef - Application Configuration
  */
 /**
  * Init failure callback method.
  * @callback initFailureCallback
  */
 /**
  * Initialization method for the kony SDK.
  * This method will fetch the app configuration from the kony server and stores in memory.
  * This method has to be invoked before invoking any other SDK methods.
  * @param {string} appKey - Appkey of the kony application
  * @param {string} appSecret - App Secret of the kony application
  * @param {string} serviceUrl - URL of the kony Server
  * @param {initSuccessCallback} successCallback  - Callback method on success
  * @param {initFailureCallback} failureCallback - Callback method on failure
  */
 kony.sdk.prototype.init = function(appKey, appSecret, serviceUrl, successCallback, failureCallback, initOptions) {
     // removing app metadata with key for the latest app metadata
     kony.sdk.logsdk.trace("Entering kony.sdk.prototype.init");
     kony.sdk.deleteMetadatafromDs();
     if (!(appKey && appSecret && serviceUrl)) {
         kony.sdk.logsdk.error("### init:: Invalid credentials passed");
         kony.sdk.verifyAndCallClosure(failureCallback, "Invalid initialization parameters passed. Please check appKey, appSecret and ServiceUrl parameters");
         return;
     }
     var networkProvider = new konyNetworkProvider();
     serviceUrl = serviceUrl.trim();
     this.mainRef.serviceUrl = serviceUrl;
     this.mainRef.appSecret = appSecret;
     konyRef = this;
     KNYMobileFabric = this;
     var options = {};
     options["ignoreintegrity"] = true;
     setIntegrityParams.call(konyRef);
     kony.sdk.logsdk.trace("### init:: calling GET on appConfig to retrieve servicedoc");
     var headers = {};
     headers[kony.sdk.constants.APP_KEY_HEADER] = appKey;
     headers[kony.sdk.constants.APP_SECRET_HEADER] = appSecret;
     headers["X-HTTP-Method-Override"] = "GET";
     //Resetting the value.
     kony.sdk.setFabricAppVersion(null);
     if (!kony.sdk.isNullOrUndefined(initOptions) && initOptions["MFAppVersion"]) {
         kony.sdk.setFabricAppVersion(initOptions["MFAppVersion"]);
     }
     populateHeaderWithFabricAppVersion(headers);
     networkProvider.post(serviceUrl, null, headers, function(data) {
         data = kony.sdk.formatSuccessResponse(data);
         kony.sdk.logsdk.info("### init::_doInit fetched servicedoc successfuly");
         kony.sdk.logsdk.debug("### init:: retrieved data from service doc", data);
         konyRef.mainRef.config = data;
         konyRef.servicedoc = data;
         konyRef.mainRef.appId = data.appId;
         var processServiceDocResult = konyRef.initWithServiceDoc(appKey, appSecret, data);
         if (processServiceDocResult === true) {
             kony.sdk.logsdk.info("### init::_doInit processing service document successful");
             kony.sdk.logsdk.debug("### init::_doInit saving done. Calling success callback", data);
             kony.sdk.initiateSession(konyRef);
             if (typeof(KNYMetricsService) !== "undefined" && kony.sdk.currentInstance.getMetricsService) {
                 KNYMetricsService = kony.sdk.currentInstance.getMetricsService();
                 if (KNYMetricsService && typeof(appConfig) !== "undefined" && kony.sdk.util.isJsonObject(appConfig) && appConfig.hasOwnProperty("eventTypes") && kony.sdk.isArray(appConfig.eventTypes) && appConfig.eventTypes.length !== 0) {
                     KNYMetricsService.setEventTracking(appConfig.eventTypes);
                 }
             }
             if (kony.sdk.skipAnonymousCall) {
                 kony.sdk.logsdk.info("### init::skipping anonymous login call");
                 // Enabling this flag to connect to any protected integration service.
                 konyRef.isAnonymousProvider = true;
                 kony.sdk.verifyAndCallClosure(successCallback, konyRef.mainRef);
             } else {
                 var identityObject = kony.sdk.getCurrentInstance().getIdentityService("$anonymousProvider");
                 identityObject.login(null, function(res) {
                     kony.sdk.verifyAndCallClosure(successCallback, konyRef.mainRef);
                 }, function(res) {
                     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(res));
                 });
             }
         } else {
             kony.sdk.logsdk.error("### init::_doInit processing servicedoc failed. Calling failure callback");
             kony.sdk.verifyAndCallClosure(failureCallback, JSON.stringify(processServiceDocResult));
         }
     }, function(error) {
         kony.sdk.logsdk.error("### init::_doInit fetching service document from Server failed", error);
         kony.sdk.logsdk.info("### init::_doInit  calling failure callback");
         kony.sdk.isInitialized = false;
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(error));
     }, null, options);
 };
 kony.sdk.prototype.initWithServiceDoc = function(appKey, appSecret, serviceDoc) {
     kony.sdk.logsdk.trace("Entering kony.sdk.prototype.initWithServiceDoc");
     konyRef = this;
     KNYMobileFabric = this;
     kony.sdk.currentInstance = this;
     var unprocessedServiceDoc = kony.sdk.cloneObject(serviceDoc);
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE) {
         if (!kony.sdk.isNullOrUndefined(serviceDoc)) {
             if (serviceDoc.hasOwnProperty("integrity_check_required") && serviceDoc.integrity_check_required === true) {
                 //MF server >=8.2
                 konyRef.mainRef.integrityKey = true;
             } else {
                 //MF server < 8.2 and integrity is disabled
                 konyRef.mainRef.integrityKey = false;
             }
         }
     } else {
         //platform phonegap and plain-js doesn't support http integrity
         konyRef.mainRef.integrityKey = false;
     }
     if (serviceDoc instanceof kony.sdk.serviceDoc) {
         var servConfig = serviceDoc.toJSON();
         processServiceDocMap(servConfig);
     } else {
         return processServiceDocMap(serviceDoc);
     }

     function processServiceDocMap(servConfig) {
         for (var item in servConfig) {
             if (kony.sdk.isNullOrUndefined(servConfig[item]) || kony.sdk.isEmptyObject(servConfig[item])) {
                 delete servConfig[item];
             }
         }
         kony.sdk.logsdk.debug("### init::_doInit::_processServiceDoc", servConfig);
         try {
             konyRef.mainRef.appKey = appKey;
             konyRef.mainRef.appSecret = appSecret;
             konyRef.mainRef.appId = servConfig.appId;
             konyRef.mainRef.config = serviceDoc;
             /* if (!servConfig.baseId) {
              throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid baseId " + servConfig.baseId);
              } */
             konyRef.mainRef.baseId = servConfig.baseId;
             /* if (!servConfig.name) {
              throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid name " + servConfig.name);
              } */
             konyRef.mainRef.name = servConfig.name;
             if (servConfig.login) {
                 konyRef.login = servConfig.login;
             } else {
                 konyRef.login = [];
             }
             var url = servConfig.selflink;
             if (url) {
                 var lastPos = url.indexOf("/appconfig");
                 if (lastPos != -1) {
                     url = url.slice(0, lastPos);
                 } else {
                     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid self link");
                 }
                 var anonymousLoginProvider = {};
                 anonymousLoginProvider.type = "anonymous";
                 anonymousLoginProvider.url = url;
                 anonymousLoginProvider.prov = "$anonymousProvider";
                 konyRef.login.push(anonymousLoginProvider);
             }
             if (typeof(servConfig.integsvc) !== 'undefined') {
                 kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Integration services");
                 konyRef.integsvc = servConfig.integsvc;
                 kony.sdk.logsdk.debug("### init::_doInit::konyRef integration Services", konyRef.integsvc);
             }
             if (typeof(servConfig.services_meta) === 'object') {
                 kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Object services");
                 kony.sdk.util.populateIndividualServiceLists(servConfig, konyRef);
             }
             if (typeof(servConfig.messagingsvc) !== 'undefined') {
                 kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Messaging services");
                 konyRef.messagingsvc = servConfig.messagingsvc;
             }
             if (typeof(servConfig.logicsvc) !== 'undefined') {
                 kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Logic services");
                 konyRef.logicsvc = servConfig.logicsvc;
             }
             if (typeof(servConfig.sync) !== 'undefined') {
                 konyRef.sync = servConfig.sync;
             }
             if (servConfig.identity_features && servConfig.identity_features.reporting_params_header_allowed) {
                 kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Identity features");
                 konyRef.reportingheaders_allowed = servConfig.identity_features.reporting_params_header_allowed;
             }
             if (kony.sdk.isLicenseUrlAvailable) {
                 if (servConfig.reportingsvc && servConfig.reportingsvc.custom && servConfig.reportingsvc.session) {
                     konyRef.customReportingURL = servConfig.reportingsvc.custom;
                     konyRef.sessionReportingURL = servConfig.reportingsvc.session;
                     if (konyRef.sessionReportingURL && kony.logger.isNativeLoggerAvailable()) {
                         var lastIndex = konyRef.sessionReportingURL.lastIndexOf("/");
                         if (lastIndex !== -1) {
                             var networkUrl = konyRef.sessionReportingURL.substring(0, lastIndex + 1) + kony.logger.networkPersistorUrlEndpoint;
                             var networkPersistor = kony.logger.createNetworkPersistor();
                             networkPersistor.URL = networkUrl;
                             kony.logger.setPersistorConfig(networkPersistor);
                         }
                     }
                 } else {
                     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid url for reporting service");
                 }
             }
             if (konyRef.internalSdkObject) {
                 konyRef.internalSdkObject.initWithServiceDoc(appKey, appSecret, servConfig);
                 if (konyRef.internalSdkObject.setClientParams) {
                     if (appConfig) {
                         konyRef.internalSdkObject.setClientParams({
                             "aid": appConfig.appId,
                             "aname": appConfig.appName
                         });
                     } else {
                         konyRef.internalSdkObject.setClientParams(konyRef.getClientParams());
                     }
                 }
                 kony.sdk.logsdk.info("### init::internal sdk object initialized");
             }
             kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing service document done");
             kony.sdk.isInitialized = true;
             if (kony.sdk.metric && kony.os.deviceInfo().name === kony.sdk.constants.PLATFORM_SPA) {
                 kony.sdk.metric.flushEvents();
             }
             if (!kony.sdk.isNullOrUndefined(servConfig.reportingsvc)) {
                 kony.sdk.saveMetadatainDs(appKey, appSecret, unprocessedServiceDoc);
                 kony.sdk.setLicenseCall(appKey, appSecret, unprocessedServiceDoc);
             }
             if (kony.sdk.getPlatformName() === kony.sdk.constants.PLATFORM_ANDROID && (appConfig.isSSOEnabled === true || appConfig.isSSOEnabled === "true")) {
                 kony.sdk.util.initializeSSO();
             }
             var sdkType = kony.sdk.getSdkType();
             var type = kony.sdk.getAType();
             var platformName = kony.sdk.getPlatformName();
             if (sdkType == kony.sdk.constants.SDK_TYPE_IDE && ((type === kony.sdk.constants.SDK_ATYPE_NATIVE) || (type === kony.sdk.constants.SDK_ATYPE_SPA))) {
                 if ((!kony.sdk.isNullOrUndefined(konyRef.offlineObjectsvc)) && !(kony.sdk.isEmptyObject(konyRef.offlineObjectsvc))) {
                     konyRef.OfflineObjects = new kony.sdk.OfflineObjects(konyRef.offlineObjectsvc);
                 }
             }
             if (kony.license) {
                 if (kony.licensevar && kony.licensevar.changeHandlers && kony.licensevar.changeHandlers.length == 0 && kony.license.registerChangeListener) {
                     kony.license.registerChangeListener(konyRef.sessionChangeHandler);
                     konyRef.overrideUserIdFlag = true;
                 }
             }
             if (konyRef.mainRef.integrityKey === true) {
                 setIntegrityParams();
                 try {
                     if (!(kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_SPA || kony.sdk.getAType() === "watch")) {
                         //invoke NFI only for android,ios and FFI for windows 
                         kony.sdk.httpIntegrity.setIntegrityCheck(konyRef.mainRef.integrityParams);
                     }
                 } catch (e) {
                     kony.sdk.logsdk.warn("Invalid Integrity properties received");
                     throw new Exception(kony.sdk.errorConstants.INTEGRITY_FAILURE, "Invalid Integrity properties");
                 }
             } else {
                 resetIntegrityParams();
                 if (!(kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_SPA || kony.sdk.getAType() === "watch")) {
                     //invoke NFI only for android,ios and FFI for windows 
                     kony.sdk.httpIntegrity.removeIntegrityCheck();
                 }
             }
             return true;
         } catch (err) {
             kony.sdk.logsdk.error("### init::_doInit::_processServiceDoc failed with an exception: ", err);
             return ("processing the ServiceDoc failed with an exception: " + JSON.stringify(err));
         }
     }
 };
 kony.sdk.prototype.sessionChangeHandler = function(changes) {
     kony.sdk.logsdk.trace("Entering kony.sdk.prototype.sessionChangeHandler");
     var konyRef = kony.sdk.getCurrentInstance();
     konyRef.getMetricsService();
     var sessionId = null;
     var userId = null;
     if (changes["sessionId"] != undefined) {
         sessionId = changes["sessionId"];
         konyRef.setSessionId(sessionId);
         if (konyRef.internalSdkObject) {
             sessionId = sessionId + "," + kony.sdk.util.getSessionType();
         }
         if (konyRef.metricsServiceObject && konyRef.metricsServiceObject.setSessionId) {
             konyRef.metricsServiceObject.setSessionId(sessionId);
         }
     }
     if (changes["userId"] != undefined) {
         konyRef.overrideUserIdFlag = true;
         userId = changes["userId"];
         konyRef.setCurrentUserId(userId);
         if (konyRef.metricsServiceObject && konyRef.metricsServiceObject.setUserId) {
             konyRef.metricsServiceObject.setUserId(userId);
         }
     }
 };

 function setIntegrityParams() {
     var integrityParams = {
         "algo": kony.sdk.constants.HASHING_ALGORITHM,
         "headerName": kony.sdk.constants.INTEGRITY_HEADER,
         "validateResp": true
     };
     if (!kony.sdk.isNullOrUndefined(konyRef.integrityCustomSecurityKey)) {
         integrityParams["salt"] = konyRef.integrityCustomSecurityKey;
     } else {
         integrityParams["salt"] = konyRef.mainRef.appSecret;
     }
     konyRef.mainRef.integrityKey = true;
     konyRef.mainRef.integrityParams = integrityParams;
 }

 function resetIntegrityParams() {
     konyRef.mainRef.integrityKey = false;
     konyRef.mainRef.integrityParams = {};
 }
 /**
  * MFSDK
  * Created by KH1969 on 18-01-2018.
  * Copyright  2018 Kony. All rights reserved.
  */
 /**
  * Constructor for ClientCache service, uses lruCache.js internally to save key, value pairs.
  * This is a singleton class, object gets created for the first time of instantiation and the same object is
  * returned for next initializations.
  *
  * @param size {Number} Maximum size of the cache. It should be non zero positive number.
  * @return {kony.sdk.ClientCache}
  *
  */
 kony.sdk.ClientCache = function(size) {
         if (typeof kony.sdk.ClientCache.instance === 'object') return kony.sdk.ClientCache.instance;
         var lruCacheObj = null;
         if (size === undefined || size === null) lruCacheObj = new lruCache(kony.sdk.constants.DEFAULT_CACHE_SIZE);
         else if (typeof size != 'number' || size <= 0) {
             kony.sdk.logsdk.warn("cache cannot be created of size <= 0");
             return null;
         } else lruCacheObj = new lruCache(size);
         /**
          * Gets the response cached for the key. Returns null if not found.
          * @param key {string}
          * @return {null|object}
          */
         this.get = function(key) {
                 return lruCacheObj.get(key);
             }
             /**
              * Gets the boolean assertion for key existence in the cache.
              * @param key {string}
              * @return {boolean}
              */
         this.has = function(key) {
                 return lruCacheObj.has(key);
             }
             /**
              * Adds the key, value pair to cache.
              * @param key {string}
              * @param value {string}
              * @param expiryTime {number} Expiry time in seconds.
              */
         this.add = function(key, value, expiryTime) {
                 lruCacheObj.add(key, value, expiryTime);
             }
             /**
              * Removes the key, value from cache.
              * @param key {string}
              */
         this.remove = function(key) {
             lruCacheObj.remove(key);
         }
         kony.sdk.ClientCache.instance = this;
     }
     /**
      * MFSDK
      * Created by KH1969 on 18-01-2018.
      * Copyright  2018 Kony. All rights reserved.
      */
     /**
      * Constructor for standalone LRU page replacement implementation.
      * Implementation is done using a double linked list data structure and a hashmap.
      * Upon every insert & get the head gets updated to the newest element.
      * Cached nodes gets removed if size is more than the requested capacity.
      * Default cache size is 100.
      *
      * Should not be called by the developer.
      *
      *  Below is the list structure if elements are inserted in the order A, B, C & D

      *  Head = D, Tail = A
      *  D--(older)-->C--(older)-->B--(older)-->A--(older)-->NULL
      *  NULL<--(newer)--D<--(newer)--C<--(newer)--B<--(newer)--A
      *
      *  Now if B is accessed the list structure will be modified as,
      *  Head = B, Tail = A
      *
      *  B--(older)-->D--(older)-->C--(older)-->A--(older)-->NULL
      *  NULL<--(newer)--B<--(newer)--D<--(newer)--C<--(newer)--A
      */
 lruCache = function(size) {
         var LOG_PREFIX = "SDK_CACHE ";
         if (size === undefined || size === null) this.capacity = kony.sdk.constants.DEFAULT_CACHE_SIZE;
         else if (typeof size != 'number' || size <= 0) {
             kony.sdk.logsdk.warn("cache cannot be created of size <= 0");
             return null;
         } else this.capacity = size;
         this.length = 0;
         this.map = {};
         // save the head and tail so we can update it easily
         this.head = null;
         this.tail = null;
         /**
          * Gets the current time in seconds.
          * @returns {number}
          */
         function getCurrentTimeInSeconds() {
             return Math.floor(new Date().getTime() / 1000);
         }
         /**
          * Double linked list data structure.
          * @param key
          * @param value
          */
         function cacheNode(key, value, expiry) {
             this.key = key;
             this.val = value;
             this.newer = null; // Next newer node
             this.older = null; // Previous older node
             this.expiryTime = 0;
             if (expiry !== undefined && typeof expiry === 'number' && expiry != 0) {
                 this.expiryTime = getCurrentTimeInSeconds() + expiry;
             }
         }
         /**
          * Shuffles the cache by last recently used.
          * @param key
          */
         function shuffleLRUCache(key) {
             var node = this.map[key];
             if (this.head === node) {
                 // No need to shuffle the cache, as the head itself is the recently accessed node.
                 return;
             }
             // Head will not have newer node.
             if (node.newer) {
                 node.newer.older = node.older;
             } else {
                 this.head = node.older;
             }
             // Tail will not have older node.
             if (node.older) {
                 node.older.newer = node.newer;
             } else {
                 this.tail = node.newer;
             }
             // Now node is detached. Place it at head.
             // Updates are done in this way
             // 1: node--(older)-->head
             // 2: null<--(newer)--node
             // 3: node<--(newer)--head
             // 4: node is assigned to head. So current head got updated to node.
             node.older = this.head;
             node.newer = null;
             if (this.head) {
                 this.head.newer = node;
             }
             this.head = node;
         }
         /**
          * Returns the current size of the cache.
          * @returns {number}
          */
         this.getSize = function() {
                 return this.length;
             }
             /**
              * Adds the key value pair to the cache.
              * Key gets removed upon expiry, expiry time is calculated by currentTimeInSeconds + expiryTime.
              * If no expiryTime is specified then key will not expire.
              * @param key {String}
              * @param value {Object}
              * @param expiryTime {Number}
              */
         this.add = function(key, value, expiryTime) {
                 if (key === undefined || value === undefined || key === null || value === null) return;
                 // update the value for existing entries
                 if (this.has(key)) {
                     this.map[key].val = value;
                     kony.sdk.logsdk.debug(LOG_PREFIX + "Key: " + key + " updated");
                     shuffleLRUCache.call(this, key);
                     return;
                 }
                 if (this.length >= this.capacity) {
                     // remove the least recently used item
                     this.remove(this.tail.key)
                 }
                 var node = new cacheNode(key, value, expiryTime);
                 // Additions are done in this way
                 // 1: node--(older)-->head
                 // 2: node<--(newer)--head
                 // 3: node is assigned to head. So current head got updated to node.
                 // 4: tail = node, if there is no tail node then current node is tail node. This happens only for the first add.
                 node.older = this.head;
                 // if have head, we need re-connect node with other nodes older than head
                 if (this.head) {
                     this.head.newer = node;
                 }
                 this.head = node;
                 // if no tail which means first insert, set the tail to node too
                 if (!this.tail) {
                     this.tail = node;
                 }
                 this.map[key] = node;
                 this.length++;
                 kony.sdk.logsdk.debug(LOG_PREFIX + "Key: " + key + " added");
             }
             /**
              * Gets the cached node by key. Returns null if key is not found.
              * The key is removed if it is expired, returns null here as well.
              * @param key {String}
              * @returns {Object}
              */
         this.get = function(key) {
                 if (this.has(key)) {
                     if (this.map[key].expiryTime != 0 && getCurrentTimeInSeconds() > this.map[key].expiryTime) {
                         this.remove(key);
                         kony.sdk.logsdk.debug(LOG_PREFIX + "Key: " + key + " expired");
                         return null;
                     }
                     shuffleLRUCache.call(this, key);
                     return this.map[key].val;
                 } else {
                     return null;
                 }
             }
             /**
              * Removes the key, value from the cache by key.
              * @param key {String} Key to delete from the cache
              */
         this.remove = function(key) {
                 if (this.has(key)) {
                     var node = this.map[key];
                     // Head node will not have newer node.
                     if (node.newer) {
                         node.newer.older = node.older;
                     } else {
                         this.head = node.older;
                     }
                     // Tail node will not have older node.
                     if (node.older) {
                         node.older.newer = node.newer;
                     } else {
                         this.tail = node.newer;
                     }
                     delete this.map[key];
                     node = null;
                     this.length--;
                 }
             }
             /**
              * Clears the cache.
              */
         this.clear = function() {
                 this.map = {};
                 this.length = 0;
             }
             /**
              * Check if key exists.
              * @param key {string} Key to be found in the cache
              * @returns {boolean}
              */
         this.has = function(key) {
                 return this.map.hasOwnProperty(key);
             }
             /**
              * Updates the cache size.
              * @param size {number}
              */
         this.setMaxCacheSize = function(size) {
             //    Todo: If requested size < capacity remove the last (N - size) nodes from tail.
             kony.sdk.logsdk.debug(LOG_PREFIX + "updating cache size from " + this.capacity + " to " + size);
             this.capacity = size;
         }
     }
     /**
      * Method to create the configuration service instance
      * @returns {ConfigurationService} Configuration service instance
      */
 kony.sdk.prototype.getConfigurationService = function() {
     kony.sdk.logsdk.trace("Entering kony.sdk.prototype.getConfigurationService")
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Configuration service.");
     }
     var configObj = new ConfigurationService(this);
     if (configObj) {
         return configObj;
     } else {
         throw new Exception(kony.sdk.errorConstants.CONFIGURATION_FAILURE, "Error in creating configuration object");
     }
 };
 /**
  * Should not be called by the developer.
  * @class
  * @classdesc Configuration service instance for fetching client app properties.
  */
 function ConfigurationService(konyRef) {
     var istUrl = konyRef.mainRef.config.reportingsvc.session.split("/IST")[0];
     kony.sdk.logsdk.debug("IST url fetched from service doc is :" + istUrl);
     var configUrl = istUrl + kony.sdk.constants.GET_CLIENT_PROPERTY_URL;
     kony.sdk.logsdk.debug("Configuration url formed is :" + configUrl);
     var networkProvider = new konyNetworkProvider();
     /**
      * Configuration svc method to get all the client app properties which is configured in admin console.
      * @successCallback this is called on successfull retrieval of properties
      * @failureCallback this is called on failure in retrieving properties
      * @returns {json} key value pair of all client app properties
      */
     this.getAllClientAppProperties = function(successCallback, failureCallback) {
         function fetchClientPropertiesHandler() {
             _getAllClientAppProperties(successCallback, failureCallback);
         }
         kony.sdk.claimsRefresh(fetchClientPropertiesHandler, failureCallback);
     };

     function _getAllClientAppProperties(successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering into _getAllClientAppProperties");
         var defaultHeaders = {};
         var token = konyRef.currentClaimToken;
         if (!token) {
             token = kony.sdk.getCurrentInstance().currentClaimToken;
         }
         defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = token;
         var options = {};
         options["disableIntegrity"] = true;
         networkProvider.get(configUrl, null, defaultHeaders, function(res) {
             kony.sdk.logsdk.trace("Entering Configuration service network success");
             kony.sdk.logsdk.debug("response from server for client properties is :" + JSON.stringify(res));
             var tempArray = ["httpresponse", kony.sdk.constants.MF_OPSTATUS];
             var tempJSON = {};
             for (var key in res) {
                 if (tempArray.indexOf(key.toLowerCase()) > -1) {
                     continue;
                 }
                 tempJSON[key] = res[key];
             }
             kony.sdk.verifyAndCallClosure(successCallback, tempJSON);
         }, function(xhr, status, err) {
             kony.sdk.logsdk.trace("Entering Configuration service network error");
             if (xhr && !(status && err)) {
                 err = xhr;
             }
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getObjectServiceErrObj(err));
         }, null, options);
     }
 }
 kony.sdk.constants = {
     /**Logger Constants**/
     LOGGER_NAME: "MFSDK",
     SYNC_LOGGER_NAME: "SYNCV1",
     APP_LOGGER_NAME: "KonyLogger",
     /**Network constants**/
     LAUNCHMODE_DEEPLINK: 3,
     DEEPLINK_VALID_PARAM: "code",
     HASHING_ALGORITHM: "SHA256",
     REMOVE_INTEGRITY_CHECK: "removeIntegrityCheck",
     SET_INTEGRITY_CHECK: "setIntegrityCheck",
     DEFAULT_CACHE_SIZE: 100,
     GET_CLIENT_PROPERTY_URL: "/metadata/configurations/client/properties",
     DEFAULT_CACHE_EXPIRY_TIME: 0, //Which means it doesn't expire in the application session.
     /**Service ID's for Identity Calls**/
     GET_BACKEND_TOKEN: "getBackendToken",
     GET_SECURITY_ATTRIBUTES: "getSecurityAttributes",
     GET_USER_ATTRIBUTES: "getUserAttributes",
     GET_USER_DATA: "getUserData",
     GET_PROFILE: "getProfile",
     /** Identity Options**/
     OAUTH_REDIRECT_SUCCESS_URL: "success_url",
     //OAuth for IE11 Workaround Constants, MFSDK-3657
     IE11_CROSS_DOMAIN_OAUTH_BASE_URL: "IE11CrossDomainOAuthBaseUrl",
     KNY_OAUTH_REDIRECT_HTML: "KNYOAuthRedirect.html",
     KNY_OAUTH_CALLBACK_HTML: "KNYOAuthCallback.html",
     KNY_OAUTH_REDIRECT_URL: "kny_oauth_redirect_url",
     /**HttpMethods and header constants**/
     HTTP_METHOD_GET: "GET",
     HTTP_METHOD_POST: "POST",
     HTTP_METHOD_DELETE: "DELETE",
     HTTP_CONTENT_HEADER: "Content-Type",
     HTTP_REQUEST_HEADER_ACCEPT: "Accept",
     /**Content Type Value Constants**/
     CONTENT_TYPE_FORM_URL_ENCODED: "application/x-www-form-urlencoded",
     CONTENT_TYPE_JSON: "application/json",
     //Added a new content-type based on the bug MFSDK-4096
     CONTENT_TYPE_JSON_CHARSET_UTF8: "application/json;charset=utf-8",
     CONTENT_TYPE_OCTET_STREAM: "application/octet-stream",
     CONTENT_TYPE_TEXT_HTML: "text/html",
     CONTENT_TYPE_TEXT_PLAIN: "text/plain",
     /**SDK Plugin Type**/
     SDK_TYPE_IDE: "js",
     SDK_TYPE_PHONEGAP: "phonegap",
     SDK_TYPE_PLAIN_JS: "plain-js",
     /**APP Session Type**/
     APP_SESSION_INTERACTIVE: "I",
     APP_SESSION_NON_INTERACTIVE: "NI",
     /**SDK Architecture Type**/
     SDK_ATYPE_NATIVE: "native",
     SDK_ATYPE_SPA: "spa",
     /**Device platform**/
     PLATFORM_WINDOWS: "windows",
     PLATFORM_ANDROID: "android",
     PLATFORM_IOS: "ios",
     //kony.os.device.info() for SPA returns thinclient
     PLATFORM_SPA: "thinclient",
     /***Metrics Constants**/
     REPORTING_PARAMS: "konyreportingparams",
     KEY_DEVICE_ID: "deviceID",
     /**Headers**/
     APP_KEY_HEADER: "X-Kony-App-Key",
     APP_SECRET_HEADER: "X-Kony-App-Secret",
     KONY_AUTHORIZATION_HEADER: "X-Kony-Authorization",
     AUTHORIZATION_HEADER: "Authorization",
     REPORTING_HEADER: "X-Kony-ReportingParams",
     INTEGRITY_HEADER: "X-Kony-Integrity",
     DEVICEID_HEADER: "X-Kony-DeviceId",
     API_VERSION_HEADER: "X-Kony-API-Version",
     APP_VERSION_HEADER: "X-Kony-App-Version",
     SDK_TYPE_HEADER: "X-Kony-SDK-Type",
     SDK_VERSION_HEADER: "X-Kony-SDK-Version",
     PLATFORM_TYPE_HEADER: "X-Kony-Platform-Type",
     HTTP_OVERRIDE_HEADER: "X-HTTP-Method-Override",
     /**Mobilefabric constants**/
     HTTP_STATUS_CODE: "httpStatusCode",
     MF_OPSTATUS: "opstatus",
     MF_CODE: "mfcode",
     MF_ERROR_MSG: "errmsg",
     MF_ERROR_CODE: "errcode",
     MF_SERVICE: "service",
     /**Engagement service API constants**/
     SUBSCRIBE_AUDIENCE: "/subscribeaudience",
     BEACON_UPDATE: "/beaconupdate",
     RICH_PUSH_MESSAGE: "/messages/rich/",
     LAST_ACTIVE_DATE: "lastActiveDate",
     KSID: "ksid",
     AUTH_TOKEN: "authToken",
     DEVICE_AUTHTOKEN_HEADER: "X-Device-AuthToken",
     /**Parsed Template Constants**/
     PROCESSED_TEMPLATE: "processedTemplate",
     MISSING_VARIABLES: "missingVariables",
     /**Mandatory Binary Params**/
     FILE_PATH: "FilePath",
     RAW_BYTES: "rawBytes",
     FILE_OBJECT: "fileObject",
     FILE_NAME: "fileName",
     /**Miscellaneous**/
     SSO_TOKEN_KEY: "ssoTokenKey",
     KONYUUID: "konyUUID",
     BROWSER_WIDGET: "browserWidget",
     INIT_FAILURE_MESSAGE: "SDK is not initialized, call init before invoking any operation on",
     DISABLE_INTEGRITY: "disableIntegrity",
     PASSTHROUGH: "passthrough",
     BINARY_DATATYPE: "binary",
     JSON_DATA: "jsondata",
     /** License Constants **/
     LICENSE_SESSION_TIMEOUT_IN_MILLIS: 14400000,
     LICENSE_BG_TO_FG_SESSION_TIMEOUT_IN_MILLIS: 1800000
 };
 if (typeof(kony.sdk) === "undefined") {
     kony.sdk = {};
 }
 if (typeof(kony.sdk.error) === "undefined") {
     kony.sdk.error = {};
 }
 kony.sdk.error.getAuthErrObj = function(errResponse) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getAuthErrObj");
     if (errResponse && errResponse.httpresponse) {
         delete errResponse.httpresponse;
     }
     if (errResponse && errResponse[kony.sdk.constants.MF_ERROR_MSG]) {
         errResponse["message"] = errResponse[kony.sdk.constants.MF_ERROR_MSG];
         delete errResponse.errmsg;
     }
     try {
         var mfcode = errResponse[kony.sdk.constants.MF_CODE];
         var message = errResponse["message"];
         var details = errResponse["details"];
         if (mfcode) {
             return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, "");
         }
         return errResponse;
     } catch (err) {
         return errResponse;
     }
 }
 kony.sdk.error.getNullClaimsTokenErrObj = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getNullClaimsTokenErrObj");
     var errorObj = {};
     errorObj.opstatus = kony.sdk.errorcodes.cliams_token_null
     errorObj.message = kony.sdk.errormessages.cliams_token_null
     errorObj.details = {};
     errorObj.mfcode = "";
     return errorObj;
 }
 kony.sdk.error.getIdentitySessionInactiveErrObj = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getIdentitySessionInactiveErrObj");
     var errorObj = {};
     errorObj.opstatus = kony.sdk.errorcodes.identity_session_inactive
     errorObj.message = kony.sdk.errormessages.identity_session_inactive
     errorObj.details = {};
     errorObj.mfcode = "";
     return errorObj;
 }
 kony.sdk.error.getNullRefreshTokenErrObj = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getNullRefreshTokenErrObj");
     var errorObj = {};
     errorObj.opstatus = kony.sdk.errorcodes.invalid_session_or_token_expiry
     errorObj.message = kony.sdk.errormessages.invalid_session_or_token_expiry
     errorObj.details = {};
     errorObj.mfcode = "";
     return errorObj;
 }
 kony.sdk.error.getIntegrationErrObj = function(errResponse) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getIntegrationErrObj");
     try {
         var mfcode = errResponse[kony.sdk.constants.MF_CODE];
         var message = errResponse[kony.sdk.constants.MF_ERROR_MSG];
         var details = errResponse["mferrmsg"];
         var service = errResponse[kony.sdk.constants.MF_SERVICE];
         if (!service) {
             service = "";
         }
         if (!details) {
             details = "";
         }
         var errorMessagePrefixForIntegration = "";
         if (service) {
             errorMessagePrefixForIntegration = "Integration Service Request Failed for " + service + ":";
         } else {
             errorMessagePrefixForIntegration = "Integration Service Request Failed:";
         }
         if (mfcode) {
             return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, errorMessagePrefixForIntegration);
         }
         return errResponse;
     } catch (err) {
         return errResponse;
     }
 }
 kony.sdk.error.getLogicErrObj = function(errResponse) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getLogicErrObj");
     try {
         var mfcode = errResponse[kony.sdk.constants.MF_CODE];
         var message = errResponse[kony.sdk.constants.MF_ERROR_MSG];
         var details = errResponse["mferrmsg"];
         var service = errResponse[kony.sdk.constants.MF_SERVICE];
         if (!service) {
             service = "";
         }
         if (!details) {
             details = "";
         }
         var errorMessagePrefixForLogic = "";
         if (service) {
             errorMessagePrefixForLogic = "Logic Service Request Failed for " + service + ":";
         } else {
             errorMessagePrefixForLogic = "Logic Service Request Failed:";
         }
         if (mfcode) {
             return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, errorMessagePrefixForLogic);
         }
         return errResponse;
     } catch (err) {
         return errResponse;
     }
 }
 kony.sdk.error.getMFcodeErrObj = function(mfcode, message, details, errMessagePrefix) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getMFcodeErrObj");
     var errorObj = {};
     errorObj.details = {};
     if (details) {
         errorObj.details = details;
     }
     errorObj.mfcode = mfcode;
     if (mfcode === "Auth-4") {
         if (!message) {
             message = kony.sdk.errormessages.invalid_user_credentials
         }
         errorObj.opstatus = kony.sdk.errorcodes.invalid_user_credentials
         errorObj.message = errMessagePrefix + message;
     } else if (mfcode === "Auth-9") {
         if (!message) {
             message = kony.sdk.errormessages.invalid_app_credentials
         }
         errorObj.opstatus = kony.sdk.errorcodes.invalid_app_credentials
         errorObj.message = errMessagePrefix + message;
     } else if (mfcode === "Auth-3") {
         if (!message) {
             message = kony.sdk.errormessages.invalid_user_app_credentials
         }
         errorObj.opstatus = kony.sdk.errorcodes.invalid_user_app_credentials
         errorObj.message = errMessagePrefix + message;
     } else if ((mfcode === "Auth-5") || (mfcode === "Auth-6") || (mfcode === "Gateway-31") || (mfcode === "Gateway-33") || (mfcode === "Gateway-35") || (mfcode === "Gateway-36") || (mfcode === "Auth-46") || (mfcode === "Auth-55")) {
         errorObj.opstatus = kony.sdk.errorcodes.invalid_session_or_token_expiry
         errorObj.message = errMessagePrefix + kony.sdk.errormessages.invalid_session_or_token_expiry
     } else if (mfcode === "Auth-7" || mfcode === "Auth-27") {
         if (!message) {
             message = errMessagePrefix + kony.sdk.errormessages.invalid_user_app_services
         }
         errorObj.opstatus = kony.sdk.errorcodes.invalid_user_app_services
         errorObj.message = message;
     } else {
         errorObj.opstatus = kony.sdk.errorcodes.default_code
         errorObj.message = errMessagePrefix + kony.sdk.errormessages.default_message
     }
     return errorObj;
 }

 function getAuthErrorMessage(mfcode) {
     kony.sdk.logsdk.trace("Entering into getAuthErrorMessage");
     if (mfcode === "Auth-4") {
         return kony.sdk.errormessages.invalid_user_credentials
     } else if (mfcode === "Auth-9") {
         return kony.sdk.errormessages.invalid_app_credentials
     } else if (mfcode === "Auth-3") {
         return kony.sdk.errormessages.invalid_user_app_credentials
     } else if ((mfcode === "Auth-5") || (mfcode === "Auth-6") || (mfcode === "Gateway-31") || (mfcode === "Gateway-33") || (mfcode === "Gateway-35") || (mfcode === "Gateway-36") || (mfcode === "Auth-46") || (mfcode === "Auth-55")) {
         return kony.sdk.errormessages.invalid_session_or_token_expiry
     } else if (mfcode === "Auth-7" || mfcode === "Auth-27") {
         return kony.sdk.errormessages.invalid_user_app_services
     } else {
         return mfcode + ":" + kony.sdk.errormessages.default_message
     }
 }
 kony.sdk.error.getObjectServiceErrObj = function(errResponse) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getObjectServiceErrObj");
     try {
         var mfcode = errResponse[kony.sdk.constants.MF_CODE];
         var message = errResponse[kony.sdk.constants.MF_ERROR_MSG];
         var details = errResponse["mferrmsg"];
         var service = errResponse[kony.sdk.constants.MF_SERVICE];
         if (!service) {
             service = "";
         }
         if (!details) {
             details = "";
         }
         var errorMessagePrefixForIntegration = "";
         if (service) {
             errorMessagePrefixForIntegration = "Object Service Request Failed for " + service + ":";
         } else {
             errorMessagePrefixForIntegration = "Object Service Request Failed:";
         }
         if (mfcode) {
             return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, errorMessagePrefixForIntegration);
         }
         return errResponse;
     } catch (err) {
         return errResponse;
     }
 }
 kony.sdk.error.getClientErrObj = function(errCode, errMsg) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getClientErrObj");
     var errObj = new Object();
     errObj.opstatus = kony.sdk.errorcodes.clientvalidation_error_opstatus;
     errObj.errmsg = errMsg;
     errObj.errcode = errCode;
     return errObj;
 }
 kony.sdk.error.getMessagingError = function(errMsg) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getMessagingError");
     var errObj = new Object();
     errObj.opstatus = kony.sdk.errorcodes.messaging_service_fail;
     errObj.errmsg = kony.sdk.errormessages.messaging_service_fail + errMsg;
     errObj.errcode = kony.sdk.errorcodes.messaging_service_fail;
     return errObj;
 }
 kony.sdk.error.getConfigServiceErrObject = function(errResponse) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getConfigServiceErrObject");
     try {
         var mfcode = errResponse[kony.sdk.constants.MF_CODE];
         var message = errResponse[kony.sdk.constants.MF_ERROR_MSG];
         var details = errResponse["mferrmsg"];
         var service = errResponse[kony.sdk.constants.MF_SERVICE];
         if (!service) {
             service = "";
         }
         if (!details) {
             details = "";
         }
         var errorMessagePrefixForIntegration = "";
         if (service) {
             errorMessagePrefixForIntegration = "Configuration Service Request Failed for " + service + ":";
         } else {
             errorMessagePrefixForIntegration = "Configuration Service Request Failed:";
         }
         if (mfcode) {
             return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, errorMessagePrefixForIntegration);
         }
         return errResponse;
     } catch (err) {
         return errResponse;
     }
 };
 kony.sdk.error.getIntegrityErrorMessage = function(httpRequest, url) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getIntegrityErrorMessage");
     var errorMessage = {};
     errorMessage.httpresponse = {};
     errorMessage[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.integrity_check_failed;
     errorMessage[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.integrity_check_failed;
     errorMessage[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.integrity_check_failed;
     errorMessage[kony.sdk.constants.HTTP_STATUS_CODE] = httpRequest.status.toString();
     errorMessage.httpresponse["response"] = httpRequest.response;
     errorMessage.httpresponse.headers = httpRequest.getAllResponseHeaders();
     errorMessage.httpresponse.url = url;
     errorMessage.httpresponse.responsecode = httpRequest.status.toString();
     return errorMessage;
 };
 kony.sdk.error.getOperationFailedErrorMessage = function(httpRequest, url) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getOperationFailedErrorMessage");
     var errorMessage = {};
     errorMessage[kony.sdk.constants.MF_OPSTATUS] = httpRequest.response.opstatus;
     errorMessage[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.server_operation_failed;
     errorMessage[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.server_operation_failed;
     errorMessage[kony.sdk.constants.HTTP_STATUS_CODE] = httpRequest.status.toString();
     var httpResponse = {};
     httpResponse.response = httpRequest.response;
     httpResponse.headers = httpRequest.getAllResponseHeaders();
     httpResponse.responsecode = httpRequest.status.toString();
     httpResponse.url = url;
     errorMessage.httpResponse = httpResponse;
     return errorMessage;
 };
 if (typeof(kony.sdk) === "undefined") {
     kony.sdk = {};
 }
 if (typeof(kony.sdk.errorcodes) === "undefined") {
     kony.sdk.errorcodes = {};
 }
 if (typeof(kony.sdk.errormessages) === "undefined") {
     kony.sdk.errormessages = {};
 }
 kony.sdk.errorcodes.invalid_user_credentials = 101;
 kony.sdk.errormessages.invalid_user_credentials = "Invalid User Credentials.";
 kony.sdk.errorcodes.invalid_app_credentials = 102;
 kony.sdk.errormessages.invalid_app_credentials = "Invalid App Credentials.";
 kony.sdk.errorcodes.invalid_user_app_credentials = 103;
 kony.sdk.errormessages.invalid_user_app_credentials = "Invalid User/App Credentials.";
 kony.sdk.errorcodes.invalid_session_or_token_expiry = 104;
 kony.sdk.errormessages.invalid_session_or_token_expiry = "Session/Token got invalidated in the backend.Please login.";
 kony.sdk.errorcodes.invalid_user_app_services = 105;
 kony.sdk.errormessages.invalid_user_app_services = "Invalid provider in appServices.";
 kony.sdk.errorcodes.cliams_token_null = 106;
 kony.sdk.errormessages.cliams_token_null = "Claims Token is Unavialable";
 kony.sdk.errorcodes.identity_session_inactive = 107;
 kony.sdk.errormessages.identity_session_inactive = "Identity Provider's sessions is not active. Please login";
 kony.sdk.errorcodes.default_code = 100;
 kony.sdk.errormessages.default_message = "UnhandledMFcode";
 kony.sdk.errorcodes.unknown_error_code = 1000;
 kony.sdk.errormessages.unknown_error_message = "An unknown error has occured";
 kony.sdk.errorcodes.connectivity_error_code = 1011;
 kony.sdk.errormessages.connectivity_error_message = "An error occurred while making the request. Please check device connectivity, server url and request parameters";
 kony.sdk.errorcodes.invalid_json_code = 1013;
 kony.sdk.errormessages.invalid_json_message = "Invalid Json response was returned";
 kony.sdk.errorcodes.request_timed_out_code = 1014;
 kony.sdk.errormessages.request_timed_out_message = "Request to server has timed out";
 kony.sdk.errorcodes.offline_auth_failed = 1015;
 kony.sdk.errormessages.offline_auth_failed = "Offline Authentication failed, User should atleast login once when network connectivity is available.";
 kony.sdk.errorcodes.servicedoc_unavailable = 1016;
 kony.sdk.errormessages.servicedoc_unavailable = "MBAAS app is not initialized properly. Service document is unavailable.";
 kony.sdk.errorcodes.transient_login_fail = 1017;
 kony.sdk.errormessages.transient_login_fail = "Transient Login failed, Previous Identity Token expired in backend.";
 kony.sdk.errorcodes.messaging_service_fail = 1018;
 kony.sdk.errormessages.messaging_service_fail = "Failure in Messaging Service. ";
 kony.sdk.errorcodes.integrity_check_failed = 1019;
 kony.sdk.errormessages.integrity_check_failed = "Http message Body Integrity Check failed.";
 kony.sdk.errorcodes.invalid_security_key = 1023;
 kony.sdk.errormessages.invalid_security_key = "Security key should be a non empty string.";
 kony.sdk.errorcodes.server_operation_failed = 1020;
 kony.sdk.errormessages.server_operation_failed = "Operation Failed on server";
 kony.sdk.errorcodes.populating_template_failed = 1021;
 kony.sdk.errormessages.populating_template_failed = "Template population failed, template parameters are invalid or template is malformed";
 kony.sdk.errorcodes.service_unavailable = 1022;
 kony.sdk.errormessages.service_unavailable_message = "Service unavailable or cannot connect to host";
 kony.sdk.errorcodes.clientvalidation_error_opstatus = 112233;
 //Invaild API's for phonegap and plain-js
 kony.sdk.errorcodes.invalid_api = 7000;
 kony.sdk.errormessages.invalid_api = "Invalid Operation name, Operation Failed.";
 //Object Service Error Messages
 kony.sdk.errorcodes.invalid_dataobject_instance = 90001;
 kony.sdk.errormessages.invalid_dataobject_instance = "Provided dataobject is invalid and should be instance of kony.sdk.dto.DataObject";
 kony.sdk.errorcodes.primarykey_unavailable = 90002;
 kony.sdk.errormessages.primarykey_unavailable = "Primary Keys missing, Operation Failed";
 kony.sdk.errorcodes.null_or_undefined = 90003;
 kony.sdk.errormessages.null_or_undefined = " cannot be null or undefined";
 kony.sdk.errorcodes.transaction_failed = 90004;
 kony.sdk.errormessages.transaction_failed = "Some error occurred, Operation Failed";
 kony.sdk.errorcodes.norecords_to_delete = 90005;
 kony.sdk.errormessages.norecords_to_delete = "No records deleted with the specified criteria";
 kony.sdk.errorcodes.invalid_queryparams_instance = 90006;
 kony.sdk.errormessages.invalid_queryparams_instance = "Provided queryParams is invalid and should be a json object";
 kony.sdk.errorcodes.invalid_params_instance = 90007;
 kony.sdk.errormessages.invalid_params_instance = "Provided params are invalid";
 kony.sdk.errorcodes.invalid_object = 90008;
 kony.sdk.errormessages.invalid_object = "Invalid object name, Operation Failed.";
 kony.sdk.errorcodes.invalid_blob = 90009;
 kony.sdk.errormessages.invalid_blob = "Failed to read from binary file, either the file does not exist or invalid";
 kony.sdk.errorConstants = {
     INIT_FAILURE: "INIT_FAILURE",
     DATA_STORE_EXCEPTION: "DATASTORE_FAILURE",
     AUTH_FAILURE: "AUTH_FAILURE",
     INTEGRATION_FAILURE: "INTEGRATION_FAILURE",
     MESSAGING_FAILURE: "MESSAGING_FAILURE",
     SYNC_FAILURE: "SYNC_FAILURE",
     METRICS_FAILURE: "METRICS_FAILURE",
     MISC_FAILURE: "MISCELLANEOUS_FAILURE",
     OBJECT_FAILURE: "OBJECT_FAILURE",
     LOGIC_SERVICE_FAILURE: "LOGIC_SERVICE_FAILURE",
     SYNC_V2_FAILURE: "SYNC_V2_FAILURE",
     CONFIGURATION_URL_FAILURE: "CONFIGURATION_URL_FAILURE",
     CONFIGURATION_FAILURE: "CONFIGURATION_FAILURE",
     INTEGRITY_FAILURE: "INTEGRITY_FAILURE",
     INVALID_API_FAILURE: "INVALID_API_FAILURE"
 };
 /**
  * Method to create the Identity service instance with the provided provider name.
  * @param {string} providerName - Name of the provider
  * @returns {IdentityService} Identity service instance
  */
 kony.sdk.offline = kony.sdk.offline || {};
 kony.sdk.sso = kony.sdk.sso || {};
 kony.sdk.isSSOLoginSuccess = kony.sdk.isSSOLoginSuccess || true;
 kony.sdk.prototype.getIdentityService = function(providerName) {
     kony.sdk.logsdk.trace("Entering kony.sdk.prototype.getIdentityService");
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Identity service.");
     }
     var provider = null;
     if (providerName) {
         if (this.login != null) {
             for (var i = 0; i < this.login.length; i++) {
                 var rec = this.login[i];
                 if ((rec.alias && rec.alias.toUpperCase() === providerName.toUpperCase()) || (rec.prov.toUpperCase() === providerName.toUpperCase())) {
                     provider = new IdentityService(this, rec);
                     break;
                 }
             }
             if (provider === null) {
                 throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Invalid providerName");
             }
             //TODO: what if the providerName is not passed by the user? 
             kony.sdk.logsdk.debug("### auth:: returning authService for providerName = " + provider.getProviderName());
             return provider;
         }
     } else {
         throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Invalid providerName");
     }
 };
 /**
  * Should not be called by the developer.
  * @class
  * @classdesc Identity service instance for handling login/logout calls.
  */
 function IdentityService(konyRef, rec) {
     kony.sdk.logsdk.trace("Entering IdentityService");
     var networkProvider = new konyNetworkProvider();
     var dataStore = new konyDataStore();
     var serviceObj = rec;
     konyRef.rec = rec;
     var mainRef = konyRef.mainRef;
     var user_attributes = {};
     var offlineEnabled = false;
     var persistToken = false;
     if (serviceObj === undefined || serviceObj.prov == undefined || serviceObj.type == undefined) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "Invalid service url and service type");
     }
     var _type = serviceObj.type;
     var _serviceUrl = stripTrailingCharacter(serviceObj.url, "/");
     var _providerName = serviceObj.prov;
     kony.sdk.logsdk.debug("### AuthService:: initialized for provider " + _providerName + " with type " + _type);

     function isLoggedIn() {
         if (kony.sdk.getCurrentInstance() && kony.sdk.getCurrentInstance().tokens && kony.sdk.getCurrentInstance().tokens.hasOwnProperty(_providerName) && !kony.sdk.isNullOrUndefined(kony.sdk.getCurrentInstance().tokens[_providerName]) && Object.keys(kony.sdk.getCurrentInstance().tokens[_providerName]).length !== 0) {
             return true;
         }
         return false;
     }
     var dsKey = _serviceUrl + "::" + _providerName + "::" + _type + "::RAW";

     function resetAllCurrentTokens(konyRef, _providerName) {
         kony.sdk.resetProviderKeys(konyRef, _providerName);
     }
     /**
      * Login with the given credentials asynchronously and executes the given callback.
      * @param {object} options - User name and password
      * @param {function} successCallback  - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     this.login = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering Login");
         var continueOnRefreshError = true;
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid("login_" + _providerName);
         kony.sdk.logsdk.debug("### AuthService::login Invoked login for provider " + _providerName + " of type " + _type);
         if (typeof(options) == 'undefined') {
             throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Missing required number of arguments to login function");
         }
         if (options && options["loginOptions"] && options["loginOptions"]["continueOnRefreshError"] === false) {
             continueOnRefreshError = false;
         }
         if (options && options["loginOptions"]) {
             offlineEnabled = options["loginOptions"]["isOfflineEnabled"] || false;
             kony.sdk.offline.isOfflineEnabled = kony.sdk.offline.isOfflineEnabled || offlineEnabled;
             kony.sdk.sso.isSSOEnabled = options["loginOptions"]["isSSOEnabled"] || false;
         } else {
             kony.sdk.sso.isSSOEnabled = false;
         }

         function invokeAjaxCall(url, params, headers) {
             if (!headers) {
                 headers = {};
             }
             if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken) && (new Date().getTime() < konyRef.claimTokenExpiry)) {
                 headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
             }
             headers[kony.sdk.constants.APP_KEY_HEADER] = mainRef.appKey;
             headers[kony.sdk.constants.APP_SECRET_HEADER] = mainRef.appSecret;
             headers[kony.sdk.constants.SDK_TYPE_HEADER] = kony.sdk.getSdkType();
             headers[kony.sdk.constants.SDK_VERSION_HEADER] = kony.sdk.version;
             headers[kony.sdk.constants.PLATFORM_TYPE_HEADER] = kony.sdk.getPlatformName();
             headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
             populateHeaderWithFabricAppVersion(headers);
             if (konyRef.reportingheaders_allowed) {
                 if (reportingData != null && reportingData != undefined) {
                     try {
                         headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
                     } catch (error) {
                         kony.sdk.logsdk.error("### login::error while parsing metrics payload" + error);
                     }
                 }
             }
             if (kony.sdk.sso.isSSOEnabled === true) {
                 var ssotoken = kony.sdk.util.getSSOTokenForProvider(_providerName);
                 if (!kony.sdk.util.isNullOrEmptyString(ssotoken)) {
                     headers[kony.sdk.constants.AUTHORIZATION_HEADER] = ssotoken;
                 }
             }
             var endPointUrl = null;
             if (_type === "anonymous") {
                 endPointUrl = _serviceUrl + url;
             } else {
                 endPointUrl = _serviceUrl + url + "?provider=" + _providerName;
                 params["provider"] = _providerName;
             }
             if (options && options["include_profile"]) {
                 params["include_profile"] = params["include_profile"] ? params["include_profile"] : options["include_profile"];
             }
             var networkOptions = {};
             if (options && options["httpRequestOptions"] && options["httpRequestOptions"] instanceof Object) {
                 networkOptions["httpRequestOptions"] = options["httpRequestOptions"];
             }
             networkProvider.post(endPointUrl, params, headers, function(data) {
                 var response = processLoginSuccessResponse(data, konyRef, false);

                 function serviceDocCallback() {
                     kony.sdk.verifyAndCallClosure(successCallback, response);
                 }
                 getLatestServiceDocIfAvailable(data, serviceDocCallback);
             }, function(data) {
                 processLoginErrorResponse(data, konyRef, true, failureCallback)
             }, null, networkOptions);
         }

         function loginHelper(url, params, headers, isError) {
             if (isError) {
                 var error = {};
                 err.message = "Login Failed";
                 err.opstatus = kony.sdk.errorcodes.transient_login_fail;
                 err.code = (params && params.error) ? params.error : "";
                 kony.sdk.verifyAndCallClosure(failureCallback, err);
                 return;
             }
             kony.sdk.logsdk.trace("Entering loginHelper");
             if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken) && !konyRef.isAnonymousProvider) {
                 kony.sdk.claimsRefresh(function(res) {
                     invokeAjaxCall(url, params, headers)
                 }, function(err) {
                     if (continueOnRefreshError) {
                         kony.sdk.logsdk.error("### AuthService::login claimsRefresh failed, performing force login");
                         invokeAjaxCall(url, params, headers);
                     } else {
                         kony.sdk.logsdk.error("### AuthService::login claimsRefresh failed, invoking failurecallback");
                         err.message = kony.sdk.errormessages.transient_login_fail;
                         err.opstatus = kony.sdk.errorcodes.transient_login_fail;
                         kony.sdk.verifyAndCallClosure(failureCallback, err);
                     }
                 })
             } else {
                 kony.sdk.logsdk.info("### AuthService::login Claims token unavailable, performing regular login");
                 invokeAjaxCall(url, params, headers);
             }
         }
         /**
          * Login once the deeplink redirection is done. .
          * @param {map} options
          */
         function loginForDeeplink(options) {
             kony.sdk.logsdk.trace("Entering loginForDeeplink");
             if (options) {
                 var code = options[kony.sdk.constants.DEEPLINK_VALID_PARAM];
                 var urlType = options["urlType"];
                 try {
                     kony.sdk.logsdk.debug("### AuthService::login received authorization code");
                     loginHelper("/" + urlType + "/" + "token", {
                         code: code
                     }, {});
                 } catch (err) {
                     kony.sdk.logsdk.error("exception ::" + err);
                     failureCallback();
                 }
             }
         }
         if (_type === "anonymous") {
             konyRef.isAnonymousProvider = true;
             kony.sdk.logsdk.info("### AuthService::login Adapter type is anonymous");
             loginHelper("/login", {}, {});
         } else if (_type == "basic") {
             var mandatory_fields = ["userid", "password"];
             if (kony.sdk.sso.isSSOEnabled === false) {
                 if (serviceObj.mandatory_fields && kony.sdk.isArray(serviceObj.mandatory_fields)) {
                     mandatory_fields = serviceObj.mandatory_fields;
                 }
                 for (var i = 0; i < mandatory_fields.length; ++i) {
                     if (kony.sdk.isNullOrUndefined(options[mandatory_fields[i]])) {
                         throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, " Require " + mandatory_fields[i]);
                     }
                 }
             }
             var payload = {};
             var encryptedStorage = {};
             if (options != null && options != undefined) {
                 for (var option in options) {
                     payload[option] = options[option];
                 }
             }
             payload["provider"] = _providerName;
             kony.sdk.logsdk.info("### AuthService::login Adapter type is basic");
             loginHelper("/login", payload, {});
         } else {
             if (options && options.userid && options.password) {
                 var payload = {};
                 for (var option in options) {
                     payload[option] = options[option];
                 }
                 payload["provider"] = _providerName;
                 loginHelper("/login", payload);
             } else {
                 kony.sdk.logsdk.debug("### AuthService::login Adapter type is " + _type);
                 if (kony.sdk.isSSOLoginSuccess && kony.sdk.sso.isSSOEnabled == true && kony.sdk.util.getSSOToken() != null && kony.sdk.util.getSSOToken() != "" && kony.sdk.util.getSSOToken() != undefined) {
                     if (_type === "oauth2") {
                         loginHelper("/oauth2/token", {}, {});
                     } else if (_type === "saml") {
                         loginHelper("/saml/token", {}, {});
                     } else {
                         loginHelper("/login", {}, {});
                     }
                 } else {
                     //To provide backward compatibility, if MF is an older it will not have the changes for blocking the popup or opening the login url in the native browser.
                     //Identity will add a new tuple in the service doc "identity_meta". SDK will validate the compatibility with the existance of serviceDoc["identity_meta"][<priovider_name>]["success_url"]
                     var isMFVersionCompatible = false;
                     var oauthOptions = {};
                     if (options && options["loginOptions"] && options["loginOptions"]["customQueryParamsForOAuth"] && options["loginOptions"]["customQueryParamsForOAuth"] instanceof Object) {
                         oauthOptions["customQueryParamsForOAuth"] = options["loginOptions"]["customQueryParamsForOAuth"];
                     }
                     if (mainRef && mainRef.config && mainRef.config.identity_meta && mainRef.config.identity_meta[_providerName] && mainRef.config.identity_meta[_providerName].success_url) {
                         isMFVersionCompatible = true;
                     }
                     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_PLAIN_JS) {
                         //Case to handle plain-js OAuth flow.
                         // Popup needs to be blocked for oauth2 type & redirect to the url "success_url" if provided in query params else the default one declared in the MF application.
                         if (options && options["noPopup"]) {
                             oauthOptions["noPopup"] = true
                         }
                         if (options && options[kony.sdk.constants.DEEPLINK_VALID_PARAM] && options["urlType"]) {
                             //Validating the identity service once after deeplink is redirected. Params "code" & "urlType" are mandatory and are used to distinguish the request.
                             loginForDeeplink(options);
                         } else {
                             oauthOptions["appSecret"] = mainRef.appSecret;
                             oauthOptions["serviceDoc"] = mainRef.config;
                             if (options && options["include_profile"]) {
                                 oauthOptions["include_profile"] = options["include_profile"]
                             }
                             OAuthHandler(_serviceUrl, _providerName, mainRef.appKey, loginHelper, _type, oauthOptions, isMFVersionCompatible);
                         }
                     } else {
                         if (kony.sdk.util.hasBrowserWidget(options)) {
                             //Case to handle OAuth for IDE
                             oauthOptions[kony.sdk.constants.BROWSER_WIDGET] = options[kony.sdk.constants.BROWSER_WIDGET];
                         } else {
                             //Default case if param browserWidget and UseDeviceBrowser not present. We create one browser widget and open the url in it.
                             if (options && options["UseDeviceBrowser"]) {
                                 //Validating to check the existence of param "UseDeviceBrowser".
                                 // if found login url will be opened in device native broser, else in browser widget.
                                 oauthOptions["UseDeviceBrowser"] = options["UseDeviceBrowser"];
                             }
                             if (options && options[kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL]) {
                                 //Validating to check the existence of param "success_url".
                                 // if found after login success we will redirect to the url specified in param "success_url".
                                 var success_url = options[kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL];
                                 //Encoding is being done specifically for android because, in android kony.application.openUrl is not
                                 // opening the url without encoding where as in ios its encoding and opening.
                                 if (kony.sdk.getPlatformName() === kony.sdk.constants.PLATFORM_ANDROID) {
                                     //decoding and encoding, to handle the case where in the user himself is giving us the encoded value.
                                     success_url = encodeURIComponent(decodeURIComponent(options[kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL]));
                                 }
                                 oauthOptions[kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL] = success_url;
                             }
                         }
                         if (options && kony.sdk.util.isValidString(options[kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL])) {
                             oauthOptions[kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL] = options[kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL];
                         }
                         OAuthHandler(_serviceUrl, _providerName, mainRef.appKey, loginHelper, _type, oauthOptions, isMFVersionCompatible);
                     }
                 }
             }
         }
     };
     /**
      * validateMfa validates the multi factor authentication parameters
      * @param {object} mfaParams- 2nd factor authentic param
      * @param {function} successCallback  - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     this.validateMfa = function(mfaParams, successCallback, failureCallback, options) {
         kony.sdk.logsdk.debug("AuthService::validateMfa Invoked login for provider " + _providerName + " of type " + _type);

         function performValidateCall(urlMFA, params) {
             var headers = {};
             headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
             headers[kony.sdk.constants.APP_KEY_HEADER] = mainRef.appKey;
             headers[kony.sdk.constants.APP_SECRET_HEADER] = mainRef.appSecret;
             headers[kony.sdk.constants.SDK_TYPE_HEADER] = kony.sdk.getSdkType();
             headers[kony.sdk.constants.SDK_VERSION_HEADER] = kony.sdk.version;
             headers[kony.sdk.constants.PLATFORM_TYPE_HEADER] = kony.sdk.getPlatformName();
             headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
             populateHeaderWithFabricAppVersion(headers);
             if (konyRef.reportingheaders_allowed) {
                 headers[kony.sdk.constants.REPORTING_HEADER] = kony.sdk.getEncodedReportingParamsForSvcid("login_" + _providerName);
             }
             var endPointUrl = _serviceUrl + urlMFA + "?provider=" + _providerName;
             var networkOptions = kony.sdk.util.checkAndFetchNetworkProviderOptions(options);
             networkProvider.post(endPointUrl, params, headers, function(data) {
                 var response = processLoginSuccessResponse(data, konyRef, false);
                 kony.sdk.verifyAndCallClosure(successCallback, response);
             }, function(data) {
                 processLoginErrorResponse(data, konyRef, true, failureCallback)
             }, null, networkOptions);
         }
         if (kony.sdk.isNullOrUndefined(mfaParams)) {
             throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, " mfaParams are null");
         }
         var payload = {};
         payload["provider"] = _providerName;
         for (var key in mfaParams) {
             payload[key] = mfaParams[key];
         }
         if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken) && !konyRef.isAnonymousProvider) {
             kony.sdk.claimsRefresh(function(res) {
                 performValidateCall("/login/MFA", payload)
             }, function(err) {
                 kony.sdk.logsdk.error("AuthService::validateMfa claimsRefresh failed, invoking failurecallback");
                 err.message = kony.sdk.errormessages.transient_login_fail;
                 err.opstatus = kony.sdk.errorcodes.transient_login_fail;
                 kony.sdk.verifyAndCallClosure(failureCallback, err);
             })
         } else {
             kony.sdk.logsdk.error("AuthService::validateMfa Claims token unavailable, please login");
             err.message = kony.sdk.errormessages.offline_auth_failed;
             err.opstatus = kony.sdk.errorcodes.offline_auth_failedl;
             kony.sdk.verifyAndCallClosure(failureCallback, err);
         }
     };
     /**
      * getMfaDetails functions lets the user to know whether 2factor security is enabled
      * @return {boolean}
      **/
     this.getMfaDetails = function() {
         var mfaDetails = {};
         mfaDetails[kony.sdk.constants.IS_MFA_ENABLED] = is_mfa_enabled;
         mfaDetails[kony.sdk.constants.MFA_META] = mfa_meta;
         return mfaDetails;
     };
     var processMultipleProvidersResponse = function(data, providerName) {
         if (data && data.profiles) {
             konyRef.isAnonymousProvider = false;
             for (var provider in data.profiles) {
                 if (!konyRef.tokens[provider]) {
                     konyRef.tokens[provider] = {};
                 }
                 konyRef.tokens[provider].profile = data.profiles[provider];
             }
         } else if (data && providerName && data.profile) {
             konyRef.isAnonymousProvider = false;
             konyRef.tokens[providerName].profile = data.profile;
         }
         if (data && data.provider_tokens) {
             for (var provider in data.provider_tokens) {
                 if (!konyRef.tokens[provider]) {
                     konyRef.tokens[provider] = {};
                 }
                 if (!konyRef.tokens[provider].provider_token) {
                     konyRef.tokens[provider].provider_token = {}
                 }
                 konyRef.tokens[provider].provider_token.value = data.provider_tokens[provider];
             }
         }
         if (data && providerName && data.provider_token) {
             konyRef.tokens[providerName].provider_token = data.provider_token;
         }
         konyRef.currentClaimToken = data.claims_token.value;
         konyRef.claimTokenExpiry = data.claims_token.exp;
         konyRef.currentRefreshToken = data.refresh_token;
         if (!konyRef.isAnonymousProvider && !kony.sdk.isNullOrUndefined(data.claims_token[kony.sdk.constants.IS_MFA_ENABLED])) {
             for (var providerPosition = 0; providerPosition < konyRef.login.length; providerPosition++) {
                 if (konyRef.login[providerPosition].prov === providerName) {
                     //we are doing this so that if user makes anoher identity object with same provider , is_mfa_enabled value can be available
                     konyRef.login[providerPosition][kony.sdk.constants.IS_MFA_ENABLED] = data.claims_token[kony.sdk.constants.IS_MFA_ENABLED];
                     konyRef.login[providerPosition][kony.sdk.constants.MFA_META] = data.claims_token[kony.sdk.constants.MFA_META];
                     var result = {};
                     result[kony.sdk.constants.IS_MFA_ENABLED] = data.claims_token[kony.sdk.constants.IS_MFA_ENABLED];
                     result[kony.sdk.constants.MFA_META] = data.claims_token[kony.sdk.constants.MFA_META];
                     return result;
                 }
             }
         }
     };
     var processLoginSuccessResponse = function(data, konyRef, isAsync, callBack) {
         kony.sdk.logsdk.trace("Entering processLoginSuccessResponse");
         data = kony.sdk.formatSuccessResponse(data);
         if (_type !== "anonymous" && !konyRef.tokens[_providerName]) {
             konyRef.tokens[_providerName] = {};
         }
         kony.sdk.logsdk.info("### AuthService::login successful. Retrieved Data::");
         processMultipleProvidersResponse(data, _providerName);
         kony.sdk.logsdk.info("### AuthService::login extracted token. Calling success callback");
         if (kony.sdk.sso.isSSOEnabled === true) {
             if (data.sso_token) {
                 var isSSOSaved = kony.sdk.util.saveSSOToken(kony.sdk.util.addOrUpdateSSOTokenWithProvider(data.sso_token, _providerName));
                 if (isSSOSaved === true) {
                     kony.sdk.isSSOLoginSuccess = true;
                     kony.sdk.logsdk.info("### SSOLoginService::SSOToken being saved successfully.");
                 } else {
                     kony.sdk.logsdk.info("### SSOLoginService::Failed to save SSOToken.This might result in failure of corresponding sso Logins. Please check the configuration params");
                 }
             } else {
                 kony.sdk.logsdk.info("### SSOLoginService::Unable to fetch sso token.");
             }
         }
         if (data.profile && data.profile != undefined && data.profile.user_attributes != undefined) {
             user_attributes = data.profile.user_attributes;
         }
         if (data.profile) {
             kony.sdk.overrideUserId(data.profile.userid);
         }
         if (kony.sdk.getPlatformName() !== kony.sdk.constants.PLATFORM_WINDOWS && kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE) {
             //We store the user credentials and the success auth response only on successful online login.
             if (kony.sdk.offline.isOfflineEnabled === true) {
                 if (kony.sdk.isNetworkAvailable() && offlineEnabled && _type === "basic") {
                     kony.sdk.offline.updateSuccessUserCredentials(_providerName);
                 }
                 kony.sdk.offline.saveUserAuthInformation("authResponse", data);
             }
         }
         kony.logger.setClaimsToken();
         if (!isAsync) {
             return {};
         } else if (callBack) {
             kony.sdk.verifyAndCallClosure(callBack, {});
         }
     };
     var processLoginErrorResponse = function(data, konyRef, isAsync, callBack) {
         kony.sdk.logsdk.trace("Entering processLoginErrorResponse");
         kony.sdk.logsdk.info("### AuthService::login Calling failure callback");
         /*resetting all the token in case of error */
         resetAllCurrentTokens(konyRef, _providerName);
         if (kony.sdk.sso.isSSOEnabled === true) {
             if (data.mfcode == "Auth-55") {
                 kony.sdk.util.deleteSSOToken();
             }
             kony.sdk.isSSOLoginSuccess = false;
         }
         if (!isAsync) {
             return kony.sdk.error.getAuthErrObj(data);
         } else if (callBack) {
             callBack(kony.sdk.error.getAuthErrObj(data));
         }
     };
     /**
      * Login anonymous with the given credentials synchronously and executes the given callback.
      * @param {object} options - User name and password
      */
     this.anonymousLoginSync = function(options) {
         kony.sdk.logsdk.trace("Entering anonymousLoginSync");
         konyRef.isAnonymousProvider = false;
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid("login_" + _providerName);
         kony.sdk.logsdk.debug("### AuthService::login Invoked login for provider " + _providerName + " of type " + _type);
         if (typeof(options) == 'undefined') {
             throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Missing required number of arguments to login function");
         }

         function invokeAjaxCall(url, params, headers) {
             if (!headers) {
                 headers = {};
             }
             headers[kony.sdk.constants.APP_KEY_HEADER] = mainRef.appKey;
             headers[kony.sdk.constants.APP_SECRET_HEADER] = mainRef.appSecret;
             headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
             if (konyRef.reportingheaders_allowed) {
                 if (reportingData != null && reportingData != undefined) {
                     try {
                         headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
                     } catch (error) {
                         kony.sdk.logsdk.error("### anonymousLoginSync::error while parsing metrics payload" + error);
                     }
                 }
             }
             var endPointUrl = null;
             if (_type === "anonymous") {
                 endPointUrl = _serviceUrl + url;
             } else {
                 endPointUrl = _serviceUrl + url + "?provider=" + _providerName;
                 params["provider"] = _providerName;
             }
             var data = networkProvider.postSync(endPointUrl, params, headers);
             if (data.opstatus == 0) {
                 return processLoginSuccessResponse(data, konyRef, false);
             } else {
                 return processLoginErrorResponse(data, konyRef, false);
             }
         }
         konyRef.isAnonymousProvider = true;
         kony.sdk.logsdk.info("### AuthService::login Adapter type is anonymous");
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         return invokeAjaxCall("/login", {}, headers);
     };
     /**
      * Logout and executes the given callback.
      * @param {function} successCallback  - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {object} options - additional options for logout
      */
     this.logout = function(successCallback, failureCallback, options) {
         kony.sdk.logsdk.trace("Entering logout");

         function logoutHandler() {
             _logout(successCallback, failureCallback, options);
         }
         if (kony.sdk.getPlatformName() !== kony.sdk.constants.PLATFORM_WINDOWS) {
             //if the user logged in using offline logout
             if (offlineEnabled == true && kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && _type === "basic" && !kony.sdk.isNetworkAvailable()) {
                 logoutHandler();
             } else {
                 kony.sdk.claimsRefresh(logoutHandler, failureCallback);
             }
         } else {
             kony.sdk.claimsRefresh(logoutHandler, failureCallback);
         }
     };

     function _logout(successCallback, failureCallback, options) {
         function invokeLogoutHelper(formData, invokeLogoutSuccess, invokeLogoutFailure) {
             var claimsTokenValue = null;
             var reportingData = kony.sdk.getEncodedReportingParamsForSvcid("logout_" + _providerName);
             if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken)) {
                 claimsTokenValue = konyRef.currentClaimToken;
             }
             formdata.provider = _providerName;
             var url = "";
             if (_type == "oauth2" && kony.sdk.getSdkType() == kony.sdk.constants.SDK_TYPE_IDE) {
                 url = _serviceUrl + "/oauth2/logout?provider=" + _providerName;
             } else {
                 url = _serviceUrl + "/logout?provider=" + _providerName;
             }
             var headers = {};
             headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = claimsTokenValue;
             headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = "*/*";
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
             if (konyRef.reportingheaders_allowed) {
                 if (reportingData != null && reportingData != undefined) {
                     try {
                         headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
                     } catch (error) {
                         kony.sdk.logsdk.error("### login::error while parsing metrics payload" + error);
                     }
                 }
             }
             populateHeaderWithFabricAppVersion(headers);
             networkProvider.post(url, formdata, headers, function(data) {
                 kony.sdk.logsdk.info("AuthService::logout successfully logged out. Calling success callback");

                 function serviceDocCallback() {
                     logoutSuccess(data);
                     return;
                 }
                 getLatestServiceDocIfAvailable(data, serviceDocCallback);
             }, function(err) {
                 kony.sdk.logsdk.error("### AuthService::logout logged out Failed. Calling failure callback");
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(err));
             });
         }

         function logoutSuccess(data) {
             kony.sdk.logsdk.trace("Entering logoutSuccess");
             data = kony.sdk.formatSuccessResponse(data);
             delete konyRef.tokens[_providerName];
             //reset all current keys
             kony.sdk.resetCurrentKeys(konyRef, _providerName);
             //processing multiple profiles
             if (data && data.claims_token) {
                 processMultipleProvidersResponse(data);
                 konyRef.isAnonymousProvider = false;
             }
             if (slo === true) {
                 kony.sdk.util.deleteSSOTokenForProvider(_providerName);
             }
             kony.sdk.verifyAndCallClosure(successCallback, {});
         }
         kony.sdk.logsdk.debug("### AuthService::logout invoked on provider " + _providerName + " of type " + _type);
         var slo = false;
         if (!kony.sdk.isNullOrUndefined(options) && (options["slo"] === true || options["slo"] === false)) {
             slo = options["slo"];
         }
         var formdata = {};
         formdata = {
             "slo": slo
         };
         if (!isLoggedIn()) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
         } else if (_type == "oauth2" && kony.sdk.getSdkType() == kony.sdk.constants.SDK_TYPE_IDE) {
             var callback_invoke = true;
             var oauth_status;

             function oAuthCallback(status) {
                 oauth_status = status;
                 //Workaround to get around redirects
                 if (callback_invoke) {
                     callback_invoke = false;
                     kony.timer.schedule("oAuthCallbackHandle", function() {
                         if (oauth_status) invokeLogoutHelper(formdata, logoutSuccess, failureCallback);
                         else kony.sdk.verifyAndCallClosure(failureCallback, {});
                     }, 3, false);
                 }
             }
             var oauthOptions = {};
             oauthOptions["logout"] = true;
             oauthOptions["slo"] = slo;
             if (kony.sdk.util.hasBrowserWidget(options)) {
                 oauthOptions[kony.sdk.constants.BROWSER_WIDGET] = options[kony.sdk.constants.BROWSER_WIDGET];
             }
             OAuthHandler(_serviceUrl, _providerName, mainRef.appKey, oAuthCallback, _type, oauthOptions);
         } else {
             if (kony.sdk.getPlatformName() !== kony.sdk.constants.PLATFORM_WINDOWS) {
                 //if the user logged in using offline login
                 if (kony.sdk.offline.isOfflineEnabled == true && kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && _type === "basic" && !kony.sdk.isNetworkAvailable()) {
                     kony.sdk.logsdk.info("AuthService::offline logout successfully logged out. Calling success callback");
                     logoutSuccess();
                     return;
                 }
             }
             invokeLogoutHelper(formdata, logoutSuccess, failureCallback);
         }
     }
     /**
      * Fetch the backend datasource token.
      * @param {boolean} fromserver - Flag to force fetch from server only.
      * @param {object} options - Options
      * @param {function} successCallback  - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     this.getBackendToken = function(fromserver, options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering getBackendToken");

         function _claimsRefreshSuccess(token) {
             kony.sdk.logsdk.trace("Entering _claimsRefreshSuccess with valid token");
             processMultipleProvidersResponse(token);
             //konyRef.currentBackEndToken = token.provider_token;
             //if offline login enabled then updating the backend token in the store
             if (kony.sdk.getPlatformName() !== kony.sdk.constants.PLATFORM_WINDOWS && kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE) {
                 if (kony.sdk.offline.isOfflineEnabled && kony.sdk.offline.isOfflineEnabled == true) {
                     kony.sdk.offline.updateAuthToken(token);
                 }
             }
             kony.sdk.verifyAndCallClosure(successCallback, konyRef.tokens[_providerName].provider_token);
         }

         function _claimsRefreshFailure(error) {
             kony.sdk.logsdk.trace("Entering _claimsRefreshFailure");
             kony.sdk.logsdk.info("### AuthService::getBackendToken fetching refresh failed. Calling failure callback");
             // konyRef.tokens[_providerName] = null;
             // konyRef.currentBackEndToken = null;
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(error));
         }
         kony.sdk.logsdk.debug("### AuthService::getBackendToken called for provider " + _providerName + " of type " + _type);
         if (!isLoggedIn()) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
         }
         var claimsOptions = null;
         if (options && options.refresh && options.refresh === true) {
             claimsOptions = {
                 "requestParams": {
                     "refresh": "true"
                 }
             };
         }
         if (fromserver != undefined && fromserver === true) {
             kony.sdk.logsdk.info("### AuthService::getBackendToken fromserver is enabled. Trying to login");
             _claimsRefresh(claimsOptions, _claimsRefreshSuccess, _claimsRefreshFailure);
         } else {
             if (konyRef.tokens[_providerName]) {
                 var val = konyRef.tokens[_providerName];
                 var _exp = val.provider_token.exp;
                 kony.sdk.logsdk.debug("token expiry time: " + _exp);
                 kony.sdk.logsdk.debug("Current time: " + (new Date().getTime()));
                 if (_exp && _exp < (new Date().getTime())) {
                     kony.sdk.logsdk.info("### AuthService::getBackendToken Token expired. Fetching refresh from claims api");
                     _claimsRefresh(claimsOptions, _claimsRefreshSuccess, _claimsRefreshFailure);
                 } else {
                     kony.sdk.logsdk.info("### AuthService::getBackendToken present token is valid/doesn't have expiry time. Calling success callback");
                     //konyRef.currentBackEndToken = val.provider_token;
                     kony.sdk.verifyAndCallClosure(successCallback, konyRef.tokens[_providerName].provider_token);
                 }
             } else {
                 kony.sdk.logsdk.info("### AuthService::getBackendToken failed for find info for key " + dsKey + "in database. calling failure callback");
                 kony.sdk.verifyAndCallClosure(failureCallback, null);
             }
         }
     };
     /**
      * Get profile.
      * @param {boolean} fromserver - Flag to force fetch from server only.
      * @param {function} successCallback  - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     this.getProfile = function(fromserver, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering getProfile");
         if (!isLoggedIn()) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
         } else if (fromserver && fromserver == true) {
             profileRefresh(function(token) {
                 konyRef.tokens[_providerName].profile = token;
                 kony.sdk.verifyAndCallClosure(successCallback, token);
             }, failureCallback)
         } else {
             if (konyRef.tokens[_providerName]) {
                 var val = konyRef.tokens[_providerName];
                 kony.sdk.verifyAndCallClosure(successCallback, val.profile);
             } else {
                 kony.sdk.verifyAndCallClosure(failureCallback, null);
             }
         }
     };
     /**
      * Get the provider name.
      * @returns {string} Provider name.
      */
     this.getProviderName = function() {
         return _providerName;
     };
     /**
      * Get the provider type.
      * @returns {string} Provider type.
      */
     this.getProviderType = function() {
         return _type;
     };
     /**
      * Get the generic session data type.
      * @returns {string} session data.
      */
     this.getUserData = function(successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering getUserData (Get the generic session data type)");
         if (!isLoggedIn()) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
         } else {
             var userDataUrl = _serviceUrl + "/session/user_data";
             var options = {};
             options["invokedFrom"] = kony.sdk.constants.GET_USER_DATA;
             getSessionData(userDataUrl, successCallback, failureCallback, options);
         }
     };
     /**
      * Get the user attributes returned by a provider
      * @returns {string} user attributes.
      */
     this.getUserAttributes = function(successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering getUserAttributes");
         if (!isLoggedIn()) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
         } else if (user_attributes && Object.keys(user_attributes).length === 0) {
             var userAttributesUrl = _serviceUrl + "/session/user_attributes?provider=" + _providerName;
             var options = {};
             options["invokedFrom"] = kony.sdk.constants.GET_USER_ATTRIBUTES;
             getSessionData(userAttributesUrl, function(res) {
                 user_attributes = res;
                 kony.sdk.verifyAndCallClosure(successCallback, user_attributes);
             }, failureCallback, options);
         } else {
             if (konyRef.currentClaimToken === null) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getNullClaimsTokenErrObj());
             } else {
                 kony.sdk.verifyAndCallClosure(successCallback, user_attributes);
             }
         }
     };
     /**
      * Get the security attributes returned by a provider
      * @returns {string} security attributes.
      */
     this.getSecurityAttributes = function(successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering getSecurityAttributes");
         if (!isLoggedIn()) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
         } else {
             var securityAttributesUrl = _serviceUrl + "/session/security_attributes?provider=" + _providerName;
             var options = {};
             options["invokedFrom"] = kony.sdk.constants.GET_SECURITY_ATTRIBUTES;
             getSessionData(securityAttributesUrl, successCallback, failureCallback, options);
         }
     };
     /**
     	utility method to get session data
     	@private
     */
     var getSessionData = function(sessionAttributesEndPointUrl, successCallback, failureCallback, options) {
         var svcid = null;
         if (options["invokedFrom"] == kony.sdk.constants.GET_USER_ATTRIBUTES) {
             svcid = kony.sdk.constants.GET_USER_ATTRIBUTES;
         } else if (options["invokedFrom"] == kony.sdk.constants.GET_SECURITY_ATTRIBUTES) {
             svcid = kony.sdk.constants.GET_SECURITY_ATTRIBUTES;
         } else {
             svcid = kony.sdk.constants.GET_USER_DATA;
         }
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(svcid);
         if (konyRef.currentClaimToken === null) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getNullClaimsTokenErrObj());
         } else {
             var headers = {};
             headers[kony.sdk.constants.AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
             if (konyRef.reportingheaders_allowed) {
                 if (reportingData != null && reportingData != undefined) {
                     try {
                         headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
                     } catch (error) {
                         kony.sdk.logsdk.error("### getSessionData::error while parsing metrics payload" + error);
                     }
                 }
             }
             populateHeaderWithFabricAppVersion(headers);
             networkProvider.get(sessionAttributesEndPointUrl, {}, headers, function(data) {
                 data = kony.sdk.formatSuccessResponse(data);
                 kony.sdk.verifyAndCallClosure(successCallback, data);
             }, function(err) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(err));
             });
         }
     };
     /**
      * Method to refresh the claims token.
      * @private
      */
     var _claimsRefresh = function(options, success, failure) {
         kony.sdk.logsdk.debug("### AuthService::_claimsRefresh fetching claims from server for provider " + _providerName);
         var refreshToken = null;
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(kony.sdk.constants.GET_BACKEND_TOKEN);
         if (!kony.sdk.isNullOrUndefined(konyRef.currentRefreshToken)) {
             refreshToken = konyRef.currentRefreshToken;
         }
         var _url = _serviceUrl + "/claims";
         if (options && options.requestParams != null) {
             _url = _url + "?";
             for (var i in options.requestParams) {
                 if (options.requestParams.hasOwnProperty(i) && typeof(i) !== 'function') {
                     _url = _url + (i + "=" + options.requestParams[i] + "&");
                 }
             }
             _url = stripTrailingCharacter(_url, "&");
         }
         if (refreshToken) {
             kony.sdk.logsdk.info("### AuthService::_claimsRefresh making POST request to claims endpoint");
             var headers = {};
             headers[kony.sdk.constants.AUTHORIZATION_HEADER] = refreshToken;
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
             if (konyRef.reportingheaders_allowed) {
                 if (reportingData != null && reportingData != undefined) {
                     try {
                         headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
                     } catch (error) {
                         kony.sdk.logsdk.error("### _claimsRefresh::error while parsing metrics payload" + error);
                     }
                 }
             }
             populateHeaderWithFabricAppVersion(headers);
             networkProvider.post(_url, {}, headers, function(data) {
                 data = kony.sdk.formatSuccessResponse(data);
                 kony.sdk.logsdk.info("### AuthService::_claimsRefresh Fetching claims succcessfull");
                 processMultipleProvidersResponse(data);
                 kony.sdk.logsdk.info("### AuthService::_claimsRefresh saved locally. Calling success callback");
                 kony.sdk.verifyAndCallClosure(success, data);
             }, function(xhr, status, err) {
                 kony.sdk.logsdk.error("### AuthService::_claimsRefresh fetching claims failed. Calling failure callback");
                 kony.sdk.verifyAndCallClosure(failure, kony.sdk.error.getAuthErrObj(err));
             });
         } else {
             kony.sdk.logsdk.info("### AuthService::_claimsRefresh no refreshtoken found. calling failure callback");
             kony.sdk.verifyAndCallClosure(failure, kony.sdk.error.getNullRefreshTokenErrObj());
         }
     };
     var profileRefresh = function(success, failure) {
         kony.sdk.logsdk.trace("Entering profileRefresh");
         kony.sdk.logsdk.debug("### AuthService::profileRefresh fetching profile from server for provider " + _providerName);
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(kony.sdk.constants.GET_PROFILE);
         var refreshToken = null;
         if (!kony.sdk.isNullOrUndefined(konyRef.currentRefreshToken)) {
             refreshToken = konyRef.currentRefreshToken;
         }
         var _url = _serviceUrl + "/profile?provider=" + _providerName;
         if (refreshToken) {
             kony.sdk.logsdk.info("### AuthService::profileRefresh making POST request to profile endpoint");
             var headers = {};
             headers[kony.sdk.constants.AUTHORIZATION_HEADER] = refreshToken;
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
             if (konyRef.reportingheaders_allowed) {
                 if (reportingData != null && reportingData != undefined) {
                     try {
                         headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
                     } catch (error) {
                         kony.sdk.logsdk.error("### profileRefresh::error while parsing metrics payload" + error);
                     }
                 }
             }
             populateHeaderWithFabricAppVersion(headers);
             networkProvider.get(_url, null, headers, function(data) {
                 data = kony.sdk.formatSuccessResponse(data);
                 konyRef.tokens[_providerName].profile = data;
                 kony.sdk.logsdk.info("### AuthService::profileRefresh Fetching profile succcessfull, Calling success callback");
                 kony.sdk.verifyAndCallClosure(success, data);
             }, function(xhr, status, err) {
                 kony.sdk.logsdk.error("### AuthService::profileRefresh fetching profile failed. Calling failure callback");
                 kony.sdk.verifyAndCallClosure(failure, kony.sdk.error.getAuthErrObj(err));
             });
         } else {
             kony.sdk.logsdk.info("### AuthService::profileRefresh no refreshtoken found. calling failure callback");
             kony.sdk.verifyAndCallClosure(failure, kony.sdk.error.getNullRefreshTokenErrObj());
         }
     };
 }

 function konySdkLogger() {
     this.INDIRECTIONLEVEL = 1;
     this.trace = function(msg, params) {
         this.getInstance().trace(msg, params);
     };
     this.debug = function(msg, params) {
         this.getInstance().debug(msg, params);
     };
     this.info = function(msg, params) {
         this.getInstance().info(msg, params);
     };
     this.perf = function(msg, params) {
         this.getInstance().perf(msg, params);
     };
     this.warn = function(msg, params) {
         this.getInstance().warn(msg, params);
     };
     this.error = function(msg, params) {
         this.getInstance().error(msg, params);
     };
     this.fatal = function(msg, params) {
         this.getInstance().fatal(msg, params);
     };
     this.loggerEngineInit = function() {
         KonySDKLoggerObj = kony.logger.createNewLogger(kony.sdk.constants.LOGGER_NAME, null);
         KonySDKLoggerObj.setIndirectionLevel = this.INDIRECTIONLEVEL;
     };
     this.getInstance = function() {
         if (typeof(KonySDKLoggerObj) === 'undefined') this.loggerEngineInit();
         return KonySDKLoggerObj;
     }
 }
 /**
  * Method to create the logic service instance with the provided service name.
  * @param {string} serviceName - Name of the service
  * @returns The url to connect to the logic service
  * @throws Exception if the serviceName or access is invalid.
  */
 kony.sdk.prototype.getLogicService = function(serviceName) {
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Logic service - " + serviceName);
     }
     if (this.logicsvc != null) {
         if (this.logicsvc[serviceName] != null) {
             kony.sdk.logsdk.debug("### getLogicService::found Logic service" + this.logicsvc[serviceName]);
             return new kony.sdk.LogicService(this, serviceName);
         }
     }
     throw new Exception(kony.sdk.errorConstants.LOGIC_SERVICE_FAILURE, "Invalid serviceName:" + serviceName);
 };
 kony.sdk.LogicService = function(konyRef, serviceName) {
     this.konyRef = konyRef;
     this.serviceName = serviceName;
     this.logicServiceUrl = null;
     this.getLogicServiceUrl = function() {
         if (this.logicServiceUrl == null) {
             this.logicServiceUrl = stripTrailingCharacter(konyRef.logicsvc[serviceName], "/");
         }
         return this.logicServiceUrl;
     };
     kony.sdk.logsdk.info(" ###LogicService Created & LogicService Url = " + this.getLogicServiceUrl());
     var networkProvider = new konyNetworkProvider();
     this.invokeOperation = function(serviceName, path, methodType, headers, data, successCallback, failureCallback, options) {
         function invokeOperationHandler() {
             _invokeOperation(serviceName, path, methodType, headers, data, true, successCallback, failureCallback, options);
         }
         kony.sdk.claimsRefresh(invokeOperationHandler, failureCallback);
     };

     function invokeOperationRetry(serviceName, path, methodType, headers, data, successCallback, failureCallback, options) {
         function invokeOperationRetryHandler() {
             _invokeOperation(serviceName, path, methodType, headers, data, false, successCallback, failureCallback, options);
         }
         kony.sdk.claimsAndProviderTokenRefresh(invokeOperationRetryHandler, failureCallback);
     }

     function retryServiceCall(errorResponse) {
         if (errorResponse[kony.sdk.constants.MF_CODE]) {
             // check for the mf code for which,
             // retry should be done.
         } else {
             if (errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] && errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] === 401) {
                 return true;
             }
         }
     }

     function _invokeOperation(serviceName, path, methodType, headers, data, isRetryNeeded, successCallback, failureCallback, options) {
         var requestData = {};
         kony.sdk.logsdk.trace("Entered into _invokeOperation servicePath: " + serviceName + ", methodType: " + methodType + ", path" + path + ", isRetryNeeded: " + isRetryNeeded);
         var reportingData = kony.sdk.getPayload(konyRef);
         var sessionId = kony.ds.read(kony.sdk.constants.KONYUUID);
         if (sessionId) {
             reportingData.rsid = sessionId[0];
         }
         if (!reportingData.rsid) {
             kony.sdk.logsdk.warn("rsid is either empty,null or undefined");
         }
         if (kony.sdk.metric) {
             if (kony.sdk.metric.reportEventBufferBackupArray.length === 0) {
                 kony.sdk.metric.readFromDS();
             }
             kony.sdk.metric.pushEventsToBufferArray();
             requestData.events = kony.sdk.metric.reportEventBufferBackupArray;
         }
         for (var key in data) {
             requestData[key] = data[key];
         }
         reportingData.svcid = serviceName;
         requestData[kony.sdk.constants.REPORTING_PARAMS] = JSON.stringify(reportingData);
         var defaultHeaders = {};
         defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
         if (typeof(svcObj) === 'object' && svcObj.version) {
             defaultHeaders[kony.sdk.constants.API_VERSION_HEADER] = svcObj.version;
         }
         // if the user has defined his own headers, use them
         if (headers) {
             for (var header in headers) {
                 defaultHeaders[header] = headers[header];
             }
         }

         function networkSuccessCallback(response) {
             if (kony.sdk.metric) {
                 kony.sdk.metric.clearBufferEvents();
             }
             kony.sdk.verifyAndCallClosure(successCallback, response);
         }

         function networkFailureCallback(xhr, status, err) {
             if (isRetryNeeded === true && retryServiceCall(xhr) === true) {
                 invokeOperationRetry(serviceName, path, methodType, headers, data, successCallback, failureCallback, options);
                 return;
             }
             kony.sdk.processLogicErrorResponse(xhr, true, failureCallback);
         }
         switch (methodType) {
             case "GET":
                 networkProvider.get(konyRef.logicsvc[serviceName] + path, requestData, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
                 break;
             case "PUT":
                 networkProvider.put(konyRef.logicsvc[serviceName] + path, requestData, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
                 break;
             case "DELETE":
                 networkProvider.invokeDeleteRequest(konyRef.logicsvc[serviceName] + path, requestData, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
                 break;
             default:
                 networkProvider.post(konyRef.logicsvc[serviceName] + path, requestData, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
                 break;
         }
     }
     kony.sdk.processLogicErrorResponse = function(err, isAsync, callBack) {
         if (kony.sdk.metric) {
             if (kony.sdk.metric.errorCodeMap[err.opstatus]) {
                 kony.sdk.metric.saveInDS();
             }
         }
         if (err[kony.sdk.constants.MF_CODE]) {
             var konyRef = kony.sdk.getCurrentInstance();
             //clear the cache if the error code related to session/token expiry
             if (kony.sdk.isSessionOrTokenExpired(err[kony.sdk.constants.MF_CODE])) {
                 kony.sdk.logsdk.warn("###LogicService::invokeOperationFailure  Session/Token expired. Authenticate and Try again");
                 //kony.sdk.resetCacheKeys(konyRef);
             }
         }
         if (!isAsync) {
             return kony.sdk.error.getLogicErrObj(err);
         } else if (callBack) {
             kony.sdk.verifyAndCallClosure(callBack, kony.sdk.error.getLogicErrObj(err));
         }
     };
 };
 kony.sdk.prototype.registerObjectService = function(objectServiceType, objectServiceClass) {
     kony.sdk.logsdk.trace("Entering kony.sdk.prototype.registerObjectService");
     kony.sdk.registeredobjsvcs = kony.sdk.registeredobjsvcs || {};
     kony.sdk.registeredobjsvcs[objectServiceType] = objectServiceClass;
 };
 /**
  * Method to create the object service instance with the provided service name.
  * @param {string} serviceName - Name of the service
  * @param {map} options - Map of key values like {"access":"offline"/"online"/"registered Object Service Name"}
  * @returns {@link kony.sdk.OnlineObjectService / @link kony.sdk.OfflineObjectService} Object service instance
  * @throws Exception if the serviceName or access is invalid.
  */
 kony.sdk.prototype.getObjectService = function(serviceName, options) {
     kony.sdk.logsdk.trace("Entering kony.sdk.prototype.getObjectService");
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Object service - " + serviceName);
     }
     var access;
     if (!kony.sdk.isNullOrUndefined(options)) {
         access = options["access"];
     }
     if (this.objectsvc != null && this.objectsvc[serviceName] != null) {
         kony.sdk.logsdk.debug("### getObjectService::found Object service" + this.objectsvc[serviceName]);
         if (kony.sdk.util.isNullOrEmptyString(access) || access.toLowerCase() === "online") {
             return new kony.sdk.OnlineObjectService(this, serviceName, this.objectsvc[serviceName]);
         } else if (access.toLowerCase() === "offline") {
             //This returns SyncV1 object service
             return new kony.sdk.OfflineObjectService(this, serviceName);
         }
     } else if (this.offlineObjectsvc != null) {
         if (this.offlineObjectsvc[serviceName] != null) {
             if (kony.sdk.util.isNullOrEmptyString(access) || access.toLowerCase() === "online") {
                 // This returns Online Object Service Instance
                 return new kony.sdk.OnlineObjectService(this, serviceName, this.offlineObjectsvc[serviceName]);
             } else if (access.toLowerCase() === "offline") {
                 //This returns Offline Enabled or SyncV2 object service
                 return new kony.sdk.OfflineEnabledObjectService(this, serviceName);
             }
         }
     }
     kony.sdk.registeredobjsvcs = kony.sdk.registeredobjsvcs || {};
     //verifying if the servicetype available in registeredservices if available initialize and return
     if (kony.sdk.registeredobjsvcs[access] != null && kony.sdk.registeredobjsvcs[access] != undefined) {
         return new kony.sdk.registeredobjsvcs[access](this, serviceName);
     }
     throw new Exception(kony.sdk.errorConstants.OBJECT_FAILURE, "Invalid serviceName:" + serviceName + "or access type:" + access);
 };
 /**
  * Method which returns the online ObjectService object
  * @param konyRef
  * @param serviceName
  * @constructor
  */
 kony.sdk.OnlineObjectService = function(konyRef, serviceName, serviceInfo) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService");
     this.konyRef = konyRef;
     this.serviceName = serviceName;
     this.serviceInfo = serviceInfo;
     this.dataUrl = null;
     this.binaryUrl = null;
     this.fileStorageObjectServiceUrl = null;
     this.operationsUrl = null;
     this.metadataUrl = null;
     this.version = null;
     var currentObject = this;
     /**
      * This method is used to create a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.create = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.create");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
             }
         }
         var tmpDataUrl = this.getDataUrl();
         var objName = options["dataObject"].objectName;

         function createOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(result) {
                 _create(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::create Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             createOperationHandler();
         } else {
             kony.sdk.claimsRefresh(createOperationHandler, failureCallback);
         }
     };
     /**
      * This method is used to fetch a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.fetch = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.fetch");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
             }
         }
         var tmpDataUrl = this.getDataUrl();
         var objName = options["dataObject"].objectName;

         function fetchOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(result) {
                 _fetch(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::fetch Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             fetchOperationHandler();
         } else {
             kony.sdk.claimsRefresh(fetchOperationHandler, failureCallback);
         }
     };
     /**
      * This method is used to update a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.update = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.update");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var tmpDataUrl = this.getDataUrl();
         var objName = options["dataObject"].objectName;

         function updateOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(result) {
                 _update(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::update Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             updateOperationHandler();
         } else {
             kony.sdk.claimsRefresh(updateOperationHandler, failureCallback);
         }
     };
     /**
      * This method is used to partial update a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.partialUpdate = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.partialUpdate");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var tmpDataUrl = this.getDataUrl();
         var objName = options["dataObject"].objectName;

         function partialUpdateOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(result) {
                 _partialUpdate(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::partialUpdate Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             partialUpdateOperationHandler();
         } else {
             kony.sdk.claimsRefresh(partialUpdateOperationHandler, failureCallback);
         }
     };
     /**
      * This method is used to delete a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.deleteRecord = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.deleteRecord");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var tmpDataUrl = this.getDataUrl();
         var objName = options["dataObject"].objectName;

         function deleteOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(result) {
                 _deleteRecord(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::delete Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             deleteOperationHandler();
         } else {
             kony.sdk.claimsRefresh(deleteOperationHandler, failureCallback);
         }
     };
     /**
      * This method is used to for performing custom operation
      * @param {string} verbName -  custom verb identifier
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.customVerb = function(verbName, options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.customVerb");
         if (verbName == null || verbName == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "verbName" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var tmpDataUrl = this.getOperationsUrl();
         var objName = options["dataObject"].objectName;

         function customVerbHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(result) {
                 _customverb(verbName, options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::customverb Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             customVerbHandler();
         } else {
             kony.sdk.claimsRefresh(customVerbHandler, failureCallback);
         }
     };
     /**
      * This method is used to retrive metadata of all objects
      * @param {map} options - includes {"getFromServer":boolean,"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.getMetadataOfAllObjects = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.getMetadataOfAllObjects");
         _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, null, options, successCallback, failureCallback);
         kony.sdk.logsdk.trace("Exiting kony.sdk.OnlineObjectService.getMetadataOfAllObjects");
     };
     /**
      * This method is used to retrive metadata of a specific object
      * @param objectName
      * @param {map} options - includes {"getFromServer":boolean,"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.getMetadataOfObject = function(objectName, options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.getMetadataOfObject");
         _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, objectName, options, successCallback, failureCallback);
         kony.sdk.logsdk.trace("Exiting kony.sdk.OnlineObjectService.getMetadataOfObject");
     };
     this.getDataUrl = function() {
         if (kony.sdk.isNullOrUndefined(currentObject.dataUrl)) {
             currentObject.dataUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["url"] + "/objects/", "/"));
         }
         return currentObject.dataUrl;
     };
     this.getFileStorageObjectServiceUrl = function() {
         if (kony.sdk.isNullOrUndefined(currentObject.fileStorageObjectServiceUrl)) {
             currentObject.fileStorageObjectServiceUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["url"], "/"));
         }
         return currentObject.fileStorageObjectServiceUrl;
     };
     this.getBinaryUrl = function() {
         if (kony.sdk.isNullOrUndefined(currentObject.binaryUrl)) {
             currentObject.binaryUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["url"] + "/binary/", "/"));
         }
         return currentObject.binaryUrl;
     };
     this.getOperationsUrl = function() {
         if (kony.sdk.isNullOrUndefined(currentObject.operationsUrl)) {
             currentObject.operationsUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["url"] + "/operations/", "/"));
         }
         return currentObject.operationsUrl;
     };
     this.getMetadataUrl = function() {
         if (kony.sdk.isNullOrUndefined(currentObject.metadataUrl)) {
             currentObject.metadataUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["metadata_url"], "/"));
         }
         return currentObject.metadataUrl;
     };
     this.getVersion = function() {
         if (kony.sdk.isNullOrUndefined(currentObject.version)) {
             currentObject.version = currentObject.serviceInfo["version"];
         }
         return currentObject.version;
     };
     /*
      *  API for uploading binary data (either file or raw bytes) to backend
      */
     this.uploadBinaryData = function(options, onFileUploadStartedCallback, onChunkUploadCompletedCallback, onFileUploadCompletedCallback, onFileUploadFailureCallback) {
         var fileUploadStartedCallback = null;
         var chunkUploadCompletedCallback = null;
         var fileUploadCompletedCallback = null;
         var fileUploadFailureCallback = null;
         var uploadParams = null;
         /* validations for callbacks */
         // validation for onFileUploadStartedCallback
         if (kony.sdk.isNullOrUndefined(onFileUploadStartedCallback) || (typeof(onFileUploadStartedCallback) !== 'function')) {
             kony.sdk.logsdk.warn("### OnlineObjectService::uploadBinaryData onFileUploadStartedCallback is null or undefined or not a function");
         } else {
             fileUploadStartedCallback = onFileUploadStartedCallback;
         }
         // validation for onChunkUploadCompletedCallback
         if (kony.sdk.isNullOrUndefined(onChunkUploadCompletedCallback) || (typeof(onChunkUploadCompletedCallback) !== 'function')) {
             kony.sdk.logsdk.warn("### OnlineObjectService::uploadBinaryData onChunkUploadCompletedCallback is null or undefined or not a function");
         } else {
             chunkUploadCompletedCallback = onChunkUploadCompletedCallback;
         }
         // validation for onFileUploadCompletedCallback
         if (kony.sdk.isNullOrUndefined(onFileUploadCompletedCallback) || (typeof(onFileUploadCompletedCallback) !== 'function')) {
             kony.sdk.logsdk.warn("### OnlineObjectService::uploadBinaryData onFileUploadCompletedCallback is null or undefined or not a function");
         } else {
             fileUploadCompletedCallback = onFileUploadCompletedCallback;
         }
         // validation for onFileUploadFailureCallback
         if (kony.sdk.isNullOrUndefined(onFileUploadFailureCallback) || (typeof(onFileUploadFailureCallback) !== 'function')) {
             kony.sdk.logsdk.warn("### OnlineObjectService::uploadBinaryData onFileUploadFailureCallback is null or undefined or not a function");
         } else {
             fileUploadFailureCallback = onFileUploadFailureCallback;
         }
         // validation for options
         if (kony.sdk.isNullOrUndefined(options)) {
             kony.sdk.logsdk.error("### OnlineObjectService::uploadBinaryData options is null or undefined");
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options " + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         var dataObject = options["dataObject"];
         if (kony.sdk.isNullOrUndefined(dataObject)) {
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         var objName = dataObject.getObjectName();
         var mfEndpointUrl = this.getDataUrl() + "/" + objName;
         if (kony.sdk.isNullOrUndefined(dataObject.getRecord())) {
             kony.sdk.logsdk.error("### OnlineObjectService::uploadBinaryData Error: Please provide record to upload Binary content.");
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }
         uploadParams = dataObject.getRecord();
         var errorObj = kony.sdk.binary.validateUploadParams(uploadParams);
         if (errorObj) {
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, errorObj);
             return;
         }
         // if rawbytes are provided, converting to base64 string as FFI can only receive base datatypes
         if (!kony.sdk.isNullOrUndefined(uploadParams[kony.sdk.constants.RAW_BYTES])) {
             var base64String = kony.convertToBase64(uploadParams[kony.sdk.constants.RAW_BYTES]);
             uploadParams[kony.sdk.constants.RAW_BYTES] = base64String;
         }

         function uploadBinaryDataOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(response) {
                 _uploadBinaryData(mfEndpointUrl, uploadParams, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::uploadBinaryData Error:", error);
                 kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             uploadBinaryDataOperationHandler();
         } else {
             kony.sdk.claimsRefresh(uploadBinaryDataOperationHandler, fileUploadFailureCallback);
         }
     };
     /*
      * Helper method to perform file upload
      */
     function _uploadBinaryData(mfEndpointUrl, uploadParams, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback) {
         var uploadOptions = {};
         if (uploadParams) {
             //Extracting Mandatory Params from uploadParams before fetching template
             if (uploadParams[kony.sdk.constants.FILE_PATH]) {
                 uploadOptions[kony.sdk.constants.FILE_PATH] = uploadParams[kony.sdk.constants.FILE_PATH];
                 delete uploadParams[kony.sdk.constants.FILE_PATH];
             } else if (uploadParams[kony.sdk.constants.RAW_BYTES]) {
                 uploadOptions[kony.sdk.constants.RAW_BYTES] = uploadParams[kony.sdk.constants.RAW_BYTES];
                 delete uploadParams[kony.sdk.constants.RAW_BYTES];
             } else if (uploadParams[kony.sdk.constants.FILE_OBJECT]) {
                 uploadOptions[kony.sdk.constants.FILE_OBJECT] = uploadParams[kony.sdk.constants.FILE_OBJECT];
                 delete uploadParams[kony.sdk.constants.FILE_OBJECT]
             }
             uploadOptions["uploadParams"] = uploadParams;
         }
         var headers = {};
         if (!kony.sdk.skipAnonymousCall) {
             headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = kony.sdk.getCurrentInstance().currentClaimToken;
         }
         uploadOptions["headers"] = headers;
         uploadOptions["URL"] = mfEndpointUrl;
         kony.sdk.binary.uploadBinaryData(uploadOptions, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback);
     }
     this.getBinaryData = function(options, arg1, arg2, arg3, arg4, arg5) {
         var externalSource = true;
         var fileDownloadStartedCallback = null;
         var chunkDownloadCompletedCallback = null;
         var fileDownloadCompletedCallback = null;
         var downloadFailureCallback = null;
         var binaryAttributeName = null;
         if (kony.sdk.isNullOrUndefined(arg5)) {
             if (kony.sdk.isNullOrUndefined(arg1)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData fileDownloadStartedCallback is null or undefined");
             } else if (typeof(arg1) === 'function') {
                 fileDownloadStartedCallback = arg1;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for fileDownloadStartedCallback");
             }
             if (kony.sdk.isNullOrUndefined(arg2)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData chunkDownloadCompletedCallback is null or undefined");
             } else if (typeof(arg2) === 'function') {
                 chunkDownloadCompletedCallback = arg2;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for chunkDownloadCompletedCallback");
             }
             if (kony.sdk.isNullOrUndefined(arg3)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData fileDownloadCompletedCallback is null or undefined");
             } else if (typeof(arg3) === 'function') {
                 fileDownloadCompletedCallback = arg3;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for fileDownloadCompletedCallback");
             }
             if (kony.sdk.isNullOrUndefined(arg4)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData downloadFailureCallback is null or undefined");
             } else if (typeof(arg4) === 'function') {
                 downloadFailureCallback = arg4;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for downloadFailureCallback");
             }
         } else {
             binaryAttributeName = arg1;
             externalSource = false;
             if (kony.sdk.isNullOrUndefined(arg2)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData fileDownloadStartedCallback is null or undefined");
             } else if (typeof(arg2) === 'function') {
                 fileDownloadStartedCallback = arg2;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for fileDownloadStartedCallback");
             }
             if (kony.sdk.isNullOrUndefined(arg3)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData chunkDownloadCompletedCallback is null or undefined");
             } else if (typeof(arg3) === 'function') {
                 chunkDownloadCompletedCallback = arg3;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for chunkDownloadCompletedCallback");
             }
             if (kony.sdk.isNullOrUndefined(arg4)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData fileDownloadCompletedCallback is null or undefined");
             } else if (typeof(arg4) === 'function') {
                 fileDownloadCompletedCallback = arg4;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for fileDownloadCompletedCallback");
             }
             if (kony.sdk.isNullOrUndefined(arg5)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData downloadFailureCallback is null or undefined");
             } else if (typeof(arg5) === 'function') {
                 downloadFailureCallback = arg5;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for downloadFailureCallback");
             }
         }
         if (kony.sdk.getSdkType() !== kony.sdk.constants.SDK_TYPE_IDE && kony.sdk.getAType() !== kony.sdk.constants.SDK_ATYPE_NATIVE) {
             kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_api, kony.sdk.errormessages.invalid_api + "platform :" + kony.sdk.getSdkType().toString()));
             return;
         }
         if (kony.sdk.isNullOrUndefined(options)) {
             kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         var tmpDataUrl = null;
         if (externalSource) {
             tmpDataUrl = this.getDataUrl();
         } else {
             tmpDataUrl = this.getBinaryUrl();
         }
         var dataObject = options["dataObject"];
         if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(kony.sdk.isNullOrUndefined(options["queryParams"]))) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var objName = dataObject.getObjectName();
         var streamingFlag = false;
         if (!kony.sdk.isNullOrUndefined(options["streaming"]) && options["streaming"] === true) {
             streamingFlag = true;
         }
         if (!externalSource) {
             if (kony.sdk.isNullOrUndefined(binaryAttributeName) || typeof(binaryAttributeName) !== "string") {
                 kony.sdk.logsdk.error("### OnlineObjectService::getBinaryData Error: Please provide column name to fetch binary content");
                 kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj("90000", "Please provide column name to fetch binary content"));
                 return;
             } else {
                 options["binaryAttrName"] = binaryAttributeName;
             }
         }
         if (kony.sdk.isNullOrUndefined(dataObject.getRecord())) {
             kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryData Error: Please provide primary key details or fileParams to get Binary content.");
             kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }

         function getBinaryDataOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(response) {
                 _getBinaryData(options, tmpDataUrl, externalSource, streamingFlag, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::getBinaryData Error:", error);
                 kony.sdk.verifyAndCallClosure(downloadFailureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             getBinaryDataOperationHandler();
         } else {
             kony.sdk.claimsRefresh(getBinaryDataOperationHandler, downloadFailureCallback);
         }
     };
     /**
      * Helps to get the binary content of the specified column on the Object
      * @param {map} options - includes {"dataObject":{@link kony.sdk.dto.DataObject}, "binaryAttrName":columnName}
      * @param successCallback
      * @param failureCallback
      */
     this.getBinaryContent = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.getBinaryContent");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         var tmpDataUrl = this.getBinaryUrl();
         var dataObject = options["dataObject"];
         if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var objName = dataObject.getObjectName();
         var binaryColName = options["binaryAttrName"];
         if (binaryColName == null || binaryColName == undefined) {
             kony.sdk.logsdk.error("### OnlineObjectService::getBinaryContent Error: Please provide column name to fetch binary content");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Please provide column name to fetch binary content"));
             return;
         }

         function getBinaryContentOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(response) {
                 _getBinaryContent(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::getBinaryContent Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             getBinaryContentOperationHandler();
         } else {
             kony.sdk.claimsRefresh(getBinaryContentOperationHandler, failureCallback);
         }
     };
     /**
      * Helps to create the binary content of the specified column on the Object
      * @param {map} options - includes {"dataObject": {@link kony.sdk.dto.DataObject}, "binaryAttrName":columnName}
      * @param successCallback
      * @param failureCallback
      */
     this.createBinaryContent = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.createBinaryContent");
         var tmpDataUrl = this.getBinaryUrl();
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         var dataObject = options["dataObject"];
         if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var objName = dataObject.getObjectName();
         var binaryColName = options["binaryAttrName"];
         if (binaryColName == null || binaryColName == undefined) {
             kony.sdk.logsdk.error("### OnlineObjectService::createBinaryContent Error: Please provide column name to create binary content");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("900000", "Please provide column name to create binary content"));
             return;
         }

         function createBinaryContentOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(response) {
                 _createBinaryContent(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::createBinaryContent Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             createBinaryContentOperationHandler();
         } else {
             kony.sdk.claimsRefresh(createBinaryContentOperationHandler, failureCallback);
         }
     };
     /**
      * Helps to update the binary content of the specified column on the Object
      * @param {map} options - includes {"dataObject": {@link kony.sdk.dto.DataObject}, "binaryAttrName":columnName}
      * @param successCallback
      * @param failureCallback
      */
     this.updateBinaryContent = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.updateBinaryContent");
         var tmpDataUrl = this.getBinaryUrl();
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         var dataObject = options["dataObject"];
         if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var objName = dataObject.getObjectName();
         var binaryColName = options["binaryAttrName"];
         if (binaryColName == null || binaryColName == undefined) {
             kony.sdk.logsdk.error("### OnlineObjectService::updateBinaryContent Error: Please provide column name to create binary content");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Please provide column name to create binary content"));
             return;
         }

         function updateBinaryContentOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(response) {
                 _updateBinaryContent(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::updateBinaryContent Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             updateBinaryContentOperationHandler();
         } else {
             kony.sdk.claimsRefresh(updateBinaryContentOperationHandler, failureCallback);
         }
     };

     function _getBinaryContent(options, tmpDataUrl, successCallback, failureCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var binaryColName = options["binaryAttrName"];
         var objName = dataObject.getObjectName();
         var queryParams = options["queryParams"];
         var url = tmpDataUrl + "/" + objName;
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objName);
         if (objMetadata.primaryKey != undefined && objMetadata.primaryKey != null) {
             var pkCount = objMetadata.primaryKey.length;
             if (pkCount == 0) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             //reading primarykey and framing filter clause
             var pkey = objMetadata.primaryKey[0];
             if (dataObject.getRecord()[pkey] == undefined || dataObject.getRecord()[pkey] == null) {
                 kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryContent Error: Please provide primary key details to get Binary content.");
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             url = url + "?" + pkey + "=" + dataObject.getRecord()[pkey];
             //passing binary column name to server
             if (binaryColName != null && binaryColName != undefined) {
                 url = url + "&fieldName=" + binaryColName;
             }
             if (queryParams != undefined && queryParams != null) {
                 url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
             }
         } else {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_getBinaryContent::invokeSuccessCallback Response:", response);
             kony.sdk.verifyAndCallClosure(successCallback, response["data"]);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryContent::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
         invokeObjectOperation(url, dataObject.getObjectName(), headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, checkAndFetchNetworkProviderOptions(options));
     }

     function _getBinaryData(options, tmpDataUrl, externalSource, streamingFlag, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var binaryColName = options["binaryAttrName"];
         var objName = dataObject.getObjectName();
         var queryParams = options["queryParams"];
         var url = tmpDataUrl + "/" + objName;
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objName);
         if (!externalSource) {
             if (!kony.sdk.isNullOrUndefined(objMetadata.primaryKey)) {
                 var pkCount = objMetadata.primaryKey.length;
                 if (pkCount == 0) {
                     kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                     return;
                 }
                 //reading primarykey and framing filter clause
                 var pkey = objMetadata.primaryKey[0];
                 if (kony.sdk.isNullOrUndefined(dataObject.getRecord()[pkey])) {
                     kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryData Error: Please provide primary key details to get Binary content.");
                     kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                     return;
                 }
                 url = url + "?" + pkey + "=" + dataObject.getRecord()[pkey];
                 //passing binary column name to server
                 if (!kony.sdk.isNullOrUndefined(binaryColName)) {
                     url = url + "&fieldName=" + binaryColName;
                 }
                 url = url + "&type=bytes";
                 if (!kony.sdk.isNullOrUndefined(queryParams)) {
                     url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
                 }
             } else {
                 kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var headerKey in headers) {
                 if (!kony.sdk.isNullOrUndefined(headerKey)) {
                     if (headerKey.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) {
                         isKonyApiVersionAvailable = true;
                         headers[kony.sdk.constants.API_VERSION_HEADER] = headers[headerKey];
                     }
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_getBinaryData::invokeSuccessCallback Response:", response);
             var downloadConfig = response["records"][0];
             downloadConfig.httpStatusCode = response.httpStatusCode;
             if (options && options["ChunkSize"]) {
                 downloadConfig.ChunkSize = options["ChunkSize"];
             }
             var fileParams = dataObject.getRecord();
             if (kony.sdk.isNullOrUndefined(fileParams["fileId"])) {
                 fileParams["fileId"] = new Date().getTime().toString();
             }
             kony.sdk.binary.getBinaryData(fileParams, streamingFlag, downloadConfig, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryData::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(downloadFailureCallback, error);
         }
         if (externalSource) {
             invokeObjectOperation(url, dataObject.getObjectName(), headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, checkAndFetchNetworkProviderOptions(options));
         } else {
             var fileParams = dataObject.getRecord();
             if (kony.sdk.isNullOrUndefined(fileParams["fileId"])) {
                 fileParams["fileId"] = dataObject.getRecord()[pkey];
             }
             if (!kony.sdk.skipAnonymousCall) {
                 headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = kony.sdk.getCurrentInstance().currentClaimToken;
             }
             var downloadConfig = {};
             downloadConfig["endpointUrl"] = url;
             downloadConfig["headers"] = headers;
             //for bypasing template call we need to add method and httpstatus code 309
             downloadConfig.method = kony.sdk.constants.HTTP_METHOD_GET;
             downloadConfig.httpStatusCode = kony.sdk.binary.constants.VALID_HTTP_REDIRECT_CODE;
             if (options && options["ChunkSize"]) {
                 downloadConfig.ChunkSize = options["ChunkSize"];
             }
             kony.sdk.binary.getBinaryData(fileParams, streamingFlag, downloadConfig, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback);
         }
     }

     function _createBinaryContent(options, tmpDataUrl, successCallback, failureCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var binaryColName = options["binaryAttrName"];
         var objName = dataObject.getObjectName();
         var queryParams = options["queryParams"];
         var url = tmpDataUrl + "/" + objName;
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objName);
         var jsonPayload = {};
         var pkey;
         if (objMetadata.primaryKey != undefined && objMetadata.primaryKey != null) {
             var pkCount = objMetadata.primaryKey.length;
             if (pkCount == 0) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             //reading primarykey and framing filter clause
             pkey = objMetadata.primaryKey[0];
             if (dataObject.getRecord()[pkey] == undefined || dataObject.getRecord()[pkey] == null) {
                 kony.sdk.logsdk.error("### OnlineObjectService::_createBinaryContent Error: Please provide primary key details to create Binary content.");
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             jsonPayload[pkey] = dataObject.getRecord()[pkey];
             jsonPayload["data"] = dataObject.getRecord()[binaryColName];
             jsonPayload["fieldName"] = binaryColName;
         } else {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         var formData = new kony.sdk.getFormData(jsonPayload);
         if (!kony.sdk.isNullOrUndefined(queryParams)) {
             kony.sdk.updateFormData(formData, "queryparams", queryParams);
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_createBinaryContent::invokeSuccessCallback Response:", response);
             kony.sdk.verifyAndCallClosure(successCallback, response[pkey]);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_createBinaryContent::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
         invokeObjectOperation(url, dataObject.getObjectName(), headers, formData, null, invokeSuccessCallback, invokeFailureCallback, checkAndFetchNetworkProviderOptions(options));
     }

     function _updateBinaryContent(options, tmpDataUrl, successCallback, failureCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var binaryColName = options["binaryAttrName"];
         var objName = dataObject.getObjectName();
         var queryParams = options["queryParams"];
         var url = tmpDataUrl + "/" + objName;
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objName);
         var jsonPayload = {};
         var pkey;
         if (objMetadata.primaryKey != undefined && objMetadata.primaryKey != null) {
             var pkCount = objMetadata.primaryKey.length;
             if (pkCount == 0) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             //reading primarykey and framing filter clause
             pkey = objMetadata.primaryKey[0];
             if (dataObject.getRecord()[pkey] == undefined || dataObject.getRecord()[pkey] == null) {
                 kony.sdk.logsdk.error("### OnlineObjectService::_updateBinaryContent Error: Please provide primary key details to create Binary content.");
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             jsonPayload[pkey] = dataObject.getRecord()[pkey];
             jsonPayload["data"] = dataObject.getRecord()[binaryColName];
             jsonPayload["fieldName"] = binaryColName;
         } else {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         headers["X-HTTP-Method-Override"] = "PUT";
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         var formData = new kony.sdk.getFormData(jsonPayload);
         if (queryParams != undefined && queryParams != null) {
             kony.sdk.updateFormData(formData, "queryparams", queryParams);
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_updateBinaryContent::invokeSuccessCallback Response:", response);
             kony.sdk.verifyAndCallClosure(successCallback, response[pkey]);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_updateBinaryContent::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
         invokeObjectOperation(url, dataObject.getObjectName(), headers, formData, null, invokeSuccessCallback, invokeFailureCallback, checkAndFetchNetworkProviderOptions(options));
     }

     function _create(options, tmpDataUrl, successCallback, failureCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var url = tmpDataUrl + "/" + dataObject.objectName;
         var record = dataObject.getRecord();
         var queryParams = options["queryParams"];
         if (record == null || record == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "record " + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         var formData = new kony.sdk.getFormData(record);
         if (queryParams != undefined && queryParams != null) {
             kony.sdk.updateFormData(formData, "queryparams", queryParams);
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_create::invokeSuccessCallback Response:", response);
             kony.sdk.verifyAndCallClosure(successCallback, response);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_create::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(failureCallback, error)
         }
         invokeObjectOperation(url, dataObject.objectName, headers, formData, null, invokeSuccessCallback, invokeFailureCallback, checkAndFetchNetworkProviderOptions(options));
     }

     function _fetch(options, tmpDataUrl, successCallback, serviceErrorCallback) {
         var dataObject = options["dataObject"];
         var odataqueryStr = dataObject.getOdataUrl();
         var headers = options["headers"];
         var queryParams = options["queryParams"];
         var url = tmpDataUrl + "/" + dataObject.objectName;
         if (odataqueryStr != undefined && odataqueryStr != null) {
             url = url + "?" + encodeURI(odataqueryStr);
             if (queryParams != undefined && queryParams != null) {
                 url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
             }
         } else if (queryParams != undefined && queryParams != null) {
             url = url + "?" + kony.sdk.util.objectToQueryParams(queryParams);
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         // If useCache is enabled and cacheID is present then network call will be skipped and cached response will be returned.
         if (options && options["useCache"] && options["cacheID"]) {
             var cacheResponse = new kony.sdk.ClientCache().get(options["cacheID"]);
             if (cacheResponse) {
                 kony.sdk.logsdk.debug("### OnlineObjectService::_fetch:: key found in cache, invokeSuccessCallback Response:", cacheResponse);
                 kony.sdk.verifyAndCallClosure(successCallback, cacheResponse);
                 return;
             }
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_fetch::invokeSuccessCallback Response:", response);
             // If useCache is enabled then the response is cached and returned.
             if (options && options["useCache"]) {
                 cacheResponseForKey(options, url, {
                     "objectName": dataObject.objectName
                 }, response);
             }
             kony.sdk.verifyAndCallClosure(successCallback, response);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_fetch::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
         }
         invokeObjectOperation(url, dataObject.objectName, headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, checkAndFetchNetworkProviderOptions(options));
     }

     function _update(options, tmpDataUrl, updateServiceCallback, serviceErrorCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var url = tmpDataUrl + "/" + dataObject.objectName;
         var queryParams = options["queryParams"];
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         headers["X-HTTP-Method-Override"] = "PUT";
         var formData = new kony.sdk.getFormData(dataObject.getRecord());
         if (queryParams != undefined && queryParams != null) {
             kony.sdk.updateFormData(formData, "queryparams", queryParams);
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_update::invokeSuccessCallback Response:", response);
             kony.sdk.verifyAndCallClosure(updateServiceCallback, response);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_update::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
         }
         invokeObjectOperation(url, dataObject.objectName, headers, formData, null, invokeSuccessCallback, invokeFailureCallback, checkAndFetchNetworkProviderOptions(options));
     }

     function _partialUpdate(options, tmpDataUrl, partialUpdateServiceCallback, serviceErrorCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var url = tmpDataUrl + "/" + dataObject.objectName;
         var queryParams = options["queryParams"];
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         headers["X-HTTP-Method-Override"] = "PATCH";
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         var formData = new kony.sdk.getFormData(dataObject.getRecord());
         if (queryParams != undefined && queryParams != null) {
             kony.sdk.updateFormData(formData, "queryparams", queryParams);
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_partialUpdate::invokeSuccessCallback Success Response:", response);
             kony.sdk.verifyAndCallClosure(partialUpdateServiceCallback, response);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_partialUpdate::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
         }
         invokeObjectOperation(url, dataObject.objectName, headers, formData, null, invokeSuccessCallback, invokeFailureCallback, checkAndFetchNetworkProviderOptions(options));
     }

     function _deleteRecord(options, tmpDataUrl, deleteSuccessCallback, serviceErrorCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, dataObject.objectName);
         var url = tmpDataUrl + "/" + dataObject.objectName;
         var queryParams = options["queryParams"];
         var odataUrl = "";
         if (objMetadata.primaryKey != undefined && objMetadata.primaryKey != null) {
             var pkCount = objMetadata.primaryKey.length;
             for (var i = 0; i < pkCount; i++) {
                 //reading primarykey and framing filter clause
                 var pkey = objMetadata.primaryKey[i];
                 if (dataObject.getRecord()[pkey] == undefined || dataObject.getRecord()[pkey] == null) {
                     kony.sdk.logsdk.error("### OnlineObjectService::_delete Error: Please provide all primary keys to process the request");
                     kony.sdk.verifyAndCallClosure(serviceErrorCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                     return;
                 }
                 if (i == 0) {
                     odataUrl = "?$filter=" + pkey + " eq '" + dataObject.getRecord()[pkey] + "'";
                 } else {
                     //appending the condition incase of composite primary key
                     odataUrl = odataUrl + " and " + pkey + " eq '" + dataObject.getRecord()[pkey] + "'";
                 }
             }
         }
         url = url + encodeURI(odataUrl);
         if (queryParams != undefined && queryParams != null) {
             if (odataUrl && odataUrl.length != 0) {
                 url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
             } else {
                 url = url + "?" + kony.sdk.util.objectToQueryParams(queryParams);
             }
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         headers["X-HTTP-Method-Override"] = "DELETE";

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_delete::invokeSuccessCallback Response:", response);
             kony.sdk.verifyAndCallClosure(deleteSuccessCallback, response);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_delete::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
         }
         invokeObjectOperation(url, dataObject.objectName, headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, checkAndFetchNetworkProviderOptions(options));
     }

     function _customverb(verbName, options, tmpDataUrl, customVerbServiceCallback, serviceErrorCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var url = tmpDataUrl + "/" + dataObject.objectName + "/" + verbName;
         var queryParams = options["queryParams"];
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         var formData = new kony.sdk.getFormData(dataObject.getRecord());
         if (queryParams != undefined && queryParams != null) {
             kony.sdk.updateFormData(formData, "queryparams", queryParams);
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_customverb::invokeSuccessCallback Success Response:", response);
             kony.sdk.verifyAndCallClosure(customVerbServiceCallback, response);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_customverb::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
         }
         invokeObjectOperation(url, dataObject.objectName, headers, formData, null, invokeSuccessCallback, invokeFailureCallback, checkAndFetchNetworkProviderOptions(options));
     }
     this.getFileStorage = function() {
         // TODO : Fix this as there are issues with getMetadataOfAllObjects call - that was hanging	
         return kony.sdk.FileStorageClasses.import(this.getFileStorageObjectServiceUrl());
     };
 };

 function _getMetadataUrl(konyRef, serviceName) {
     var metadataUrl = null;
     if (konyRef.objectsvc[serviceName]) {
         metadataUrl = encodeURI(stripTrailingCharacter(konyRef.objectsvc[serviceName]["metadata_url"], "/"));
     } else if (konyRef.offlineObjectsvc[serviceName]) {
         metadataUrl = encodeURI(stripTrailingCharacter(konyRef.offlineObjectsvc[serviceName]["metadata_url"], "/"));
     }
     return metadataUrl;
 }

 function _getVersion(konyRef, serviceName) {
     var version = null;
     if (konyRef.objectsvc[serviceName]) {
         version = konyRef.objectsvc[serviceName]["version"];
     } else if (konyRef.offlineObjectsvc[serviceName]) {
         version = konyRef.offlineObjectsvc[serviceName]["version"];
     }
     return version;
 }
 /*This method is used to fetch metadata for Object/Objectservice.
  * It is fetched from cache first, if it not available in cache then fetches method data from metadata URL.
  */
 function _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, objectName, options, successCallback, failureCallback) {
     var tmpMetadataUrl = _getMetadataUrl(konyRef, serviceName);;
     if (!(kony.sdk.isNullOrUndefined(options)) && !(options["queryParams"] == null || options["queryParams"] == undefined)) {
         if (!(options["queryParams"] instanceof Object)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
         }
     }

     function getMetadataOfObjectOperationHandler() {
         _getMetadataForObjectOrService(konyRef, serviceName, objectName, options, tmpMetadataUrl, successCallback, failureCallback);
     }
     if (kony.sdk.skipAnonymousCall) {
         getMetadataOfObjectOperationHandler();
     } else {
         kony.sdk.claimsRefresh(getMetadataOfObjectOperationHandler, failureCallback);
     }
 }

 function _getMetadataForObjectOrService(konyRef, serviceName, objectName, options, tmpMetadataUrl, successCallback, failureCallback) {
     //if the getFromServer flag is true then get metadata from server even though its available in cache
     var getFromServer = false;
     var headers = null;
     var queryParams = null;
     if (options != null && options != undefined) {
         getFromServer = options["getFromServer"];
         headers = options["headers"];
         queryParams = options["queryParams"];
     }
     var tmpObjOrSvcMetadata = null;
     if (objectName) {
         tmpObjOrSvcMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objectName);
     } else {
         tmpObjOrSvcMetadata = kony.sdk.ObjectServiceUtil.getCachedMetadata(serviceName);
     }
     if (getFromServer != true && tmpObjOrSvcMetadata != null && tmpObjOrSvcMetadata != undefined) {
         kony.sdk.logsdk.debug("### OnlineObjectService::_getMetadataOfObject from KonyStore:", tmpObjOrSvcMetadata);
         kony.sdk.verifyAndCallClosure(successCallback, tmpObjOrSvcMetadata);
     } else {
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = _getVersion(konyRef, serviceName);
             }
         }
         var url = tmpMetadataUrl;
         var svcid = "metadata";
         if (objectName) {
             url = url + "/" + objectName;
             svcid = svcid + "_" + objectName;
         }
         if (queryParams != undefined && queryParams != null) {
             url = url + "?" + kony.sdk.util.objectToQueryParams(queryParams);
         }

         function invokeSuccessCallback(result) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_getMetadataForObjectOrService::invokeSuccessCallback Response:", result);
             if (objectName) {
                 var table = result["Metadata"]["table"];
                 kony.sdk.ObjectServiceUtil.cacheObjectMetadata(serviceName, table);
                 var tmpObjMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objectName);
                 kony.sdk.verifyAndCallClosure(successCallback, tmpObjMetadata);
             } else {
                 var tableArray = result["Metadata"]["tables"];
                 kony.sdk.ObjectServiceUtil.cacheMetadata(serviceName, tableArray);
                 var tmpMetadata = kony.sdk.ObjectServiceUtil.getCachedMetadata(serviceName);
                 kony.sdk.verifyAndCallClosure(successCallback, tmpMetadata);
             }
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_getMetadataForObjectOrService::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
         invokeObjectOperation(url, svcid, headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, checkAndFetchNetworkProviderOptions(options));
     }
 }

 function checkAndFetchNetworkProviderOptions(options) {
     var providerOptions = {};
     //Fetching httpRequestOptions
     if (options && options["httpRequestOptions"] && options["httpRequestOptions"] instanceof Object) {
         providerOptions["httpRequestOptions"] = options["httpRequestOptions"];
     }
     //Fetching XMLHttpRequestOptions
     if (options && options["xmlHttpRequestOptions"] && options["xmlHttpRequestOptions"] instanceof Object) {
         providerOptions["xmlHttpRequestOptions"] = options["xmlHttpRequestOptions"];
     }
     return providerOptions;
 }
 //Method is used to send http request for ObjectService operations
 function invokeObjectOperation(url, svcid, headers, formData, httpMethod, successCallback, failureCallback, networkProviderOptions) {
     kony.sdk.logsdk.trace("Entering invokeObjectOperation");
     var networkProvider = new konyNetworkProvider();
     var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(svcid);
     var defaultHeaders = {};
     if (!httpMethod) {
         //default http method is post
         httpMethod = "POST";
     }
     if (!kony.sdk.skipAnonymousCall) {
         // Check to find if the service is public or not, in case of public service no token is required.
         defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
     }
     defaultHeaders[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
     defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON;
     var deviceId = kony.sdk.getDeviceId();
     if (!kony.sdk.isNullOrUndefined(deviceId)) {
         defaultHeaders[kony.sdk.constants.DEVICEID_HEADER] = deviceId;
     }
     if (reportingData != null && reportingData != undefined) {
         try {
             defaultHeaders[kony.sdk.constants.REPORTING_HEADER] = reportingData;
         } catch (error) {
             kony.sdk.logsdk.error("### invokeObjectOperation::error while parsing metrics payload" + error);
         }
     }
     // if the user has defined his own headers, use them
     if (headers) {
         var tempHeader = "";
         for (var header in headers) {
             if (kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT.toLowerCase() === header.toLowerCase()) {
                 //Accept can be multiple
                 //Reason being client can be programmed to accept more than one type of content from server.
                 tempHeader = kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT;
                 if (defaultHeaders[tempHeader].toLowerCase() !== headers[header].toLowerCase()) {
                     defaultHeaders[header] = defaultHeaders[tempHeader] + "," + headers[header];
                 }
             } else if (kony.sdk.constants.KONY_AUTHORIZATION_HEADER.toLowerCase() === header.toLowerCase()) {
                 tempHeader = kony.sdk.constants.KONY_AUTHORIZATION_HEADER;
                 if (defaultHeaders[tempHeader] !== headers[header]) {
                     defaultHeaders[tempHeader] = headers[header];
                 }
             } else if ("content-type" === header.toLowerCase()) {
                 tempHeader = kony.sdk.constants.HTTP_CONTENT_HEADER;
                 //Content-type can and should be a single value.
                 //Reason being client can only send a single kind of content at a single instance
                 if (defaultHeaders[tempHeader].toLowerCase() !== headers[header].toLowerCase()) {
                     defaultHeaders[tempHeader] = headers[header];
                 }
             } else {
                 if (defaultHeaders[header] !== headers[header]) {
                     defaultHeaders[header] = headers[header];
                 }
             }
         }
     }

     function networksuccess(res) {
         kony.sdk.logsdk.trace("Entering networksuccess");
         kony.sdk.verifyAndCallClosure(successCallback, res);
     }

     function networkerror(xhr, status, err) {
         kony.sdk.logsdk.trace("Entering networkerror");
         if (xhr && !(status && err)) {
             err = xhr;
         }
         if (err[kony.sdk.constants.MF_CODE]) {
             var konyRef = kony.sdk.getCurrentInstance();
             //clear the cache if the error code related to session/token expiry
             if (kony.sdk.isSessionOrTokenExpired(err[kony.sdk.constants.MF_CODE])) {
                 kony.sdk.logsdk.warn("###ObjectService::invokeObjectOperationFailure  Session/Token expired. Authenticate and Try again");
                 //kony.sdk.resetCacheKeys(konyRef);
             }
         }
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getObjectServiceErrObj(err));
     }
     if (httpMethod === "GET") {
         networkProvider.get(url, null, defaultHeaders, networksuccess, networkerror, "formdata", networkProviderOptions);
     } else {
         networkProvider.post(url, formData, defaultHeaders, networksuccess, networkerror, "formdata", networkProviderOptions);
     }
 }
 kony.sdk.util = kony.sdk.util || {};
 kony.sdk.ObjectServiceUtil = kony.sdk.ObjectServiceUtil || {};
 kony.sdk.dto = kony.sdk.dto || {};
 kony.sdk.constants.DateTimeType = {
     TODAY: "TODAY",
     YESTERDAY: "YESTERDAY",
     TOMORROW: "TOMORROW",
     CURRENTWEEK: "CURRENTWEEK",
     LASTWEEK: "LASTWEEK",
     NEXTWEEK: "NEXTWEEK",
     CURRENTMONTH: "CURRENTMONTH",
     LASTMONTH: "LASTMONTH",
     NEXTMONTH: "NEXTMONTH"
 };
 kony.sdk.constants.Aggregation = {
     NONE: "",
     COUNT: "COUNT",
     SUM: "SUM",
     MAX: "MAX",
     MIN: "MIN",
     AVG: "AVG"
 };
 kony.sdk.constants.OrderType = {
     ASCENDING: "ASC",
     DESCENDING: "DESC"
 };
 kony.sdk.constants.MatchType = {
     EQUALS: {
         value: "=",
         name: "EQUALS"
     },
     GREATER: {
         value: ">",
         name: "GREATER"
     },
     GREATEREQUAL: {
         value: ">=",
         name: "GREATEREQUAL"
     },
     LESS: {
         value: "<",
         name: "LESS"
     },
     LESSEQUAL: {
         value: "<=",
         name: "LESSEQUAL"
     },
     STARTSWITH: {
         value: "LIKE",
         name: "STARTSWITH"
     },
     CONTAINS: {
         value: "LIKE",
         name: "CONTAINS"
     },
     LIKE: {
         value: "LIKE",
         name: "LIKE"
     },
     ENDSWITH: {
         value: "LIKE",
         name: "ENDSWITH"
     },
     NOTEQUAL: {
         value: "<>",
         name: "NOTEQUAL"
     },
     ISNULL: {
         value: "IS NULL",
         name: "ISNULL"
     },
     ISNOTNULL: {
         value: "IS NOT NULL",
         name: "ISNOTNULL"
     }
 };
 kony.sdk.constants.JoinType = {
     INNER: "INNER",
     LEFT: "LEFT",
     RIGHT: "RIGHT"
 };
 kony.sdk.constants.Operator = {
     AND: "AND",
     OR: "OR"
 };
 kony.sdk.constants.ObjectServiceConstants = {
     DATAOBJECT: "dataObject",
     QUERYPARAMS: "queryParams"
 };
 /**
  * This is a utility function used to check whether the two strings provided
  * would match with each other.
  * @param string1
  * @param string2
  * @return boolean
  */
 kony.sdk.util.matchIgnoreCase = function(string1, string2) {
     if (string1 === null || string2 === null || string1 === undefined || string2 === undefined) {
         return false;
     }
     return (string1.toUpperCase() === string2.toUpperCase());
 };
 kony.sdk.util.isNull = function(val) {
     if (val === null || val === undefined) return true;
     val = val + "";
     return (kony.sdk.util.matchIgnoreCase(val, "null"));
 };
 kony.sdk.util.isValidNumberType = function(val) {
     if (kony.sdk.util.matchIgnoreCase(typeof val, "number")) return true;
     else if (kony.sdk.util.matchIgnoreCase(typeof val, "string") && null != kony.sdk.util.toNumber(val)) return true;
     else return false;
 };
 kony.sdk.util.toNumber = function(arg) {
     if (arguments.length != 1) {
         throw new Error("Invalid argument to kony.sdk.util.toNumber");
     }
     if (typeof(arg) === "number") {
         return arg;
     } else if (typeof(arg) === "string") {
         var str = arg.replace(/^\s*/, '').replace(/\s*$/, '');
         if (str === '') {
             return null;
         } else {
             var num = str - 0;
             return (isNaN(num) ? null : num);
         }
     } else {
         return null;
     }
 };
 kony.sdk.util.validateCriteriaObject = function(criteria) {
     if (criteria !== null && criteria !== undefined) {
         return (criteria instanceof kony.sdk.dto.Criteria || criteria instanceof kony.sdk.dto.Match || criteria instanceof kony.sdk.dto.Between || criteria instanceof kony.sdk.dto.LogicGroup || criteria instanceof kony.sdk.dto.And || criteria instanceof kony.sdk.dto.Or || criteria instanceof kony.sdk.dto.Not || criteria instanceof kony.sdk.dto.Expression || criteria instanceof kony.sdk.dto.InCriteria || criteria instanceof kony.sdk.dto.Exists || criteria instanceof kony.sdk.dto.Join);
     } else {
         return false;
     }
 };
 kony.sdk.ObjectServiceUtil.cacheMetadata = function(serviceName, objects) {
     if (objects !== undefined && objects !== null) {
         kony.sdk.dataStore.removeItem(serviceName);
         for (var i = 0; i < objects.length; i++) {
             var object = objects[i];
             //clearing the existing metadata of service and updating it with the latest metadata
             kony.sdk.ObjectServiceUtil.cacheObjectMetadata(serviceName, object);
         }
     }
 };
 kony.sdk.ObjectServiceUtil.cacheObjectMetadata = function(serviceName, object) {
     if (object !== undefined && object !== null) {
         //getting metadata of servicename
         var metadataOfAllObjs = kony.sdk.dataStore.getItem(serviceName);
         var jsonObject = JSON.parse('{}');
         //if metadata available get it
         if (metadataOfAllObjs !== null && metadataOfAllObjs !== undefined && metadataOfAllObjs !== "{}") {
             jsonObject = JSON.parse(metadataOfAllObjs);
         }
         //adding metadata of object to the existing metadata
         jsonObject[object.name] = object;
         var jsonStr = JSON.stringify(jsonObject);
         kony.sdk.dataStore.setItem(serviceName, jsonStr);
     }
 };
 kony.sdk.ObjectServiceUtil.getCachedMetadata = function(serviceName) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.ObjectServiceUtil.getCachedMetadata");
     var appMetadata = kony.sdk.util.getPackagedMetadata();
     if (appMetadata != null && appMetadata != undefined) {
         if (serviceName != undefined && serviceName != null) return appMetadata[serviceName];
     } else {
         //reading metadata from the store
         var jsonObject = null;
         var metadataOfAllObjs = kony.sdk.dataStore.getItem(serviceName);
         if (metadataOfAllObjs !== null && metadataOfAllObjs !== undefined && metadataOfAllObjs !== "{}") {
             jsonObject = JSON.parse(metadataOfAllObjs);
         }
         return jsonObject;
     }
     return null;
 };
 kony.sdk.ObjectServiceUtil.getCachedObjectMetadata = function(serviceName, objectName) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.ObjectServiceUtil.getCachedObjectMetadata");
     var objectMetadata;
     if (objectName !== undefined && objectName !== null) {
         var metadataOfAllObjs = kony.sdk.ObjectServiceUtil.getCachedMetadata(serviceName);
         var jsonObject = null;
         if (metadataOfAllObjs !== null && metadataOfAllObjs !== undefined && metadataOfAllObjs !== "{}") {
             jsonObject = metadataOfAllObjs;
             //getting the object's metadata from the stored metadata
             objectMetadata = jsonObject[objectName];
         }
     }
     return objectMetadata;
 };
 /**
  * An object used to perform CRUD operations on objects
  * @param objectName
  * @param record
  * @constructor
  */
 kony.sdk.dto.DataObject = function(objectName, record) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.DataObject");
     this.objectName = objectName;
     if (record != null && record != undefined) {
         this.record = record;
     } else {
         this.record = {};
     }
     this.odataUrl = null;
     this.selectQueryObject = null;
     this.offlineObjectsOptions = {};
     this.setOfflineObjectsOptions = function(offlineObjectsOptions) {
         this.offlineObjectsOptions = offlineObjectsOptions;
     };
     this.getOfflineObjectsOptions = function() {
         return this.offlineObjectsOptions;
     };
     /**
      * This function is used to add fields and their values to the dataobject
      * @param fieldName
      * @param value
      */
     this.addField = function(fieldName, value) {
         this.record[fieldName] = value;
     };
     /**
      * This function is used to set a map of records to the dataobject
      * @param fieldValuesMap
      */
     this.setRecord = function(fieldValuesMap) {
         this.record = fieldValuesMap;
     };
     /**
      * This function is used to get the map of records present in the DataObject
      * @returns {JSON} record
      */
     this.getRecord = function() {
         return this.record;
     };
     /**
      * This function is used to add a child Dataobject into the data object
      * @param  childDataObject {@link kony.sdk.dto.DataObject}
      */
     this.addChildDataObject = function(childDataObject) {
         if (this.record[childDataObject.objectName] == null || this.record[childDataObject.objectName] == undefined) {
             this.record[childDataObject.objectName] = [];
         }
         this.record[childDataObject.objectName].push(childDataObject.getRecord());
     };
     /**
      * This function is used to set the odata url to query
      * @param odataUrl
      */
     this.setOdataUrl = function(odataUrl) {
         this.odataUrl = odataUrl;
     };
     /**
      * This function is used to get the odata url to query
      * @returns {null}
      */
     this.getOdataUrl = function() {
         return this.odataUrl;
     };
     /**
      * This function is used to set a SelectQueryObject {@link kony.sdk.dto.SelectQuery}
      * @param selectQueryObject {@link kony.sdk.dto.SelectQuery}
      */
     this.setSelectQueryObject = function(selectQueryObject) {
         this.selectQueryObject = selectQueryObject;
     };
     /**
      * This function is used to get a SelectQueryObject {@link kony.sdk.dto.SelectQuery}
      * @returns selectQueryObject {@link kony.sdk.dto.SelectQuery}
      */
     this.getSelectQueryObject = function() {
         return this.selectQueryObject;
     };
     /**
      * This function is used to get the object name
      * @returns objectName {string}
      */
     this.getObjectName = function() {
         return this.objectName;
     };
 };
 /**
  * This object is used to define a record object used in Offline CRUD
  * @constructor
  */
 kony.sdk.dto.RecordObject = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.RecordObject");
     this.tableName = "";
     this.columnValues = {};
     this.childRecords = [];
 };
 kony.sdk.util.getSyncDbName = function() {
     return kony.sync.getDBName();
 };
 kony.sdk.util.getPrimarykeysFromMetadata = function(objMetadata) {
     var tmpSrcAttributes = null;
     if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined && objMetadata.primaryKey.length > 0) {
         tmpSrcAttributes = {};
         var pkLen = objMetadata.primaryKey.length;
         for (var indx = 0; indx < pkLen; indx++) {
             var pKey = objMetadata.primaryKey[indx];
             //adding primarykey column names in srcattributes which will be useful while deleting children
             tmpSrcAttributes[pKey] = pKey;
         }
     }
     return tmpSrcAttributes;
 };
 /**
  * This is a replaceAll utility function
  * @param string
  * @param toReplace
  * @param replaceWith
  * @return String temp
  */
 kony.sdk.util.replaceAll = function(string, toReplace, replaceWith) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.replaceAll");
     var temp = string;
     var index = temp.indexOf(toReplace);
     while (index != -1) {
         temp = temp.replace(toReplace, replaceWith);
         index = temp.indexOf(toReplace);
     }
     return temp;
 };
 kony.sdk.util.validateDateTypeInput = function(dateType) {
     return (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.TODAY) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.TOMORROW) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.YESTERDAY) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.CURRENTWEEK) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.NEXTWEEK) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.LASTWEEK) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.CURRENTMONTH) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.NEXTMONTH) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.LASTMONTH));
 };
 kony.sdk.util.getDateRange = function(dateType) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.getDateRange");
     var result = [];
     var currentDate = new Date();
     var formattedDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), currentDate.getHours(), currentDate.getMinutes(), currentDate.getSeconds(), currentDate.getMilliseconds());
     var start;
     var end;
     if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.TODAY)) {
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.TOMORROW)) {
         formattedDate.setDate(formattedDate.getDate() + 1);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.YESTERDAY)) {
         formattedDate.setDate(formattedDate.getDate() - 1);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.CURRENTWEEK)) {
         var firstDayofWeek = formattedDate.getDate() - formattedDate.getDay();
         var lastDayofWeek = firstDayofWeek + 6;
         formattedDate.setDate(firstDayofWeek);
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
         formattedDate.setDate(lastDayofWeek);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.LASTWEEK)) {
         formattedDate.setDate(formattedDate.getDate() - 7);
         var firstDayofWeek = formattedDate.getDate() - formattedDate.getDay();
         var lastDayofWeek = firstDayofWeek + 6;
         formattedDate.setDate(firstDayofWeek);
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
         formattedDate.setDate(lastDayofWeek);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.NEXTWEEK)) {
         formattedDate.setDate(formattedDate.getDate() + 7);
         var firstDayofWeek = formattedDate.getDate() - formattedDate.getDay();
         var lastDayofWeek = firstDayofWeek + 6;
         formattedDate.setDate(firstDayofWeek);
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
         formattedDate.setDate(lastDayofWeek);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.CURRENTMONTH)) {
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), 1, 0, 0, 0);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth() + 1, 0, 23, 59, 59);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.LASTMONTH)) {
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth() - 1, 1, 0, 0, 0, 0);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), 0, 23, 59, 59, 999);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.NEXTMONTH)) {
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth() + 1, 1, 0, 0, 0, 0);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth() + 2, 0, 23, 59, 59, 999);
     } else {
         start = 0;
         end = 0;
     }
     result.push(start);
     result.push(end);
     return result;
 };
 //Helps to prepare the primary condition to get binary data
 kony.sdk.util.getPkTableForBinary = function(objMetadata, columnValues, failureCallback) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.getPkTableForBinary");
     var pkTable = {};
     var whereClause = [];
     if (!kony.sdk.isNullOrUndefined(objMetadata.primaryKey)) {
         for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
             var pKey = objMetadata.primaryKey[indx];
             var pKeyValue = columnValues[pKey];
             if (kony.sdk.isNullOrUndefined(pKeyValue)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             pkTable[pKey] = pKeyValue;
         }
         return pkTable;
     } else {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
     }
 };
 //Helps to provide the Metadata of column in a Object
 kony.sdk.util.getMetadataOfColumn = function(objMetadata, colName) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.getMetadataOfColumn");
     if (objMetadata != null && objMetadata != undefined) {
         var columns = objMetadata["columns"];
         if (columns != null && columns != undefined) {
             for (var indx in columns) {
                 var colMeta = columns[indx];
                 if (colMeta["name"] == colName) {
                     return colMeta;
                 }
             }
         }
     }
     return null;
 };
 //Helps in generating kony.sdk.dto.RecordObject from a given complex record
 kony.sdk.util.populateColumnValues = function(record, childRecords) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.populateColumnValues");
     var columnValues = {};
     var recordsLength = Object.keys(record).length;
     for (var index = 0; index < recordsLength; index++) {
         var colName = Object.keys(record)[index];
         var colVal = record[colName];
         if (colVal instanceof Array) {
             for (var tempIndex = 0; tempIndex < colVal.length; tempIndex++) {
                 var tempRecord = new kony.sdk.dto.RecordObject();
                 tempRecord.tableName = colName;
                 tempRecord.columnValues = kony.sdk.util.populateColumnValues(record[colName][tempIndex], tempRecord.childRecords);
                 childRecords.push(tempRecord);
             }
         } else {
             columnValues[colName] = colVal;
         }
     }
     return columnValues;
 };
 //Helps in getting the relationship data of an entity from a given relationship list
 kony.sdk.util.getRelationOfEntity = function(relationshipList, entityName) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.getRelationOfEntity");
     var i = 0;
     for (; i < relationshipList.length; i++) {
         //considering only OneToMany relationships as it will have parent and child hierarchy
         if (relationshipList[i] != null && relationshipList[i]["relationshipType"] == "OneToMany" && relationshipList[i].relatedEntity.localeCompare(entityName) == 0) {
             return relationshipList[i];
         }
     }
     return null;
 };
 //Helps in finding if a given column name is a primary key
 kony.sdk.util.isPrimaryKey = function(primaryKeyList, columnValue) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.isPrimaryKey");
     for (var i = 0; i < primaryKeyList.length; i++) {
         if (primaryKeyList[i] == columnValue) return true;
     }
     return false;
 };
 kony.sdk.util.objectToQueryParams = function(valueObject) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.objectToQueryParams ");
     var queryParams = "";
     if (!kony.sdk.isNullOrUndefined(valueObject) && valueObject instanceof Object && Object.keys(valueObject).length > 0) {
         var objCount = Object.keys(valueObject).length;
         for (var i = 0; i < objCount; i++) {
             var tempKey = Object.keys(valueObject)[i];
             if (queryParams.length === 0) queryParams = encodeURIComponent(tempKey) + "=" + encodeURIComponent(valueObject[tempKey]);
             else queryParams = queryParams + "&" + encodeURIComponent(tempKey) + "=" + encodeURIComponent(valueObject[tempKey]);
         }
     }
     return queryParams;
 };
 kony.sdk.util.getPackagedMetadata = function() {
     kony.sdk.logsdk.trace("Entering into   kony.sdk.util.getPackagedMetadata");
     if (kony.sdk.APP_META === undefined || kony.sdk.APP_META === null) {
         kony.sdk.APP_META = {};
     }
     return kony.sdk.APP_META["objectsvc_meta"];
 };
 /**
  User needs to call this API to prepackage the metadata of the app. The data needs to be passed as json object or a stringified version of json object
  */
 kony.sdk.util.setPackagedMetadata = function(metadataJson) {
     kony.sdk.logsdk.trace("Entering into   kony.sdk.util.setPackagedMetadata");
     try {
         if (typeof metadataJson == "object") {
             kony.sdk.APP_META = metadataJson;
         } else if (typeof metadataJson == "string") {
             var parsedMetadata = JSON.parse(metadataJson);
             kony.sdk.APP_META = parsedMetadata;
         }
     } catch (error) {
         kony.sdk.logsdk.error("### kony.sdk.setPackagedMetadata::error while validating the input packaged metadata", error);
     }
 };
 stripTrailingCharacter = function(str, character) {
     kony.sdk.logsdk.trace("Entering into stripTrailingCharacter");
     if (str.substr(str.length - 1) === character) {
         return str.substr(0, str.length - 1);
     }
     return str;
 };
 kony.sdk.setLogLevelFromServerResponse = function(responseHeaders) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.setLogLevelFromServerResponse");
     var sdkRef = kony.sdk.getCurrentInstance();
     if (responseHeaders && responseHeaders[kony.logger.deviceLogLevelHeader]) {
         logLevel = responseHeaders[kony.logger.deviceLogLevelHeader].toUpperCase();
         if (!logLevel.localeCompare(kony.logger.logLevel.NONE.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.NONE) kony.logger.currentLogLevel = kony.logger.logLevel.NONE;
         else if (!logLevel.localeCompare(kony.logger.logLevel.FATAL.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.FATAL) kony.logger.currentLogLevel = kony.logger.logLevel.FATAL;
         else if (!logLevel.localeCompare(kony.logger.logLevel.ERROR.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.ERROR) kony.logger.currentLogLevel = kony.logger.logLevel.ERROR;
         else if (!logLevel.localeCompare(kony.logger.logLevel.WARN.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.WARN) kony.logger.currentLogLevel = kony.logger.logLevel.WARN;
         else if (!logLevel.localeCompare(kony.logger.logLevel.PERF.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.PERF) kony.logger.currentLogLevel = kony.logger.logLevel.PERF;
         else if (!logLevel.localeCompare(kony.logger.logLevel.INFO.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.INFO) kony.logger.currentLogLevel = kony.logger.logLevel.INFO;
         else if (!logLevel.localeCompare(kony.logger.logLevel.DEBUG.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.DEBUG) kony.logger.currentLogLevel = kony.logger.logLevel.DEBUG;
         else if (!logLevel.localeCompare(kony.logger.logLevel.TRACE.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.TRACE) kony.logger.currentLogLevel = kony.logger.logLevel.TRACE;
         else if (!logLevel.localeCompare(kony.logger.logLevel.ALL.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.ALL) kony.logger.currentLogLevel = kony.logger.logLevel.ALL;
         else if (!logLevel.localeCompare('OFF')) {
             kony.logger.deactivatePersistors(kony.logger.networkPersistor);
             kony.logger.currentLogLevel = kony.logger.logLevel.NONE;
             sdkRef.removeGlobalRequestParam(kony.logger.deviceLogLevelHeader, sdkRef.globalRequestParamType.headers);
             return;
         } else {
             return;
         }
         sdkRef.setGlobalRequestParam(kony.logger.deviceLogLevelHeader, logLevel, sdkRef.globalRequestParamType.headers);
         kony.logger.activatePersistors(kony.logger.networkPersistor);
     }
 };
 kony.sdk.prototype.enableDebug = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.prototype.enableDebug");
     kony.sdk.isDebugEnabled = true;
 };
 kony.sdk.prototype.disableDebug = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.prototype.disableDebug");
     kony.sdk.isDebugEnabled = false;
 };

 function Exception(name, message) {
     kony.sdk.logsdk.error("Exception --> " + name + ": " + message);
     return {
         code: name,
         message: message
     };
 }
 kony.sdk.verifyAndCallClosure = function(closure, params) {
     if (typeof(closure) === 'function') {
         closure(params);
     } else {
         kony.sdk.logsdk.warn("invalid callback", JSON.stringify(closure));
     }
 };
 kony.sdk.overrideUserId = function(userId) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.overrideUserId");
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && typeof(kony.setUserID) === 'function') {
         kony.setUserID(userId, true);
     } else {
         konyRef.setCurrentUserId(userId);
     }
 };
 kony.sdk.formatCurrentDate = function(inputDateString) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.formatCurrentDate");
     var dateObj = new Date(inputDateString);
     var year = dateObj.getUTCFullYear();
     var month = kony.sdk.formatDateComponent(dateObj.getUTCMonth() + 1);
     var date = kony.sdk.formatDateComponent(dateObj.getUTCDate());
     var hours = kony.sdk.formatDateComponent(dateObj.getUTCHours());
     var minutes = kony.sdk.formatDateComponent(dateObj.getUTCMinutes());
     var seconds = kony.sdk.formatDateComponent(dateObj.getUTCSeconds());
     var dateSeparator = "-";
     var timeSeparator = ":";
     var dateString = year + dateSeparator + month + dateSeparator + date + " " + hours + timeSeparator + minutes + timeSeparator + seconds;
     return dateString;
 };
 kony.sdk.formatDateComponent = function(dateComponent) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.formatDateComponent");
     if (dateComponent < 10) {
         dateComponent = "0" + dateComponent;
     }
     return dateComponent;
 };
 kony.sdk.isNullOrUndefined = function(val) {
     if (val === null || val === undefined) {
         return true;
     } else {
         return false;
     }
 };
 kony.sdk.constants.reportingType = {
     session: "session",
     custom: "custom"
 };
 kony.sdk.isEmptyObject = function(obj) {
     if (typeof(obj) === "boolean" || typeof(obj) === "number") {
         return false;
     } else if (typeof(obj) === "string") {
         return obj.trim().length === 0;
     }
     for (var prop in obj) {
         return false;
     }
     return true;
 };
 kony.sdk.isArray = function(data) {
     if (data && Object.prototype.toString.call(data) === '[object Array]') {
         return true;
     }
     return false;
 };
 kony.sdk.formatSuccessResponse = function(data) {
     if (data && data.httpresponse) {
         delete data.httpresponse;
     }
     return data;
 };
 kony.sdk.isJson = function(str) {
     try {
         JSON.parse(str);
     } catch (e) {
         return false;
     }
     return true;
 };
 kony.sdk.util.getString = function(val) {
     if (!kony.sdk.isNullOrUndefined(val) && (val.toString()).toLocaleLowerCase() !== "null") {
         return val.toString();
     }
     return "";
 };
 //private method to identify whether session/token expired or not based on error code
 kony.sdk.isSessionOrTokenExpired = function(mfcode) {
     if (mfcode && (mfcode === "Auth-5" || mfcode === "Auth-6" || mfcode === "Gateway-31" || mfcode === "Gateway-33" || mfcode === "Gateway-35" || mfcode === "Gateway-36" || mfcode === "Auth-46" || mfcode === "Auth-55")) {
         return true;
     }
     return false;
 };
 //private method to clear cache
 kony.sdk.resetProviderKeys = function(konyRef, _providerName) {
     try {
         if (konyRef) {
             if (_providerName) {
                 if (konyRef.tokens.hasOwnProperty(_providerName)) {
                     konyRef.tokens[_providerName] = null;
                 }
             }
         }
     } catch (e) {
         kony.sdk.logsdk.error("Error while clearing the cache..");
     }
 };
 //private method to clear cache
 kony.sdk.resetCurrentKeys = function(konyRef, _providerName) {
     try {
         if (konyRef) {
             konyRef.currentClaimToken = null;
             konyRef.currentBackEndToken = null;
             konyRef.claimTokenExpiry = null;
             konyRef.currentRefreshToken = null;
             //setting the anonymous provider as true to access the public protected urls without any issue
             konyRef.isAnonymousProvider = true;
             if (_providerName) {
                 if (konyRef.tokens.hasOwnProperty(_providerName)) {
                     konyRef.tokens[_providerName] = null;
                 }
             }
         }
     } catch (e) {
         kony.sdk.logsdk.error("Error while clearing the cache..");
     }
 };
 kony.sdk.util.populateIndividualServiceLists = function(serviceConfig, objectToPopulate) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.populateIndividualServiceLists");
     var svcMeta = serviceConfig["services_meta"];
     if (kony.sdk.isNullOrUndefined(objectToPopulate["objectsvc"])) {
         objectToPopulate["objectsvc"] = {};
     }
     if (kony.sdk.isNullOrUndefined(objectToPopulate["offlineObjectsvc"])) {
         objectToPopulate["offlineObjectsvc"] = {};
     }
     if (svcMeta) {
         for (var svc in svcMeta) {
             if (svcMeta.hasOwnProperty(svc)) {
                 var svcObj = svcMeta[svc];
                 if (svcObj && svcObj["type"] === "objectsvc") {
                     if (!kony.sdk.isNullOrUndefined(svcObj["offline"])) {
                         if (svcObj["offline"] === false) {
                             objectToPopulate["objectsvc"][svc] = svcObj;
                         } else if (svcObj["offline"] === true) {
                             objectToPopulate["offlineObjectsvc"][svc] = svcObj;
                         }
                     } else {
                         objectToPopulate["objectsvc"][svc] = svcObj;
                         objectToPopulate["offlineObjectsvc"][svc] = svcObj;
                     }
                 } else if (svcObj && svcObj["type"] === "integsvc") {
                     objectToPopulate["integsvc"][svc] = svcObj;
                 }
             }
         }
     }
 };
 /**
  * Generates hash code for the URL by sha512 algorithm
  * @param url
  * @param requestParams
  * @return {*}
  */
 kony.sdk.util.generateHashcodeForURL = function(url, requestParams) {
     var concatenatedResult = "";
     var hashID = null;
     if (!kony.sdk.isNullOrUndefined(url)) concatenatedResult += url;
     if (!kony.sdk.isNullOrUndefined(requestParams)) {
         concatenatedResult += JSON.stringify(requestParams);
     }
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && !kony.sdk.util.isNullOrEmptyString(concatenatedResult)) {
         hashID = kony.crypto.createHash("sha512", concatenatedResult);
     }
     return hashID;
 };
 /**
  * Utility function to save the response in the cache.
  * @param options {object} save the response with key options["cacheID"]. If not provided then we will calculate hashcode by url and requestData.
  * @param url {string}
  * @param requestData {object}
  * @param response {object}
  */
 function cacheResponseForKey(options, url, requestData, response) {
     var hashCode = null;
     if (options["cacheID"]) hashCode = options["cacheID"];
     else hashCode = kony.sdk.util.generateHashcodeForURL(url, requestData);
     if (hashCode) {
         if (typeof(hashCode) !== "string") {
             hashCode = hashCode.toString();
         }
         var expiry = options["expiryTime"] ? options["expiryTime"] : kony.sdk.constants.DEFAULT_CACHE_EXPIRY_TIME;
         response["cacheID"] = hashCode;
         new kony.sdk.ClientCache().add(hashCode, response, expiry);
     }
 }
 kony.sdk.util.isNullOrEmptyString = function(val) {
     if (kony.sdk.isNullOrUndefined(val) || (typeof(val) === "string" && val.trim() === "")) {
         return true;
     }
     return false;
 };

 function doesMFSupportsAppversioning() {
     // In case of IDE platforms we will check the existence of appConfig.svcDoc.service_doc_etag for compatibility of app version with the MF.
     // In case of plain-js & phone gap initOptions should not be sent during init call.
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && !kony.sdk.isNullOrUndefined(appConfig) && !kony.sdk.isNullOrUndefined(appConfig.svcDoc) && !kony.sdk.isNullOrUndefined(appConfig.svcDoc.service_doc_etag)) {
         return true;
     } else if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_PLAIN_JS || kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_PHONEGAP) {
         return true;
     } else {
         return false;
     }
 }

 function populateHeaderWithFabricAppVersion(headers) {
     if (doesMFSupportsAppversioning() && !kony.sdk.isNullOrUndefined(headers) && !kony.sdk.isNullOrUndefined(kony.sdk.getFabricAppVersion())) {
         headers[kony.sdk.constants.APP_VERSION_HEADER] = kony.sdk.getFabricAppVersion();
     }
 }
 /*
  * Utility method to check whether options has browserWidget or not
  * @return true if it supports
  * */
 kony.sdk.util.hasBrowserWidget = function(options) {
     return options && options[kony.sdk.constants.BROWSER_WIDGET] && kony.sdk.util.type(options[kony.sdk.constants.BROWSER_WIDGET]) === "kony.ui.Browser";
 };
 /*
  * Utility method to check whether binary is supported
  * @return true if it supports
  * */
 kony.sdk.util.isBinarySupported = function() {
     return kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_NATIVE;
 };
 /*
  ** Intializing SSO FFI's with null implementation
  *  Supporting platforms like IDE has sso_handler which has implementation.
  */
 kony.sdk.util.saveSSOToken = function() {
     kony.sdk.logsdk.warn("kony.sdk.util.saveSSOToken:: SSO is not supported.");
     return null;
 };
 kony.sdk.util.getSSOToken = function() {
     kony.sdk.logsdk.warn("kony.sdk.util.getSSOToken:: SSO is not supported.");
     return null;
 };
 kony.sdk.util.deleteSSOToken = function() {
     kony.sdk.logsdk.warn("kony.sdk.util.deleteSSOToken:: SSO is not supported.");
     return null;
 };
 kony.sdk.util.initializeSSO = function() {
     // STUB code returns nothing
 };
 /*
  ** Utility method to clone any object
  *  @return cloned object
  */
 kony.sdk.cloneObject = function(obj) {
     var clonedObject;
     try {
         clonedObject = JSON.parse(JSON.stringify(obj));
     } catch (err) {
         kony.sdk.logsdk.error("cloning object failed, reverting back to copy");
         clonedObject = obj;
     }
     return clonedObject;
 };
 /**
  * Utility method to check if a given variable is JSON Object
  * @param obj
  * @returns {boolean}
  */
 kony.sdk.util.isJsonObject = function(obj) {
     if (obj === null || obj === undefined) {
         return false;
     }
     return obj.constructor === {}.constructor;
 };
 /**
  * Utility method to check whether the given variable is a valid string
  * @param str
  * @returns {boolean}
  */
 kony.sdk.util.isValidString = function(str) {
     if (str === null || str === undefined || str.constructor !== "".constructor) {
         return false;
     }
     return str.trim() !== ""
 };
 /**
  * Utility method to convert JSON object keys to lower case
  * @param obj {Object} - JSON object
  * @returns convertedJSON {Object} - JSON object keys in lower case and values assigned to respective keys.
  */
 kony.sdk.util.convertJsonKeysToLowerCase = function(obj) {
     var convertedJSON = {};
     if (!kony.sdk.util.isJsonObject(obj)) {
         return obj;
     }
     var keys = Object.keys(obj);
     for (var i = 0; i < keys.length; i++) {
         convertedJSON[keys[i].toLowerCase()] = obj[keys[i]];
     }
     return convertedJSON;
 };
 /**
  * Utility method to get JSON property case-insensitively
  * @param {Object} jsonObject
  * @param {String} key
  * @returns {*}
  */
 kony.sdk.util.getValueForKeyAndIgnoreCase = function(jsonObject, key) {
     var keysInJSON = Object.keys(jsonObject);
     var index = 0;
     for (var jsonKey in keysInJSON) {
         if (keysInJSON[jsonKey].toLocaleLowerCase() === key.toLocaleLowerCase()) {
             return Object.values(jsonObject)[index];
         } else {
             index++
         }
     }
     return null;
 };
 /**
  * Utility method to populate JSON Template
  * @param {String} template
  * @param {Object} templateParams : Input Params provided by the User
  * @return Object containing processed template and missing variables
  */
 kony.sdk.util.populateTemplate = function(template, templateParams) {
     if (kony.sdk.util.isNullOrEmptyString(template) || !kony.sdk.util.isJsonObject(templateParams)) {
         kony.sdk.logsdk.error(kony.sdk.errorConstants.populating_template_failed + " " + kony.sdk.errormessages.populating_template_failed);
         return null;
     }
     var DOLLAR_VARIABLE_PATTERN = /(\${)+(\w.*?)+(})/g;
     var templateVariables = [];
     var missingVariables = [];
     var resultSet = {};
     var populatedTemplate = kony.sdk.cloneObject(template);
     var inputTemplateVariables = populatedTemplate.match(DOLLAR_VARIABLE_PATTERN);
     //Match returns Array of all the matches.
     //Iterating over the array and extracting all template variables.
     for (var iteratorVariable in inputTemplateVariables) {
         var inputVariable = inputTemplateVariables[iteratorVariable].toString();
         var templateParameter = inputVariable.slice(2, (inputVariable.length) - 1);
         templateVariables.push(templateParameter);
     }
     //Populating the template with user inputs.
     for (var iterateVariable = 0; iterateVariable < templateVariables.length; iterateVariable++) {
         var inputParameter = templateVariables[iterateVariable];
         if (templateParams.hasOwnProperty(inputParameter)) {
             populatedTemplate = populatedTemplate.replace("${" + inputParameter + "}", templateParams[inputParameter]);
         } else {
             missingVariables.push(inputParameter);
         }
     }
     resultSet[kony.sdk.constants.PROCESSED_TEMPLATE] = populatedTemplate;
     resultSet[kony.sdk.constants.MISSING_VARIABLES] = missingVariables;
     return resultSet;
 };
 /**
  * Checks if the browser is IE11
  * @returns {boolean}
  */
 kony.sdk.util.checkForIE11 = function() {
     //Checking if this is being run in DesktopWeb
     if (typeof(XMLHttpRequest) !== 'undefined') {
         var ua = window.navigator.userAgent;
         var trident = ua.indexOf('Trident/');
         if (trident > 0) {
             // IE 11 => return version number
             var rv = ua.indexOf('rv:');
             return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10) === 11;
         }
     }
     return false;
 };
 /**
  * Utility method to get persistToken flag from data store
  *
  * @returns {boolean}
  */
 kony.sdk.util.isPersistentLoginResponseEnabled = function() {
         var dataStore = new konyDataStore();
         var persistTokenFlag = dataStore.getItem("persistLoginResponseFlag");
         if (!kony.sdk.isNullOrUndefined(persistTokenFlag) && persistTokenFlag === true) {
             return true;
         }
         return false;
     }
     /**
      * Based on interactive or non-interactive session info from license, returning session type
      * @return {string}
      */
 kony.sdk.util.getSessionType = function() {
     var sessionType;
     if (kony.licensevar && kony.licensevar.isInteractive != undefined) {
         sessionType = kony.licensevar.isInteractive ? kony.sdk.constants.APP_SESSION_INTERACTIVE : kony.sdk.constants.APP_SESSION_NON_INTERACTIVE;
     } else {
         /**
          *In case of phonegap and plain js, we are sending interacting session.
          */
         kony.sdk.logsdk.trace("Updating interacting session in kony reporting params by default");
         sessionType = kony.sdk.constants.APP_SESSION_INTERACTIVE;
     }
     return sessionType;
 };
 /**
  * Utility method to get kony reporting params in encoded string
  * @return {string}
  */
 kony.sdk.getEncodedReportingParamsForSvcid = function(svcid) {
     var reportingData = kony.sdk.getPayload(konyRef);
     reportingData.rsid = kony.sdk.currentInstance.getSessionId();
     if (svcid) {
         reportingData.svcid = svcid;
     } else {
         kony.sdk.logsdk.warn("### kony.sdk.getEncodedReportingParamsForSvcid:: svcid is either null or undefined");
     }
     return encodeURI(JSON.stringify(reportingData));
 };
 kony.sdk.serviceDoc = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.serviceDoc");
     var appId = "";
     var baseId = "";
     var services_meta = {};
     var name = "";
     var selflink = "";
     var login = null;
     var integsvc = {};
     var reportingsvc = {};
     var messagingsvc = {};
     var sync = {};
     var objectsvc = {};
     var logicsvc = {};
     this.toJSON = function() {
         servConfig = {};
         servConfig.appId = this.getAppId();
         servConfig.baseId = this.getBaseId();
         servConfig.name = this.getAppName();
         servConfig.selflink = this.getSelfLink();
         servConfig.services_meta = this.getServicesMeta();
         servConfig.login = this.getAuthServices();
         servConfig.integsvc = this.getIntegrationServices();
         servConfig.messagingsvc = this.getMessagingServices();
         servConfig.sync = this.getSyncServices();
         servConfig.reportingsvc = this.getReportingServices();
         servConfig.objectsvc = this.getObjectServices();
         servConfig.logicsvc = this.getLogicServices();
         kony.sdk.util.populateIndividualServiceLists(this, servConfig);
         return servConfig;
     }
     this.setAppId = function(appIdStr) {
         appId = appIdStr;
     };
     this.getAppId = function() {
         return appId;
     };
     this.setBaseId = function(baseIdStr) {
         baseId = baseIdStr;
     };
     this.getBaseId = function() {
         return baseId;
     };
     this.setAppName = function(appName) {
         name = appName;
     };
     this.getAppName = function() {
         return name;
     };
     this.setSelfLink = function(selfLinkStr) {
         selflink = selfLinkStr;
     };
     this.getSelfLink = function() {
         return selflink;
     };

     function setEndPoints(providerType, providerValues) {
         for (var provider in providerValues) {
             providerType[provider] = providerValues[provider];
         }
     }
     this.setAuthService = function(loginProvider) {
         if (login === null) {
             login = [];
         }
         login.push(loginProvider);
     };
     //what will this return? name?
     this.getAuthServiceByName = function(authServiceProvider) {
         if (login === null) {
             return null;
         }
         for (var i in login) {
             var provider = login[i];
             if (provider.prov == authServiceProvider) {
                 return provider;
             }
         }
     };
     this.getAuthServices = function() {
         return login;
     };
     this.setIntegrationService = function(providerName, endPointUrl) {
         integsvc[providerName] = endPointUrl;
     };
     this.getIntegrationServiceByName = function(integrationServiceProviderName) {
         return integsvc[integrationServiceProviderName];
     };
     this.getIntegrationServices = function() {
         return integsvc;
     };
     this.setObjectService = function(providerName, endPointUrl) {
         objectsvc[providerName] = endPointUrl;
     };
     this.getObjectServiceByName = function(objectServiceProviderName) {
         return objectsvc[objectServiceProviderName];
     };
     this.getObjectServices = function() {
         return objectsvc;
     };
     this.getLogicServices = function() {
         return logicsvc;
     };
     this.getServicesMeta = function() {
         return services_meta;
     };
     this.setReportingService = function(reportingType, url) {
         if (reportingType == kony.sdk.constants.reportingType.session || reportingType == kony.sdk.constants.reportingType.custom) {
             reportingsvc[reportingType] = url;
         } else {
             throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid reporting type " + reportingType);
         }
     }
     this.getReportingServiceByType = function(reportingServiceProviderType) {
         return reportingsvc[reportingServiceProviderType];
     };
     this.getReportingServices = function() {
         return reportingsvc;
     };
     this.setMessagingService = function(appId, url) {
         messagingsvc[appId] = url;
     };
     this.getMessagingServiceByName = function(messagingServiceProviderName) {
         return messagingsvc[messagingServiceProviderName];
     };
     this.getMessagingServices = function() {
         return messagingsvc;
     }
     this.setSyncService = function(syncServiceProvider) {
         sync = syncServiceProvider;
     };
     this.getSyncServices = function() {
         return sync;
     };
 };
 kony.logger = kony.logger || {};
 kony.logger = {
     // Logger constants
     networkPersistorUrlEndpoint: "deviceLogs",
     deviceLogLevelHeader: "X-KONY-DEVICE-LOG-LEVEL",
     filePersistor: 1,
     consolePersistor: 2,
     networkPersistor: 4,
     // Log Level Block which gives all the handle for setting and getting
     //ALL(0) < TRACE(1) < DEBUG(2) < INFO(4) < PEF(8) < WARN(16) < ERROR(32) < FATAL(64) < NONE(127)
     logLevel: {
         NONE: {
             value: 127,
             name: "none",
             code: "NONE"
         },
         FATAL: {
             value: 64,
             name: "fatal",
             code: "FATAL"
         },
         ERROR: {
             value: 32,
             name: "error",
             code: "ERROR"
         },
         WARN: {
             value: 16,
             name: "warn",
             code: "WARN"
         },
         PERF: {
             value: 8,
             name: "perf",
             code: "PERF"
         },
         INFO: {
             value: 4,
             name: "info",
             code: "INFO"
         },
         DEBUG: {
             value: 2,
             name: "debug",
             code: "DEBUG"
         },
         TRACE: {
             value: 1,
             name: "trace",
             code: "TRACE"
         },
         ALL: {
             value: 0,
             name: "all",
             code: "ALL"
         }
     },
     get currentLogLevel() {
         if (typeof(currentLevel) === 'undefined') currentLevel = kony.logger.logLevel.NONE;
         if (kony.logger.isNativeLoggerAvailable()) {
             var logLevelValue = KonyLogger.getLogLevel();
             for (var key in kony.logger.logLevel) {
                 if (kony.logger.logLevel.hasOwnProperty(key)) {
                     if (kony.logger.logLevel[key].value == logLevelValue) {
                         currentLevel = kony.logger.logLevel[key];
                         break;
                     }
                 }
             }
         }
         return currentLevel;
     },
     set currentLogLevel(level) {
         currentLevel = level;
         if (kony.logger.isNativeLoggerAvailable()) KonyLogger.setLogLevel(currentLevel.value);
     },
     isNativeLoggerAvailable: function() {
         if (typeof(KonyLogger) === 'undefined') return false;
         else return true;
     },
     flush: function() {
         if (kony.logger.isNativeLoggerAvailable()) KonyLogger.flush();
     },
     // Persister block for activating and deactivating
     activatePersistors: function(activatedList) {
         if (kony.logger.isNativeLoggerAvailable()) KonyLogger.activatePersistors(activatedList);
     },
     deactivatePersistors: function(deactivatedList) {
         if (kony.logger.isNativeLoggerAvailable()) KonyLogger.deactivatePersistors(deactivatedList);
     },
     //setting claims token after referesh
     setClaimsToken: function() {
         var token = kony.sdk.getCurrentInstance().currentClaimToken;
         if (kony.logger.isNativeLoggerAvailable()) KonyLogger.setClaimsToken(token);
     },
     setConfig: function(loggerConfig) {
         if (kony.logger.isNativeLoggerAvailable()) {
             KonyLogger.setConfig(loggerConfig.getLoggerConfig());
         }
     },
     setPersistorConfig: function(persistor) {
         if (kony.logger.isNativeLoggerAvailable()) {
             KonyLogger.setPersistorConfig(persistor.getPersistorConfig());
         }
     },
     createLoggerObject: function(loggerName, loggerConfig) {
         var loggerObj = {};
         loggerObj.config = parseConfig(loggerConfig);
         loggerObj.trace = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.TRACE, msg, params);
         };
         loggerObj.debug = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.DEBUG, msg, params);
         };
         loggerObj.info = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.INFO, msg, params);
         };
         loggerObj.perf = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.PERF, msg, params);
         };
         loggerObj.warn = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.WARN, msg, params);
         };
         loggerObj.error = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.ERROR, msg, params);
         };
         loggerObj.fatal = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.FATAL, msg, params);
         };
         var indirectionLevel = 0;
         loggerObj.setIndirectionLevel = function(_indirectionLevel) {
             indirectionLevel = _indirectionLevel;
         }
         loggerObj.getIndirectionLevel = function() {
             return indirectionLevel;
         }
         loggerObj.loggerName = loggerName;
         return loggerObj;
     },
     createLoggerConfig: function() {
         var formatC = {};
         var logFilterC = {};
         var accConfig = {};
         var overrideConfig = null;
         var persistorList = [];
         var config = {
             //formatterConfig
             //timeformat
             set timeFormat(val) {
                 formatC.timeFormat = val;
             },
             //timeZone
             set timeZone(val) {
                 formatC.timeZone = val;
             },
             //FilterConfig
             //logLevel
             set logLevel(val) {
                 logFilterC.logLevel = val;
             },
             //accumulatorConfig
             //bytesLimit
             set bytesLimit(val) {
                 accConfig.bytesLimit = val;
             },
             //statementsLimit
             set statementsLimit(val) {
                 accConfig.statementsLimit = val;
             },
             //overrideConfig
             set overrideConfig(val) {
                 overrideConfig = val;
             },
             //peristorList
             get persistorList() {
                 return persistorList;
             },
             addPersistor: function(val) {
                 persistorList.push(val.getPersistorConfig());
             },
             getLoggerConfig: function() {
                 var loggerConfig = {};
                 if (Object.keys(formatC).length > 0) loggerConfig.formatterConfig = formatC;
                 if (Object.keys(logFilterC).length > 0) loggerConfig.logFilterConfig = logFilterC;
                 if (Object.keys(accConfig).length > 0) loggerConfig.accumulatorConfig = accConfig;
                 if (overrideConfig !== null) loggerConfig.overrideConfig = overrideConfig;
                 loggerConfig.persistors = persistorList;
                 return loggerConfig;
             }
         };
         return config;
     },
     createFilePersistor: function() {
         var prop = {};
         var persistorProperties = {
             //Persistor properites
             get persistorType() {
                 return kony.logger.filePersistor;
             },
             //maxNumberOfLogFiles
             set maxNumberOfLogFiles(val) {
                 prop.maxNumberOfLogFiles = val;
             },
             //maxFileSize
             set maxFileSize(val) {
                 prop.maxFileSize = val;
             },
             getPersistorConfig: function() {
                 var perConfig = {};
                 perConfig.type = this.persistorType;
                 if (Object.keys(prop).length > 0) perConfig.properties = prop;
                 return perConfig;
             }
         };
         return persistorProperties;
     },
     createNetworkPersistor: function() {
         var prop = {};
         var persistorProperties = {
             //persistorType
             get persistorType() {
                 return kony.logger.networkPersistor;
             },
             //URL
             set URL(val) {
                 prop.URL = val;
             },
             getPersistorConfig: function() {
                 var perConfig = {};
                 perConfig.type = this.persistorType;
                 if (Object.keys(prop).length > 0) perConfig.properties = prop;
                 return perConfig;
             }
         };
         return persistorProperties;
     },
     appLoggerInitialisation: function() {
         var loggerObj = {};
         loggerObj = new kony.logger.createNewLogger(kony.sdk.constants.APP_LOGGER_NAME, null);
         return loggerObj;
     },
     isValidJSTable: function(inputTable) {
         if (kony.sdk.isNullOrUndefined(inputTable)) {
             return false;
         }
         if (typeof inputTable === "object" || typeof inputTable === "Object" || typeof inputTable === "Array" || typeof inputTable === "array") {
             return true;
         } else {
             return false;
         }
     }
 };
 kony.sdk.FileStorageClasses = (function() {
     var instance = null;
     var LOG_PREFIX = "kony.FileStorageAdapter";
     "use strict";

     function createInstance(url) {
         kony.sdk.logsdk.trace(LOG_PREFIX + ": Creating instance of FileStorageClasses");
         var obj = {};
         obj.listFiles = function(filter, headers, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking list files");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("listFiles : Refresh claims token SUCCESS");
                 var headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 //Calling FileStorage listFiles API.
                 kony.sdk.FileStorageClasses.listFiles(url, filter, headers, successCallback, failureCallback, options);
             }.bind(this), function(error) {
                 //claims refresh failure callback
                 kony.sdk.logsdk.error("listFiles : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         obj.upload = function(uploadInputType, uploadParams, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking upload");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("upload : Refresh claims token SUCCESS");
                 var headers = uploadParams["headers"];
                 headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 uploadParams["headers"] = headers;
                 //Calling FileStorage upload API.
                 kony.sdk.FileStorageClasses.upload(url, uploadInputType, uploadParams, successCallback, failureCallback, options);
             }.bind(this), function(error) {
                 //claims refresh failure callback
                 kony.sdk.logsdk.error("upload : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         obj.download = function(downloadParams, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking downloadFile");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("downloadFile : Refresh claims token SUCCESS");
                 var headers = downloadParams["headers"];
                 headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 downloadParams["headers"] = headers;
                 kony.sdk.FileStorageClasses.download(url, downloadParams, successCallback, failureCallback, options);
             }.bind(this), function(error) { //claims refresh failure callback
                 kony.sdk.logsdk.error("upload : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         obj.deleteById = function(fileId, deleteParams, headers, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking deleteById");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("deleteById : Refresh claims token SUCCESS");
                 var headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 kony.sdk.FileStorageClasses.deleteById(url, fileId, deleteParams, headers, successCallback, failureCallback, options);
             }.bind(this), function(error) {
                 //claims refresh failure callback
                 kony.sdk.logsdk.error("deleteById : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         obj.deleteByCriteria = function(deleteParams, headers, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking deleteByCriteria");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("deleteByCriteria : Refresh claims token SUCCESS");
                 var headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 kony.sdk.FileStorageClasses.deleteByCriteria(url, deleteParams, headers, successCallback, failureCallback, options);
             }.bind(this), function(error) {
                 //claims refresh failure callback
                 kony.sdk.logsdk.error("deleteByCriteria : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         obj.update = function(updateParams, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking update");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("update : Refresh claims token SUCCESS");
                 var headers = updateParams["headers"];
                 headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 updateParams["headers"] = headers;
                 kony.sdk.FileStorageClasses.update(url, updateParams, successCallback, failureCallback, options);
             }.bind(this), function(error) {
                 //claims refresh failure callback
                 kony.sdk.logsdk.error("deleteByCriteria : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         obj.abort = function(fileId, abortParams, headers, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking abort");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("abort : Refresh claims token SUCCESS");
                 var headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 kony.sdk.FileStorageClasses.abort(url, fileId, abortParams, headers, successCallback, failureCallback, options);
             }.bind(this), function(error) {
                 //claims refresh failure callback
                 kony.sdk.logsdk.error("abort : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         return obj;
     }
     return {
         import: function(url) {
             kony.sdk.logsdk.trace(LOG_PREFIX + ": Importing native FileStorageClasses");
             if (instance === null) {
                 instance = createInstance(url);
             }
             return instance;
         }
     };
 })();
 // Add token to headers
 kony.sdk.FileStorageClasses.addTokenToHeaders = function(headers, token) {
     if (kony.sdk.isNullOrUndefined(headers)) {
         headers = {};
     }
     headers["X-Kony-Authorization"] = token;
     return headers;
 };
 kony.sdk.KNYObj = function(name, objectServiceName, namespace) {
     var LOG_PREFIX = "KNYObj";
     kony.sdk.logsdk.info(LOG_PREFIX + ": Creating KNYObj with name " + name);
     var sdkObjectSync = kony.sdk.KNYObj.createSDKObjectSync(name, objectServiceName, namespace);
     this.name = name;
     this.getSdkObjectSync = function() {
         return sdkObjectSync;
     }
     this.startSync = function(syncConfig, successCallback, failureCallback, progressCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Starting sync on " + this.name + " object");
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Refreshing claims token");
         kony.sdk.claimsRefresh(function() { //claims refresh success callback
             kony.sdk.logsdk.info(LOG_PREFIX + ": Refresh claims token SUCCESS");
             var token = kony.sdk.getCurrentInstance().currentClaimToken;
             kony.sdk.OfflineObjects.setToken(token);
             kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
             kony.sdk.KNYObj.startSync(this, syncConfig, successCallback, failureCallback, progressCallback)
         }.bind(this), function(error) { //claims refresh failure callback
             kony.sdk.logsdk.info(LOG_PREFIX + ": Refresh claims token FAILED");
             failureCallback(error);
         });
     };
     this.getPendingRecordsForUpload = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Fetching PendingEditSyncRecords in " + this.name + " object");
         kony.sdk.KNYObj.getPendingRecordsForUpload(this, options, successCallback, failureCallback);
     };
     this.create = function(record, options, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Create record in " + this.name + " object");
         kony.sdk.KNYObj.create(this, record, options, successCallback, failureCallback);
     };
     this.update = function(record, options, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Update record in " + this.name + " object");
         kony.sdk.KNYObj.update(this, record, options, successCallback, failureCallback);
     };
     this.updateByPK = function(record, options, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Update record by PK in " + this.name + " object");
         kony.sdk.KNYObj.updateByPK(this, record, options, successCallback, failureCallback);
     };
     this.delete = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Delete record in " + this.name + " object");
         kony.sdk.KNYObj.delete(this, options, successCallback, failureCallback);
     };
     this.deleteByPK = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Delete record by PK in " + this.name + " object");
         kony.sdk.KNYObj.deleteByPK(this, options, successCallback, failureCallback);
     };
     this.get = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Get record from " + this.name + " object");
         kony.sdk.KNYObj.get(this, options, successCallback, failureCallback);
     };
     this.getBinary = function(options, fileDownloadStartedCallback, chunkDownloadCompletedCallback, streamDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Get binary for " + this.name + " object");
         kony.sdk.KNYObj.getBinary(this, options, fileDownloadStartedCallback, chunkDownloadCompletedCallback, streamDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback);
     };
     this.getBinaryStatus = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": getBinaryStatus for " + this.name + " object");
         kony.sdk.KNYObj.getBinaryStatus(this, options, successCallback, failureCallback);
     };
     this.rollback = function(primaryKeyValueMap, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Rollback for " + this.name + " object");
         kony.sdk.KNYObj.rollback(this, primaryKeyValueMap, successCallback, failureCallback);
     };
     this.markForUpload = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": MarkForUpload for " + this.name + " object");
         kony.sdk.KNYObj.markForUpload(this, options, successCallback, failureCallback);
     };
     this.getUploadDeferredRecordKeys = function(successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Get deferred record primary keys in " + this.name + " object");
         kony.sdk.KNYObj.getUploadDeferredRecordKeys(this, successCallback, failureCallback);
     };
     this.cancelSync = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Cancel for " + this.name + " object");
         kony.sdk.KNYObj.cancelSync(this, options, successCallback, failureCallback);
     };
 };
 kony.sdk.KNYObjSvc = function(name) {
     var LOG_PREFIX = "KNYObjSvc";
     kony.sdk.logsdk.debug(LOG_PREFIX + ": Creating KNYObjSvc with name " + name);
     var sdkObjectServiceSync = kony.sdk.KNYObjSvc.createSDKObjectServiceSync(name);
     this.name = name;
     this.getSdkObjectServiceSync = function() {
         return sdkObjectServiceSync;
     }
     this.getSdkObjectByName = function(name) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Creating KNYObj with name " + name + " and objectServiceName " + this.name);
         return new kony.sdk.KNYObj(name, this.name);
     }
     this.startSync = function(syncConfig, successCallback, failureCallback, progressCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Starting sync on " + this.name + " object service");
         kony.sdk.logsdk.trace(LOG_PREFIX + ": Refreshing claims token");
         kony.sdk.claimsRefresh(function() { //claims refresh success callback
             kony.sdk.logsdk.info(LOG_PREFIX + ": Refresh claims token SUCCESS");
             var token = kony.sdk.getCurrentInstance().currentClaimToken;
             kony.sdk.OfflineObjects.setToken(token);
             kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
             kony.sdk.KNYObjSvc.startSync(this, syncConfig, successCallback, failureCallback, progressCallback)
         }.bind(this), function(error) { //claims refresh failure callback
             kony.sdk.logsdk.error(LOG_PREFIX + ": Refresh claims token FAILED");
             failureCallback(error);
         });
     };
     this.rollback = function(successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Rollback on " + this.name + " object service");
         kony.sdk.KNYObjSvc.rollback(this, successCallback, failureCallback)
     }
     this.cancelSync = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Cancel for " + this.name + " object service");
         kony.sdk.KNYObjSvc.cancelSync(this, options, successCallback, failureCallback);
     }
     this.clearOfflineData = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.debug(LOG_PREFIX + ": Clearing Offline Data for " + this.name + " object service.");
         kony.sdk.KNYObjSvc.clearOfflineData(this, options, successCallback, failureCallback);
     }
 };
 kony.sdk.OfflineObjects = function(objServiceList) {
     var LOG_PREFIX = "OfflineObjects";
     kony.sdk.logsdk.trace(LOG_PREFIX + ": Creating OfflineObjects");
     this.setup = function(options, successCallback, failureCallback) {
         // This check is required for app upgrade from 8.0 to 8.1
         var argSuccessCallback = successCallback;
         var argFailueCallback = failureCallback;
         var setupOptions = (typeof arguments[0] != "function") ? options : null;
         if (setupOptions === null) {
             argSuccessCallback = options;
             argFailueCallback = successCallback;
         }
         kony.sdk.logsdk.trace(LOG_PREFIX + ": OfflineObjects.setup() called");
         kony.sdk.logsdk.trace(LOG_PREFIX + ": Refreshing claims token");
         kony.sdk.claimsRefresh(function() { //claims refresh success callback
             kony.sdk.logsdk.trace(LOG_PREFIX + ": Refresh claims token SUCCESS");
             var token = kony.sdk.getCurrentInstance().currentClaimToken;
             //kony.sdk.logsdk.debug(LOG_PREFIX+": Token : "+token);
             kony.sdk.OfflineObjects.setToken(token);
             kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
             kony.sdk.OfflineObjects.setup(objServiceList, setupOptions, argSuccessCallback, argFailueCallback);
         }, function() { //claims refresh failure callback
             kony.sdk.logsdk.error(LOG_PREFIX + ": Refresh claims token FAILED. Setup offline started.");
             kony.sdk.OfflineObjects.setup(objServiceList, setupOptions, argSuccessCallback, argFailueCallback);
         });
     };
     this.incrementalSetup = function(options, successCallback, failureCallback) {
         if (!options) {
             options = {};
         }
         options.incrementalSetup = true;
         this.setup(options, successCallback, failureCallback);
     }
     this.drop = function(options, successCallback, failureCallback) {
         // This change is required for app upgrade from 8.0 to 8.1
         var argSuccessCallback = successCallback;
         var argFailueCallback = failureCallback;
         var dropOptions = (typeof arguments[0] != "function") ? options : null;
         if (dropOptions === null) {
             argSuccessCallback = options;
             argFailueCallback = successCallback;
         }
         kony.sdk.logsdk.trace(LOG_PREFIX + ": OfflineObjects.drop() called");
         kony.sdk.OfflineObjects.drop(dropOptions, argSuccessCallback, argFailueCallback);
     }
     this.reset = function(options, successCallback, failureCallback) {
         // This change is required for app upgrade from 8.0 to 8.1
         var argSuccessCallback = successCallback;
         var argFailueCallback = failureCallback;
         var resetOptions = (typeof arguments[0] != "function") ? options : null;
         if (resetOptions === null) {
             argSuccessCallback = options;
             argFailueCallback = successCallback;
         }
         kony.sdk.logsdk.trace(LOG_PREFIX + ": OfflineObjects.reset called");
         kony.sdk.logsdk.trace(LOG_PREFIX + ": Refreshing claims token");
         kony.sdk.claimsRefresh(function() { //claims refresh success callback
             kony.sdk.logsdk.trace(LOG_PREFIX + ": Refresh claims token SUCCESS");
             var token = kony.sdk.getCurrentInstance().currentClaimToken;
             //kony.sdk.logsdk.debug(LOG_PREFIX+": Token : "+token);
             kony.sdk.OfflineObjects.setToken(token);
             kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
             kony.sdk.OfflineObjects.reset(objServiceList, resetOptions, argSuccessCallback, argFailueCallback);
         }, function(error) { //claims refresh failure callback
             kony.sdk.logsdk.error(LOG_PREFIX + ": Refresh claims token FAILED");
             failureCallback(error);
         });
     }
     this.rollback = function(successCallback, failureCallback) {
         kony.sdk.logsdk.trace(LOG_PREFIX + ": OfflineObjects.rollback() called");
         kony.sdk.OfflineObjects.rollback(successCallback, failureCallback);
     }
     this.executeSelectQuery = function(query, successCallback, failureCallback) {
         kony.sdk.logsdk.trace(LOG_PREFIX + ": OfflineObjects.executeSelectQuery() called");
         kony.sdk.OfflineObjects.executeSelectQuery(query, successCallback, failureCallback);
     }
     this.startSync = function(options, successCallback, failureCallback, progressCallback) {
         kony.sdk.logsdk.trace(LOG_PREFIX + ": OfflineObjects.startSync called");
         kony.sdk.logsdk.trace(LOG_PREFIX + ": Refreshing claims token");
         kony.sdk.claimsRefresh(function() { //claims refresh success callback
             kony.sdk.logsdk.trace(LOG_PREFIX + ": Refresh claims token SUCCESS");
             var token = kony.sdk.getCurrentInstance().currentClaimToken;
             kony.sdk.OfflineObjects.setToken(token);
             kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
             kony.sdk.OfflineObjects.startSync(options, successCallback, failureCallback, progressCallback);
         }, function(error) { //claims refresh failure callback
             kony.sdk.logsdk.error(LOG_PREFIX + "Application Sync : Refresh claims token FAILED");
             failureCallback(error);
         });
     }
 };
 kony.sdk.OfflineObjects.BinaryStatus = {
         "pending": 2,
         "completed": 4,
         "errored": 8
     }
     //
     //Binary FFI related functions
     //
 if (kony.sdk) {
     kony.sdk.binary = {};
 }
 kony.sdk.binary.constants = {
     ENDPOINT_URL: "endpointUrl",
     DOMAIN: "domain",
     RELATIVE_PATH: "relativepath",
     URL: "URL",
     HEADERS: "headers",
     METHOD: "method",
     UPLOAD_MODE: "uploadMode",
     BLOB: "blob",
     FILE_CONTENT: "${fileContent}",
     FILE: "file",
     HTTP_STATUS_CODE: "httpStatusCode",
     VALID_HTTP_REDIRECT_CODE: "309",
     UPLOAD_MODE_BINARY: "binary",
     UPLOAD_MODE_MULTIPART: "multipart",
     UPLOAD_PARAMS: "uploadParams",
     BLOB_ID: "BlobID",
     CONTEXT: "Context",
     SESSION_ID: "SessionID",
     BLOB_OBJECT: "BlobObject",
     ERROR: "Error",
     FILE_DETAILS: "FileDetails"
 };
 kony.sdk.binary.addMandatoryInternalOptions = function(options) {
     if (kony.sdk.isNullOrUndefined(options)) {
         options = {};
     }
     options[kony.sdk.binary.constants.DOMAIN] = konyRef.sessionReportingURL.split("/IST")[0];
     if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken)) {
         options[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
     }
     return options;
 };
 kony.sdk.binary.validateUploadParams = function(uploadParams) {
     //Validating user input.
     if (!kony.sdk.util.isJsonObject(uploadParams)) {
         kony.sdk.logsdk.error("### kony.sdk.binary.validateUploadParams :: Error: Upload params should be supplied as valid JSON object");
         return kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_params_instance, "Invalid datatype of uploadParams " + kony.sdk.util.type(uploadParams) + " " + kony.sdk.errormessages.invalid_params_instance)
     }
     // check for fileName
     if (!kony.sdk.util.isValidString(uploadParams[kony.sdk.constants.FILE_NAME])) {
         kony.sdk.logsdk.error("### kony.sdk.binary.validateUploadParams :: Error: fileName : expected string not found");
         return kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_params_instance, "" + "Invalid datatype of fileName " + kony.sdk.util.type(uploadParams[kony.sdk.constants.FILE_NAME]) + " " + kony.sdk.errormessages.invalid_params_instance);
     }
     // Check if fileObject is provided by user
     if (kony.sdk.isNullOrUndefined(uploadParams[kony.sdk.constants.FILE_OBJECT])) {
         kony.sdk.logsdk.error("### kony.sdk.binary.validateUploadParams :: Error: fileObject is not provided - please provide");
         return kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_params_instance, "fileObject is not provided " + kony.sdk.errormessages.invalid_params_instance);
     }
     // check if the fileObject provided by user is browser file object
     if (uploadParams[kony.sdk.constants.FILE_OBJECT].constructor !== File) {
         kony.sdk.logsdk.error("### kony.sdk.binary.validateUploadParams :: Error: fileObject : expected File Object and found " + kony.sdk.util.type(uploadParams[kony.sdk.constants.FILE_OBJECT]));
         return kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_params_instance, "Invalid datatype of fileObject " + kony.sdk.util.type(uploadParams[kony.sdk.constants.FILE_OBJECT]) + " " + kony.sdk.errormessages.invalid_params_instance);
     }
     return null;
 };
 kony.sdk.binary.networkHandler = function(requestUrl, method, headers, requestBody, successCallback, failureCallback) {
     var xmlHttpRequest = new XMLHttpRequest();
     var successCB = successCallback;
     var failureCB = failureCallback;
     if (kony.sdk.constants.HTTP_METHOD_GET === method) {
         xmlHttpRequest.open(kony.sdk.constants.HTTP_METHOD_GET, requestUrl, true);
         xmlHttpRequest.responseType = kony.sdk.binary.constants.BLOB;
     } else {
         // The responseType for the post request will be undefined hence default, which is "text" will be considered
         xmlHttpRequest.open(kony.sdk.constants.HTTP_METHOD_POST, requestUrl, true);
     }
     for (var header in headers) {
         if (headers.hasOwnProperty(header)) {
             xmlHttpRequest.setRequestHeader(header, headers[header]);
         }
     }

     function localRequestCallback() {
         var readyState = 0;
         var response = "";
         var status = xmlHttpRequest.status;
         switch (xmlHttpRequest.readyState) {
             case 0: // UNINITIALIZED
             case 1: // LOADING
             case 2: // LOADED
             case 3: // INTERACTIVE
                 readyState = xmlHttpRequest.readyState;
                 response = "";
                 break;
             case 4: // COMPLETED
                 readyState = xmlHttpRequest.readyState;
                 //Not using hasOwnProperty because its not available on browser generated objects like XMLHTTPRequest
                 if (xmlHttpRequest.response) {
                     response = xmlHttpRequest.response;
                 } else if (xmlHttpRequest.responseText) {
                     response = xmlHttpRequest.responseText;
                 }
                 if (status >= 200 && status <= 300) {
                     kony.sdk.verifyAndCallClosure(successCB, response);
                 } else {
                     kony.sdk.verifyAndCallClosure(failureCB, response);
                 }
                 break;
             default:
                 kony.sdk.logsdk.error("Unknown Error : XMLHttpRequest Error");
         }
     }
     xmlHttpRequest.onreadystatechange = localRequestCallback;
     xmlHttpRequest.send(requestBody);
 };
 kony.sdk.binary.getRequestParamsFromTemplate = function(template, templateParams, options) {
     var requestParamsForBinaryCall = {};
     var parsedTemplateData = kony.sdk.util.populateTemplate(JSON.stringify(template), templateParams);
     var parsedTemplate = JSON.parse(parsedTemplateData[kony.sdk.constants.PROCESSED_TEMPLATE]);
     requestParamsForBinaryCall[kony.sdk.constants.PROCESSED_TEMPLATE] = parsedTemplateData[kony.sdk.constants.PROCESSED_TEMPLATE];
     // TODO: Validate missing variables
     requestParamsForBinaryCall[kony.sdk.constants.MISSING_VARIABLES] = parsedTemplateData[kony.sdk.constants.MISSING_VARIABLES];
     var additionalParams = kony.sdk.binary.addMandatoryInternalOptions(options);
     //Fetching headers from template
     var headers = {};
     if (parsedTemplate.hasOwnProperty(kony.sdk.binary.constants.HEADERS) && kony.sdk.util.isJsonObject(parsedTemplate[kony.sdk.binary.constants.HEADERS]) && Object.keys(parsedTemplate[kony.sdk.binary.constants.HEADERS] > 0)) {
         headers = parsedTemplate[kony.sdk.binary.constants.HEADERS];
     }
     //Parsing the Backend Url from template
     var url = "";
     if (parsedTemplate.hasOwnProperty(kony.sdk.binary.constants.ENDPOINT_URL)) {
         url = parsedTemplate[kony.sdk.binary.constants.ENDPOINT_URL];
     } else if (parsedTemplate.hasOwnProperty(kony.sdk.binary.constants.DOMAIN) && parsedTemplate.hasOwnProperty(kony.sdk.binary.constants.RELATIVE_PATH)) {
         var domain = "";
         if (parsedTemplate[kony.sdk.binary.constants.DOMAIN] === "#middlewaredomain") {
             headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = additionalParams[kony.sdk.constants.KONY_AUTHORIZATION_HEADER];
             domain = additionalParams[kony.sdk.binary.constants.DOMAIN];
         } else {
             domain = parsedTemplate[kony.sdk.binary.constants.DOMAIN];
         }
         url = domain + parsedTemplate[kony.sdk.binary.constants.RELATIVE_PATH];
     }
     requestParamsForBinaryCall[kony.sdk.binary.constants.URL] = url;
     requestParamsForBinaryCall[kony.sdk.binary.constants.METHOD] = parsedTemplate[kony.sdk.binary.constants.METHOD];
     requestParamsForBinaryCall[kony.sdk.binary.constants.HEADERS] = headers;
     return requestParamsForBinaryCall;
 };
 kony.sdk.binary.getBinaryData = function(inputParams, streaming, downloadConfig, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, fileDownloadFailureCallback, options) {
     if (kony.sdk.isNullOrUndefined(downloadConfig[kony.sdk.binary.constants.ENDPOINT_URL]) && kony.sdk.isNullOrUndefined(downloadConfig[kony.sdk.binary.constants.DOMAIN]) && kony.sdk.isNullOrUndefined(downloadConfig[kony.sdk.binary.constants.RELATIVE_PATH])) {
         kony.sdk.verifyAndCallClosure(fileDownloadFailureCallback, "endpointUrl or domain and relative path is required in order to download a file");
         return;
     }
     var fileId = new Date().getTime().toString();
     kony.sdk.verifyAndCallClosure(fileDownloadStartedCallback, {
         "BlobID": fileId,
         "Context": inputParams
     });
     var requestParams = kony.sdk.binary.getRequestParamsFromTemplate(downloadConfig, inputParams, options);
     var parsedTemplate = JSON.parse(requestParams[kony.sdk.constants.PROCESSED_TEMPLATE]);
     if (parsedTemplate[kony.sdk.binary.constants.HTTP_STATUS_CODE] == kony.sdk.binary.constants.VALID_HTTP_REDIRECT_CODE) {
         kony.sdk.binary.networkHandler(requestParams[kony.sdk.binary.constants.URL], requestParams[kony.sdk.binary.constants.METHOD].toLocaleUpperCase(), requestParams[kony.sdk.binary.constants.HEADERS], null, function(blobObject) {
             var successObject = {};
             if (kony.sdk.isNullOrUndefined(inputParams["fileId"])) {
                 successObject[kony.sdk.binary.constants.BLOB_ID] = fileId;
             } else {
                 successObject[kony.sdk.binary.constants.BLOB_ID] = inputParams["fileId"];
             }
             successObject[kony.sdk.binary.constants.BLOB_OBJECT] = blobObject;
             successObject[kony.sdk.binary.constants.CONTEXT] = inputParams;
             kony.sdk.verifyAndCallClosure(fileDownloadCompletedCallback, successObject);
         }, function(networkError) {
             var errorObject = {};
             if (kony.sdk.isNullOrUndefined(inputParams["fileId"])) {
                 errorObject[kony.sdk.binary.constants.BLOB_ID] = fileId;
             } else {
                 errorObject[kony.sdk.binary.constants.BLOB_ID] = inputParams["fileId"];
             }
             errorObject[kony.sdk.binary.constants.CONTEXT] = inputParams;
             errorObject[kony.sdk.binary.constants.ERROR] = networkError;
             kony.sdk.verifyAndCallClosure(fileDownloadFailureCallback, errorObject);
         });
     } else {
         //TODO: Handle http status which is not 309
         kony.sdk.verifyAndCallClosure(fileDownloadFailureCallback, "Unhandled httpStatusCode received: " + parsedTemplate[kony.sdk.binary.constants.HTTP_STATUS_CODE]);
     }
 };
 kony.sdk.binary.uploadBinaryData = function(uploadParams, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback, options) {
     function templateFetchSuccess(uploadConfig) {
         if (kony.sdk.isNullOrUndefined(uploadConfig[kony.sdk.binary.constants.ENDPOINT_URL]) && kony.sdk.isNullOrUndefined(uploadConfig[kony.sdk.binary.constants.DOMAIN]) && kony.sdk.isNullOrUndefined(uploadConfig[kony.sdk.binary.constants.RELATIVE_PATH])) {
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "endpointUrl or domain and relative path is required in order to upload a file");
             return;
         }
         var sessionId = new Date().getTime().toString();
         kony.sdk.verifyAndCallClosure(fileUploadStartedCallback, {
             "SessionID": sessionId,
             "Context": uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS]
         });
         var requestParams = kony.sdk.binary.getRequestParamsFromTemplate(uploadConfig, uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS], options);
         var parsedTemplate = JSON.parse(requestParams[kony.sdk.constants.PROCESSED_TEMPLATE]);
         if (parsedTemplate[kony.sdk.binary.constants.HTTP_STATUS_CODE] == kony.sdk.binary.constants.VALID_HTTP_REDIRECT_CODE) {
             var requestBody;
             var fileObject;
             var requestBodyTemplateVariable = kony.sdk.util.getValueForKeyAndIgnoreCase(parsedTemplate, "requestBody");
             if (parsedTemplate[kony.sdk.binary.constants.UPLOAD_MODE].toLowerCase() === kony.sdk.binary.constants.UPLOAD_MODE_BINARY) {
                 if (requestBodyTemplateVariable === kony.sdk.binary.constants.FILE_CONTENT) {
                     requestBody = uploadParams[kony.sdk.constants.FILE_OBJECT];
                 } else if (kony.sdk.isValidString(requestBodyTemplateVariable) && requestBodyTemplateVariable.indexOf(kony.sdk.binary.constants.FILE_CONTENT) !== -1) {
                     //TODO - handling substituting fileContent in the template variable
                     kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "Received request body structure is not supported");
                 } else {
                     kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "Unhandled request body format received");
                 }
             } else if (parsedTemplate[kony.sdk.binary.constants.UPLOAD_MODE].toLowerCase() === kony.sdk.binary.constants.UPLOAD_MODE_MULTIPART) {
                 var formData = new FormData();
                 for (var key in requestBodyTemplateVariable) {
                     if (requestBodyTemplateVariable.hasOwnProperty(key) && kony.sdk.util.isJsonObject(requestBodyTemplateVariable)) {
                         if (requestBodyTemplateVariable[key] === kony.sdk.binary.constants.FILE_CONTENT) {
                             fileObject = uploadParams[kony.sdk.constants.FILE_OBJECT];
                         } else if (kony.sdk.util.isJsonObject(requestBodyTemplateVariable[key])) {
                             formData.append(key, JSON.stringify(requestBodyTemplateVariable[key]));
                         } else {
                             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "Unhandled request body format received");
                         }
                     }
                 }
                 formData.append(kony.sdk.binary.constants.FILE, fileObject);
                 requestBody = formData;
             }
             kony.sdk.binary.networkHandler(requestParams[kony.sdk.binary.constants.URL], requestParams[kony.sdk.binary.constants.METHOD].toLocaleUpperCase(), requestParams[kony.sdk.binary.constants.HEADERS], requestBody, function(networkResponse) {
                 var successObject = {};
                 successObject[kony.sdk.binary.constants.SESSION_ID] = sessionId;
                 successObject[kony.sdk.binary.constants.CONTEXT] = uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS];
                 successObject[kony.sdk.binary.constants.FILE_DETAILS] = networkResponse;
                 kony.sdk.verifyAndCallClosure(fileUploadCompletedCallback, successObject);
             }, function(networkError) {
                 var errorObject = {};
                 errorObject[kony.sdk.binary.constants.SESSION_ID] = sessionId;
                 errorObject[kony.sdk.binary.constants.CONTEXT] = uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS];
                 errorObject[kony.sdk.binary.constants.ERROR] = networkError;
                 kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, errorObject);
             });
         } else {
             //TODO: Handle http status which is not 309
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "Unhandled httpStatusCode received: " + parsedTemplate[kony.sdk.binary.constants.HTTP_STATUS_CODE]);
         }
     }
     //Invoking the template call
     var networkProvider = new konyNetworkProvider();
     networkProvider.post(uploadParams[kony.sdk.binary.constants.URL], uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS], uploadParams[kony.sdk.binary.constants.HEADERS], templateFetchSuccess, fileUploadFailureCallback)
 };
 if (typeof(kony.sdk.metric) === "undefined") {
     kony.sdk.metric = {};
 }
 kony.sdk.metric.eventFlowTag = "";
 kony.sdk.metric.eventConfig = {
     "confType": "BUFFER",
     "eventBufferAutoFlushCount": kony.sdk.metric.eventBufferAutoFlushValue,
     "eventBufferMaxCount": kony.sdk.metric.eventBufferMaxValue
 };
 kony.sdk.metric.eventBufferMaxValue = 1000;
 kony.sdk.metric.eventBufferAutoFlushValue = 15;
 kony.sdk.metric.characterLengthLimit = 256;
 kony.sdk.metric.reportEventBufferArray = [];
 kony.sdk.metric.reportEventBufferBackupArray = [];
 kony.sdk.metric.retrievedDS = false;
 kony.sdk.metric.eventBufferCount = 0;
 kony.sdk.metric.eventTypeMap = {
     "formentry": "FormEntry",
     "touch": "Touch",
     "servicecall": "ServiceCall",
     "gesture": "Gesture",
     "orientation": "Orientation",
     "custom": "Custom"
 };
 kony.sdk.metric.errorCodeMap = {
     "1000": true,
     "1011": true,
     "1012": true,
     "1014": true,
     "1015": true,
     "1016": true
 };
 kony.sdk.metric.setEventFlowTag = function(flowTag) {
     if (kony.sdk.isNullOrUndefined(flowTag)) {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for event flow tag");
     } else if (flowTag.length <= kony.sdk.metric.characterLengthLimit) {
         kony.sdk.metric.eventFlowTag = flowTag;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
     }
 };
 kony.sdk.metric.clearEventFlowTag = function() {
     kony.sdk.metric.eventFlowTag = "";
 };
 kony.sdk.metric.getEventFlowTag = function() {
     return kony.sdk.metric.eventFlowTag;
 };
 kony.sdk.metric.setEventConfig = function(confType, eventBufferAutoFlushCount, eventBufferMaxCount) {
     if (kony.sdk.isNullOrUndefined(confType)) {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Config Type can not be null");
     } else {
         confType = confType.toUpperCase();
     }
     if (confType === "BUFFER") {
         kony.sdk.metric.eventConfig["confType"] = confType;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for config type");
     }
     if (!kony.sdk.isNullOrUndefined(eventBufferMaxCount) && typeof(eventBufferMaxCount) === "number" && eventBufferMaxCount > 0) {
         kony.sdk.metric.eventConfig["eventBufferMaxCount"] = eventBufferMaxCount;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferMaxCount has to be a Number and greater than 0");
     }
     if (!kony.sdk.isNullOrUndefined(eventBufferAutoFlushCount) && typeof(eventBufferAutoFlushCount) === "number" && eventBufferAutoFlushCount > 0 && eventBufferAutoFlushCount <= eventBufferMaxCount) {
         kony.sdk.metric.eventConfig["eventBufferAutoFlushCount"] = eventBufferAutoFlushCount;
     } else if (eventBufferAutoFlushCount >= eventBufferMaxCount) {
         kony.sdk.metric.eventConfig["eventBufferMaxCount"] = 1000;
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferAutoFlushCount can not be greater than eventBufferMaxCount");
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferAutoFlushCount has to be a Number and greater than 0");
     }
 };
 kony.sdk.metric.reportEvent = function(evttype, evtSubType, formID, widgetID, flowTag) {
     if (kony.sdk.metric.reportEventBufferBackupArray.length === 0) {
         kony.sdk.metric.readFromDS();
     }
     kony.sdk.metric.eventBufferCount = kony.sdk.metric.reportEventBufferBackupArray.length + kony.sdk.metric.reportEventBufferArray.length;
     if (kony.sdk.metric.eventBufferCount === kony.sdk.metric.eventConfig["eventBufferMaxCount"]) {
         throw new Exception(kony.sdk.errorConstants.DATA_STORE_EXCEPTION, "Reached maximum limit to store events");
         return;
     }
     var reportEventMap = {};
     reportEventMap.ts = kony.sdk.formatCurrentDate(new Date());
     evttype = evttype.toLowerCase();
     if (kony.sdk.isNullOrUndefined(kony.sdk.metric.eventTypeMap[evttype])) {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for event type");
         return;
     } else {
         reportEventMap["evttype"] = kony.sdk.metric.eventTypeMap[evttype];
     }
     if (kony.sdk.isNullOrUndefined(evtSubType)) {
         reportEventMap["evtSubType"] = "";
     } else if (evtSubType.length <= kony.sdk.metric.characterLengthLimit) {
         reportEventMap["evtSubType"] = evtSubType;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
         return;
     }
     if (kony.sdk.isNullOrUndefined(formID)) {
         reportEventMap["formID"] = kony.application.getCurrentForm().id;
     } else if (formID.length <= kony.sdk.metric.characterLengthLimit) {
         reportEventMap["formID"] = formID;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
         return;
     }
     if (kony.sdk.isNullOrUndefined(widgetID)) {
         reportEventMap["widgetID"] = "";
     } else if (widgetID.length <= kony.sdk.metric.characterLengthLimit) {
         reportEventMap["widgetID"] = widgetID;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
         return;
     }
     if (kony.sdk.isNullOrUndefined(flowTag)) {
         reportEventMap["flowTag"] = kony.sdk.metric.getEventFlowTag();
     } else if (flowTag.length <= kony.sdk.metric.characterLengthLimit) {
         reportEventMap["flowTag"] = flowTag;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
         return;
     }
     reportEventMap.SID = kony.ds.read(kony.sdk.constants.KONYUUID)[0];
     kony.sdk.metric.reportEventBufferArray.push(reportEventMap);
     if (kony.sdk.metric.reportEventBufferArray.length % kony.sdk.metric.eventConfig["eventBufferAutoFlushCount"] === 0) {
         kony.sdk.metric.flushEvents();
     }
 };
 kony.sdk.metric.flushEvents = function() {
     if (kony.sdk.metric.reportEventBufferBackupArray.length === 0) {
         kony.sdk.metric.readFromDS();
     }
     if (kony.sdk.metric.reportEventBufferBackupArray.length === 0 && kony.sdk.metric.reportEventBufferArray.length === 0) {
         kony.sdk.logsdk.warn("There are no events to flush");
         return;
     }
     var payload = kony.sdk.getPayload(kony.sdk.getCurrentInstance());
     var params = {};
     if (kony.sdk.metric.reportEventBufferArray.length !== 0) {
         kony.sdk.metric.pushEventsToBufferArray();
     }
     var headers = {};
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
     params.httpheaders = headers;
     payload.events = kony.sdk.metric.reportEventBufferBackupArray;
     payload.svcid = "SendEvents";
     payload.rsid = kony.sdk.metric.reportEventBufferBackupArray[0].SID;
     params[kony.sdk.constants.REPORTING_PARAMS] = JSON.stringify(payload);
     kony.net.invokeServiceAsync(kony.sdk.currentInstance.customReportingURL, params, flushCallback);

     function flushCallback(status, response) {
         if (status === 400) {
             if (response.opstatus == 0) {
                 kony.sdk.metric.clearBufferEvents();
             } else if (kony.sdk.metric.errorCodeMap[response.opstatus]) {
                 kony.sdk.metric.saveInDS();
             } else {
                 kony.sdk.metric.clearBufferEvents();
             }
         } else if (status === 300) {
             kony.sdk.metric.saveInDS();
         }
     }
 };
 /*Stores event data in Data Store on failure of service Call*/
 kony.sdk.metric.saveInDS = function() {
     if (!kony.sdk.isNullOrUndefined(kony.sdk.metric.reportEventBufferBackupArray) && kony.sdk.metric.reportEventBufferBackupArray.length > 0) {
         var eventsToSave = [];
         eventsToSave.push(JSON.stringify(kony.sdk.metric.reportEventBufferBackupArray));
         kony.ds.save(eventsToSave, "konyMetricsBuffer");
         kony.sdk.metric.reportEventBufferBackupArray = [];
     }
 };
 /*Clearing events sent to server */
 kony.sdk.metric.clearBufferEvents = function() {
     kony.sdk.metric.reportEventBufferBackupArray = [];
     kony.ds.remove("konyMetricsBuffer");
 };
 /*Reading any pending events from Data Store */
 kony.sdk.metric.readFromDS = function() {
     var eventsFromDS = kony.ds.read("konyMetricsBuffer");
     if (eventsFromDS !== null) {
         var pushToArray = [];
         pushToArray.push(JSON.parse(eventsFromDS[0]));
         kony.sdk.metric.reportEventBufferBackupArray.push.apply(kony.sdk.metric.reportEventBufferBackupArray, pushToArray);
     }
 };
 /*Pushes events received from user to BufferBackupArray which will be flushed to server */
 kony.sdk.metric.pushEventsToBufferArray = function() {
     kony.sdk.metric.reportEventBufferBackupArray.push.apply(kony.sdk.metric.reportEventBufferBackupArray, kony.sdk.metric.reportEventBufferArray);
     kony.sdk.metric.reportEventBufferArray = [];
 };
 kony.sdk.metric.getEventsInBuffer = function() {
     var eventsFromDS = kony.ds.read("konyMetricsBuffer");
     var eventsToReturn = [];
     if (!kony.sdk.isNullOrUndefined(eventsFromDS)) {
         eventsToReturn.push(JSON.parse(eventsFromDS[0]));
     }
     if (kony.sdk.metric.reportEventBufferArray.length !== 0) {
         eventsToReturn.push.apply(eventsToReturn, kony.sdk.metric.reportEventBufferArray);
     }
     if (eventsToReturn.length !== 0) {
         return eventsToReturn;
     } else {
         return null;
     }
 };
 kony.logger = kony.logger || {};
 kony.logger.createNewLogger = function(loggerName, loggerConfig) {
     parseConfig = function(loggerConfig) {
         //private methods
         if (loggerConfig === null || typeof(loggerConfig) === 'undefined') {
             loggerConfig = {};
         } else {
             loggerConfig = loggerConfig.getLoggerConfig();
         }
         if (typeof(appConfig) != 'undefined') {
             appDetails = {
                 appID: appConfig.appId,
                 appVersion: appConfig.appVersion,
                 sessionID: kony.license.getSessionId()
             };
             //appInfo
             loggerConfig.appInfo = appDetails;
         }
         return loggerConfig;
     };
     logMessage = function(loggerObj, logLevel, msg, params) {
         logMessageInFFI = function(NativeLoggerObject, logLevel, message) {
             switch (logLevel) {
                 case kony.logger.logLevel.TRACE:
                     NativeLoggerObject.logTrace(message);
                     break;
                 case kony.logger.logLevel.DEBUG:
                     NativeLoggerObject.logDebug(message);
                     break;
                 case kony.logger.logLevel.INFO:
                     NativeLoggerObject.logInfo(message);
                     break;
                 case kony.logger.logLevel.PERF:
                     NativeLoggerObject.logPerf(message);
                     break;
                 case kony.logger.logLevel.WARN:
                     NativeLoggerObject.logWarning(message);
                     break;
                 case kony.logger.logLevel.ERROR:
                     NativeLoggerObject.logError(message);
                     break;
                 case kony.logger.logLevel.FATAL:
                     NativeLoggerObject.logFatal(message);
                     break;
                 default:
                     kony.print("Implementation not found for the specified log level " + logLevel);
                     return;
             }
         };
         formatLineInfo = function(callerInformation) {
             if (callerInformation.length == 3) {
                 return callerInformation[1];
             }
             // MFSDK-3910
             // Temporary Fix to send line number as null if not present instead of undefined(<null>)
             return "";
         };
         formatFileInfo = function(callerInformation) {
             if (callerInformation.length >= 1) {
                 callerInformation = callerInformation[callerInformation.length - 1];
                 callerInformation = callerInformation.replace("(", "");
                 callerInformation = callerInformation.replace(")", "");
                 callerInformation = callerInformation.split(":");
                 if (callerInformation.length == 3) {
                     return callerInformation[0];
                 }
             }
         };
         formatMethodInformation = function(callerInformation) {
             if (callerInformation.length > 1) return callerInformation[callerInformation.length - 2];
         };
         formatCallerInformation = function(callerInformation) {
             //JSCore syntax: <methodName>@<fileName>:<row>:<col>
             //V8 syntax: at <methodName> (<fileName>:<row>:<col>)
             //Chakra syntax: at (<methodURL> <fileURL>:<row>:<col>)
             if (callerInformation !== null) {
                 var seperator = " ";
                 formattedCallerInformation = callerInformation.split(seperator);
                 return formattedCallerInformation;
             }
             return [];
         };
         getCallerInformationFromCallStack = function(callStack, indirectionLevel) {
             var index = 5;
             index += indirectionLevel;
             if (callStack.length >= index) return callStack[index];
             return null;
         };
         generateCallerInformation = function(indirectionLevel) {
             var errorObject = new Error();
             var callStack;
             // In IE, Error object doesn't contain stack information, hence can't provide caller info
             if (errorObject.hasOwnProperty("stack")) {
                 callStack = errorObject.stack.split("\n");
             } else {
                 callStack = [];
             }
             var callerInformation = getCallerInformationFromCallStack(callStack, indirectionLevel);
             return formatCallerInformation(callerInformation);
         };
         parseMessage = function(loggerObj, logLevel, msg, params) {
             var logLevelVal = (kony.logger.isNativeLoggerAvailable()) ? KonyLogger.getLogLevel() : kony.logger.currentLogLevel.value;
             if (logLevel.value >= logLevelVal) {
                 var metaData = {};
                 params = (typeof(params) === "undefined") ? "" : params;
                 //Stringify object
                 if (kony.logger.isValidJSTable(params)) {
                     params = JSON.stringify(params, null, " ");
                 }
                 metaData.message = msg + params;
                 metaData.callerInformation = generateCallerInformation(loggerObj.getIndirectionLevel());
                 metaData.methodName = formatMethodInformation(metaData.callerInformation);
                 metaData.fileName = formatFileInfo(metaData.callerInformation);
                 metaData.lineNo = formatLineInfo(metaData.callerInformation);
                 if (kony.logger.isNativeLoggerAvailable()) {
                     if (!loggerObj.NativeLoggerObject) {
                         loggerObj.NativeLoggerObject = new KonyLogger.InitializeLogger(loggerObj.loggerName);
                         KonyLogger.setConfig(loggerObj.config);
                     }
                     if (loggerObj.NativeLoggerObject) {
                         logMessageInFFI(loggerObj.NativeLoggerObject, logLevel, metaData);
                     } else {
                         var date = new Date().toLocaleDateString();
                         var time = new Date().toLocaleTimeString();
                         var level = logLevel.code;
                         var formattedMessage = "[" + loggerObj.loggerName + "][" + level + "][" + date + " " + time + "][" + metaData.fileName + "][" + metaData.methodName + "][" + metaData.lineNo + "] : " + metaData.message;
                         kony.print(formattedMessage);
                     }
                 } else {
                     var date = new Date().toLocaleDateString();
                     var time = new Date().toLocaleTimeString();
                     var level = logLevel.code;
                     var formattedMessage = "[" + loggerObj.loggerName + "][" + level + "][" + date + " " + time + "][" + metaData.fileName + "][" + metaData.methodName + "][" + metaData.lineNo + "] : " + metaData.message;
                     kony.print(formattedMessage);
                 }
             }
         };
         parseMessage(loggerObj, logLevel, msg, params);
     };
     //Exposed object and it's methods
     var loggerObj = kony.logger.createLoggerObject(loggerName, loggerConfig);
     //Native object creation
     if (kony.logger.isNativeLoggerAvailable()) {
         loggerObj.NativeLoggerObject = new KonyLogger.InitializeLogger(loggerName);
         KonyLogger.setConfig(loggerObj.config);
     }
     return loggerObj;
 }
 kony.logger["appLogger"] = kony.logger.appLoggerInitialisation();
 /**
  * MFSDK
  * Created by KH2204.
  * Copyright  2018 Kony. All rights reserved.
  */
 /**
  * Method to create the integration service instance with the provided service name.
  * @param {string} serviceName - Name of the service
  * @returns {IntegrationService} Integration service instance
  */
 kony.sdk.prototype.getIntegrationService = function(serviceName) {
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + "integration service :" + serviceName);
     }
     var konyRef = kony.sdk.getCurrentInstance();
     if (!kony.sdk.skipAnonymousCall && !this.currentClaimToken && !konyRef.isAnonymousProvider) {
         throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Valid claims token is not found, login using identity service before performing an operation on this integration service :" + serviceName);
     }
     if (this.integsvc != null) {
         if (this.integsvc[serviceName] != null) {
             kony.sdk.logsdk.debug("found integration service" + this.integsvc[serviceName]);
             return new IntegrationService(this, serviceName);
         }
     }
     throw new Exception(kony.sdk.errorConstants.INTEGRATION_FAILURE, "Integration service is not found or invalid :" + serviceName);
 };
 /**
  * Method should not be called by developer.
  * @class
  * @classdesc Integration service instance for invoking the integration services.
  */
 function IntegrationService(konyRef, serviceName) {
     var serviceUrl = "";
     var svcObj = konyRef.integsvc[serviceName];
     if (typeof(svcObj) === "object") {
         serviceUrl = svcObj["url"];
     } else {
         serviceUrl = svcObj;
     }
     var networkProvider = new konyNetworkProvider();
     if (kony.sdk.util.isNullOrEmptyString(serviceName) || kony.sdk.util.isNullOrEmptyString(serviceUrl)) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "Invalid serviceUrl and serviceName");
     }
     serviceUrl = stripTrailingCharacter(serviceUrl, "/");
     this.getUrl = function() {
         return serviceUrl;
     };
     /**
      * Integration service success callback method.
      * @callback integrationSuccessCallback
      * @param {json} response - Integration service response
      */
     /**
      * Integration service failure callback method.
      * @callback integrationFailureCallback
      * @param {json} error - Error information
      */
     /**
      * invoke the specified operation
      * @param {string} operationName - Name of the operation
      * @param {object} headers - Input headers for the operation
      * @param {object} data - Input data for the operation
      * @param {integrationSuccessCallback} successCallback  - Callback method on success
      * @param {integrationFailureCallback} failureCallback - Callback method on failure
      * @param {object} options - XMLHttpRequest options like withCredentials value.
      */
     this.invokeOperation = function(operationName, headers, data, successCallback, failureCallback, options) {
         function invokeOperationHandler() {
             _invokeOperation(operationName, headers, data, true, successCallback, failureCallback, options);
         }
         if (kony.sdk.skipAnonymousCall) {
             invokeOperationHandler();
         } else {
             kony.sdk.claimsRefresh(invokeOperationHandler, failureCallback);
         }
     };
     /**
      * Integration service API to upload binaries based on adapter template
      * @param {string} operationName - Name of the operation
      * @param {Object} uploadParams - InputContext or template variables
      * @param {callback} fileUploadStartedCallback - Callback which is invoked on start of file upload
      * @param {callback} chunkUploadCompletedCallback - Callback which is invoked on chunk upload
      * @param {callback} fileUploadCompletedCallback - Callback which is invoked on complete of file upload
      * @param {callback} fileUploadFailureCallback - Callback which is invoked in case of error during upload
      * @param {Object} options - Provision for user to send additional options
      */
     this.uploadBinaryData = function(operationName, uploadParams, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback, options) {
         var errorObj = kony.sdk.binary.validateUploadParams(uploadParams);
         if (errorObj) {
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, errorObj);
             return;
         }
         // if rawbytes are provided, converting to base64 string as can only receive base datatypes
         if (!kony.sdk.isNullOrUndefined(uploadParams[kony.sdk.constants.RAW_BYTES])) {
             var base64String = kony.convertToBase64(uploadParams[kony.sdk.constants.RAW_BYTES]);
             uploadParams[kony.sdk.constants.RAW_BYTES] = base64String;
         }

         function uploadBinaryDataHandler() {
             var uploadOptions = {};
             uploadOptions["URL"] = serviceUrl + "/" + operationName;
             var headers = {};
             if (!kony.sdk.skipAnonymousCall) {
                 headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = kony.sdk.getCurrentInstance().currentClaimToken;
             }
             uploadOptions["headers"] = headers;
             //Extracting Mandatory Params from uploadParams before fetching template
             if (uploadParams[kony.sdk.constants.FILE_PATH]) {
                 uploadOptions[kony.sdk.constants.FILE_PATH] = uploadParams[kony.sdk.constants.FILE_PATH];
                 delete uploadParams[kony.sdk.constants.FILE_PATH];
             } else if (uploadParams[kony.sdk.constants.RAW_BYTES]) {
                 uploadOptions[kony.sdk.constants.RAW_BYTES] = uploadParams[kony.sdk.constants.RAW_BYTES];
                 delete uploadParams[kony.sdk.constants.RAW_BYTES];
             } else if (uploadParams[kony.sdk.constants.FILE_OBJECT]) {
                 uploadOptions[kony.sdk.constants.FILE_OBJECT] = uploadParams[kony.sdk.constants.FILE_OBJECT];
                 delete uploadParams[kony.sdk.constants.FILE_OBJECT]
             }
             uploadOptions["uploadParams"] = uploadParams;
             kony.sdk.binary.uploadBinaryData(uploadOptions, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback, options);
         }
         if (kony.sdk.skipAnonymousCall) {
             uploadBinaryDataHandler();
         } else {
             kony.sdk.claimsRefresh(uploadBinaryDataHandler, fileUploadFailureCallback);
         }
     };
     /**
      * Integration service API to download binaries based on adapter template
      * @param {string} operationName - Name of the operation
      * @param {Object} fileparams - InputContext or template variables
      * @param {boolean} streaming - Boolean value to determine, whether chunks need to be saved to file or sent in callbacks
      * @param {Object} headers - Provision for custom headers
      * @param {callback} fileDownloadStartedCallback - Callback which is invoked on start of file download
      * @param {callback} chunkDownloadCompletedCallback - Callback which is invoked on stream/chunk download
      * @param {callback} fileDownloadCompletedCallback - Callback which is invoked on complete of file download
      * @param {callback} downloadFailureCallback - Callback which is invoked in case of error during download
      * @param {Object} options - Provision for user to send additional options
      */
     this.getBinaryData = function(operationName, fileparams, streaming, headers, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback, options) {
         function getBinaryDataHandler() {
             _invokeOperation(operationName, headers, fileparams, true, function(downloadConfig) {
                 if (kony.sdk.isNullOrUndefined(downloadConfig)) {
                     downloadConfig = {};
                 }
                 if (options && options["ChunkSize"]) {
                     downloadConfig.ChunkSize = options["ChunkSize"];
                 }
                 if (headers) {
                     if (kony.sdk.isNullOrUndefined(downloadConfig.headers)) {
                         downloadConfig.headers = {};
                     }
                     for (var header in headers) {
                         if (headers.hasOwnProperty(header)) {
                             downloadConfig.headers[header] = headers[header];
                         }
                     }
                 }
                 kony.sdk.binary.getBinaryData(fileparams, streaming, downloadConfig, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback, options);
             }, downloadFailureCallback, options);
         }
         if (kony.sdk.skipAnonymousCall) {
             // Check to find if the service is public or not, in case of public service anonymous login is not required.
             getBinaryDataHandler();
         } else {
             kony.sdk.claimsRefresh(getBinaryDataHandler, downloadFailureCallback);
         }
     };

     function invokeOperationRetry(operationName, headers, data, successCallback, failureCallback, options) {
         function invokeOperationRetryHandler() {
             _invokeOperation(operationName, headers, data, false, successCallback, failureCallback, options);
         }
         if (kony.sdk.skipAnonymousCall) {
             invokeOperationRetryHandler();
         } else {
             kony.sdk.claimsAndProviderTokenRefresh(invokeOperationRetryHandler, failureCallback);
         }
     }

     function retryServiceCall(errorResponse) {
         if (errorResponse[kony.sdk.constants.MF_CODE]) {
             // check for the mfcode for which,
             // retry should be done.
         } else {
             if (errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] && errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] === 401) {
                 kony.sdk.logsdk.debug("### IntegrationService::retryServiceCall received 401 from fabric, trying to refresh backend token");
                 return true;
             }
         }
     }

     function _invokeOperation(operationName, headers, data, isRetryNeeded, successCallback, failureCallback, options) {
         var requestData = kony.sdk.getEncodedReportingParamsForSvcid(operationName);
         var dataToSend = {};
         for (var key in data) {
             if (data.hasOwnProperty(key)) {
                 dataToSend[key] = data[key];
             }
         }
         var defaultHeaders = {};
         defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         defaultHeaders["X-Kony-ReportingParams"] = requestData;
         if (!kony.sdk.skipAnonymousCall) {
             // Check to find if the service is public or not, in case of public service no token is required.
             var token = konyRef.currentClaimToken;
             if (!token) {
                 token = kony.sdk.getCurrentInstance().currentClaimToken;
             }
             defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = token;
         }
         var deviceId = kony.sdk.getDeviceId();
         if (!kony.sdk.isNullOrUndefined(deviceId)) {
             defaultHeaders["X-Kony-DeviceId"] = deviceId;
         }
         if (typeof(svcObj) === 'object' && svcObj.version) {
             defaultHeaders["X-Kony-API-Version"] = svcObj.version;
         }
         // if the user has defined his own headers, use them
         if (!kony.sdk.isNullOrUndefined(headers)) {
             if ((Object.keys(headers)).length !== 0 && typeof(headers) === "object") {
                 var defaultKeys = Object.keys(defaultHeaders);
                 var lowerCaseHeaders = defaultKeys.map(function(x) {
                     return x.toLowerCase()
                 });
                 for (var header in headers) {
                     var headerConst = header;
                     if (lowerCaseHeaders.indexOf(headerConst.toLowerCase()) !== -1) {
                         for (var i = 0; i < defaultKeys.length; i++) {
                             var tempKey = defaultKeys[i];
                             if (tempKey.toLowerCase() === headerConst.toLowerCase()) {
                                 defaultHeaders[tempKey] = headers[header];
                             }
                         }
                     } else {
                         defaultHeaders[header] = headers[header];
                     }
                 }
             }
         }
         // If useCache is enabled and cacheID is present then network call will be skipped and cached response will be returned.
         if (options && options["useCache"] && options["cacheID"]) {
             var cacheResponse = new kony.sdk.ClientCache().get(options["cacheID"]);
             if (cacheResponse) {
                 kony.sdk.logsdk.debug("Key found in hash, returning cached response.");
                 kony.sdk.verifyAndCallClosure(successCallback, cacheResponse);
                 return;
             }
         }

         function networkSuccessCallback(res) {
             // If useCache is enabled then the response is cached and returned.
             if (options && options["useCache"]) {
                 cacheResponseForKey(options, serviceUrl + "/" + operationName, requestData, res);
             }
             kony.sdk.verifyAndCallClosure(successCallback, res);
         }

         function networkFailureCallback(xhr, status, err) {
             if (xhr && !(status && err)) {
                 err = xhr;
             }
             if (isRetryNeeded === true && retryServiceCall(err) === true) {
                 kony.sdk.logsdk.debug("errorCallback, retrying the operation: " + operationName);
                 invokeOperationRetry(operationName, headers, data, successCallback, failureCallback);
                 return;
             }
             kony.sdk.processIntegrationErrorResponse(err, true, failureCallback);
         }
         networkProvider.post(serviceUrl + "/" + operationName, dataToSend, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
     }
     kony.sdk.processIntegrationErrorResponse = function(err, isAsync, callBack) {
         if (err[kony.sdk.constants.MF_CODE]) {
             //clear the cache if the error code related to session/token expiry
             if (kony.sdk.isSessionOrTokenExpired(err[kony.sdk.constants.MF_CODE])) {
                 kony.sdk.logsdk.info("###IntegrationService::invokeOperationFailure  Session/Token expired. Authenticate and Try again");
                 //TODO: Start a conversation with Suhas and Krishna regarding the scenario wherein one auth session expired and other is still valid.
             }
         }
         if (!isAsync) {
             return kony.sdk.error.getIntegrationErrObj(err);
         } else if (callBack) {
             kony.sdk.verifyAndCallClosure(callBack, kony.sdk.error.getIntegrationErrObj(err));
         }
     };
     //This is an internal api to invoke an service synchronously
     this.invokeOperationSync = function(operationName, headers, data) {
         var res = null;
         res = kony.sdk.claimsRefreshSync();
         if (res && res.message && res.message === "success") {
             return _invokeOperationSync(operationName, headers, data);
         } else {
             return res;
         }
     };

     function _invokeOperationSync(operationName, headers, data) {
         var requestData = {};
         var konyRef = kony.sdk.getCurrentInstance();
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(operationName);
         for (var key in data) {
             if (data.hasOwnProperty(key)) {
                 requestData[key] = data[key];
             }
         }
         var token;
         for (var tempToken in konyRef.tokens) {
             if (konyRef.tokens.hasOwnProperty(tempToken) && typeof(tempToken) !== 'function') {
                 token = konyRef.tokens[tempToken];
                 break;
             }
         }
         requestData[kony.sdk.constants.REPORTING_PARAMS] = reportingData;
         var defaultHeaders = {}
         defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
         if (typeof(svcObj) === 'object' && svcObj.version) {
             defaultHeaders["X-Kony-API-Version"] = svcObj.version;
         }
         // if the user has defined his own headers, use them
         if ((Object.keys(headers)).length !== 0) {
             var defaultKeys = [];
             defaultKeys = Object.keys(defaultHeaders);
             var defaultkeyLower = {};
             defaultkeyLower = defaultKeys.map(function(x) {
                 return x.toLowerCase()
             });
             for (var header in headers) {
                 var headerConst = header;
                 if (defaultkeyLower.indexOf(headerConst.toLowerCase()) !== -1) {
                     for (var i = 0; i < defaultKeys.length; i++) {
                         var tempKey = defaultKeys[i];
                         if (tempKey.toLowerCase() === headerConst.toLowerCase()) {
                             defaultHeaders[tempKey] = headers[header];
                         }
                     }
                 } else {
                     defaultHeaders[header] = headers[header];
                 }
             }
         }
         var res = null;
         res = networkProvider.postSync(serviceUrl + "/" + operationName, requestData, defaultHeaders);
         if (res.opstatus == 0) {
             return res;
         } else {
             return kony.sdk.processIntegrationErrorResponse(res, false);
         }
     }
 }
 kony.sdk.claimsRefreshSync = function() {
     var konyRef = kony.sdk.getCurrentInstance();
     var networkProvider = new konyNetworkProvider();
     var loginWithAnonymousProvider = function() {
         var identityObject = konyRef.getIdentityService("$anonymousProvider");
         var res = identityObject.anonymousLoginSync(null);
         if (res && JSON.stringify(res) == "{}") {
             return {
                 "message": "success"
             };
         } else {
             return kony.sdk.error.getAuthErrObj(res);
         }
     };
     if (konyRef.currentClaimToken === null) {
         kony.sdk.logsdk.info("claims Token is Unavialable");
         if (konyRef.isAnonymousProvider) {
             return loginWithAnonymousProvider();
         } else {
             return kony.sdk.error.getNullClaimsTokenErrObj();
         }
     } else if (konyRef.claimTokenExpiry && new Date().getTime() > konyRef.claimTokenExpiry) {
         if (konyRef.isAnonymousProvider) {
             return loginWithAnonymousProvider();
         } else {
             kony.sdk.logsdk.info("claims token has expired. fetching new token..");
             var _serviceUrl = stripTrailingCharacter(konyRef.rec.url, "/");
             var _url = _serviceUrl + "/claims";
             kony.sdk.logsdk.debug("service url is " + _url);
             if (konyRef.currentRefreshToken === null) {
                 return kony.sdk.error.getNullRefreshTokenErrObj();
             } else {
                 var headers = {};
                 headers[kony.sdk.constants.AUTHORIZATION_HEADER] = konyRef.currentRefreshToken;
                 headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
                 var data = networkProvider.postSync(_url, {}, headers);
                 if (data.opstatus == 0) {
                     kony.sdk.logsdk.info("refresh success..acquiring new tokens");
                     return kony.sdk.processClaimsSuccessResponse(data, konyRef, false);
                 } else {
                     kony.sdk.logsdk.info("failed to acquire refresh token");
                     return kony.sdk.processClaimsErrorResponse(data, konyRef, false);
                 }
             }
         }
     } else {
         return {
             "message": "success"
         };
     }
 };
 /**
  * Method to create the messaging service instance.
  * @returns {MessagingService} Messaging service instance
  */
 kony.sdk.prototype.getMessagingService = function() {
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Messaging service.");
     }
     return new MessagingService(this);
 };
 /**
  * Should not be called by the developer.
  * @class
  * @classdesc Messaging service instance for invoking the Messaging services.
  * @param konyRef - reference to kony object
  */
 function MessagingService(konyRef) {
     var homeUrl = konyRef.messagingsvc.url;
     var appId = konyRef.messagingsvc.appId;
     var networkProvider = new konyNetworkProvider();
     var dsKey_KSID = appId + "_KSID";
     var dsKey_authToken = appId + "_AUTHTOKEN";
     var currentObject = this;
     var geoBoundaryData;
     var KSID;
     var AUTHTOKEN;
     this.getUrl = function() {
         return homeUrl;
     };
     this.setKSID = function(ksid) {
         kony.sdk.dataStore.setItem(dsKey_KSID, ksid);
         KSID = ksid;
     };
     this.getKSID = function() {
         if (!KSID) {
             KSID = kony.sdk.dataStore.getItem(dsKey_KSID);
         }
         return KSID;
     };
     this.setAuthToken = function(authToken) {
         kony.sdk.dataStore.setItem(dsKey_authToken, authToken);
         AUTHTOKEN = authToken
     };
     this.getAuthToken = function(options) {
         if (options && options[kony.sdk.constants.AUTH_TOKEN]) {
             AUTHTOKEN = options[kony.sdk.constants.AUTH_TOKEN];
         } else {
             //retrieving from local store if user given token is null
             AUTHTOKEN = kony.sdk.dataStore.getItem(dsKey_authToken);
         }
         return AUTHTOKEN;
     };
     var setGeoBoundaryData = function(data) {
         kony.sdk.dataStore.setItem("geoBoundaryData", data);
         geoBoundaryData = data;
     };
     var getGeoBoundaryDataForBoundaryId = function(boundaryId) {
         if (!geoBoundaryData) {
             geoBoundaryData = kony.sdk.dataStore.getItem("geoBoundaryData")
         }
         return geoBoundaryData[boundaryId];
     };
     this.setKmsAppId = function(id) {
         appId = id;
     };
     this.getKmsAppId = function() {
         return appId;
     };
     KSID = currentObject.getKSID();
     AUTHTOKEN = currentObject.getAuthToken();
     var registerForMessagingService = function(osType, deviceId, pnsToken, email, authToken, successCallback, failureCallback) {
         var uri = homeUrl + "/subscribers";
         var subscribeParamsJson = {
             "sid": pnsToken,
             "appId": appId,
             "ufid": email,
             "osType": osType,
             "deviceId": deviceId
         };
         if (authToken != undefined && authToken != null) {
             subscribeParamsJson[kony.sdk.constants.AUTH_TOKEN] = authToken;
         }
         var jsonParam = {
             "subscriptionService": {
                 "subscribe": subscribeParamsJson
             }
         };
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var payload = {
             postdata: JSON.stringify(jsonParam)
         };
         var networkOptions = {};
         networkOptions["disableIntegrity"] = true;
         networkProvider.post(uri, payload, headers, function(data) {
             currentObject.setKSID(data.id);
             currentObject.setAuthToken(authToken);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(data, status, error) {
             kony.sdk.logsdk.error("ERROR: Failed to register device for KMS");
             var errorObj = {};
             errorObj.data = data;
             errorObj.status = status;
             errorObj.error = error;
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     var subscribeAudienceOrUpdate = function(firstName, lastName, emailId, mobileNumber, country, state, options, successCallback, failureCallback) {
         var uri = homeUrl + kony.sdk.constants.SUBSCRIBE_AUDIENCE;
         var subscribeAudienceJson = {
             "ksid": KSID,
             "firstName": firstName,
             "lastName": lastName,
             "email": emailId,
             "mobileNumber": mobileNumber,
             "country": country,
             "state": state
         };
         var currentdate = new Date();
         //toLocaleString gives current time in below format
         //6/25/2018, 12:38:21 PM
         var datetime = currentdate.toLocaleString('en-US', {
             timeZone: 'UTC'
         });
         //remove , in the current UTC time
         datetime = datetime.replace(",", "");
         subscribeAudienceJson[kony.sdk.constants.LAST_ACTIVE_DATE] = datetime;
         if (!kony.sdk.isNullOrUndefined(options)) {
             for (var key in options) {
                 if (options.hasOwnProperty(key)) {
                     if (key === kony.sdk.constants.AUTH_TOKEN) {
                         subscribeAudienceJson[key] = currentObject.getAuthToken(options);
                     } else {
                         subscribeAudienceJson[key] = options[key];
                     }
                 }
             }
         }
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var payload = {
             postdata: JSON.stringify(subscribeAudienceJson)
         };
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         networkProvider.post(uri, payload, headers, function(data) {
             //override data store auth token with user given token
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(data, status, error) {
             kony.sdk.logsdk.error("ERROR: Failed to create or update audience", errorObj);
             var errorObj = {};
             errorObj.data = data;
             errorObj.status = status;
             errorObj.error = error;
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     /**
     * register to messaging service
     * @param {string} osType - Type of the operating system
     * @param {string} deviceId - Device Id
     * @param {string} pnsToken - Token value
     * @param {string} ufid - UFID can be email-id,mobile number or
	 						any dynamic attribute configured as reconciliation key in Engagement console
     * @param {function} successCallback - Callback method on success
     * @param {function} failureCallback - Callback method on failure
     * @param {dictionary} options - {authToken: <Auth Token>}
     */
     this.register = function(osType, deviceId, pnsToken, ufid, successCallback, failureCallback, options) {
         var authToken = null;
         if (kony.sdk.isNullOrUndefined(pnsToken)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid pnsToken/sId, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(osType)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid osType, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(deviceId)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid deviceId, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(ufid)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid email, it cannot be null");
         }
         authToken = currentObject.getAuthToken(options);
         registerForMessagingService(osType, deviceId, pnsToken, ufid, authToken, function(data) {
             //override data store auth token with user given token
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(errorObj) {
             kony.sdk.logsdk.error("Register :: Register for messaging service failed with error", errorObj);
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         });
     };
     /**
      * register to messaging service
      * @param {string} osType - Type of the operating system
      * @param {string} deviceId - Device Id
      * @param {string} authToken - Authorization Token
      * @param {string} pnsToken - Token value
      * @param {string} email - email
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     /**
      * @deprecated This method is deprecated because authToken can be given as input through options param of
      * register method.
      */
     this.registerWithAuthToken = function(osType, deviceId, pnsToken, email, authToken, successCallback, failureCallback) {
         if (kony.sdk.isNullOrUndefined(pnsToken)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid pnsToken/sId,it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(osType)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid osType, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(deviceId)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid deviceId, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(email)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid email, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(authToken)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid authToken, it cannot be null");
         }
         registerForMessagingService(osType, deviceId, pnsToken, email, authToken, function(data) {
             kony.sdk.verifyAndCallClosure(successCallback, data)
         }, function(errorObj) {
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         });
     };
     var unregisterFromMessagingService = function(authToken, successCallback, failureCallback) {
         var uri = homeUrl + "/subscribers";
         var unsubscribeObj = {
             "ksid": currentObject.getKSID()
         };
         if (authToken != undefined && authToken != null) {
             unsubscribeObj[kony.sdk.constants.AUTH_TOKEN] = authToken;
         }
         var inp = {
             "subscriptionService": {
                 "unsubscribe": unsubscribeObj
             }
         };
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var payload = {
             postdata: JSON.stringify(inp)
         };
         kony.sdk.logsdk.info("unsubscribe uri:" + uri);
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         networkProvider.post(uri, payload, headers, function(data) {
             kony.sdk.dataStore.removeItem(dsKey_KSID);
             kony.sdk.dataStore.removeItem(dsKey_authToken);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(data, status, error) {
             kony.sdk.logsdk.error("ERROR: Failed to unregister device for KMS");
             var errorObj = {};
             errorObj.data = data;
             errorObj.status = status;
             errorObj.error = error;
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     /**
      * unregister to messaging service
      * @param {dictionary} options - {authToken: <Auth Token>}
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     this.unregister = function(successCallback, failureCallback, options) {
         var tempKSID = currentObject.getKSID();
         var authToken = null;
         if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
         }
         authToken = currentObject.getAuthToken(options);
         unregisterFromMessagingService(authToken, successCallback, failureCallback);
     };
     /**
      * unregister to messaging service
      * @param {string} authToken - Authorization Token
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     /**
      * @deprecated This method is deprecated because authToken can be given as input through options param of
      * unregister method.
      */
     this.unregisterWithAuthToken = function(authToken, successCallback, failureCallback) {
         var tempKSID = currentObject.getKSID();
         if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
         }
         if (typeof(authToken) === 'undefined' || authToken === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid authToken.");
         }
         unregisterFromMessagingService(authToken, successCallback, failureCallback);
     };
     /**
      * Fetch all messages
      * @param {number} startIndex - starting index
      * @param {number} pageSize - page size
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {dictionary} options - {authToken: <Auth Token>}
      */
     this.fetchAllMessages = function(startIndex, pageSize, successCallback, failureCallback, options) {
         var tempKSID = currentObject.getKSID();
         if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
         }
         var uri = homeUrl + "/messages/fetch";
         var data = {
             "ksid": tempKSID,
             "startElement": startIndex,
             "elementsPerPage": pageSize
         };
         data[kony.sdk.constants.AUTH_TOKEN] = currentObject.getAuthToken(options);
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var payload = {
             postdata: JSON.stringify(data)
         };
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         networkProvider.post(uri, payload, headers, function(data) {
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(errorObj) {
             kony.sdk.logsdk.error("FetchAllMessages :: FetchAllMessages for messaging service failed with error", errorObj);
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     var updateGeoLocationForMessagingService = function(latitude, longitude, locationName, authToken, successCallback, failureCallback) {
         var uri = homeUrl + "/location";
         var data = {
             "ksid": currentObject.getKSID(),
             "latitude": latitude,
             "longitude": longitude
         };
         if (typeof(locationName) === "string") {
             data["locname"] = locationName;
         }
         if (authToken != null && authToken != undefined) {
             data[kony.sdk.constants.AUTH_TOKEN] = authToken;
         }
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var payload = {
             postdata: JSON.stringify(data)
         };
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         networkProvider.post(uri, payload, headers, function(data) {
             //override data store auth token with user given token
             currentObject.setAuthToken(authToken);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(errorObj) {
             kony.sdk.logsdk.error("UpdateGeoLocation :: UpdateGeoLocation for messaging service failed with error", errorObj);
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     /**
      * Update the location
      * @param {string} latitude - Latitude value
      * @param {string} longitude - Longitude value
      * @param {string} locationName - Location name
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {dictionary} options - {authToken: <Auth Token>}
      */
     this.updateGeoLocation = function(latitude, longitude, locationName, successCallback, failureCallback, options) {
         var tempKSID = currentObject.getKSID();
         var authToken = null;
         if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
         }
         if (typeof(latitude) === 'undefined' || latitude === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid latitude.");
         }
         if (typeof(longitude) === 'undefined' || longitude === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid longitude.");
         }
         authToken = currentObject.getAuthToken(options);
         updateGeoLocationForMessagingService(latitude, longitude, locationName, authToken, successCallback, failureCallback);
     };
     /**
      * Update the location
      * @param {string} latitude - Latitude value
      * @param {string} longitude - Longitude value
      * @param {string} locationName - Location name
      * @param {string} authToken - Authorization Token
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     /**
      * @deprecated This method is deprecated because authToken can be given as a input through options param of
      * updateGeoLocation method
      */
     this.updateGeoLocationWithAuthToken = function(latitude, longitude, locationName, authToken, successCallback, failureCallback) {
         var tempKSID = currentObject.getKSID();
         if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
         }
         if (typeof(latitude) === 'undefined' || latitude === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid latitude.");
         }
         if (typeof(longitude) === 'undefined' || longitude === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid longitude.");
         }
         if (typeof(authToken) === 'undefined' || authToken === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid authToken.");
         }
         updateGeoLocationForMessagingService(latitude, longitude, locationName, authToken, successCallback, failureCallback);
     };
     /**
      * Mark the message as read for a given message id
      * @param {string} fetchId - Message id
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {dictionary} options - {authToken: <Auth Token>}
      */
     this.markMessageRead = function(fetchId, successCallback, failureCallback, options) {
         if (typeof(fetchId) === 'undefined' || fetchId === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid FetchId, it cannot be null");
         }
         var headers = {};
         headers["X-HTTP-Method-Override"] = "get";
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var uri = homeUrl + "/messages/open/" + fetchId;
         headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         networkProvider.get(uri, null, headers, function(data) {
             //override data store auth token with user given token
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(errorObj) {
             kony.sdk.logsdk.error("MarkMessageRead :: MarkMessageRead for messaging service failed with error", errorObj);
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     /**
      * Fetches the message conetent for a given message id
      * @param {string} fetchId - Message id
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {dictionary} options - {authToken: <Auth Token>}
      */
     this.fetchMessageContent = function(fetchId, successCallback, failureCallback, options) {
         if (typeof(fetchId) === 'undefined' || fetchId === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid FetchId, it cannot be null");
         }
         var uri = homeUrl + "/messages/content/" + fetchId;
         var headers = {};
         headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         networkProvider.get(uri, null, headers, function(data) {
             //override data store auth token with user given token
             overrideAuthToken(options)
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(errorObj) {
             kony.sdk.logsdk.error("FetchMessageContent :: FetchMessageContent for messaging service failed with error", errorObj);
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     /**
      * subscribeAudience to create a audience for subscribed device
      * @param {string} firstName - audience firstName
      * @param {string} lastName - audience lastName
      * @param {string} emailId - audience emailId
      * @param {string} mobileNumber - audience mobileNumber
      * @param {string} country - country
      * @param {string} state - state
      * @param {Object] options - {authToken: <Auth Token>} and user defined attributes like PAN no,SSN.
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     this.subscribeAudience = function(firstName, lastName, emailId, mobileNumber, country, state, successCallback, failureCallback, options) {
         if (kony.sdk.isNullOrUndefined(KSID)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service before creating or updating");
         }
         if (kony.sdk.isNullOrUndefined(firstName)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid first name, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(lastName)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid last name, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(mobileNumber)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid mobile number, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(emailId)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid email Id, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(country)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid country, it cannot be null");
         }
         subscribeAudienceOrUpdate(firstName, lastName, emailId, mobileNumber, country, state, options, successCallback, failureCallback);
     };
     /**
      * delete subscribed audience
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {dictionary} options - {authToken: <Auth Token>}
      **/
     this.unSubscribeAudience = function(successCallback, failureCallback, options) {
         if (kony.sdk.isNullOrUndefined(KSID)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service before unsubscribe audience");
         }
         var uri = homeUrl + kony.sdk.constants.SUBSCRIBE_AUDIENCE + "/" + KSID;
         var headers = {};
         headers[kony.sdk.constants.HTTP_OVERRIDE_HEADER] = kony.sdk.constants.HTTP_METHOD_DELETE;
         headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         networkProvider.post(uri, null, headers, function(data) {
             //override data store auth token with user given token
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(err) {
             kony.sdk.logsdk.error("### MessagingService::unSubscribeAudience failed to unsubscribe audience", err);
             kony.sdk.verifyAndCallClosure(failureCallback, err);
         }, null, networkOptions);
     };
     /*
      * get subscribed audience details
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {dictionary} options - {authToken: <Auth Token>}
      */
     this.getSubscribedAudienceDetails = function(successCallback, failureCallback, options) {
             if (kony.sdk.isNullOrUndefined(KSID)) {
                 throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service before get subscribed audience details");
             }
             var uri = homeUrl + kony.sdk.constants.SUBSCRIBE_AUDIENCE + "/" + KSID;
             var headers = {};
             headers[kony.sdk.constants.HTTP_OVERRIDE_HEADER] = kony.sdk.constants.HTTP_METHOD_GET;
             headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
             var networkOptions = {};
             networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
             networkProvider.get(uri, null, headers, function(data) {
                 //override data store auth token with user given token
                 overrideAuthToken(options);
                 kony.sdk.verifyAndCallClosure(successCallback, data);
             }, function(err) {
                 kony.sdk.logsdk.error("### MessagingService::getSubscribedAudienceDetails failed to get audience details", err);
                 kony.sdk.verifyAndCallClosure(failureCallback, err);
             }, null, networkOptions);
         }
         /*
          * get rich push content
          * @param pushId {string} - pushId for getting rich push content.Which we get after registering
          * for push notifications.
          * @param {function} successCallback - Callback method on success
          * @param {function} failureCallback - Callback method on failure
          * @param {dictionary} options - {authToken: <Auth Token>}
          */
     this.getRichPushContent = function(pushId, successCallback, failureCallback, options) {
         if (kony.sdk.isNullOrUndefined(KSID)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service to get rich push content");
         }
         if (kony.sdk.isNullOrUndefined(pushId)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid PushId,it cannot be null");
         }
         var uri = homeUrl + kony.sdk.constants.RICH_PUSH_MESSAGE + pushId;
         var headers = {};
         headers[kony.sdk.constants.HTTP_OVERRIDE_HEADER] = kony.sdk.constants.HTTP_METHOD_GET;
         headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         networkProvider.get(uri, null, headers, function(data) {
             //override data store auth token with user given token
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(err) {
             kony.sdk.logsdk.error("MESSAGING SERVICE :: getRichPushContent failed to get rich content with error", err);
             kony.sdk.verifyAndCallClosure(failureCallback, err);
         }, null, networkOptions);
     };
     /*
      * Update the list of beacons
      * @param {string} uuId - Universally Unique Identifier to identify a beacon in a network
      * @param {string} major - major id to identity and distinguish a group
      * @param {string} minor - distinguishing individual beacons within a group of beacons assigned a major value.
      * @param {function} successCallback - Callback method called on success.
      * @param {function} failureCallback - Callback method called on failure.
      * @param {object} options - options which accepts optional parameters such as ufid,appid and {authToken: <Auth Token>}
      */
     this.updateListOfBeacons = function(uuId, major, minor, successCallback, failureCallback, options) {
         if (kony.sdk.isNullOrUndefined(KSID)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service before updating list of beacons");
         }
         if (kony.sdk.isNullOrUndefined(uuId)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid UUID,it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(major)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid major,it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(minor)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid minor,it cannot be null");
         }
         var uri = homeUrl + kony.sdk.constants.BEACON_UPDATE;
         var payload = {};
         payload[kony.sdk.constants.KSID] = KSID;
         var beaconsList = {};
         //beacon object has beacon details like uuid,major and minor
         var beacon = {};
         beacon["uuid"] = uuId;
         beacon["major"] = major;
         beacon["minor"] = minor;
         beaconsList["beacon"] = beacon;
         payload["beacons"] = beaconsList;
         payload[kony.sdk.constants.AUTH_TOKEN] = currentObject.getAuthToken(options);
         //appid and ufid are optional
         if (options && options["ufid"]) {
             payload["ufid"] = options["ufid"];
         }
         if (options && options["appid"]) {
             payload["appid"] = options["appid"];
         }
         var payload = {
             postdata: JSON.stringify(payload)
         }
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         networkProvider.post(uri, payload, headers, function(data) {
             //override data store auth token with user given token
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(err) {
             kony.sdk.logsdk.error("MESSAGING SERVICE :: updateListOfBeacons failed to update with error", err);
             kony.sdk.verifyAndCallClosure(failureCallback, err);
         }, null, networkOptions);
     };
     /*
      * Utility method to override datastore authtoken with user given auth token.
      */
     var overrideAuthToken = function(options) {
         var authToken;
         if (options && options[kony.sdk.constants.AUTH_TOKEN]) {
             currentObject.setAuthToken(options[kony.sdk.constants.AUTH_TOKEN]);
         }
     };
 }
 /**
  * Method to create the Metrics service instance with the provided service name.
  * @returns {MetricsService} Metrics service instance
  */
 kony.sdk.prototype.getMetricsService = function() {
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Metrics service.");
     }
     if (!kony.sdk.isLicenseUrlAvailable) {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "metrics is not enabled");
     }
     //var metricsServiceObject = null;
     if (this.metricsServiceObject) {
         return this.metricsServiceObject;
     }
     if (this.internalSdkObject) {
         //framework implementation
         this.metricsServiceObject = this.internalSdkObject.getMetricsService();
     } else {
         //sdk local implementation
         this.metricsServiceObject = new MetricsService(this);
     }
     return this.metricsServiceObject;
 };
 /**
  * Should not be called by the developer.
  * @class
  * @classdesc Metrics service instance for invoking the Metrics services.
  */
 function MetricsService(konyRef) {
     var url = konyRef.customReportingURL;
     if (typeof(url) === 'undefined') {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "reporting url is undefined");
     }
     var networkProvider = new konyNetworkProvider();
     /**
      * invoke the getUserId operation
      */
     this.getUserId = function() {
         return konyRef.getUserId();
     };
     //start of event api
     var eventFlowTag = "";
     var eventBufferMaxValue = 1000;
     var eventBufferAutoFlushValue = 15;
     var characterLengthLimit = 256;
     var eventConfig = {
         "confType": "BUFFER",
         "eventBufferAutoFlushCount": eventBufferAutoFlushValue,
         "eventBufferMaxCount": eventBufferMaxValue
     };
     var reportEventBufferArray = [];
     var reportEventBufferBackupArray = [];
     var retrievedDS = false;
     var eventBufferCount = 0;
     var eventTypeMap = {
         "formentry": "FormEntry",
         "formexit": "FormExit",
         "touch": "Touch",
         "servicerequest": "ServiceRequest",
         "serviceresponse": "ServiceResponse",
         "gesture": "Gesture",
         "orientation": "Orientation",
         "error": "Error",
         "exception": "Exception",
         "crash": "Crash",
         "custom": "Custom",
         "servicecall": "ServiceCall",
         "apptransition": "AppTransition",
         "appload": "AppLoad",
         "component": "Component"
     };
     var errorCodeMap = {
         "1000": true,
         "1011": true,
         "1012": true,
         "1014": true,
         "1015": true,
         "1016": true
     };
     /**
      * This method will take the a String to set a Flow Tag for the reported events.
      * @param {string} flowTag - sets flow tag for reporting the events.
      */
     this.setFlowTag = function(flowTag) {
         if (kony.sdk.isNullOrUndefined(flowTag)) {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for event flow tag");
         } else if (flowTag.length <= characterLengthLimit) {
             eventFlowTag = flowTag;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + characterLengthLimit + " characters");
         }
     };
     /**
      * This method will clear the flow tag set by the user previously.
      */
     this.clearFlowTag = function() {
         eventFlowTag = "";
     };
     /**
      * This method will return the a String to set a Flow Tag for the reported events.
      * @return {string} flowTag - flow tag set by the user for reporting the events.
      */
     this.getFlowTag = function() {
         return eventFlowTag;
     };
     /**
      * This method will take the required values to set the event Configuration values.
      * @param {string} confType - sets the Current Configuration Type
      * 					possible values BUFFER or INSTANT.
      * @param {number} eventBufferAutoFlushCount - event buffer count to auto flush the events
      * 								possible values any positive integer
      * 								Default value 15
      * @param {number} eventBufferMaxCount - Maximum event buffer count to store the events
      * 								possible values any positive integer
      * 								Default value 1000
      */
     this.setEventConfig = function(confType, eventBufferAutoFlushCount, eventBufferMaxCount) {
         if (kony.sdk.isNullOrUndefined(confType)) {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Config Type can not be null");
         } else {
             confType = confType.toUpperCase();
         }
         if (confType === "BUFFER") {
             eventConfig["confType"] = confType;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for config type");
         }
         if (!kony.sdk.isNullOrUndefined(eventBufferMaxCount) && typeof(eventBufferMaxCount) === "number" && eventBufferMaxCount > 0) {
             eventConfig["eventBufferMaxCount"] = eventBufferMaxCount;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferMaxCount has to be a Number and greater than 0");
         }
         if (!kony.sdk.isNullOrUndefined(eventBufferAutoFlushCount) && typeof(eventBufferAutoFlushCount) === "number" && eventBufferAutoFlushCount > 0 && eventBufferAutoFlushCount <= eventBufferMaxCount) {
             eventConfig["eventBufferAutoFlushCount"] = eventBufferAutoFlushCount;
         } else if (eventBufferAutoFlushCount >= eventBufferMaxCount) {
             eventConfig["eventBufferMaxCount"] = 1000;
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferAutoFlushCount can not be greater than eventBufferMaxCount");
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferAutoFlushCount has to be a Number and greater than 0");
         }
     };
     /**
      * This method takes the event details from the developer and schedule it for sending to server as per Configuration values set by the developer.
      * @param {string} evttype - Event Type for the reported event.
      * @param {string} evtSubType - string literal for eventSubType(max 256 Chars)
      * @param {string} formID -   string literal for formID(max 256 Chars)
      * @param {string} widgetID - string literal for widgetID(max 256 Chars)
      * @param {string} flowTag - string literal to override flow tag (max 256 Chars)
      * @param {string} metaData - string to describe metaData
      * @throws Exception
      */
     this.sendEvent = function(evttype, evtSubType, formID, widgetID, flowTag, metaData) {
         if (reportEventBufferBackupArray.length === 0) {
             this.readFromDS();
         }
         eventBufferCount = reportEventBufferBackupArray.length + reportEventBufferArray.length;
         if (eventBufferCount === eventConfig["eventBufferMaxCount"]) {
             throw new Exception(kony.sdk.errorConstants.DATA_STORE_EXCEPTION, "Reached maximum limit to store events");
         }
         var reportEventMap = {};
         reportEventMap.ts = kony.sdk.formatCurrentDate(new Date());
         evttype = evttype.toLowerCase();
         if (kony.sdk.isNullOrUndefined(eventTypeMap[evttype])) {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for event type");
         } else {
             reportEventMap["evttype"] = eventTypeMap[evttype];
         }
         if (kony.sdk.isNullOrUndefined(evtSubType)) {
             reportEventMap["evtSubType"] = "";
         } else if (evtSubType.length <= characterLengthLimit) {
             reportEventMap["evtSubType"] = evtSubType;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event evtSubType is " + characterLengthLimit + " characters");
         }
         if (kony.sdk.isNullOrUndefined(formID)) {
             reportEventMap["formID"] = kony.application.getCurrentForm().id;
         } else if (formID.length <= characterLengthLimit) {
             reportEventMap["formID"] = formID;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event formID is " + characterLengthLimit + " characters");
         }
         if (kony.sdk.isNullOrUndefined(widgetID)) {
             reportEventMap["widgetID"] = "";
         } else if (widgetID.length <= characterLengthLimit) {
             reportEventMap["widgetID"] = widgetID;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event widgetID is " + characterLengthLimit + " characters");
         }
         if (kony.sdk.isNullOrUndefined(flowTag)) {
             reportEventMap["flowTag"] = this.getFlowTag();
         } else if (flowTag.length <= characterLengthLimit) {
             reportEventMap["flowTag"] = flowTag;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flowTag is " + characterLengthLimit + " characters");
         }
         reportEventMap.SID = this.getSessionId();
         reportEventMap.metaData = metaData;
         //checking each event data is a proper json or not
         // 	throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid json string passed for events data");
         // }
         reportEventBufferArray.push(reportEventMap);
         if (reportEventBufferArray.length % eventConfig["eventBufferAutoFlushCount"] === 0) {
             this.flushEvents();
         }
     };
     /**
      * This method will send the buffered events to the server at once.
      */
     this.flushEvents = function() {
         var url = kony.sdk.currentInstance.customReportingURL;
         var ref = this;
         if (reportEventBufferBackupArray.length === 0) {
             ref.readFromDS();
         }
         if (reportEventBufferBackupArray.length === 0 && reportEventBufferArray.length === 0) {
             kony.sdk.logsdk.warn("There are no events to flush");
             return;
         }
         var payload = kony.sdk.getPayload(kony.sdk.getCurrentInstance());
         var params = {};
         if (reportEventBufferArray.length !== 0) {
             ref.pushEventsToBufferArray();
         }
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         payload.events = reportEventBufferBackupArray;
         payload.svcid = "SendEvents";
         payload.rsid = this.getSessionId();
         params[kony.sdk.constants.REPORTING_PARAMS] = JSON.stringify(payload);
         var options = {};
         options["disableIntegrity"] = true;
         networkProvider.post(url, params, headers, flushSuccessCallback, flushErrorCallback, null, options);

         function flushSuccessCallback(response) {
             if (response.opstatus == 0) {
                 ref.clearBufferEvents();
             } else if (errorCodeMap[response.opstatus]) {
                 ref.saveInDS();
             } else {
                 ref.clearBufferEvents();
             }
         }

         function flushErrorCallback(response) {
             kony.sdk.logsdk.error("Unable to flush events");
             ref.saveInDS();
         }
     };
     /*Stores event data in Data Store on failure of service Call*/
     this.saveInDS = function() {
         var eventsToSave = [];
         eventsToSave.push(JSON.stringify(reportEventBufferBackupArray));
         kony.ds.save(eventsToSave, "konyMetricsBuffer");
         reportEventBufferBackupArray = [];
     };
     /*Clearing events sent to server */
     this.clearBufferEvents = function() {
         reportEventBufferBackupArray = [];
         kony.ds.remove("konyMetricsBuffer");
     };
     /*Reading any pending events from Data Store */
     this.readFromDS = function() {
         var eventsFromDS = kony.ds.read("konyMetricsBuffer");
         if (eventsFromDS !== null) {
             var pushToArray = [];
             pushToArray.push(JSON.parse(eventsFromDS[0]));
             reportEventBufferBackupArray.push.apply(reportEventBufferBackupArray, pushToArray);
         }
     };
     /*Pushes events received from user to BufferBackupArray which will be flushed to server */
     this.pushEventsToBufferArray = function() {
         reportEventBufferBackupArray.push.apply(reportEventBufferBackupArray, reportEventBufferArray);
         reportEventBufferArray = [];
     };
     /**
      * This method will return the a List of the buffered events.
      * @return {object} events - list of events stored in buffer.
      */
     this.getEventsInBuffer = function() {
         var eventsFromDS = kony.ds.read("konyMetricsBuffer");
         var eventsToReturn = [];
         if (!kony.sdk.isNullOrUndefined(eventsFromDS)) {
             eventsToReturn.push(JSON.parse(eventsFromDS[0]));
         }
         if (reportEventBufferArray.length !== 0) {
             eventsToReturn.push.apply(eventsToReturn, reportEventBufferArray);
         }
         if (eventsToReturn.length !== 0) {
             return eventsToReturn;
         } else {
             return null;
         }
     };
     /**
      * invoke the sendCustomMetrics operation
      * @param {string} reportingGroupID - reporting Group ID
      * @param {object} metrics - metrics being reported
      */
     this.sendCustomMetrics = function(reportingGroupID, metrics) {
         if (typeof(metrics) !== "object") {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid type for metrics data.");
         }
         var reportData = kony.sdk.dataStore.getItem("konyCustomReportData");
         if (!reportData) {
             reportData = [];
         } else {
             reportData = JSON.parse(reportData);
         }
         kony.sdk.dataStore.removeItem("konyCustomReportData");
         var currentData = {};
         currentData.ts = kony.sdk.formatCurrentDate(new Date().toString());
         currentData.fid = reportingGroupID;
         currentData.metrics = metrics;
         currentData.rsid = this.getSessionId();
         reportData.push(currentData);
         //nyRef.getDataStore().setItem("konyCustomReportData",JSON.stringify(reportData));
         var payload = kony.sdk.getPayload(konyRef);
         if (kony.sdk.metric) {
             if (kony.sdk.metric.reportEventBufferBackupArray.length === 0) {
                 kony.sdk.metric.readFromDS();
             }
             kony.sdk.metric.pushEventsToBufferArray();
             payload.events = kony.sdk.metric.reportEventBufferBackupArray;
         }
         payload.reportData = reportData;
         payload.rsid = this.getSessionId();
         payload.svcid = "CaptureKonyCustomMetrics";
         var newData = {};
         newData[kony.sdk.constants.REPORTING_PARAMS] = JSON.stringify(payload);
         var options = {};
         options["disableIntegrity"] = true;
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         networkProvider.post(url, newData, headers, function(res) {
             //successcallback
             //konyRef.getDataStore().removeItem("konyCustomReportData");
             if (kony.sdk.metric) {
                 kony.sdk.metric.clearBufferEvents();
             }
             kony.sdk.logsdk.info("metric data successfully sent" + JSON.stringify(res));
         }, function(res) {
             var storeData = kony.sdk.dataStore.getItem("konyCustomReportData");
             if (!storeData) {
                 storeData = reportData;
             } else {
                 storeData = JSON.parse(storeData);
                 reportData.forEach(function(e) {
                     storeData.push(e);
                 });
             }
             if (kony.sdk.metric) {
                 if (kony.sdk.metric.errorCodeMap[res.opstatus]) {
                     kony.sdk.metric.saveInDS();
                 }
             }
             kony.sdk.dataStore.setItem("konyCustomReportData", JSON.stringify(storeData));
             kony.sdk.logsdk.error("Unable to send metric report" + JSON.stringify(res));
         }, true, options);
     };
     /**
      * This method takes the event details from the developer and schedule it for sending to server as per Configuration values set by the developer.
      * @param {string} errorCode - errorCode of the reported error. Can be empty if not applicable
      * @param {string} errorType -   errorType of the reported error. Can be empty if not applicable
      * @param {string} errorMessage - errorMessage of the reported error. Can be empty if not applicable
      * @param {json} errorDetails - errorDetails of the reported error as a json string that can have key-value pairs for the following
     				keys errfile, errmethod, errline, errstacktrace, formID, widgetID, flowTag.
      * @throws Exception
      */
     this.reportError = function(errorCode, errorType, errorMessage, errorDetails) {
         var metaData = {};
         metaData.errcode = errorCode ? errorCode : "";
         metaData.errmsg = errorMessage ? errorMessage : "";
         if (errorDetails && kony.sdk.isJson(errorDetails)) {
             metaData.errfile = errorDetails.errfile ? errorDetails.errfile : "";
             metaData.errmethod = errorDetails.errmethod ? errorDetails.errmethod : "";
             metaData.errline = errorDetails.errline ? errorDetails.errline : "";
             metaData.errstacktrace = errorDetails.errstacktrace ? errorDetails.errstacktrace : "";
             metaData.errcustommsg = errorDetails.errcustommsg ? errorDetails.errcustommsg : "";
             var formID = errorDetails.formID ? errorDetails.formID : "";
             var widgetID = errorDetails.widgetID ? errorDetails.widgetID : "";
             var flowTag = errorDetails.flowTag ? errorDetails.flowTag : "";
             var evtSubType = errorType ? errorType : "";
             this.sendEvent("Error", evtSubType, formID, widgetID, flowTag, JSON.stringify(metaData));
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid json string passed for error details.");
         }
     };
     /**
      * This method takes the event details from the developer and schedule it for sending to server as per Configuration values set by the developer.
      * @param {string} exceptionCode - Code for the reported exception. Can be empty if not applicable
      * @param {string} exceptionType -   Type of the reported exception. Can be empty if not applicable
      * @param {string} exceptionMessage - Message of the reported exception. Can be empty if not applicable
      * @param {json}   exceptionDetails - Details of the reported exception as a JSON string that can have key-value pairs for the
     				following keys exceptioncode, exceptionfile, exceptionmethod, exceptionline,
     				exceptionstacktrace, formID, widgetID, flowTag.
      * @throws Exception
      */
     this.reportHandledException = function(exceptionCode, exceptionType, exceptionMessage, exceptionDetails) {
         var metaData = {};
         metaData.exceptioncode = exceptionCode ? exceptionCode : "";
         metaData.exceptionmsg = exceptionMessage ? exceptionMessage : "";
         if (exceptionDetails && kony.sdk.isJson(exceptionDetails)) {
             metaData.exceptionfile = exceptionDetails.errfile ? exceptionDetails.errfile : "";
             metaData.exceptionmethod = exceptionDetails.errmethod ? exceptionDetails.errmethod : "";
             metaData.exceptionline = exceptionDetails.errline ? exceptionDetails.errline : "";
             metaData.exceptionstacktrace = exceptionDetails.errstacktrace ? exceptionDetails.errstacktrace : "";
             metaData.exceptioncustommsg = exceptionDetails.errcustommsg ? exceptionDetails.errcustommsg : "";
             var formID = exceptionDetails.formID ? exceptionDetails.formID : "";
             var widgetID = exceptionDetails.widgetID ? exceptionDetails.widgetID : "";
             var flowTag = exceptionDetails.flowTag ? exceptionDetails.flowTag : "";
             var evtSubType = exceptionType ? exceptionType : "";
             this.sendEvent("Exception", evtSubType, formID, widgetID, flowTag, JSON.stringify(metaData));
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid json string passed for exception details.");
         }
     };
     /**
      * sets the current sessionId
      * @param {string} sessionId
      */
     this.setSessionId = function(sessionId) {
         if (sessionId) {
             kony.sdk.currentInstance.setSessionId(sessionId);
         }
     };
     /**
      * get the current sessionID
      *
      */
     this.getSessionId = function() {
         return kony.sdk.currentInstance.getSessionId();
     };
     /**
      * stub method used for event tracking
      *
      */
     this.setEventTracking = function(eventTypes) {
         // Stub.  This is implemented in native->js binding
     }
 }
 kony.sdk.initiateSession = function() {};
 /**
  * Method which returns the offline enabled ObjectService object
  * @param konyRef
  * @param serviceName
  * @constructor
  */
 kony.sdk.OfflineEnabledObjectService = function(konyRef, serviceName) {
     this.serviceName = serviceName;
     this.konyRef = konyRef;
     /**
      * This method is used to fetch records on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.fetch = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.fetch");
         if (!areOptionsValid(options, failureCallback)) {
             return;
         }
         try {
             var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
             var objectName = dataObject.getObjectName();

             function fetchHandler(objMetadata) {
                 var obj = new kony.sdk.KNYObj(objectName);
                 var readOptions = dataObject.getOfflineObjectsOptions();
                 /* If read options are not supplied, caller such as fetchDataForColumns model API would provide a select query object and some callers provide query params.
                  *  We parse the select query or queryParams to suite offline objects read API.
                  */
                 if (!readOptions || Object.keys(readOptions).length == 0) {
                     var selectQueryObject = dataObject.getSelectQueryObject();
                     var queryParams = options[kony.sdk.constants.ObjectServiceConstants.QUERYPARAMS];
                     if (selectQueryObject) {
                         readOptions.projectionColumns = [];
                         var columns = selectQueryObject.getColumns();
                         for (var column in columns) {
                             readOptions.projectionColumns.push(columns[column].getName());
                         }
                         var criteriaList = selectQueryObject.getCriterias();
                         var primaryKeys = {};
                         for (var criteria in criteriaList) {
                             var colObj = criteriaList[criteria].getColumn();
                             if (colObj) {
                                 primaryKeys[colObj.getName()] = criteriaList[criteria].getValue();
                             }
                         }
                         readOptions.primaryKeys = primaryKeys;
                     } else if (queryParams) {
                         var primaryKeys = {};
                         if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined) {
                             for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
                                 var pKey = objMetadata.primaryKey[indx];
                                 var pKeyValue = queryParams[pKey];
                                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                                     kony.sdk.logsdk.error("### OfflineEnabledObjectService:: fetch Error: Primarykey details missing so unable to fetch");
                                     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                                     return;
                                 }
                                 primaryKeys[pKey] = pKeyValue;
                             }
                             readOptions.primaryKeys = primaryKeys;
                         } else {
                             kony.sdk.logsdk.error("### OfflineEnabledObjectService:: fetch Error: Primarykey details missing so unable to fetch");
                             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                             return;
                         }
                     }
                 }

                 function fetchSuccessHandler(res) {
                     var response = {};
                     response.records = res;
                     successCallback(response);
                 }
                 obj.get(readOptions, fetchSuccessHandler, failureCallback);
             }
             this.getMetadataOfObject(objectName, {}, fetchHandler, failureCallback);
         } catch (error) {
             kony.sdk.logsdk.error("Fetch on offline enabled object failed with error: " + error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
     };
     /**
      * This method is used to create a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.create = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.create");
         if (!areOptionsValid(options, failureCallback)) {
             return;
         }
         try {
             var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
             var objectName = dataObject.getObjectName();
             var obj = new kony.sdk.KNYObj(objectName);
             var createOptions = dataObject.getOfflineObjectsOptions();
             var records = dataObject.getRecord();
             obj.create(records, createOptions, successCallback, failureCallback);
         } catch (error) {
             kony.sdk.logsdk.error("Create on offline enabled object failed with error: " + error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
     };
     /**
      * This method is used to update a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.update = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.update");
         if (!areOptionsValid(options, failureCallback)) {
             return;
         }
         try {
             var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
             var objectName = dataObject.getObjectName();

             function updateHandler(objMetadata) {
                 var obj = new kony.sdk.KNYObj(objectName);
                 var updateOptions = dataObject.getOfflineObjectsOptions();
                 var records = dataObject.getRecord();
                 // If primary keys are not supplied through options, they are picked from the user supplied record.
                 if (!updateOptions || Object.keys(updateOptions).length == 0 || !updateOptions['primaryKeys']) {
                     if (records) {
                         var primaryKeys = {};
                         if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined) {
                             for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
                                 var pKey = objMetadata.primaryKey[indx];
                                 var pKeyValue = records[pKey];
                                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                                     kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Update Error: Primarykey details missing so unable to update");
                                     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                                     return;
                                 }
                                 primaryKeys[pKey] = pKeyValue;
                             }
                             updateOptions.primaryKeys = primaryKeys;
                         } else {
                             kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Update Error: Primarykey details missing so unable to update");
                             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                             return;
                         }
                     } else {
                         kony.sdk.logsdk.error("Update Failed: primaryKeys key missing. Please use dataObject setOfflineObjectsOptions to set primaryKeys for update operation.");
                         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                         return;
                     }
                 }
                 obj.updateByPK(records, updateOptions, successCallback, failureCallback);
             }
             this.getMetadataOfObject(objectName, {}, updateHandler, failureCallback);
         } catch (error) {
             kony.sdk.logsdk.error("Update on offline enabled object failed with error: " + error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
     };
     /**
      * This method is used to delete a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.deleteRecord = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.deleteRecord");
         if (!areOptionsValid(options, failureCallback)) {
             return;
         }
         try {
             var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
             var objectName = dataObject.getObjectName();

             function deleteHandler(objMetadata) {
                 var obj = new kony.sdk.KNYObj(objectName);
                 var deleteOptions = dataObject.getOfflineObjectsOptions();
                 // If primary keys are not supplied through options, they are picked from the user supplied record
                 if (!deleteOptions || Object.keys(deleteOptions).length == 0 || !deleteOptions['primaryKeys']) {
                     var records = dataObject.getRecord();
                     if (records) {
                         var primaryKeys = {};
                         if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined) {
                             for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
                                 var pKey = objMetadata.primaryKey[indx];
                                 var pKeyValue = records[pKey];
                                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                                     kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Delete Error: Primarykey details missing so unable to delete");
                                     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                                     return;
                                 }
                                 primaryKeys[pKey] = pKeyValue;
                             }
                             deleteOptions.primaryKeys = primaryKeys;
                         } else {
                             kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Delete Error: Primarykey details missing so unable to delete");
                             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                             return;
                         }
                     } else {
                         kony.sdk.logsdk.error("Delete Failed: primaryKeys key missing. Please use dataObject setOfflineObjectsOptions to set primaryKeys for delte operation.");
                         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                         return;
                     }
                 }
                 obj.deleteByPK(deleteOptions, successCallback, failureCallback);
             }
             this.getMetadataOfObject(objectName, {}, deleteHandler, failureCallback);
         } catch (error) {
             kony.sdk.logsdk.error("Delete on offline enabled object failed with error: " + error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
     };
     /**
      * This method is used to retrieve metadata of all objects
      * @param options
      * @param successCallback
      * @param failureCallback
      */
     this.getMetadataOfAllObjects = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.getMetadataOfAllObjects");
         _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, null, options, successCallback, failureCallback);
         kony.sdk.logsdk.trace("EXiting kony.sdk.OfflineEnabledObjectService.getMetadataOfAllObjects");
     };
     /**
      * This method is used to retrive metadata of a specific object
      * @param objectName
      * @param options
      * @param successCallback
      * @param failureCallback
      */
     this.getMetadataOfObject = function(objectName, options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.getMetadataOfObject");
         _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, objectName, options, successCallback, failureCallback);
         kony.sdk.logsdk.trace("Exiting kony.sdk.OfflineEnabledObjectService.getMetadataOfObject");
     };
     /**
      * This method is used to validate options
      * @param options
      * @param failureCallback
      */
     function areOptionsValid(options, failureCallback) {
         if (options == null || options == undefined) {
             kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Options Validity check: options null or undefined");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return false;
         }
         if (!(options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Options Validity check: invalid data object");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return false;
         }
         var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
         var objectName = dataObject.getObjectName();
         if (objectName == null || objectName == undefined) {
             kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Options Validity check: objectname null or undefined");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "objectName" + kony.sdk.errormessages.null_or_undefined));
             return false;
         }
         return true;
     };
 };
 /**
  * Method which returns the offline ObjectService object
  * @param konyRef
  * @param serviceName
  * @constructor
  */
 kony.sdk.OfflineObjectService = function(konyRef, serviceName) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService");
     this.konyRef = konyRef;
     this.serviceName = serviceName;
     /**
      * This method is used to create a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.create = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.create");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         var dataObject = options["dataObject"];

         function createHandler(objMetadata) {
             _invokeOfflineCreate(dataObject, successCallback, failureCallback, options);
         }
         this.getMetadataOfObject(dataObject.getObjectName(), {}, createHandler, failureCallback);
     };
     /**
      * This method is used to fetch records from the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.fetch = function(options, successCallback, failureCallback) {
         throw "This method is not implemented.Instead use executeSelectQuery";
     };
     /**
      * This method is used to update a record in the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.update = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.update");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         var dataObject = options["dataObject"];

         function updateHandler(objMetadata) {
             function updateSuccessCallback(response) {
                 kony.sdk.verifyAndCallClosure(successCallback, response);
             }

             function updateFailureCallback(error) {
                 if (error != null && error != undefined) {
                     //if the errorcode is equivalent to transaction failed then giving some generic error message to the client.
                     if (error["errorCode"] == 7010) {
                         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.transaction_failed, kony.sdk.errormessages.transaction_failed));
                         return;
                     }
                 }
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             }
             _invokeOfflineUpdate(dataObject, updateSuccessCallback, updateFailureCallback, options);
         }
         this.getMetadataOfObject(dataObject.getObjectName(), {}, updateHandler, failureCallback);
     };
     /**
      * This method is used to delete a record in the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.deleteRecord = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.deleteRecord");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         var dataObject = options["dataObject"];

         function deleteHandler(objMetadata) {
             function deleteSuccessCallback(response) {
                 //verifying delete response contains deleted records count as 0
                 if (response != null && response != undefined) {
                     if (response["rowsdeleted"] == 0) {
                         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.norecords_to_delete, kony.sdk.errormessages.norecords_to_delete));
                         return;
                     }
                 }
                 kony.sdk.verifyAndCallClosure(successCallback, response);
             }

             function deleteFailureCallback(error) {
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             }
             _invokeOfflineDelete(dataObject, deleteSuccessCallback, deleteFailureCallback, options);
         }
         this.getMetadataOfObject(dataObject.getObjectName(), {}, deleteHandler, failureCallback);
     };
     /**
      * This method is used to retrieve metadata of all objects
      * @param options
      * @param successCallback
      * @param failureCallback
      */
     this.getMetadataOfAllObjects = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.getMetadataOfAllObjects");
         _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, null, options, successCallback, failureCallback);
         kony.sdk.logsdk.trace("Exiting kony.sdk.OfflineObjectService.getMetadataOfAllObjects");
     };
     /**
      * This method is used to retrive metadata of a specific object
      * @param objectName
      * @param options
      * @param successCallback
      * @param failureCallback
      */
     this.getMetadataOfObject = function(objectName, options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.getMetadataOfObject");
         _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, objectName, options, successCallback, failureCallback);
         kony.sdk.logsdk.trace("Exiting kony.sdk.OfflineObjectService.getMetadataOfObject");
     };
     /**
      * This method is used to execute an sql query
      * @param queryStr
      * @param successCallback
      * @param failureCallback
      */
     this.executeSelectQuery = function(queryStr, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.executeSelectQuery");

         function selctSuccess(response) {
             kony.sdk.logsdk.debug("### OfflineObjectService::executeSelectQuery::selectSuccess Response:", response);
             kony.sdk.verifyAndCallClosure(successCallback, response);
         }

         function selectError(error) {
             kony.sdk.logsdk.error("### OfflineObjectService::executeSelectQuery::selectError Error:", error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
         kony.sync.single_select_execute(kony.sdk.util.getSyncDbName(), queryStr, null, selctSuccess, selectError);
     };
     /**
      * Helps to get the binary content of the specified column on the Object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject), "responsetype":"base64string/filepath(Default)", "binaryAttrName":columnName}
      * @param successCallback
      * @param failureCallback
      */
     this.getBinaryContent = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.getBinaryContenttion");
         if (kony.sdk.isNullOrUndefined(options)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         var dataObject = options["dataObject"];
         if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         var binaryColName = options["binaryAttrName"];
         if (kony.sdk.isNullOrUndefined(binaryColName)) {
             kony.sdk.logsdk.error("### OfflineObjectService::getBinaryContent Error: Please provide column name to fetch binary content");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Please provide column name to fetch binary content"));
             return;
         }
         var getBase64 = options["responsetype"] === "base64string" ? true : false;
         var config = options["config"];

         function getBinaryDataHandler(objMetadata) {
             function selectSuccessCallback(response) {
                 kony.sdk.logsdk.debug("### OfflineObjectService::getBinaryContent::selectSuccessCallback Response", response);
                 var result;
                 if (getBase64) {
                     //get base64 from response
                     var tempFile = new kony.io.File(response["FilePath"]);
                     if (!kony.sdk.isNullOrUndefined(tempFile) && tempFile.exists() && tempFile.readable) {
                         var tempRawBytes = tempFile.read();
                         result = kony.convertToBase64(tempRawBytes);
                     } else {
                         kony.sdk.logsdk.error("Error in reading binary file from filepath ", response["FilePath"]);
                         var errorCode = kony.sdk.errorcodes.invalid_blob;
                         var errorMessage = kony.sdk.errormessages.invalid_blob;
                         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(errorCode, errorMessage));
                     }
                 } else {
                     //get filepath from response
                     result = response["FilePath"];
                 }
                 kony.sdk.verifyAndCallClosure(successCallback, result);
             }

             function selectErrorCallback(error) {
                 kony.sdk.logsdk.error("### OfflineObjectService::getBinaryContent::selectErrorCallback Error:", error);
                 _invokeOfflineErrorCallback(failureCallback, error);
             }
             var dbName = kony.sdk.util.getSyncDbName();
             var objName = dataObject.getObjectName();
             var columnValues = kony.sdk.util.populateColumnValues(dataObject.getRecord(), null);
             var colMeta = kony.sdk.util.getMetadataOfColumn(objMetadata, binaryColName);
             if (kony.sdk.isNullOrUndefined(colMeta)) {
                 kony.sdk.logsdk.warn("### OfflineObjectService::getBinaryContent Error: Invalid binary attribute name.");
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Invalid binary attribute name."));
                 return;
             }
             if (colMeta["datatype"] !== kony.sdk.constants.BINARY_DATATYPE) {
                 kony.sdk.logsdk.warn("### OfflineObjectService::getBinaryContent Error: Datatype is not binary for the specified binary attribute name");
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Datatype is not binary for the specified binary attribute name"));
                 return;
             }
             var pkTable = kony.sdk.util.getPkTableForBinary(objMetadata, columnValues, failureCallback);
             kony.sync.getBinary(dbName, objName, binaryColName, pkTable, config, selectSuccessCallback, selectErrorCallback);
         }
         this.getMetadataOfObject(dataObject.getObjectName(), {}, getBinaryDataHandler, failureCallback);
     };

     function _invokeOfflineErrorCallback(failureCallback, errorObject) {
         //call the failureCallback after adding opstatus to the errorObject.
         var errorCode, errorMessage;
         if (errorObject) {
             errorCode = (errorObject.hasOwnProperty("errorCode")) ? errorObject["errorCode"] : kony.sdk.errorcodes.transaction_failed;
             errorMessage = (errorObject.hasOwnProperty("errorMessage")) ? errorObject["errorMessage"] : kony.sdk.errormessages.transaction_failed;
         } else {
             errorCode = kony.sdk.errorcodes.transaction_failed;
             errorMessage = kony.sdk.errormessages.transaction_failed;
         }
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(errorCode, errorMessage));
     }

     function _invokeOfflineCreate(dataObject, successCallback, failureCallback, options) {
         var dbname = kony.sdk.util.getSyncDbName();
         kony.sync.single_insert_execute(dbname, dataObject.getObjectName(), dataObject.getRecord(), successCallback, function(err) {
             _invokeOfflineErrorCallback(failureCallback, err);
         }, true, options);
     }

     function _invokeOfflineUpdate(dataObject, successCallback, failureCallback, options) {
         var objectName = dataObject.getObjectName();
         var columnValues = dataObject.getRecord();
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objectName);
         var pkTable = {};
         var whereClause = [];
         if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined) {
             for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
                 var pKey = objMetadata.primaryKey[indx];
                 var pKeyValue = columnValues[pKey];
                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                     //TODO change to error object
                     kony.sdk.logsdk.error("### OfflineObjectService::_invokeOfflineUpdate Error: Primarykey details missing so unable to update");
                     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                     return;
                 }
                 pkTable.pKey = {
                     "key": pKey,
                     "value": pKeyValue
                 };
                 var condition = {};
                 condition.key = pKey;
                 condition.value = pKeyValue;
                 whereClause.push(condition);
             }
         } else {
             //TODO change to error object
             kony.sdk.logsdk.error("### OfflineObjectService::_invokeOfflineUpdate Error: Primarykey details missing so unable to update");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }
         var dbName = kony.sdk.util.getSyncDbName();
         kony.sync.single_update_execute(dbName, objectName, columnValues, whereClause, successCallback, function(err) {
             _invokeOfflineErrorCallback(failureCallback, err);
         }, false, true, null, options);
     }

     function _invokeOfflineDelete(dataObject, successCallback, failureCallback, options) {
         var isError = false;
         var markForUpload = false;
         var tbname = dataObject.getObjectName();
         var errMsg = null;
         var wcs = [];
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, dataObject.getObjectName());
         var dbName = kony.sdk.util.getSyncDbName();
         var srcAttributes = kony.sdk.util.getPrimarykeysFromMetadata(objMetadata);
         if (srcAttributes != null && srcAttributes != undefined) {
             var pkLen = Object.keys(srcAttributes).length;
             for (var indx = 0; indx < pkLen; indx++) {
                 var pKey = Object.keys(srcAttributes)[indx];
                 var pKeyValue = dataObject.getRecord()[pKey];
                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                     //TODO
                     //throw error
                     kony.sdk.logsdk.error("### _invokeOfflineDelete:: Error Primarykey details missing so unable to delete");
                     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                     return;
                 }
                 var whereClause = {};
                 whereClause.key = pKey;
                 whereClause.value = pKeyValue;
                 kony.table.insert(wcs, whereClause);
             }
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### _invokeOfflineDelete:: Error Primarykey details missing so unable to delete");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }
         kony.sync.single_delete_execute(dbName, tbname, wcs, successCallback, function(err) {
             _invokeOfflineErrorCallback(failureCallback, err);
         }, false, false, true, options);
     }
 };
 //Utils specific to MVVM/MDA/MVC SDK
 // This function is responsible for checking if the array contains the object based on object's name property.
 // returns the array element if the object matches
 kony.sdk.util.getExtendedFieldsFromArray = function(array, object) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.getExtendedFieldsFromArray");
     if (array instanceof Array) {
         for (var i = 0; i < array.length; i++) {
             if (array[i] instanceof kony.sdk.dto.FieldMetadata && object instanceof kony.sdk.dto.Column) {
                 if (kony.sdk.util.matchIgnoreCase(array[i].name, object.getName()) && kony.sdk.util.matchIgnoreCase(array[i].type, "extendedfield")) {
                     return array[i];
                 }
             }
         }
         return null;
     }
 };
 /**
  * This Object represent picklist values
  * @constructor
  */
 kony.sdk.dto.PickList = function() {
         kony.sdk.logsdk.trace("Entering into kony.sdk.dto.PickList");
         this.id = null;
         this.active = null;
         this.label = null;
         this.value = null;
         this.validFor = null;
         this.defaultValue = null;
         this.fieldMappingId = null;
         this.setId = function(id) {
             this.id = id;
         }
         this.getId = function() {
             return this.id;
         }
         this.setActive = function(active) {
             this.active = active;
         }
         this.isActive = function() {
             return this.active;
         }
         this.setLabel = function(label) {
             this.label = label;
         }
         this.getLabel = function() {
             return this.label;
         }
         this.setValue = function(value) {
             this.value = value;
         }
         this.getValue = function() {
             return this.value;
         }
         this.setValidFor = function(validFor) {
             this.validFor = validFor;
         }
         this.getValidFor = function() {
             return this.validFor;
         }
         this.setDefaultValue = function(defaultValue) {
             this.defaultValue = defaultValue;
         }
         this.getDefaultValue = function() {
             return this.defaultValue;
         }
         this.setFieldMappingId = function(fieldMappingId) {
             this.fieldMappingId = fieldMappingId;
         }
         this.getFieldMappingId = function() {
             return this.fieldMappingId;
         }
     }
     /**
      * The structure of Object Metadata obtained from server
      * @constructor
      */
 kony.sdk.dto.ObjectMetadata = function() {
         //variables to store metadata of the object.
         this.custom;
         this.customizable;
         this.displayName;
         this.entityTypeID;
         this.columns;
         this.junction;
         this.name;
         this.primaryKey;
         this.relationshipList;
         this.sourceEntityName;
         this.updateable;
         this.uniqueKeys;
     }
     /**
      * The structure of Field Metadata obtained from server
      * @constructor
      */
 kony.sdk.dto.FieldMetadata = function() {
         this.auditColumn;
         this.createable;
         this.custom;
         this.customizable;
         this.type;
         this.defaultValue;
         this.displayName;
         this.fieldMappingId;
         this.hasIndex;
         this.name;
         this.nameField;
         this.nullable;
         this.primaryKey;
         this.sourceFieldName;
         this.table;
         this.updateable;
         // array of picklistValueDto objects to hold the pick list values. This will be populated only when the data type is of picklist type
         this.pickListValues;
     }
     /**
      * The structure of Object Relationship in metadata obtained from server
      * @constructor
      */
 kony.sdk.dto.ObjectRelationship = function() {
         this.entityName;
         this.entityPageTemplateId;
         this.id;
         this.junctionTableName;
         this.operationType;
         this.relatedEntity;
         this.relationshipFields;
         this.relationshipName;
         this.relationshipType;
         this.custom;
     }
     /**
      * The Object used to define select query object, in order to fetch data
      * @param serviceName
      * @param tableObj {@link kony.sdk.dto.Table}
      * @constructor
      */
 kony.sdk.dto.SelectQuery = function(serviceName, tableObj) {
     this.tables = [];
     this.columnList = [];
     this.criteriaList = [];
     this.isDistinct = false;
     this.orderList = [];
     this.joinList = [];
     this.groupList = [];
     this.limit = null;
     this.skip = null;
     this.oDataURL = null;
     if (tableObj instanceof kony.sdk.dto.Table) {
         this.tables.push(tableObj);
     }
     /**
      * This function is used to set Limit value
      * @param val
      */
     this.setLimit = function(val) {
         this.limit = val;
     };
     /**
      * This function is used to set Skip value
      * @param val
      */
     this.setSkip = function(val) {
         this.skip = val;
     };
     /**
      * This function is used to get the Limit Value
      * @returns {integer} limit
      */
     this.getLimit = function() {
         return this.limit;
     };
     /**
      * This function is used to get the Skip Value
      * @returns {integer} skip
      */
     this.getSkip = function() {
         return this.skip;
     };
     /**
      * This function is used to add a column object into the select query
      * @param columnObj {@Link kony.sdk.dto.Column}
      * @returns {Array}
      */
     this.addColumn = function(columnObj) {
         if (columnObj instanceof kony.sdk.dto.Column) {
             this.columnList.push(columnObj);
             return this.columnList;
         }
     };
     /**
      * This function is used to add a criteria object to the select query
      * @param criteriaObj
      * @returns {Array}
      */
     this.addCriteria = function(criteriaObj) {
         if (kony.sdk.util.validateCriteriaObject(criteriaObj)) {
             this.criteriaList.push(criteriaObj);
             return this.criteriaList;
         }
     };
     /**
      * This function is used to add a group object to select query
      * @param groupObj
      */
     this.addGroup = function(groupObj) {
         if (groupObj instanceof kony.sdk.dto.Group) {
             this.groupList.push(groupObj);
             for (var i = 0; i < this.tables.length; i++) {
                 if (this.tables[i].getName().toUpperCase() === groupObj.getColumn().getTable().getName().toUpperCase()) {
                     return;
                 }
             }
             this.tables.push(groupObj.getColumn().getTable());
         }
     };
     /**
      * This function is used to add a join object
      * @param joinObj
      */
     this.addJoin = function(joinObj) {
         if (joinObj instanceof kony.sdk.dto.Join) {
             this.joinList.push(joinObj);
             for (var i = 0; i < this.tables.length; i++) {
                 if (this.tables[i].getName().toUpperCase() === joinObj.getTable().getName().toUpperCase()) {
                     if (this.tables[i].getAlias() != null || joinObj.getTable().getAlias() != null || this.tables[i].getAlias() != undefined || joinObj.getTable().getAlias() != undefined) {
                         if (this.tables[i].getAlias().toUpperCase() === joinObj.getTable().getAlias().toUpperCase()) {
                             return;
                         } else {
                             this.tables.push(joinObj.getTable());
                             return;
                         }
                     } else {
                         return;
                     }
                 }
             }
             this.tables.push(joinObj.getTable());
         }
     };
     /**
      * This function is used to add order object to a select query
      * @param orderObj
      */
     this.addOrder = function(orderObj) {
         var currentobject = this;
         if (orderObj instanceof kony.sdk.dto.Order) {
             this.orderList.push(arguments[0]);
             for (var i = 0; i < this.tables.length; i++) {
                 if (this.tables[i].getName().toUpperCase() === arguments[0].getColumn().getTable().getName().toUpperCase()) {
                     return;
                 }
             }
             this.tables.push(orderObj.getColumn().getTable());
         }
     };
     /**
      * This function is used to return tables in select query
      * @returns {Array} Tables
      */
     this.getTables = function() {
         return this.tables;
     };
     /**
      * This function is used to get isDistinct flag
      * @returns {boolean}
      */
     this.getDistinct = function() {
         return this.isDistinct;
     };
     /**
      * This function is used to return columns in select query
      * @returns {Array} Columns
      */
     this.getColumns = function() {
         return this.columnList;
     };
     /**
      * This function is used to get criteria objects in the select query
      * @returns {Array} Criterias
      */
     this.getCriterias = function() {
         return this.criteriaList;
     };
     /**
      * This function is used to get the group objects in the select query
      * @returns {Array} GroupObjs
      */
     this.getGroups = function() {
         return this.groupList;
     };
     /**
      * This function is used to get the Join objects in the select query
      * @returns {Array} Joins
      */
     this.getJoins = function() {
         return this.joinList;
     };
     /**
      * This function is used to get the Order Objects in the select query
      * @returns {Array} OrderObjs
      */
     this.getOrders = function() {
         return this.orderList;
     };
     /**
      * This function is used to remove columnobject set in select query
      * @param columnObj {@link kony.sdk.dto.Column}
      */
     this.removeColumn = function(columnObj) {
         if (columnObj instanceof kony.sdk.dto.Column) {
             this.columnList.splice(this.columnList.indexOf(columnObj), 1);
         }
     };
     /**
      * This function is used to remove criteriaObject from select query
      * @param criteriaObj
      */
     this.removeCriteria = function(criteriaObj) {
         if (criteriaObj instanceof Criteria) {
             this.criteriaList.splice(this.criteriaList.indexOf(criteriaObj), 1);
         }
     };
     /**
      * This function is used to remove group set from select query
      * @param groupObj
      */
     this.removeGroup = function(groupObj) {
         if (groupObj instanceof kony.sdk.dto.Group) {
             this.groupList.splice(this.groupList.indexOf(groupObj), 1);
         }
     };
     /**
      * This function is used to remove Join set in select query
      * @param joinObj
      */
     this.removeJoin = function(joinObj) {
         if (joinObj instanceof kony.sdk.dto.Criteria) {
             this.joinList.splice(this.joinList.indexOf(joinObj), 1);
         }
     };
     /**
      * This function is used to remove OrderObj set in SelectQuery
      * @param orderObj
      */
     this.removeOrder = function(orderObj) {
         if (orderObj instanceof kony.sdk.dto.Order) {
             this.orderList.splice(this.orderList.indexOf(orderObj), 1);
         }
     };
     /**
      * This function is used to set isDistinct
      * @param isDistinct
      */
     this.setDistinct = function(isDistinct) {
         this.isDistinct = isDistinct;
     };
     /**
      * This function is used to get the select query in the form of a string
      * @returns {string}
      */
     this.toString = function() {
         var selectQueryDto = this;
         var query = "";
         query = query + "SELECT ";
         if (this.getDistinct() == true || this.getDistinct() == "true") {
             query = query + " DISTINCT ";
         }
         // Fetch the metadata for the base table and see if there are any extended fields associated with it
         // If there are any, create a join between the base table and the corresponding parent table and fetch it
         var columns = this.columnList;
         var extendedFields = [];
         var columnsArr = [];
         var extendedJoins = [];
         var baseTable = this.getTables()[0];
         var objectMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, baseTable.getName());
         if (columns.length !== 0) {
             var field = null;
             for (var colIndex = 0; colIndex < columns.length; colIndex++) {
                 field = kony.sdk.util.getExtendedFieldsFromArray(objectMetadata.columns, columns[colIndex]);
                 if (field !== null && field !== undefined) {
                     selectQueryDto.columnList[colIndex].dataType = field.type;
                     selectQueryDto.columnList[colIndex].parentFieldName = field.parentFieldName;
                     extendedFields.push(field);
                     field = null;
                 } else {
                     columnsArr.push(columns[colIndex]);
                 }
             }
         } else {
             var col = null;
             var field = null;
             for (var colIndex = 0; colIndex < objectMetadata.columns.length; colIndex++) {
                 field = objectMetadata.columns[colIndex];
                 col = new kony.sdk.dto.Column(baseTable, field.name);
                 col.dataType = field.type;
                 col.parentFieldName = field.parentFieldName;
                 selectQueryDto.columnList.push(col);
                 if (field !== null && field !== undefined && kony.sdk.util.matchIgnoreCase(field.type, "extendedfield")) {
                     extendedFields.push(field);
                     field = null;
                 } else {
                     columnsArr.push(columns[colIndex]);
                 }
             }
         }
         var columnStr = selectQueryDto.appendListToQuery(columnsArr, ", ", 0);
         if (columnStr !== null && columnStr !== "") {
             query = query + columnStr;
         }
         //TODO have to modify the code based on latest metadata
         if (extendedFields !== null && extendedFields !== undefined && extendedFields.length !== 0) {
             var join = null;
             var table = null;
             var srcCol = null;
             var destCol = null;
             var joinType = kony.sdk.constants.JoinType.LEFT;
             var col = null;
             var colList = [];
             var extendedTablesAdded = {};
             for (var extIndex = 0; extIndex < extendedFields.length; extIndex++) {
                 if (extendedTablesAdded !== null && extendedTablesAdded.hasOwnProperty(extendedFields[extIndex].parentTableName)) {
                     extendedTablesAdded["" + extendedFields[extIndex].parentTableName] = ++extendedTablesAdded["" + extendedFields[extIndex].parentTableName];
                 } else {
                     extendedTablesAdded["" + extendedFields[extIndex].parentTableName] = 0;
                 }
                 table = new kony.sdk.dto.Table(extendedFields[extIndex].parentTableName);
                 // Now add all extended field columns to the query
                 col = new kony.sdk.dto.Column(table, extendedFields[extIndex].parentFieldName);
                 colList.push(col);
                 // Need to fetch the source table's primary key name from the metadata. For now hard coding it to 'id'
                 //TODO
                 srcCol = new kony.sdk.dto.Column(baseTable, extendedFields[extIndex].foreignKeyFieldName);
                 destCol = new kony.sdk.dto.Column(table, extendedFields[extIndex].referencedField || "id");
                 join = new kony.sdk.dto.Join(table, srcCol, destCol, joinType);
                 if (join !== null && join !== undefined && extendedTablesAdded["" + extendedFields[extIndex].parentTableName] === 0) {
                     extendedJoins.push(join);
                 }
             }
             var extColStr = "";
             for (var i = 0; i < colList.length; i++) {
                 extColStr = extColStr + colList[i].toString();
                 if (i < colList.length - 1) {
                     extColStr = extColStr + ",";
                 }
             }
             if (extColStr !== null && extColStr !== "") {
                 query = query + "," + extColStr;
             }
             if (extendedJoins !== null && extendedJoins !== undefined) {
                 for (var joinIndex = 0; joinIndex < extendedJoins.length; joinIndex++) {
                     selectQueryDto.addJoin(extendedJoins[joinIndex]);
                 }
             }
         }
         query = query + " FROM ";
         query = query + selectQueryDto.getTables()[0].toString();
         if (selectQueryDto.getJoins().length !== 0) {
             var joinStr = selectQueryDto.appendListToQuery(selectQueryDto.joinList, " ", -1);
             query = query + joinStr;
         }
         if (!(selectQueryDto.criteriaList.length == 0)) {
             query = query + " WHERE ";
             query = query + selectQueryDto.appendListToQuery(selectQueryDto.criteriaList, " AND ", -1);
         }
         if (!(selectQueryDto.groupList.length == 0)) {
             query = query + " GROUP BY ";
             query = query + selectQueryDto.appendListToQuery(selectQueryDto.groupList, ", ", -1);
         }
         if (!(selectQueryDto.orderList.length == 0)) {
             query = query + " ORDER BY ";
             query = query + selectQueryDto.appendListToQuery(selectQueryDto.orderList, " ,", -1);
         }
         if (selectQueryDto.limit !== null && selectQueryDto.limit !== undefined && kony.sdk.util.isValidNumberType(selectQueryDto.limit) && selectQueryDto.limit !== 0) {
             query = query + " LIMIT " + selectQueryDto.limit;
         }
         if (selectQueryDto.skip !== null && selectQueryDto.skip !== undefined && kony.sdk.util.isValidNumberType(selectQueryDto.skip) && selectQueryDto.skip !== 0) {
             query = query + " OFFSET " + selectQueryDto.skip;
         }
         return query;
     };
     this.appendListToQuery = function(objectList, seperator, mode) {
         kony.sdk.logsdk.trace("Entering into kony.sdk.dto.appendListToQuery");
         var listBuffer = "";
         for (var i = 0; i < objectList.length; i++) {
             var obj = objectList[i];
             if (mode > -1) {
                 if (obj !== null) {
                     if (obj instanceof kony.sdk.dto.Column) {
                         listBuffer = listBuffer.concat(obj.toString());
                     } else {
                         listBuffer = listBuffer.concat(obj.toString());
                     }
                 }
             } else if (obj !== null && obj !== undefined) {
                 listBuffer = listBuffer.concat(obj.toString());
             }
             if (i < objectList.length - 1) {
                 listBuffer = listBuffer.concat(seperator);
             }
         }
         return listBuffer;
     };
 };
 /**
  * This function is the Table constructor.
  * @param tableName
  * @param tableAlias
  * @param junctionType
  * @constructor
  */
 kony.sdk.dto.Table = function(tableName, tableAlias, junctionType) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Table");
     this.name = tableName;
     this.alias = tableAlias;
     this.isjunction = junctionType;
     this.getAlias = function() {
         return this.alias;
     };
     /**
      * This function is used to set alias.
      *
      * @param alias
      */
     this.setAlias = function(alias) {
         this.alias = alias;
     };
     this.getName = function() {
         return this.name;
     };
     /**
      * This function is used to set name.
      *
      * @param name
      */
     this.setName = function(name) {
         this.name = name;
     };
     /**
      * This function is used to check object equality.
      *
      * @param obj
      * @return Boolean
      */
     this.equals = function(obj) {
         var areObjectsEqual = false;
         if (obj === null || obj === undefined) {
             areObjectsEqual = false;
         } else if (typeof(this) === typeof(obj)) {
             areObjectsEqual = true;
             if (this.hasAlias() && obj.hasAlias()) {
                 areObjectsEqual = this.getAlias() === obj.getAlias();
             } else {
                 areObjectsEqual = this.getName() === obj.getName();
             }
         } else {
             areObjectsEqual = false;
         }
         return areObjectsEqual;
     };
     this.getColumn = function(columnName) {
         return new kony.sdk.dto.Column(this, columnName);
     };
     /**
      * This function is used to check if alias is present or not.
      *
      * @return Boolean
      */
     this.hasAlias = function() {
         return (this.alias !== null && this.alias !== undefined);
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         return this.getName() + (this.hasAlias() ? " " + this.getAlias() : "");
     };
     /**
      * This function is used to return if the table is a junction table.
      *
      * @return boolean
      */
     this.isJunction = function() {
         return (this.isjunction && this.isjunction == true);
     };
     /**
      * This function is used to set the type of table junction/non-junction table.
      *
      * @param junctionType
      */
     this.setJunction = function(junctionType) {
         this.isjunction = junctionType;
     };
 };
 /**
  * This function is a Column constructor
  * @param tableObj {@link kony.sdk.dto.Table}
  * @param colName
  * @constructor
  */
 kony.sdk.dto.Column = function(tableObj, colName) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Column");
     if (tableObj instanceof kony.sdk.dto.Table) {
         this.aggregation = null;
         this.alias = null;
         this.dataType = null;
         this.name = null;
         this.table = null;
         if (colName !== undefined && colName !== null && typeof(colName) === "string") {
             this.name = colName;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Column:: Error: colName is undefined");
         }
         this.table = tableObj;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Column:: Error: tableObj is not an instance of kony.sdk.dto.Table");
     }
     this.getAggregation = function() {
         return this.aggregation;
     };
     this.setAggregation = function(aggregation) {
         this.aggregation = aggregation;
     };
     this.getAlias = function() {
         return this.alias;
     };
     this.setAlias = function(alias) {
         this.alias = alias;
     };
     this.getDataType = function() {
         return this.dataType;
     };
     this.setDataType = function(dataType) {
         this.dataType = dataType;
     };
     this.isComputedField = function() {
         return this.fieldComputed;
     };
     this.setComputedField = function(fieldComputed) {
         this.fieldComputed = fieldComputed;
     };
     this.getName = function() {
         return this.name;
     };
     this.setName = function(name) {
         if (name !== undefined && name !== null && typeof(name) === "string") {
             this.name = name;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Column::setName:: Error: name is undefined");
         }
     };
     this.getTable = function() {
         return this.table;
     };
     this.setTable = function(table) {
         if (table instanceof kony.sdk.dto.Table) {
             this.table = table;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Column:: Error: setTable is undefined");
         }
     };
     this.toStringByMode = function(mode) {
         var tableName = (this.getTable().getAlias() !== null && this.getTable().getAlias() !== undefined) ? this.getTable().getAlias() : this.getTable().getName();
         var constructedColumn = null;
         var constructDataType = null;
         var constructAlias = null;
         var constructAggregation = null;
         switch (mode) {
             case 0:
                 if (this.getDataType() !== null && this.getDataType() !== undefined) {
                     if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Integer")) {
                         constructDataType = "CAST (" + tableName + "." + this.getName() + " AS INTEGER)";
                     } else if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Numeric")) {
                         constructDataType = "CAST (" + tableName + "." + this.getName() + " AS NUMERIC)";
                     } else if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Date")) {
                         constructDataType = "date(" + tableName + "." + this.getName() + ")";
                     } else {
                         constructDataType = tableName + "." + this.getName();
                     }
                 } else {
                     constructDataType = tableName + "." + this.getName();
                 }
                 constructAlias = (this.getAlias() !== null && this.getAlias() !== undefined && this.getAlias() !== "") ? " AS " + this.getAlias() : "";
                 constructAggregation = (this.getAggregation() === kony.sdk.constants.Aggregation.NONE || (this.getAggregation() === null || this.getAggregation() === undefined)) ? constructDataType : (this.isComputedField() ? this.getAggregation() : this.getAggregation() + "(" + constructDataType + ")");
                 constructedColumn = constructAggregation + constructAlias;
                 break;
             case 1:
                 if (this.getDataType() !== null && this.getDataType() !== undefined) {
                     if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "STRING")) this.setDataType("text");
                 }
                 constructDataType = (this.getDataType() !== null && this.getDataType() !== undefined) ? "CAST (" + tableName + "." + this.getName() + " AS " + this.getDataType() + ")" : tableName + "." + this.getName();
                 constructAggregation = (this.getAggregation() === kony.sdk.constants.Aggregation.NONE || (this.getAggregation() === null || this.getAggregation() === undefined)) ? constructDataType : (this.isComputedField() ? this.getAggregation() : this.getAggregation() + "(" + constructDataType + ")");
                 constructedColumn = constructAggregation;
                 break;
             case 2:
                 constructedColumn = this.getName();
                 break;
             case 3:
                 constructedColumn = this.getName();
                 break;
             default:
                 if (this.getDataType() !== null && this.getDataType() !== undefined) {
                     if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "STRING")) this.setDataType("text");
                 }
                 constructDataType = (this.getDataType() !== null && this.getDataType() !== undefined) ? "CAST (" + tableName + "." + this.getName() + " AS " + this.getDataType() + ")" : tableName + "." + this.getName();
                 constructAlias = (this.getAlias() !== null && this.getAlias() !== undefined) ? " AS " + this.getAlias() : "";
                 constructAggregation = (this.getAggregation() === kony.sdk.constants.Aggregation.NONE || (this.getAggregation() === null || this.getAggregation() === undefined)) ? constructDataType : (this.isComputedField() ? this.getAggregation() : this.getAggregation() + "(" + constructDataType + ")");
                 constructedColumn = constructAggregation + constructAlias;
                 break;
         }
         return constructedColumn;
     };
     this.toString = function() {
         // To be removed later from here
         if (this.getDataType() !== null && this.getDataType() !== undefined) {
             if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "STRING")) dataType = "text";
         }
         var tableName = (this.getTable().getAlias() !== null && this.getTable().getAlias() !== undefined && this.getTable().getAlias() !== "") ? this.getTable().getAlias() : this.getTable().getName();
         var constructedColumn = null;
         var constructDataType = null;
         var constructAggregation = null;
         if (this.getDataType() !== null && this.getDataType() !== undefined) {
             if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Integer")) {
                 constructDataType = "CAST (" + tableName + "." + this.getName() + " AS INTEGER)";
             } else if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Numeric")) {
                 constructDataType = "CAST (" + tableName + "." + this.getName() + " AS NUMERIC)";
             } else if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Date")) {
                 constructDataType = "date(" + tableName + "." + this.getName() + ")";
             } else {
                 if (!this.isComputedField()) constructDataType = tableName + "." + this.getName();
             }
         } else {
             if (!this.isComputedField()) constructDataType = tableName + "." + this.getName();
         }
         var constructAlias = (this.getAlias() !== null && this.getAlias() !== undefined && this.getAlias() !== "") ? " AS " + this.getAlias() : "";
         constructAggregation = (this.getAggregation() === kony.sdk.constants.Aggregation.NONE || (this.getAggregation() === null || this.getAggregation() === undefined)) ? constructDataType : (this.isComputedField() ? this.getAggregation() : this.getAggregation() + "(" + constructDataType + ")");
         constructedColumn = constructAggregation + constructAlias;
         return constructedColumn;
     };
     this.toStringByTablePrefix = function(includeTablePrefix) {
         if (includeTablePrefix) {
             return this.toString();
         } else {
             return this.getName();
         }
     }
 };
 /**
  * This Object represents a groupby clause in select query
  * @param columnObj {@link kony.sdk.dto.Column}
  * @constructor
  */
 kony.sdk.dto.Group = function(columnObj) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Group");
     if (columnObj instanceof kony.sdk.dto.Column) {
         this.column = columnObj;
     }
     this.getColumn = function() {
         return this.column;
     };
     this.setColumn = function(column) {
         if (column instanceof kony.sdk.dto.Column) {
             this.column = column;
         }
     };
     this.toString = function() {
         var tableName = (this.column.getTable().getAlias() !== null && this.column.getTable().getAlias() !== undefined) ? this.column.getTable().getAlias() : this.column.getTable().getName();
         return tableName + "." + this.column.getName();
     };
 };
 /**
  * This Object represents JOINS used in kony.sdk.dto.SelectQuery
  * @constructor
  */
 kony.sdk.dto.Join = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Join");
     this.criteria;
     this.table;
     this.joinType;
     var currentObject = this;
     if (arguments.length === 3) {
         getJoinByTableCriteriaAndJoinType(arguments[0], arguments[1], arguments[2]);
     } else if (arguments.length === 4) {
         getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType(arguments[0], arguments[1], arguments[2], arguments[3]);
     }
     /**
      * This function is the Join constructor which has 3 arguments.
      *
      * @param table
      * @param criteria
      * @param joinType
      */
     function getJoinByTableCriteriaAndJoinType(table, criteria, joinType) {
         kony.sdk.logsdk.trace("Entering into getJoinByTableCriteriaAndJoinType");
         if (table instanceof kony.sdk.dto.Table && kony.sdk.util.validateCriteriaObject(criteria) && joinType !== null && joinType !== undefined && (joinType === kony.sdk.constants.JoinType.INNER || joinType === kony.sdk.constants.JoinType.LEFT)) {
             currentObject.table = table;
             currentObject.joinType = joinType;
             currentObject.criteria = criteria;
             return currentObject;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Join::getJoinByTableCriteriaAndJoinType:: Error: Validation error at getJoinByTableCriteriaAndJoinType");
         }
     }
     /**
      * This function is the Join constructor which has 4 arguments.
      *
      * @param destTable
      * @param srcColumn
      * @param destColumn
      * @param joinTypeObj
      */
     function getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType(destTable, srcColumn, destColumn, joinTypeObj) {
         kony.sdk.logsdk.trace("Entering into getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType");
         if (destTable instanceof kony.sdk.dto.Table && srcColumn instanceof kony.sdk.dto.Column && destColumn instanceof kony.sdk.dto.Column && joinTypeObj !== null && joinTypeObj !== undefined && joinTypeObj !== '' && (joinTypeObj === kony.sdk.constants.JoinType.INNER || joinTypeObj === kony.sdk.constants.JoinType.LEFT)) {
             currentObject.table = destTable;
             currentObject.joinType = joinTypeObj;
             var criteria = new kony.sdk.dto.Match(srcColumn, kony.sdk.constants.MatchType.EQUALS, destColumn);
             currentObject.criteria = criteria;
             return currentObject;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Join::getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType:: Error: Validation error at getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType");
         }
     }
     this.getCriteria = function() {
         return this.criteria;
     };
     this.setCriteria = function(criteria) {
         if (kony.sdk.util.validateCriteriaObject(criteria)) {
             this.criteria = criteria;
         }
     };
     this.getTable = function() {
         return this.table;
     };
     this.setTable = function(table) {
         if (table instanceof kony.sdk.dto.Table) {
             this.table = table;
         }
     };
     this.getJoinType = function() {
         return this.joinType;
     };
     this.setJoinType = function(joinType) {
         if (joinType !== null) {
             this.joinType = joinType;
         }
     };
     this.initCriteria = function(srcColumn, destColumn) {
         if ((srcColumn instanceof kony.sdk.dto.Column) && (destColumn instanceof kony.sdk.dto.Column)) {
             var criteria = new kony.sdk.dto.Match(srcColumn, kony.sdk.constants.MatchType.EQUALS, destColumn);
             this.setCriteria(criteria);
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Join::initCriteria:: Error: srcColumn or destColumn is not an isntanceof kony.sdk.dto.Column");
         }
     };
     this.toString = function() {
         var returnString = null;
         var temp = null;
         var join;
         if (kony.sdk.constants.JoinType.INNER == this.getJoinType()) {
             join = "INNER";
         } else if (kony.sdk.constants.JoinType.LEFT == this.getJoinType()) {
             join = "LEFT";
         } else if (kony.sdk.constants.JoinType.RIGHT == this.getJoinType()) {
             join = "RIGHT";
         }
         returnString = " " + join + " JOIN " + this.getTable().toString() + " ON ";
         temp = this.getCriteria().toString();
         returnString = returnString + temp;
         return returnString;
     };
 };
 /**
  * This function is the Order constructor.
  * @param columnObj
  * @param orderTypeObj
  */
 kony.sdk.dto.Order = function(columnObj, orderTypeObj) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Order");
     if ((columnObj instanceof kony.sdk.dto.Column) && (orderTypeObj == kony.sdk.constants.OrderType.ASCENDING || orderTypeObj == kony.sdk.constants.OrderType.DESCENDING)) {
         this.column = columnObj;
         this.type = orderTypeObj;
         return this;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Order:: Error: Validation error")
     }
     this.getColumn = function() {
         return this.column;
     };
     /**
      * This function is used to set column.
      *
      * @param column
      */
     this.setColumn = function(column) {
         if (column instanceof kony.sdk.dto.Column) {
             this.column = column;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Order::setColumn: Error: column is not an instance of kony.sdk.dto.Column");
         }
     };
     this.getType = function() {
         return this.type;
     };
     /**
      * This function is used to set type.
      *
      * @param type
      */
     this.setType = function(type) {
         this.type = type;
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         return this.column.toString() + " " + (this.type);
     };
 };
 /**
  * This function is used to check the range of values of columnObj
  * @param columnObj {@link kony.sdk.dto.Column}
  * @param colRange
  * @constructor
  */
 kony.sdk.dto.Between = function(columnObj, colRange) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Between");
     this.column;
     this.range;
     if (columnObj instanceof kony.sdk.dto.Column && (colRange instanceof kony.sdk.dto.DateRange || colRange instanceof kony.sdk.dto.StringRange || colRange instanceof kony.sdk.dto.IntegerRange || colRange instanceof kony.sdk.dto.FloatRange)) {
         this.column = columnObj;
         this.range = colRange;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Between:: Error: Vaildation error");
     }
     this.quote = function(str) {
         if (kony.sdk.util.isNull(str)) {
             return "null";
         }
         // var str1 = new String(str);
         var strBuf = [];
         strBuf.push('\'');
         for (var index = 0; index < str.length; index++) {
             var charItem = str.charAt(index);
             if (charItem == '\\' || charItem == '\"' || charItem == '\'') {
                 // strBuf.concat('\\');
                 strBuf.push('\\');
             }
             strBuf.push(charItem);
         }
         strBuf.push('\'');
         return strBuf.join("");
     };
     this.setColumn = function(column) {
         if (column instanceof kony.sdk.dto.Column) {
             this.column = column;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Between::setColumn: Error:column is not an instance of kony.sdk.dto.Column");
         }
     };
     this.setRange = function(range) {
         if (range instanceof kony.sdk.dto.DateRange || range instanceof kony.sdk.dto.StringRange || range instanceof kony.sdk.dto.IntegerRange || range instanceof kony.sdk.dto.FloatRange) {
             this.range = range;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Between::setRange: Error: Validation Error");
         }
     };
     this.getColumn = function() {
         return this.column;
     };
     this.getRange = function() {
         return this.range;
     };
     this.toString = function() {
         var returnStr = "";
         returnStr = this.getColumn().toString() + " Between " + this.getRange().toString();
         return returnStr;
     };
 };
 /**
  * This function is the DateRange constructor.
  * @param startDate
  * @param endDate
  */
 kony.sdk.dto.DateRange = function() {
     this.end;
     this.start;
     if (arguments.length === 2) {
         var startDate = arguments[0];
         var endDate = arguments[1];
         if (startDate instanceof Date && endDate instanceof Date) {
             this.start = startDate;
             this.end = endDate;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.DataRange:: Error: startDate or endDate is not an instance of Date");
         }
     } else if (arguments.length === 1) {
         var dateType = arguments[0];
         if (kony.sdk.util.validateDateTypeInput(dateType)) {
             var range = kony.sdk.util.getDateRange(dateType);
             if (range.length !== 2 || range[0] === 0 || range[1] === 0) {
                 //TODO
                 //throw error
                 kony.sdk.logsdk.error("### kony.sdk.dto.DateRange:: Error: Validation Error");
             } else {
                 this.start = range[0];
                 this.end = range[1];
             }
         }
     }
     this.getEnd = function() {
         return this.end;
     };
     /**
      * This function is used to set End value.
      *
      * @param end
      */
     this.setEnd = function(end) {
         if (end instanceof Date) {
             var month = end.getMonth() + 1;
             var date = end.getDate();
             var hr = end.getHours();
             var min = end.getMinutes();
             var sec = end.getSeconds();
             if (month < 10) {
                 month = "0" + month;
             }
             if (date < 10) {
                 date = "0" + date;
             }
             if (hr < 10) {
                 hr = "0" + hr;
             }
             if (min < 10) {
                 min = "0" + min;
             }
             if (sec < 10) {
                 sec = "0" + sec;
             }
             var endDate = end.getFullYear() + "-" + month + "-" + date + " " + hr + ":" + min + ":" + sec;
             this.end = endDate;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.DateRange::setEnd:: Error: end is not an instance of Date");
         }
     };
     this.getStart = function() {
         return this.start;
     };
     /**
      * This function is used to set start value.
      *
      * @param start
      */
     this.setStart = function(start) {
         if (start instanceof Date) {
             var month = start.getMonth() + 1;
             var date = start.getDate();
             var hr = start.getHours();
             var min = start.getMinutes();
             var sec = start.getSeconds();
             if (month < 10) {
                 month = "0" + month;
             }
             if (date < 10) {
                 date = "0" + date;
             }
             if (hr < 10) {
                 hr = "0" + hr;
             }
             if (min < 10) {
                 min = "0" + min;
             }
             if (sec < 10) {
                 sec = "0" + sec;
             }
             var startDate = start.getFullYear() + "-" + month + "-" + date + " " + hr + ":" + min + ":" + sec;
             this.start = startDate;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.DateRange::setStart:: Error: start is not an instance of Date");
         }
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         var returnString = null;
         returnString = "'" + this.start + "'" + " AND " + "'" + this.end + "'";
         return returnString;
     };
 };
 /**
  * This function is the DecimalRange constructor.
  * @param startDecimal
  * @param endDecimal
  */
 kony.sdk.dto.DecimalRange = function(startDecimal, endDecimal) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.DecimalRange");
     if ((endDecimal !== null && endDecimal !== undefined && typeof endDecimal === 'number') && (startDecimal !== null && startDecimal !== undefined && typeof startDecimal === 'number')) {
         this.end = endDecimal;
         this.start = startDecimal;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.DecimalRange:: Error: Validation Error");
     }
     this.getEnd = function() {
         return this.end;
     };
     /**
      * This function is used to set End value.
      *
      * @param end
      */
     this.setEnd = function(end) {
         if (end !== null && end !== undefined && typeof end === 'number') {
             this.end = end;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.DecimalRange::setEnd:: Error: Validation Error");
         }
     };
     this.getStart = function() {
         return this.start;
     };
     /**
      * This function is used to set start value.
      *
      * @param start
      */
     this.setStart = function(start) {
         if (start !== null && start !== undefined && typeof start === 'number') {
             this.start = start;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.DecimalRange::setStart:: Error: Validation Error");
         }
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         var returnString = null;
         returnString = this.start + " AND " + this.end;
         return returnString;
     };
 };
 /**
  * This function is the FloatRange constructor.
  * @param startFloat
  * @param endFloat
  */
 kony.sdk.dto.FloatRange = function(startFloat, endFloat) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.FloatRange");
     this.end = endFloat;
     this.start = startFloat;
     this.getEnd = function() {
         return this.end;
     };
     /**
      * This function is used to set End value.
      *
      * @param end
      */
     this.setEnd = function(end) {
         if (end !== null && end !== undefined && typeof end === 'number') {
             this.end = end;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.FloatRange::setEnd:: Error: Validation Error");
         }
     };
     this.getStart = function() {
         return this.start;
     };
     /**
      * This function is used to set start value.
      *
      * @param start
      */
     this.setStart = function(start) {
         if (start !== null && start !== undefined && typeof start === 'number') {
             this.start = start;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.FloatRange::setStart:: Error: Validation Error");
         }
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         var returnString = null;
         returnString = this.start + " AND " + this.end;
         return returnString;
     };
 };
 /**
  * This function is the IntegerRange constructor.
  * @param startInt
  * @param endInt
  */
 kony.sdk.dto.IntegerRange = function(startInt, endInt) {
     if ((endInt !== null && endInt !== undefined && typeof endInt === 'number') && (startInt !== null && startInt !== undefined && typeof startInt === 'number')) {
         this.end = endInt;
         this.start = startInt;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.IntegerRange:: Error: Validation Error");
     }
     this.getEnd = function() {
         return this.end;
     };
     /**
      * This function is used to set End value.
      *
      * @param end
      */
     this.setEnd = function(end) {
         if (end !== null && end !== undefined && typeof end === 'number') {
             this.end = end;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.IntegerRange::setEnd:: Error: Validation Error");
         }
     };
     this.getStart = function() {
         return this.start;
     };
     /**
      * This function is used to set start value.
      *
      * @param start
      */
     this.setStart = function(start) {
         if (start !== null && start !== undefined && typeof start === 'number') {
             this.start = start;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.IntegerRange::setStart:: Error: Validation Error");
         }
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         var returnString = null;
         returnString = this.start.toFixed() + " AND " + this.end.toFixed();
         return returnString;
     };
 };
 /**
  * This function is the StringRange constructor.
  * @param startString
  * @param endString
  */
 kony.sdk.dto.StringRange = function(startString, endString) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.StringRange");
     if ((endString !== null && endString !== undefined && typeof endString === 'string') && (startString !== null && startString !== undefined && typeof startString === 'string')) {
         this.end = endString;
         this.start = startString;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.StringRange:: Error: Validation Error");
     }
     this.getEnd = function() {
         return this.end;
     };
     /**
      * This function is used to set End value.
      *
      * @param end
      */
     this.setEnd = function(end) {
         if (end !== null && end !== undefined && typeof end === 'string') {
             this.end = end;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.StringRange::setEnd:: Error: Validation Error");
         }
     };
     this.getStart = function() {
         return this.start;
     };
     /**
      * This function is used to set start value.
      *
      * @param start
      */
     this.setStart = function(start) {
         if (start !== null && start !== undefined && typeof start === 'string') {
             this.start = start;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.StringRange::setStart:: Error: Validation Error");
         }
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         var returnString = null;
         var crit = new kony.sdk.dto.Criteria();
         returnString = crit.quote(this.start) + " AND " + crit.quote(this.end);
         return returnString;
     };
 };
 /**
  * This function helps in preparing And {@link kony.sdk.dto.And} and Or {@Link kony.sdk.dto.Or} clauses
  * @param operatorLg
  * @param leftOp
  * @param rightOp
  * @constructor
  */
 kony.sdk.dto.LogicGroup = function(operatorLg, leftOp, rightOp) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.LogicGroup");
     this.left = leftOp;
     this.operator = operatorLg;
     this.right = rightOp;
     /**
      * This function is used to initialize LogicGroup.
      *
      * @param operator
      * @param left
      * @param right
      */
     this.initializeLogicGroup = function(operator, left, right) {
         this.left = left;
         this.operator = operator;
         this.right = right;
     };
     this.getLeft = function() {
         return this.left;
     };
     /**
      * This function is used to set left.
      *
      * @param val
      */
     this.setLeft = function(val) {
         this.val = val;
     };
     this.getOperator = function() {
         return this.operator;
     };
     /**
      * This function is used to set Operator.
      *
      * @param val
      */
     this.setOperator = function(val) {
         this.operator = val;
     };
     this.getRight = function() {
         return this.right;
     };
     /**
      * This function is used to set Right.
      *
      * @param val
      */
     this.setRight = function(val) {
         this.right = val;
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         var leftOperator = (this.getLeft() !== null && this.getLeft !== undefined) ? this.getLeft().toString() : "";
         var rightOperator = (this.getRight() !== null && this.getRight() !== undefined) ? this.getRight().toString() : "";
         return "(" + leftOperator + " " + this.getOperator() + " " + rightOperator + ")";
     };
 };
 /**
  * This function is the And constructor.
  *
  * @param left
  * @param right
  */
 kony.sdk.dto.And = function(left, right) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.And");
     if (arguments.length !== 2) {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.And:: Error: invalid number of arguments, expected are left and right");
     }
     if ((right !== null && left !== null && right !== undefined && left !== undefined && kony.sdk.util.validateCriteriaObject(left) && kony.sdk.util.validateCriteriaObject(right))) {
         kony.sdk.dto.LogicGroup.call(this, 'AND', left, right);
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.And:: Error: Validation Error");
     }
     this.initializeAnd = function(left, right) {
         kony.sdk.dto.LogicGroup.call(this, 'AND', left, right);
     };
 };
 /**
  * This function is the Or constructor.
  *
  * @param left
  * @param right
  */
 kony.sdk.dto.Or = function(left, right) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Or");
     if (arguments.length !== 2) {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Or:: Error: invalid number of arguments, expected are left and right");
     }
     if ((right !== null && left !== null && right !== undefined && left !== undefined && kony.sdk.util.validateCriteriaObject(left) && kony.sdk.util.validateCriteriaObject(right))) {
         kony.sdk.dto.LogicGroup.call(this, 'OR', left, right);
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Or:: Error: Validation Error");
     }
     this.initializeOr = function(left, right) {
         kony.sdk.dto.LogicGroup.call(this, 'OR', left, right);
     };
 };
 /**
  * This function is the Not constructor.
  *
  * @param right
  */
 kony.sdk.dto.Not = function(right) {
     if (arguments.length !== 1) {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Not:: Error: invalid number of arguments, expected right");
     }
     if (right !== null && right !== undefined && kony.sdk.util.validateCriteriaObject(right)) {
         kony.sdk.dto.LogicGroup.call(this, 'NOT', null, right);
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Not:: Error: Validation Error");
     }
     this.initializeNot = function(right) {
         kony.sdk.dto.LogicGroup.call(this, 'NOT', null, right);
     };
 };
 /**
  * This function is a constructor for Expression Object
  * @constructor
  */
 kony.sdk.dto.Expression = function() {
     this.term;
     this.operator;
     this.expression;
     var currentExpObj = this;
     if (arguments.length === 1) {
         if (kony.sdk.util.validateCriteriaObject(arguments[0])) {
             setTerm(arguments[0]);
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Expression:: Error: Validation Error");
         }
     } else if (arguments.length === 2) {
         initExpression(arguments[0], arguments[1]);
     } else if (arguments.length === 3) {
         initExpressionByExpression(arguments[0], arguments[1], arguments[2]);
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Expression:: Error: invalid number of arguments, atleast 'term' is expected");
     }
     /**
      * Recursively generates a Expression from a given list of
      * criteria and an infix operator to join each criteria with the
      * next in the list. Operator AND or Operator OR that joins each
      * criteria term with the next in the list.
      *
      * @param criterias
      *            the list of criteria terms from which the
      *            constructor generates the new criteria expression.
      * @param operator
      *            the infix operator
      */
     function initExpression(criterias, operator) {
         if (operator === kony.sdk.constants.Operator.OR) {
             setOperator(kony.sdk.constants.Operator.OR);
         } else if (operator === kony.sdk.constants.Operator.AND) {
             setOperator(kony.sdk.constants.Operator.AND);
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Expression::initExpression:: Error: Invalid Operator");
         }
         if (criterias !== null && criterias !== undefined && criterias instanceof Array && criterias.length > 0) {
             if (kony.sdk.util.validateCriteriaObject(criterias[0])) {
                 setTerm(criterias[0]);
             }
             if (criterias.length > 1) {
                 var tmpOperator = operator;
                 criterias.shift();
                 setExpression(new kony.sdk.dto.Expression(criterias, tmpOperator));
             }
         } else {
             if (kony.sdk.util.validateCriteriaObject(criterias)) {
                 setTerm(criterias);
                 // return currentExpObj;
             } else {
                 //TODO
                 //throw error
                 kony.sdk.logsdk.error("### kony.sdk.dto.Expression::initExpression:: Error: Validation Error");
             }
         }
     }

     function setExpression(expression) {
         if (expression instanceof kony.sdk.dto.Expression) {
             currentExpObj.expression = expression;
             // return currentExpObj;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Expression::setExpression:: Error: expression not an instance of kony.sdk.do.Expression");
         }
     }

     function setTerm(term) {
         if (kony.sdk.util.validateCriteriaObject(term)) {
             currentExpObj.term = term;
             // return currentExpObj;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Expression::setTerm:: Error: Validation Error");
         }
     }
     /**
      * Initializes a Expression with an initial criteria term, an
      * operator, and a another trailing criteria expression.
      *
      * @param criterias
      *            the starting criteria to assign to the new
      *            criteria expression.
      * @param operator
      *            the infix operator
      * @param expression
      *            the trailing expression to assign to the new
      *            criteria expression.
      */
     function initExpressionByExpression(criterias, operator, expression) {
         if (operator === kony.sdk.constants.Operator.OR) {
             initExpression(criterias, kony.sdk.constants.Operator.OR);
         } else if (operator === kony.sdk.constants.Operator.AND) {
             initExpression(criterias, kony.sdk.constants.Operator.AND);
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Expression::initExpressionByExpression:: Error: Invalid Operator");
         }
         setExpression(expression);
         // return currentExpObj;
     }

     function setOperator(operator) {
         currentExpObj.operator = operator;
     }
     this.getTerm = function() {
         return this.term;
     };
     this.getOperator = function() {
         return this.operator;
     };
     this.getExpression = function() {
         return this.expression;
     };
     this.toString = function() {
         var returnString = null;
         if ((this.getTerm() === null || this.getTerm() === undefined) && (this.getExpression() === null || this.getExpression() === undefined)) {
             returnString = "";
         } else if (this.getExpression() === null || this.getExpression() === undefined) {
             returnString = this.getTerm().toString();
         } else if (this.getOperator() === kony.sdk.constants.Operator.AND) {
             returnString = (new kony.sdk.dto.And(this.getTerm(), this.getExpression())).toString();
         } else if (this.getOperator() === kony.sdk.constants.Operator.OR) {
             returnString = (new kony.sdk.dto.Or(this.getTerm(), this.getExpression())).toString();
         }
         return returnString;
     }
 };
 /**
  * This function is a constructor for InCriteria Object
  * @constructor
  */
 kony.sdk.dto.InCriteria = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.InCriteria");
     this.column;
     this.values;
     var currentInCriteriaObj = this;
     if (arguments.length === 2) {
         getInCriteriaByColumnAndCollection(arguments[0], arguments[1]);
     } else if (arguments.length === 3) {
         getInCriteriaByTableAndCollection(arguments[0], arguments[1], arguments[2]);
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.InCriteria:: Error: invalid number of arguments, atleast column,values are expected");
     }
     /**
      * This function is the InCriteria constructor which has 3
      * arguments.
      *
      * @param table
      * @param columnname
      * @param values
      */
     function getInCriteriaByTableAndCollection(table, columnname, values) {
         kony.sdk.logsdk.trace("Entering into getInCriteriaByTableAndCollection");
         if (table instanceof kony.sdk.dto.Table) {
             currentInCriteriaObj.column = new kony.sdk.dto.Column(table, columnname);
             currentInCriteriaObj.values = values;
             return currentInCriteriaObj;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.InCriteria::getInCriteriaByTableAndCollection:: Error: table is not an instance of kony.sdk.dto.Table");
         }
     }
     /**
      * This function is the InCriteria constructor which has 2
      * arguments.
      *
      * @param column
      * @param values
      */
     function getInCriteriaByColumnAndCollection(column, values) {
         kony.sdk.logsdk.trace("Entering into getInCriteriaByColumnAndCollection");
         if (column instanceof kony.sdk.dto.Column && values instanceof Array && values.length > 0) {
             currentInCriteriaObj.column = column;
             currentInCriteriaObj.values = values;
             return currentInCriteriaObj;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.InCriteria::getInCriteriaByColumnAndCollection:: Error: Validation Error");
         }
     }
     this.getColumnForTable = function(table, columnName) {
         if (table instanceof kony.sdk.dto.Table) {
             var column = new kony.sdk.dto.Column(table, columnName);
             return column;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.InCriteria::getColumnForTable:: Error: table not an instance of kony.sdk.dto.Table");
         }
     };
     this.getColumn = function() {
         return this.column;
     };
     this.setColumn = function(column) {
         if (column instanceof kony.sdk.dto.Column) {
             this.column = column;
         }
     };
     this.setValues = function(valuesCollection) {
         this.values = valuesCollection;
     };
     this.getValues = function() {
         return this.values;
     };
     this.toString = function() {
         var result = "";
         result = this.column.toString() + " IN (";
         if (this.values !== null && this.values !== undefined && this.values.length > 0) {
             for (var index = 0; index < this.values.length; index++) {
                 var value;
                 var criteria = new kony.sdk.dto.Criteria();
                 if (typeof(this.values[index]) === "string") {
                     value = criteria.quote(this.values[index]);
                 } else {
                     value = this.values[index];
                 }
                 result = result + value;
                 if (index !== (this.values.length - 1)) {
                     result = result + ", ";
                 }
             }
         }
         /*
          * else if (this.subSelect !== null && this.subSelect !==
          * undefined) { result = result + this.subSelect; }
          */
         result = result + ")";
         return result;
     };
 };
 /**
  * This function is used to in set Exists param in select query
  * @param subSelectQuery {@link kony.sdk.dto.SelectQuery}
  * @constructor
  */
 kony.sdk.dto.Exists = function(subSelectQuery) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Exists");
     if (subSelectQuery instanceof kony.sdk.dto.SelectQuery) {
         this.subSelect = subSelectQuery;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Exists:: Error: subSelectQuery is not an instance of kony.sdk.dto.SelectQuery");
     }
     this.getSubSelect = function() {
         return this.subSelect;
     };
     this.setSubSelect = function(subSelect) {
         if (subSelect instanceof kony.sdk.dto.SelectQuery) {
             this.subSelect = subSelect;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Exists::subSelectQuery:: Error: subSelectQuery is not an instance of kony.sdk.dto.SelectQuery");
         }
     };
     this.toString = function() {
         return "EXISTS ( " + this.subSelect.toString() + " )";
     };
 };
 /**
  * This is Interface to define where clauses
  * @constructor
  */
 kony.sdk.dto.Criteria = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Criteria");
     this.quote = function(str) {
         if (str === null || str === undefined) {
             return "null";
         }
         // var str1 = new String(str);
         var strBuf = [];
         strBuf.push('\'');
         for (var index = 0; index < str.length; index++) {
             var charItem = str.charAt(index);
             if (charItem == '\\' || charItem == '\"' || charItem == '\'') {
                 // strBuf.concat('\\');
                 strBuf.push('\\');
             }
             strBuf.push(charItem);
         }
         strBuf.push('\'');
         return strBuf.join("");
     };
 };
 /**
  * This function is used to define where clause
  * @constructor
  */
 kony.sdk.dto.Match = function() {
     this.column;
     this.matchType;
     this.value;
     var currentMatchObj = this;
     if (arguments.length === 3) {
         initMatchByColumn(arguments[0], arguments[1], arguments[2]);
     } else if (arguments.length === 4) {
         initMatchByTableAndColName(arguments[0], arguments[1], arguments[2], arguments[3]);
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Match:: Error: Invalid number of arguments, atleast columnObj,matchType,value is required")
     }
     /**
      * This function is the Match constructor which has 3 arguments.
      *
      * @param columnObj
      * @param matchType
      * @param value
      */
     function initMatchByColumn(columnObj, matchType, value) {
         if (columnObj instanceof kony.sdk.dto.Column) {
             currentMatchObj.column = columnObj;
             if (matchType !== kony.sdk.constants.MatchType.EQUALS && matchType !== kony.sdk.constants.MatchType.GREATER && matchType !== kony.sdk.constants.MatchType.GREATEREQUAL && matchType !== kony.sdk.constants.MatchType.LESS && matchType !== kony.sdk.constants.MatchType.LESSEQUAL && matchType !== kony.sdk.constants.MatchType.STARTSWITH && matchType !== kony.sdk.constants.MatchType.CONTAINS && matchType !== kony.sdk.constants.MatchType.LIKE && matchType !== kony.sdk.constants.MatchType.ENDSWITH && matchType !== kony.sdk.constants.MatchType.NOTEQUAL && matchType !== kony.sdk.constants.MatchType.ISNULL && matchType !== kony.sdk.constants.MatchType.ISNOTNULL) {
                 //TODO
                 //throw error
                 kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByColumn:: Error: Invalid MatchType");
             } else {
                 if (matchType !== kony.sdk.constants.MatchType.ISNULL && matchType !== kony.sdk.constants.MatchType.ISNOTNULL) {
                     // check if the value is passed or not except
                     // for NULL and NOT NULL cases.
                     if (value !== null && value !== undefined) {
                         if (value instanceof Array && value.length <= 0) {
                             //TODO
                             //throw error
                             kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByColumn:: Error: value is undefined ,null or empty object");
                         }
                         currentMatchObj.value = value;
                     } else {
                         //TODO
                         //throw error
                         kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByColumn:: Error: Invalid MatchType");
                     }
                 }
                 currentMatchObj.matchType = matchType;
                 return currentMatchObj;
             }
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByColumn:: Error: columnObj is not an instance of kony.sdk.dto.Column");
         }
     }
     /**
      * This function is the Match constructor which has 4 arguments.
      *
      * @param tableObj
      * @param columnName
      * @param matchType
      * @param value
      */
     function initMatchByTableAndColName(tableObj, columnName, matchType, value) {
         // check for validity of tableObj
         if (tableObj instanceof kony.sdk.dto.Table) {
             // columnName should not empty or null or undefined.
             if (columnName !== null && columnName !== undefined && typeof(columnName) === 'string' && columnName.trim().length > 0) {
                 currentMatchObj.column = tableObj.getColumn(columnName);
                 if (matchType !== kony.sdk.constants.MatchType.EQUALS && matchType !== kony.sdk.constants.MatchType.GREATER && matchType !== kony.sdk.constants.MatchType.GREATEREQUAL && matchType !== kony.sdk.constants.MatchType.LESS && matchType !== kony.sdk.constants.MatchType.LESSEQUAL && matchType !== kony.sdk.constants.MatchType.STARTSWITH && matchType !== kony.sdk.constants.MatchType.CONTAINS && matchType !== kony.sdk.constants.MatchType.LIKE && matchType !== kony.sdk.constants.MatchType.ENDSWITH && matchType !== kony.sdk.constants.MatchType.NOTEQUAL && matchType !== kony.sdk.constants.MatchType.ISNULL && matchType !== kony.sdk.constants.MatchType.ISNOTNULL) {
                     //TODO
                     //throw error
                     kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByTableAndColName:: Error: Invalid MatchType");
                 } else {
                     if (matchType !== kony.sdk.constants.MatchType.ISNULL && matchType !== kony.sdk.constants.MatchType.ISNOTNULL) {
                         // check if the value is passed or not
                         // except for NULL and NOT NULL cases.
                         if (value !== null && value !== undefined) {
                             currentMatchObj.value = value;
                         } else {
                             //TODO
                             //throw error
                             kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByTableAndColName:: Error: value is undefined ,null or empty object");
                         }
                     }
                     currentMatchObj.matchType = matchType;
                 }
                 return currentMatchObj;
             } else {
                 //TODO
                 //throw error
                 kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByTableAndColName:: Error: Invalid MatchType");
             }
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Match:: Error: columnObj is not an instance of kony.sdk.dto.Column");
         }
     }
     this.getColumn = function() {
         if (this.column !== null && this.column !== undefined) {
             return this.column;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Match::getColumn:: Error: column is null or undefined");
         }
     };
     this.getMatchType = function() {
         if (this.matchType !== null && this.matchType !== undefined) {
             return this.matchType;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Match::getMatchType:: Error: matchType is null or undefined");
         }
     };
     /**
      * This function is used to set match type.
      *
      * @param matchType
      */
     this.setMatchType = function(matchType) {
         this.matchType = matchType;
     };
     this.getValue = function() {
         return this.value;
     };
     /*
      * quote=function(value){ return "'"+value+"'"; }
      */
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         if (this.matchType !== null && this.matchType !== undefined && this.column !== null && this.column !== undefined) {
             var constructedMatch = null;
             var constructedValue = null;
             var type = this.matchType;
             var val = this.matchType.name;
             if (this.value instanceof Date) {
                 var dateStr = "";
                 var month = this.getValue().getMonth() + 1;
                 var date = this.getValue().getDate();
                 if (month < 10) {
                     month = "0" + month;
                 }
                 if (date < 10) {
                     date = "0" + date;
                 }
                 dateStr = this.getValue().getFullYear() + "-" + month + "-" + date;
                 constructedMatch = "date(substr(" + this.getColumn().toString() + ",0,11)) " + this.getMatchType().value + "'" + dateStr + "'";
                 return constructedMatch;
             }
             if (typeof(this.getValue()) === 'boolean') {
                 if (this.getValue() === true) {
                     return "(" + this.getColumn().toString() + " = 'true' OR " + this.getColumn().toString() + " = 1)";
                 } else if (this.getValue() === false) {
                     return "(" + this.getColumn().toString() + " = 'false' OR " + this.getColumn().toString() + " = 0)";
                 } else {
                     this.value = "'" + this.value + "'";
                 }
             }
             constructedMatch = this.getColumn().toString() + " " + this.getMatchType().value + " ";
             if (typeof(this.getValue()) === 'string') {
                 constructedValue = kony.sdk.util.replaceAll(this.getValue(), "'", "");
                 if (kony.sdk.util.matchIgnoreCase(type.name, "STARTSWITH")) {
                     constructedValue = constructedValue + "%";
                 } else if (kony.sdk.util.matchIgnoreCase(type.name, "CONTAINS")) {
                     constructedValue = "%" + constructedValue + "%";
                 } else if (kony.sdk.util.matchIgnoreCase(type.name, "ENDSWITH")) {
                     constructedValue = "%" + constructedValue;
                 } else if (kony.sdk.util.matchIgnoreCase(type.name, "ISNULL")) {
                     return "(lower(" + this.getColumn().toString() + ") = 'null' OR " + this.getColumn().toString() + " IS NULL)";
                 } else if (kony.sdk.util.matchIgnoreCase(type.name, "ISNOTNULL")) {
                     return "(lower(" + this.getColumn().toString() + ") != 'null' OR " + this.getColumn().toString() + " IS NOT NULL)";
                 }
                 constructedValue = new kony.sdk.dto.Criteria().quote(constructedValue);
             } else {
                 if (kony.sdk.util.matchIgnoreCase(type.name, "ISNULL")) {
                     return "(lower(" + this.getColumn().toString() + ") = 'null' OR " + this.getColumn().toString() + " IS NULL)";
                 } else if (kony.sdk.util.matchIgnoreCase(type.name, "ISNOTNULL")) {
                     return "(lower(" + this.getColumn().toString() + ") != 'null' OR " + this.getColumn().toString() + " IS NOT NULL)";
                 }
                 constructedValue = this.getValue().toString();
             }
             if (!(kony.sdk.util.matchIgnoreCase(type.name, "ISNULL") || kony.sdk.util.matchIgnoreCase(type.name, "ISNOTNULL"))) {
                 constructedMatch = constructedMatch + constructedValue;
             }
             return constructedMatch;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Match::toString:: Error: matchType is undefined");
         }
     }
 };

 function OAuthHandler(serviceUrl, providerName, appkey, callback, type, options, isMFVersionCompatible) {
     var urlType = "/" + type + "/";
     var isSuccess = true;
     var isLogout = false;
     // This will make sure the scheduler to request tokens will be instantiated only once in the method handleRequestCallback.
     // In case of Google OAuth changes Identity returns the success_url, so page gets refreshed twice which will fail in instantiating the scheduler twice.
     var isLoginCallbackInvoked = false;
     if (options && options.hasOwnProperty("logout") && options["logout"] === true) {
         isLogout = true;
     }
     var slo = false;
     if (options && options.hasOwnProperty("slo") && options["slo"] === true) {
         slo = options["slo"];
     }
     var customQueryParamsForOAuth;
     if (options && options.hasOwnProperty("customQueryParamsForOAuth")) {
         customQueryParamsForOAuth = kony.sdk.util.objectToQueryParams(options["customQueryParamsForOAuth"]);
     }
     var requestUrl;

     function appendCustomOAuthParamsToURL(url) {
         if (!kony.sdk.util.isNullOrEmptyString(customQueryParamsForOAuth)) {
             url = url + "&" + customQueryParamsForOAuth;
         }
         return url;
     }

     function constructURLIE11(crossPlatformBaseURL, identityOAuthUrl) {
         //Identity Server will route the final result be it success or error to Injected callback page
         identityOAuthUrl = identityOAuthUrl + "&" + kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL + "=" + encodeURIComponent(crossPlatformBaseURL + "/" + kony.sdk.constants.KNY_OAUTH_CALLBACK_HTML);
         //Invoking the identity through the injected Redirect Page to overcome IE imposed cross domain security restrictions.
         var finalRequestUrl = crossPlatformBaseURL + "/" + kony.sdk.constants.KNY_OAUTH_REDIRECT_HTML + "?" + kony.sdk.constants.KNY_OAUTH_REDIRECT_URL + "=" + encodeURIComponent(identityOAuthUrl);
         return finalRequestUrl;
     }
     if (typeof(XMLHttpRequest) !== 'undefined') {
         var _window = window;
         var _popup = null;
         var _listener = function(event) {
             var _contents = event.data;
             /**
              MFSDK-3431 - Recieving post message event from other endpoints.
              This is a short term fix. Currently Identity sends us only string in post message event, later on they have to
              send json with some more keys giving us the knowledge of source
              */
             if (kony.sdk.util.isValidString(_contents) && !kony.sdk.isJson(_contents)) {
                 _popup.close();
                 _detachEvent();
                 try {
                     kony.sdk.logsdk.debug("### OAuthHandler::_listener received authorization code as " + _contents);
                     var headers = {};
                     if (type === "oauth2" || type === "saml") {
                         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED
                     }
                     callback(urlType + "token", {
                         code: _contents
                     }, headers);
                 } catch (err) {
                     kony.sdk.logsdk.error("exception ::" + err);
                     failureCallback();
                 }
             } else if (kony.sdk.isJson(_contents) || kony.sdk.util.isJsonObject(_contents)) {
                 kony.sdk.logsdk.debug("### OAuthHandler::_listener received event.data in unknown format as " + JSON.stringify(_contents));
                 //TODO - After Identity changes check for desired key in the json.
             }
         };
         var _attachEvent = function() {
             if (_window.addEventListener) {
                 _window.addEventListener('message', _listener, false);
             } else if (_window.attachEvent) {
                 _window.attachEvent('message', _listener);
             } else {
                 throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "environment doesn't support event attaching");
             }
         };
         var _detachEvent = function() {
             if (_window.detachEvent) {
                 _window.detachEvent('message', _listener);
             } else if (_window.removeEventListener) {
                 _window.removeEventListener('message', _listener);
             } else {
                 throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "environment doesn't support detaching an event");
             }
         };
         _attachEvent();
         if (isLogout) {
             requestUrl = serviceUrl + urlType + "logout?provider=" + providerName + "&appkey=" + appkey + "&slo=" + slo;
         } else {
             requestUrl = serviceUrl + urlType + "login?provider=" + providerName + "&appkey=" + appkey;
             requestUrl = appendCustomOAuthParamsToURL(requestUrl);
             //Checking whether server is compatable to redirect to user defined callback url
             //Changes to support OAuth on IE11, MFSDK-3657
             if (isMFVersionCompatible && kony.sdk.util.checkForIE11() && kony.sdk.util.isJsonObject(options) && options.hasOwnProperty(kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL)) {
                 requestUrl = constructURLIE11(stripTrailingCharacter(options[kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL], "/"), requestUrl);
             }
         }
         _popup = _window.open(requestUrl);
     } else {
         var browserSF = null;
         var userDefined = false;
         if (kony.sdk.util.hasBrowserWidget(options)) {
             browserSF = options[kony.sdk.constants.BROWSER_WIDGET];
             userDefined = true;
         } else if (options && options["UseDeviceBrowser"] && isMFVersionCompatible) {
             kony.sdk.util.OAuthCallback = callback;
             kony.sdk.util.OAuthType = type;
         } else {
             var formBasic = {
                 id: "popUp",
                 skin: null,
                 isModal: false,
                 transparencyBehindThePopup: 80,
                 "needAppMenu": false
             };
             var formLayout = {
                 containerWeight: 100,
                 padding: [5, 5, 5, 5],
                 "paddingInPixel": true
             };
             var formPSP = {
                 "titleBar": true,
                 "titleBarConfig": {
                     "renderTitleText": true,
                     "prevFormTitle": false,
                     "titleBarLeftSideView": "button",
                     "labelLeftSideView": "Back",
                     "titleBarRightSideView": "none"
                 },
                 "titleBarSkin": "slTitleBar"
             };
             //to do.. this is a workaround for android browser issue.. need to refactor this code
             browserSF = new kony.ui.Browser({
                 "id": "browserSF",
                 "text": "Browser",
                 "isVisible": true,
                 "detectTelNumber": true,
                 "screenLevelWidget": true,
                 "enableZoom": false
             }, {
                 "margin": [0, 0, 0, 0],
                 "marginInPixel": true,
                 "paddingInPixel": true,
                 "containerWeight": 100
             }, {});
             var prevForm = kony.application.getCurrentForm();
             var oauthForm = new kony.ui.Form2(formBasic, formLayout, formPSP);
             oauthForm.add(browserSF);
             oauthForm.show();
         }
         var urlConf;
         var headersConf = {};
         if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken)) {
             headersConf[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
         }
         konyRef.appendGlobalHeaders(headersConf);
         requestUrl = serviceUrl + urlType;
         if (isLogout) {
             requestUrl += "logout?provider=" + providerName + "&appkey=" + appkey + "&slo=" + slo;
         } else {
             requestUrl += "login?provider=" + providerName + "&appkey=" + appkey;
         }
         if (!kony.sdk.isNullOrUndefined(kony.sdk.getFabricAppVersion())) {
             requestUrl += "&app_version=" + kony.sdk.getFabricAppVersion();
         }
         if (isLogout) {
             browserSF.onSuccess = handleOAuthLogoutSuccessCallback;
             browserSF.onFailure = handleOAuthLogoutFailureCallback;
         } else {
             if (options && options["success_url"] && isMFVersionCompatible) requestUrl += "&success_url=" + options["success_url"];
             if (options && options["UseDeviceBrowser"] && isMFVersionCompatible) {
                 kony.application.openURL(requestUrl);
                 return;
             } else {
                 isLoginCallbackInvoked = false;
                 browserSF.handleRequest = handleRequestCallback;
                 requestUrl = appendCustomOAuthParamsToURL(requestUrl);
             }
         }
         urlConf = {
             URL: requestUrl,
             requestMethod: constants.BROWSER_REQUEST_METHOD_GET
         };
         if (Object.keys(headersConf).length > 0) {
             urlConf["headers"] = headersConf;
         }
         browserSF.requestURLConfig = urlConf;

         function handleOAuthLogoutSuccessCallback() {
             if (!userDefined) {
                 var prevFormPostShow = prevForm.postShow;

                 function postShowOverride() {
                     oauthForm.destroy();
                     if (prevFormPostShow) {
                         prevFormPostShow();
                     }
                     prevForm.postShow = prevFormPostShow;
                 }
                 prevForm.postShow = postShowOverride;
                 prevForm.show();
             }
             callback(isSuccess);
         }

         function handleOAuthLogoutFailureCallback() {
             isSuccess = false;
         }

         function handleRequestCallback(browserWidget, params) {
             var originalUrl = params["originalURL"];
             if (!isLoginCallbackInvoked && typeof(params.queryParams) !== "undefined" && typeof(params.queryParams.code) !== "undefined") {
                 if (!userDefined) {
                     var prevFormPostShow = prevForm.postShow;
                     prevForm.postShow = postShowOverride;

                     function postShowOverride() {
                         oauthForm.destroy();
                         if (prevFormPostShow) {
                             prevFormPostShow();
                         }
                         prevForm.postShow = prevFormPostShow;
                     }
                     prevForm.show();
                 }
                 var headers = {};
                 if (type === "oauth2" || type === "saml") {
                     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
                 }
                 if (!isLoginCallbackInvoked) {
                     // make request for tokens
                     kony.timer.schedule(new Date().getTime().toString(), function(url, callback, code, headers) {
                         return function() {
                             callback(url, {
                                 code: code
                             }, headers);
                         };
                     }(urlType + "token", callback, decodeURIComponent(params.queryParams.code), headers), 1, false);
                     isLoginCallbackInvoked = true;
                 }
             }
             return false;
         }
     }
 }
 /**
  * Handles the deeplink callback, this needs to be called once deep link redirection is done.
  * @param {json} params parameters from Identity service - "code": HashValue
  */
 function handleDeeplinkCallback(params) {
     if (params && kony.sdk.isValidDeeplinkCallback(params)) {
         var headers = {};
         var requestUrl;
         if (kony.sdk.util.OAuthType === "oauth2" || kony.sdk.util.OAuthType === "saml") {
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         }
         if (kony.sdk.util.OAuthType === "oauth2") {
             requestUrl = "/oauth2/token";
         } else if (kony.sdk.util.OAuthType === "saml") {
             requestUrl = "/saml/token";
         } else {
             requestUrl = "/login";
         }
         // make request for tokens
         kony.sdk.util.OAuthCallback(requestUrl, {
             code: decodeURIComponent(params.launchparams.code)
         }, headers);
     }
 }
 if (kony.sdk) {
     kony.sdk.offline = {};
 }
 /**
  * Created by Tharalika Palakurthy
  */
 var KNYMobileFabric = null;
 var KNYMetricsService = null;
 kony.setupsdks = function(initConfig, successCallBack, errorCallBack) {
     var dsAppMetaData = null;
     var AppServiceDoc = null;
     var dsAppData;
     var dsAppServiceDoc;
     var serviceDocTimerId = null;
     var getServiceDocNonMFApp = function(initConfig) {
         var serviceDoc = new kony.sdk.serviceDoc();
         serviceDoc.setAppId(initConfig.appConfig.appId);
         serviceDoc.setBaseId(initConfig.appConfig.appId);
         serviceDoc.setAppName(initConfig.appConfig.appName);
         serviceDoc.setReportingService(kony.sdk.constants.reportingType.session, getLicenseUrl(initConfig.appConfig));
         serviceDoc.setReportingService(kony.sdk.constants.reportingType.custom, getMetricsUrl(initConfig.appConfig));
         return serviceDoc.toJSON();
     };
     // Comparing the older etag vs current etag sent by tools, if mismatch considering the service doc from tools is latest.
     if (initConfig.appConfig.svcDoc && initConfig.appConfig.svcDoc.service_doc_etag) {
         var currentToolsEtag = initConfig.appConfig.svcDoc.service_doc_etag;
         var cachedToolsEtag = kony.sdk.dataStore.getItem("tools_etagID");
         if (currentToolsEtag !== cachedToolsEtag) {
             kony.print("New etag set from the app/visulizer");
             kony.sdk.dataStore.setItem("tools_etagID", currentToolsEtag);
             kony.sdk.dataStore.setItem(appConfig.appId + "_mobileFabricServiceDoc", JSON.stringify(initConfig.appConfig.svcDoc));
         }
     }
     dsAppData = kony.sdk.dataStore.getItem(appConfig.appId);
     if (!kony.sdk.isNullOrUndefined(dsAppData)) {
         dsAppMetaData = JSON.parse(dsAppData);
     }
     dsAppServiceDoc = kony.sdk.dataStore.getItem(appConfig.appId + "_mobileFabricServiceDoc");
     if (!kony.sdk.isNullOrUndefined(dsAppServiceDoc)) {
         AppServiceDoc = JSON.parse(dsAppServiceDoc);
     }
     var getLicenseUrl = function(appConfig) {
         var url = "";
         if (appConfig.isturlbase) {
             url = appConfig.isturlbase + "/IST";
         } else if (appConfig.secureurl) {
             url = getFromServerUrl(appConfig.secureurl, "IST");
         } else if (appConfig.url) {
             url = getFromServerUrl(appConfig.url, "IST");
         }
         return url;
     };
     var getMetricsUrl = function(appConfig) {
         var url = "";
         if (appConfig.isturlbase) {
             url = appConfig.isturlbase + "/CMS";
         } else if (appConfig.secureurl) {
             url = getFromServerUrl(appConfig.secureurl, "CMS");
         } else if (appConfig.url) {
             url = getFromServerUrl(appConfig.url, "CMS");
         }
         return url;
     };
     var getFromServerUrl = function(url, path) {
         // ServerURL for non-mf has /mwservlet appended after the context path.
         // We need to remove it to get the base server url
         //url = url.replace(/mwservlet\/*$/i, "");
         //return url + path;
         var newUrl = "";
         var exactSubString = url.match(/mwservlet/i);
         if (exactSubString) {
             var exactSubStringLength = "mwservlet".length;
             var lastSubStringIndex = url.lastIndexOf(exactSubString);
             var subString = url.slice(0, lastSubStringIndex);
             var index = (lastSubStringIndex + exactSubStringLength);
             var subString2 = url.slice(index, url.length);
             var has = /[a-zA-Z0-9]/.test(subString2);
             if (!has) {
                 newUrl = subString;
             } else {
                 newUrl = url;
             }
         } else {
             newUrl = url;
         }
         return newUrl + path;
     };
     var konyAPMSuccessCallBack = function(metricsObject, initConfig) {
         kony.print("Initializing event tracking");
         KNYMetricsService = metricsObject;
         if (KNYMetricsService) {
             KNYMetricsService.setEventTracking(initConfig.eventTypes);
         }
     };
     var initKNYMobileFabric = function(initConfig) {
         KNYMobileFabric = new kony.sdk();
         clientParams = {};
         clientParams.aid = appConfig.appId;
         clientParams.aname = appConfig.appName;
         KNYMobileFabric.setClientParams(clientParams);
     };
     var sdkInit = function(initConfig, successcallback, failurecallback) {
         var isInvalidConfig = false;
         var networkProvider = new konyNetworkProvider();
         if (!kony.sdk.isNullOrUndefined(dsAppMetaData) && !kony.sdk.isNullOrUndefined(dsAppServiceDoc)) {
             if (dsAppMetaData.appId === appConfig.appId && dsAppMetaData.appVersion === appConfig.appVersion) {
                 appConfig.appKey = dsAppMetaData.appKey;
                 appConfig.appSecret = dsAppMetaData.appSecret;
                 appConfig.serviceUrl = dsAppMetaData.serviceUrl;
                 var reportingServiceUrl = dsAppMetaData.licenseUrl;
                 appConfig.isturlbase = reportingServiceUrl.replace("/IST", "");
                 appConfig.svcDoc = AppServiceDoc;
                 sdkInitConfig.appKey = dsAppMetaData.appKey;
                 sdkInitConfig.appSecret = dsAppMetaData.appSecret;
                 sdkInitConfig.serviceUrl = dsAppMetaData.serviceUrl;
             }
         }
         var refreshServiceDoc = function() {
             var networkProvider = new konyNetworkProvider();
             if (!kony.sdk.isNullOrUndefined(dsAppMetaData) && !kony.sdk.isNullOrUndefined(dsAppServiceDoc)) {
                 if (dsAppMetaData.appId === appConfig.appId && dsAppMetaData.appVersion === appConfig.appVersion) {
                     initConfig.appKey = dsAppMetaData.appKey;
                     initConfig.appSecret = dsAppMetaData.appSecret;
                     initConfig.serviceUrl = dsAppMetaData.serviceUrl;
                 }
             }
             var headers = {};
             headers[kony.sdk.constants.APP_KEY_HEADER] = initConfig.appKey;
             headers[kony.sdk.constants.APP_SECRET_HEADER] = initConfig.appSecret;
             networkProvider.get(initConfig.serviceUrl, null, headers, function(data) {
                 kony.sdk.dataStore.setItem(appConfig.appId + "_mobileFabricServiceDoc", JSON.stringify(data));
             }, function(data) {
                 kony.sdk.logsdk.warn("Refresh of serviceDoc failed:" + data);
             });
         };
         if (KNYMobileFabric == null) {
             initKNYMobileFabric(initConfig);
         }
         if (initConfig && initConfig.appConfig && (getLicenseUrl(initConfig.appConfig) === "")) {
             if (kony.license && kony.license.setIsLicenseUrlAvailable) {
                 kony.license.setIsLicenseUrlAvailable(false);
                 kony.sdk.isLicenseUrlAvailable = false;
             }
         }
         if (kony.sdk.isLicenseUrlAvailable && kony.license && kony.license.createSession) {
             kony.license.createSession();
         }
         if (!initConfig.isMFApp) {
             initWithServiceDocHelper(initConfig, successcallback, failurecallback, getServiceDocNonMFApp(initConfig));
         } else {
             if (!initConfig.appConfig.svcDocRefresh) {
                 if (initConfig.appConfig.svcDoc) {
                     initWithServiceDocHelper(initConfig, successcallback, failurecallback, initConfig.appConfig.svcDoc);
                 } else {
                     isInvalidConfig = true;
                 }
             }
             if (isInvalidConfig || initConfig.appConfig.svcDocRefresh) {
                 var cachedServiceDoc = kony.sdk.dataStore.getItem(appConfig.appId + "_mobileFabricServiceDoc");
                 if (cachedServiceDoc) {
                     try {
                         cachedServiceDoc = JSON.parse(cachedServiceDoc);
                     } catch (err) {
                         cachedServiceDoc = "";
                         kony.sdk.logsdk.error("cached service doc corrupted:" + err);
                     }
                 }
                 //Todo: Dead code, remove this refresh service doc logic. (MFSDK-2084)
                 var headers = {};
                 headers[kony.sdk.constants.APP_KEY_HEADER] = initConfig.appKey;
                 headers[kony.sdk.constants.APP_SECRET_HEADER] = initConfig.appSecret;
                 if (initConfig.appConfig.svcDocRefreshTimeSecs && !isInvalidConfig) {
                     if (cachedServiceDoc || initConfig.appConfig.svcDoc) {
                         var offlineServiceDoc = cachedServiceDoc ? cachedServiceDoc : initConfig.appConfig.svcDoc;
                         initWithServiceDocHelper(initConfig, successcallback, failurecallback, offlineServiceDoc);
                         serviceDocTimerId = Date.now().toString();
                         kony.timer.schedule(serviceDocTimerId, refreshServiceDoc, initConfig.appConfig.svcDocRefreshTimeSecs, true);
                     } else {
                         networkProvider.get(initConfig.serviceUrl, null, headers, function(res) {
                             res = kony.sdk.formatSuccessResponse(res);
                             initWithServiceDocHelper(initConfig, successcallback, failurecallback, res);
                         }, function(res) {
                             failurecallback(res);
                         });
                     }
                 } else {
                     networkProvider.get(initConfig.serviceUrl, null, headers, function(res) {
                         res = kony.sdk.formatSuccessResponse(res);
                         initWithServiceDocHelper(initConfig, successcallback, failurecallback, res);
                     }, function(res) {
                         if (cachedServiceDoc || initConfig.appConfig.svcDoc) {
                             var offlineServiceDoc = cachedServiceDoc ? cachedServiceDoc : initConfig.appConfig.svcDoc;
                             initWithServiceDocHelper(initConfig, successcallback, failurecallback, offlineServiceDoc);
                         } else {
                             failurecallback(res);
                         }
                     });
                 }
             }
         }
     };
     var initWithServiceDocHelper = function(initConfig, successcallback, failurecallback, serviceDoc) {
         try {
             if (!kony.sdk.isNullOrUndefined(initConfig) && !kony.sdk.isNullOrUndefined(initConfig["appMetadata"])) {
                 kony.sdk.util.setPackagedMetadata(initConfig["appMetadata"]);
             }
             KNYMobileFabric.initWithServiceDoc(initConfig.appKey, initConfig.appSecret, serviceDoc);
             var MetricsService = null;
             if (kony.sdk.isLicenseUrlAvailable) {
                 MetricsService = KNYMobileFabric.getMetricsService();
             }
             if (initConfig.isMFApp) {
                 konyRef.isAnonymousProvider = true;
             }
             if (successcallback) {
                 successcallback(MetricsService, initConfig);
             }
         } catch (error) {
             if (failurecallback) failurecallback(error);
         }
     };
     /*
      * isMFApp -- boolean to indicate app is being built for MFapp as backend or plain Konyserver
      * appConfig -- set to appConfig of startup.js
      *
      * --MF Parameters--
      * serviceUrl -- mf appconfig url
      * appKey -- set to App Key for MF app scenario
      * appSecret -- set to App Secret for MF app scenario
      *
      * -- For APM --
      * eventTypes -- This should be set to comma separated values chosen in the IDE for events chosen for automatic tracking
      *
      * Examples
      * var sdkInitConfigForMF = {
      *    "isMFApp": true,
           "appConfig" : appconfig,

           "appKey" :"<appkey fetched from MF>",
           "appSecret":"<appsecret fetched from MF>",
           "serviceUrl" : "<appconfig url of the form https://100000013.auth.sit2-konycloud.com/appconfig>",
           "eventTypes" :   ["FormEntry","FormExit","Touch","ServiceRequest","ServiceResponse","Gesture","Orientation","Error","Crash"]
           }
      * var sdkInitConfigForNonMF = {
           "isMFApp": false,
           "appConfig" : appconfig

           "eventTypes" :   ["FormEntry","FormExit","Touch","ServiceRequest","ServiceResponse","Gesture","Orientation","Error","Crash"]
           }
      */
     sdkInit(initConfig, function(metricsObject, initConfig) {
         kony.print("sdk initialization done");
         konyAPMSuccessCallBack(metricsObject, initConfig);
         if (successCallBack) successCallBack(KNYMobileFabric);
     }, function(errorObj) {
         var errorMsg = errorObj ? errorObj.toString() : "";
         kony.print("Error in setup " + errorMsg);
         if (errorCallBack) errorCallBack(errorObj);
     });
 };
 kony.sdk.util = kony.sdk.util || {};

 function konyLogger() {
     this.log = function(text) {
         if (kony.sdk.isDebugEnabled) {
             kony.print(text);
         }
     }
 }
 /**
  * Flag used to override the network availability api for automation testing.
  * @type {boolean}
  */
 overrideNetworkFlag = false;
 /**
  *	Utility Method for the application to check the network availability.
  */
 kony.sdk.isNetworkAvailable = function() {
     //Check the network flag if set for testing. This would mandate the application to be offline if device has network connectivity.
     if (overrideNetworkFlag !== undefined && overrideNetworkFlag !== null && overrideNetworkFlag && overrideNetworkFlag === true) return false;
     return kony.net.isNetworkAvailable(constants.NETWORK_TYPE_ANY);
 };
 /**
  *	Utility method to set the network flag for offline testing.
  */
 kony.sdk.overrideNetworkFlag = function() {
     overrideNetworkFlag = true;
 };
 /**
  *	Utility method to reset the network flag set for offline testing.
  */
 kony.sdk.resetNetworkFlag = function() {
     overrideNetworkFlag = false;
     overrideNetworkFlag = undefined;
 };
 kony.sdk.overrideAnonymousLoginFlag = function() {
     kony.sdk.skipAnonymousCall = true;
 };
 kony.sdk.resetAnonymousLoginFlag = function() {
     kony.sdk.skipAnonymousCall = false;
 };

 function konyNetworkProvider() {
     this.post = function(url, params, headers, successCallback, failureCallback, konyContentType, options) {
         if (kony.sdk.util.isNullOrEmptyString(url)) {
             kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
             return;
         }
         //Appending global params
         if (kony.sdk.isNullOrUndefined(params)) {
             params = {};
         }
         if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
             url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
         }
         konyNetHttpRequest(url, params, headers, "POST", konyContentType, successCallback, failureCallback, options);
     };
     this.put = function(url, params, headers, successCallback, failureCallback, konyContentType, options) {
         if (kony.sdk.util.isNullOrEmptyString(url)) {
             kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
             return;
         }
         //Appending global params
         if (kony.sdk.isNullOrUndefined(params)) {
             params = {};
         }
         if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
             url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
         }
         konyNetHttpRequest(url, params, headers, "PUT", konyContentType, successCallback, failureCallback, options);
     };
     this.invokeDeleteRequest = function(url, params, headers, successCallback, failureCallback, konyContentType, options) {
         if (kony.sdk.util.isNullOrEmptyString(url)) {
             kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
             return;
         }
         //Appending global params
         if (kony.sdk.isNullOrUndefined(params)) {
             params = {};
         }
         if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
             url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
         }
         konyNetHttpRequest(url, params, headers, "DELETE", konyContentType, successCallback, failureCallback, options);
     };
     //postSync will only work for Richclients like Android,IOS
     this.postSync = function(url, params, headers) {
         if (kony.sdk.util.isNullOrEmptyString(url)) {
             kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
             return;
         }
         //Appending global params
         if (kony.sdk.isNullOrUndefined(params)) {
             params = {};
         }
         if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
             url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
         }
         return konyNetHttpRequestSync(url, params, headers);
     };
     this.get = function(url, params, headers, successCallback, failureCallback, konyContentType, options) {
         if (kony.sdk.util.isNullOrEmptyString(url)) {
             kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
             return;
         }
         //Appending global params
         if (kony.sdk.isNullOrUndefined(params)) {
             params = {};
         }
         if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
             url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
         }
         konyNetHttpRequest(url, null, headers, "GET", konyContentType, successCallback, failureCallback, options);
     }
 }

 function konyNetHttpRequest(url, params, headers, httpMethod, konyContentType, successCallback, failureCallback, options) {
     var paramsTable = null;
     var httpRequest;
     if (options && options["httpRequestOptions"] && options["httpRequestOptions"] instanceof Object) {
         httpRequest = new kony.net.HttpRequest(options["httpRequestOptions"]);
     } else {
         httpRequest = new kony.net.HttpRequest();
     }
     if (options && options["responseType"]) {
         httpRequest.responseType = options["responseType"];
     }
     // check for the deprecated property if set in appmiddlewaresecureinvokerasync() API
     if (options && options["httpconfig_old"]) {
         if (options["httpconfig_old"]["timeout"]) {
             httpRequest.timeout = options["httpconfig_old"]["timeout"] * 1000;
         }
     }
     // As older versions of IE doesn't have xmlHttpRequest2, and it doesn't support "withCredentials" property
     // We put a check to handle a crash. Cookies will not be transferred in CORS request for IE due to this restriction
     if (typeof(XMLHttpRequest) !== "undefined" && "withCredentials" in (new XMLHttpRequest()) && options && options["xmlHttpRequestOptions"] && options["xmlHttpRequestOptions"]["enableWithCredentials"] === true) {
         httpRequest.enableWithCredentials = true;
     }
     var isInvalidResponse = false;
     //if httpmethod is not provided falling back to POST
     if (!httpMethod) {
         httpMethod = constants.HTTP_METHOD_POST;
     }
     httpRequest.open(httpMethod, url);

     function localRequestCallback(result) {
         var readyState = Number(httpRequest.readyState.toString());
         var status = Number(httpRequest.status.toString());
         var response = {};
         if (readyState === 4) {
             //If option "passthrough" is enabled then SDK will not parse the result from backend.
             if (options && options[kony.sdk.constants.PASSTHROUGH]) {
                 response.rawResponse = result.response;
             } else {
                 //parseHttpResponse parse response based on the content-type response header
                 var parsedResp = parseHttpResponse(httpRequest);
                 if (parsedResp.isRawResponse) {
                     response.rawResponse = parsedResp.response;
                 } else {
                     response = parsedResp.response;
                 }
                 isInvalidResponse = parsedResp.isInvalidResponse;
             }
             kony.sdk.setLogLevelFromServerResponse(httpRequest.getAllResponseHeaders());
             if (response && !isInvalidResponse) {
                 response.httpresponse = {};
                 response.httpresponse.headers = httpRequest.getAllResponseHeaders();
                 response.httpresponse.url = url;
                 response.httpresponse.responsecode = status;
             }
             if (isInvalidResponse || (!response && status >= 200 && status < 300)) {
                 var errorMessage = {};
                 errorMessage.httpresponse = {};
                 errorMessage[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.invalid_json_code;
                 errorMessage[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.invalid_json_message;
                 errorMessage[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.invalid_json_code;
                 errorMessage[kony.sdk.constants.HTTP_STATUS_CODE] = status;
                 errorMessage.httpresponse["response"] = parsedResp.response;
                 errorMessage.httpresponse.headers = httpRequest.getAllResponseHeaders();
                 errorMessage.httpresponse.url = url;
                 errorMessage.httpresponse.responsecode = status;
                 failureCallback(errorMessage);
             } else if (status >= 200 && status < 300) {
                 if (!response.opstatus) {
                     response.opstatus = 0;
                 }
                 if (response.opstatus == 0 || (response.opstatus >= 500100 && response.opstatus <= 500200)) {
                     if (options && (options[kony.sdk.constants.DISABLE_INTEGRITY] || options[kony.sdk.constants.PASSTHROUGH])) {
                         successCallback(response);
                     } else {
                         if (typeof(konyRef) !== "undefined" && konyRef && konyRef.mainRef.integrityKey === true) {
                             if (response.httpresponse.headers.hasOwnProperty(kony.sdk.constants.INTEGRITY_HEADER) || response.httpresponse.headers.hasOwnProperty(kony.sdk.constants.INTEGRITY_HEADER.toLowerCase())) {
                                 if (!(kony.sdk.isNullOrUndefined(httpRequest.integrityStatus))) {
                                     var integrityStatus = parseInt(httpRequest["integrityStatus"].toString());
                                     switch (integrityStatus) {
                                         case constants.HTTP_INTEGRITY_CHECK_NOT_DONE:
                                             failureCallback(kony.sdk.error.getIntegrityErrorMessage(httpRequest, url));
                                             break;
                                         case constants.HTTP_INTEGRITY_CHECK_SUCCESSFUL:
                                             successCallback(response);
                                             break;
                                         case constants.HTTP_INTEGRITY_CHECK_FAILED:
                                             failureCallback(kony.sdk.error.getIntegrityErrorMessage(httpRequest, url));
                                             break;
                                     }
                                 } else {
                                     failureCallback(kony.sdk.error.getIntegrityErrorMessage(httpRequest, url));
                                 }
                             } else if (options && options != null && options["ignoreintegrity"]) {
                                 successCallback(response);
                             } else {
                                 failureCallback(kony.sdk.error.getIntegrityErrorMessage(httpRequest, url));
                             }
                         } else {
                             successCallback(response);
                         }
                     }
                 } else {
                     failureCallback(response);
                 }
             } else {
                 invokeNetworkErrorCallback(url, httpRequest, response, status);
             }

             function invokeNetworkErrorCallback(url, httpRequest, response, status) {
                 var errorObj = {};
                 errorObj.httpresponse = {};
                 if (status == 408) {
                     errorObj[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.request_timed_out_code;
                     errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.request_timed_out_code;
                     errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.request_timed_out_message;
                 } else if (status == 503) {
                     errorObj[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.service_unavailable;
                     errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.service_unavailable;
                     errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.service_unavailable_message;
                 } else if (response) {
                     errorObj = response;
                 } else {
                     errorObj[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.connectivity_error_code;
                     errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.connectivity_error_code;
                     errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.connectivity_error_message;
                 }
                 errorObj[kony.sdk.constants.HTTP_STATUS_CODE] = status;
                 errorObj.httpresponse.headers = httpRequest.getAllResponseHeaders();
                 errorObj.httpresponse.url = url;
                 failureCallback(errorObj);
             }
         }
     }
     if (konyContentType === "application/json") {
         if (params) {
             paramsTable = JSON.stringify(params);
         }
     } else if (konyContentType == undefined || konyContentType == null || konyContentType != 'formdata') {
         //preparing params for other than object services
         var firstKey = true;
         for (var key in params) {
             if (firstKey) {
                 paramsTable = new kony.net.FormData();
                 firstKey = false;
             }
             if (typeof(params[key]) != "undefined") {
                 if (typeof(params[key]) !== "string") {
                     params[key] = JSON.stringify(params[key]);
                 }
                 paramsTable.append((key), (params[key]));
             }
         }
     } else if (konyContentType == "formdata") {
         //for specific requests like object services we will send formdata through form encoding mechanism.
         if (params) {
             //for object services we are getting kony.net.FormData so using the same.
             paramsTable = params;
         }
     }
     if (headers) {
         for (var key in headers) {
             httpRequest.setRequestHeader(key, headers[key]);
         }
     } else {
         httpRequest.setRequestHeader(kony.sdk.constants.HTTP_CONTENT_HEADER, kony.sdk.constants.CONTENT_TYPE_JSON);
     }
     httpRequest.onReadyStateChange = localRequestCallback;
     if (options && (options[kony.sdk.constants.DISABLE_INTEGRITY] || options[kony.sdk.constants.PASSTHROUGH])) {
         //mesasging service and pass through enabled integration svc doesn't support http message body integrity
         //if integrity is enabled earlier,remove integrity
         //check is for windows 8.x and Kiosk platforms,which doesn't support integrity
         if (kony.sdk.constants.REMOVE_INTEGRITY_CHECK in kony.net) {
             kony.net.removeIntegrityCheck();
         }
         if (paramsTable) {
             httpRequest.send(paramsTable);
         } else {
             httpRequest.send();
         }
     } else {
         if (typeof(konyRef) !== "undefined" && konyRef && konyRef.mainRef.integrityKey === true) {
             var properties = konyRef.mainRef.integrityParams;
             try {
                 //check is for windows 8.x and Kiosk platforms,which doesn't support integrity
                 if (kony.sdk.constants.SET_INTEGRITY_CHECK in kony.net) {
                     kony.net.setIntegrityCheck(properties);
                 }
             } catch (e) {
                 kony.sdk.logsdk.warn("Invalid Integrity properties received");
                 throw "Invalid Integrity properties received";
             }
         } else {
             //check is for windows 8.x and Kiosk platforms,which doesn't support integrity
             if (kony.sdk.constants.REMOVE_INTEGRITY_CHECK in kony.net) {
                 kony.net.removeIntegrityCheck();
             }
         }
         if (paramsTable) {
             httpRequest.send(paramsTable);
         } else {
             httpRequest.send();
         }
     }
 }

 function konyNetHttpRequestSync(url, params, headers) {
     var paramsTable = null;
     var httpRequest = new kony.net.HttpRequest();
     var isInvalidJSON = false;
     httpRequest.open(constants.HTTP_METHOD_POST, url, false);
     var firstKey = true;
     for (var key in params) {
         if (firstKey) {
             paramsTable = new kony.net.FormData();
             firstKey = false;
         }
         if (typeof(params[key]) != "undefined") {
             if (typeof(params[key]) !== "string") {
                 params[key] = JSON.stringify(params[key]);
             }
             paramsTable.append((key), (params[key]));
         }
     }
     if (headers) {
         for (var key in headers) {
             httpRequest.setRequestHeader(key, headers[key]);
         }
     } else {
         httpRequest.setRequestHeader(kony.sdk.constants.HTTP_CONTENT_HEADER, kony.sdk.constants.CONTENT_TYPE_JSON);
     }
     //httpRequest.onReadyStateChange = localRequestCallback;
     httpRequest.send(paramsTable);
     var response = null;
     var status = Number(httpRequest.status.toString());
     kony.sdk.setLogLevelFromServerResponse(httpRequest.getAllResponseHeaders());
     if (httpRequest.response) {
         response = httpRequest.response;
     }
     if (response && typeof(response) === 'string') {
         if (kony.sdk.isJson(response)) {
             response = JSON.parse(response);
         } else {
             isInvalidJSON = true;
         }
     }
     if (response && !(isInvalidJSON)) {
         response.httpresponse = {};
         response.httpresponse.headers = httpRequest.getAllResponseHeaders();
         response.httpresponse.url = url;
         response.httpresponse.responsecode = status;
     }
     if (isInvalidJSON || (!response && status >= 200 && status < 300)) {
         var errorMessage = {};
         errorMessage.httpresponse = {};
         errorMessage[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.invalid_json_code;
         errorMessage[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.invalid_json_message;
         errorMessage[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.invalid_json_code;
         errorMessage[kony.sdk.constants.HTTP_STATUS_CODE] = status;
         errorMessage.httpresponse["response"] = response;
         errorMessage.httpresponse.headers = httpRequest.getAllResponseHeaders();
         errorMessage.httpresponse.url = url;
         errorMessage.httpresponse.responsecode = status;
         return errorMessage;
     } else if (status >= 200 && status < 300) {
         if (!response.opstatus) {
             response.opstatus = 0;
         }
         return response;
     } else {
         var resultTable = {};
         if (response) {
             resultTable = response;
             resultTable.httpStatusCode = httpRequest.status.toString();
         } else {
             resultTable[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.connectivity_error_code;
             resultTable[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.connectivity_error_code;
             resultTable[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.connectivity_error_message;
         }
         return resultTable;
     }
 }

 function konyDataStore() {
     //kony.sdk.logsdk.trace("Setting konyDataStore");
     this.setItem = function(key, value) {
         if (typeof(key) !== "string") {
             throw new Exception(kony.sdk.errorConstants.DATA_STORE_EXCEPTION, "Invalid Key");
         } else {
             try {
                 key = key.replace(/\//gi, "");
                 kony.store.setItem(key, value);
             } catch (e) {
                 kony.sdk.logsdk.error("Failed to set item in dtastore:" + e);
             }
         }
     };
     this.getItem = function(key) {
         kony.sdk.logsdk.debug("Getting item for key:" + key);
         if (typeof(key) !== "string") {
             throw new Exception(kony.sdk.errorConstants.DATA_STORE_EXCEPTION);
         } else {
             key = key.replace(/\//gi, "");
             var value = kony.store.getItem(key);
             if (value === null || value === undefined) {
                 kony.sdk.logsdk.debug("No value found with key:" + key);
                 return null;
             } else {
                 return value;
             }
         }
     };
     this.removeItem = function(key) {
         kony.sdk.logsdk.debug("Removing item for key:" + key);
         if (typeof(key) !== "string") {
             throw new Exception(Error.DATA_STORE_EXCEPTION);
         } else {
             key = key.replace(/\//gi, "");
             kony.store.removeItem(key); //If no item with that key exists, the method does not perform any action. Thus no need to check for key availablity.
         }
     };
     this.destroy = function() {
         kony.sdk.logsdk.info("Destroying data store for this app");
         kony.store.clear();
     };
     this.getAllItems = function() {
         kony.sdk.logsdk.info("Getting all item from data store");
         var items = {};
         var len = kony.store.length(); //get key length
         for (var i = 0; i < len; i++) {
             var key = kony.store.key(i); //get ith key
             var value = kony.store.getItem(key); //get value
             items[key] = value; //prepare itemset
         }
         return items;
     }
 }

 function parseHttpResponse(httpRequest) {
     var isInvalidResponse = false;
     var isJsonResponse = false;
     var parsedResponse = {};
     parsedResponse.isRawResponse = false;
     var value = "";
     var response = null;
     if (kony.sdk.isNullOrUndefined(httpRequest) || kony.sdk.isNullOrUndefined(httpRequest.response)) {
         kony.sdk.logsdk.warn("parseHttpResponse :: Null or Invalid response received");
     } else if (httpRequest.responseType && httpRequest.responseType === "blob") {
         parsedResponse.response = httpRequest.response;
         parsedResponse.isRawResponse = true;
     } else {
         response = kony.sdk.cloneObject(httpRequest.response);
         kony.sdk.logsdk.debug("parseHttpResponse :: Network response :", response);
         //Defaulting to JSON format
         if (kony.sdk.util.isJsonObject(response)) {
             parsedResponse.response = response;
             isJsonResponse = true;
         } else if (kony.sdk.util.isValidString(response)) {
             if (kony.sdk.isJson(response)) {
                 parsedResponse.response = JSON.parse(response);
                 isJsonResponse = true;
             }
         }
         //Handling when response is not json
         if (!isJsonResponse) {
             if (kony.sdk.util.isValidString(httpRequest.response)) {
                 parsedResponse.response = response;
             } else {
                 parsedResponse.response = httpRequest.response;
             }
             var lowerCaseHeaders = kony.sdk.util.convertJsonKeysToLowerCase(httpRequest.getAllResponseHeaders());
             //value variable contains response header in lower case
             if (!kony.sdk.isNullOrUndefined(lowerCaseHeaders)) {
                 value = lowerCaseHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER.trim().toLowerCase()];
             } else {
                 kony.sdk.logsdk.warn("parseHttpResponse :: received null response headers  " + lowerCaseHeaders);
             }
             kony.sdk.logsdk.warn("parseHttpResponse :: content-type of response " + value);
             //MFSDK-3525 Adding an additional check to see if content type is present.
             if (kony.sdk.util.isValidString(value) && value.startsWith(kony.sdk.constants.CONTENT_TYPE_JSON)) {
                 kony.sdk.logsdk.warn("parseHttpResponse :: Unhandled content received for content-type application/json");
                 isInvalidResponse = true;
             } else {
                 parsedResponse.isRawResponse = true;
             }
         }
     }
     parsedResponse.isInvalidResponse = isInvalidResponse;
     return parsedResponse;
 }
 kony.sdk.getSdkType = function() {
     return kony.sdk.constants.SDK_TYPE_IDE;
 };
 kony.sdk.getPayload = function(konyRef) {
     var payload = {};
     payload.os = kony.os.deviceInfo().version + "";
     payload.dm = kony.os.deviceInfo().model;
     payload.did = kony.sdk.getDeviceId();
     payload.ua = kony.os.userAgent();
     if (appConfig) {
         payload.aid = appConfig.appId;
         payload.aname = appConfig.appName;
     } else {
         var clientParams = konyRef.getClientParams();
         payload.aid = clientParams.aid ? clientParams.aid : konyRef.mainRef.baseId;
         payload.aname = clientParams.aname ? clientParams.aname : konyRef.mainRef.name;
     }
     payload.chnl = kony.sdk.getChannelType();
     payload.plat = kony.sdk.getPlatformName();
     if (payload.plat === kony.sdk.constants.PLATFORM_IOS && kony.os.deviceInfo().name !== kony.sdk.constants.PLATFORM_SPA) {
         payload.did = getDeviceIdForIOSPlatform();
     }
     if (payload.plat === kony.sdk.constants.PLATFORM_IOS && payload.dm.toLowerCase().indexOf("ipod") !== -1) {
         payload.chnl = "ipod";
     }
     payload.aver = appConfig.appVersion;
     payload.atype = kony.sdk.getAType();
     payload.stype = "b2c";
     payload.kuid = konyRef.getUserId();
     payload.mfaid = konyRef.mainRef.appId;
     payload.mfbaseid = konyRef.mainRef.baseId;
     payload.mfaname = konyRef.mainRef.name;
     payload.sdkversion = kony.sdk.version;
     payload.sdktype = kony.sdk.getSdkType();
     if (kony.application.getCurrentForm()) {
         var fid = kony.application.getCurrentForm().id;
         if (fid) {
             payload.fid = fid;
         }
     }
     payload.sessiontype = kony.sdk.util.getSessionType();
     return payload;
 };
 /**
  * Returns unique identifier for a device.
  * In case of Android & Windows the API kony.os.deviceInfo().deviceid is guaranteed to provide unique identifier for a device.
  * In case of iOS the API kony.os.deviceInfo().identifierForVendor is guaranteed to provide unique key per vendor.
  * A different value is returned for apps on the same device that come from different vendors, and for apps on different devices regardless of vendor
  * @return {string}
  */
 kony.sdk.getDeviceId = function() {
     var name = kony.os.deviceInfo().name;
     if (name === kony.sdk.constants.PLATFORM_SPA) {
         var deviceID = kony.ds.read(kony.sdk.constants.KEY_DEVICE_ID);
         if (!deviceID) {
             deviceID = kony.license.generateUUID().toString();
             kony.ds.save(deviceID, kony.sdk.constants.KEY_DEVICE_ID);
         }
         return deviceID;
     } else {
         // For Android & Windows platforms.
         return kony.os.deviceInfo().deviceid;
     }
 };
 kony.sdk.getChannelType = function() {
     var returnVal = "";
     returnVal = "mobile";
     return returnVal;
 };
 kony.sdk.getPlatformName = function() {
     var returnVal = "";
     returnVal = kony.sdk.constants.PLATFORM_ANDROID;
     return returnVal;
 };
 kony.sdk.util.createSessionAndSendIST = function() {
     kony.license.createSession();
     kony.license.captureKonyLicenseUsage(true);
 }
 kony.mbaas.invokeMbaasServiceFromKonyStudio = function(url, inputParam, serviceID, operationID, callBack, infoObject) {
     var currentInstance = kony.sdk.getCurrentInstance();
     if (!currentInstance) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + "this service.");
     }
     var integrationService = currentInstance.getIntegrationService(serviceID);
     var options = {};
     if (inputParam && inputParam["httpconfig"]) {
         options["httpconfig_old"] = inputParam["httpconfig"];
         delete inputParam["httpconfig"];
     }
     if (inputParam && inputParam["httpRequestOptions"] && inputParam["httpRequestOptions"] instanceof Object) {
         options["httpRequestOptions"] = inputParam["httpRequestOptions"];
         delete inputParam["httpRequestOptions"];
     }
     var headers = null;
     if (inputParam && inputParam["httpheaders"]) {
         headers = inputParam["httpheaders"];
         delete inputParam["httpheaders"];
     }
     integrationService.invokeOperation(operationID, headers, inputParam, function(res) {
         if (typeof(callBack) === 'function') {
             callBack(400, res, infoObject);
         }
     }, function(res) {
         if (typeof(callBack) === 'function') {
             callBack(400, res, infoObject);
         }
     }, options);
 };
 kony.mbaas.invokeMbaasServiceFromKonyStudioSync = function(url, inputParam, serviceID, operationID) {
     var currentInstance = kony.sdk.getCurrentInstance();
     if (!currentInstance) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + "this service.");
     }
     var integrationService = currentInstance.getIntegrationService(serviceID);
     var headers = null;
     if (inputParam && inputParam["httpheaders"]) {
         headers = inputParam["httpheaders"];
         delete inputParam["httpheaders"];
     }
     return integrationService.invokeOperationSync(operationID, headers, inputParam);
 };
 kony.mbaas.invokeMbaasServiceFromKonyStudioAsync = function(url, inputParam, serviceID, operationID, callBack, info) {
     kony.mbaas.invokeMbaasServiceFromKonyStudio(url, inputParam, serviceID, operationID, callBack, info);
 };

 function getDeviceIdForIOSPlatform() {
     if (kony.os.deviceInfo().osversion >= 6.0) {
         return kony.os.deviceInfo().identifierForVendor;
     }
     return kony.os.deviceInfo().customdeviceid;
 }
 //Helps to prepare the input wrapped into kony.net.FormData
 kony.sdk.getFormData = function(payload) {
     var formData = new kony.net.FormData();
     formData.append(kony.sdk.constants.JSON_DATA, JSON.stringify(payload));
     return formData;
 };
 //Helps to update prepare the input wrapped into kony.net.FormData
 kony.sdk.updateFormData = function(formData, key, value) {
     formData.append(key, JSON.stringify(value));
     return formData;
 };
 //Helps to get the atype for Spa and DesktopWeb applications it would be kony.sdk.constants.SDK_ATYPE_SPA ,for android wear applications it would be "watch" and remaining it would be "native"
 kony.sdk.getAType = function() {
     var returnVal = kony.sdk.constants.SDK_ATYPE_NATIVE;
     returnVal = kony.sdk.constants.SDK_ATYPE_SPA;
     return returnVal;
 };
 kony.sdk.setLicenseCall = function(appKey, appSecret, data) {
     //checking if new MF app is connected
     var reportingServiceUrl = data.reportingsvc.session;
     if (typeof(appConfig) != "undefined") {
         if ((appKey === appConfig.appKey) && (appSecret === appConfig.appSecret) && (typeof(appConfig.svcDoc) !== "undefined" && reportingServiceUrl === appConfig.svcDoc.reportingsvc.session)) {
             return; //user is doing init on same environment and same MF-app
         } else {
             appConfig.isturlbase = reportingServiceUrl.replace("/IST", "");
             appConfig.appKey = appKey;
             appConfig.appSecret = appSecret;
             appConfig.serviceUrl = data.selflink;
             appConfig.svcDoc = data;
             // IST is triggered with new sid and new MF app on the same or different IST server based on how isturlbase is populated
             kony.sdk.util.createSessionAndSendIST();
         }
     }
 };
 kony.sdk.saveMetadatainDs = function(appKey, appSecret, servConfig) {
     // Saving App metadata in storage for Persistence.
     kony.sdk.isLicenseUrlAvailable = true;
     var appId = {
         "appKey": appKey,
         "appSecret": appSecret,
         "serviceUrl": servConfig.selflink,
         "appVersion": appConfig.appVersion,
         "licenseUrl": servConfig.reportingsvc.session
     };
     if (typeof(sdkInitConfig) !== "undefined") {
         sdkInitConfig.appKey = appKey;
         sdkInitConfig.appSecret = appSecret;
         sdkInitConfig.serviceUrl = servConfig.selflink;
     }
     kony.sdk.dataStore.setItem(appConfig.appId + "_mobileFabricServiceDoc", JSON.stringify(servConfig));
     kony.sdk.dataStore.setItem(appConfig.appId, JSON.stringify(appId));
 };
 kony.sdk.deleteMetadatafromDs = function() {
     kony.sdk.dataStore.removeItem(appConfig.appId);
 };
 /**
  * Validates the deeplink params. A valid deeplink redirection will contain params "code" & "launchmode" is 3.
  * @param {map} params  - query parameters from the deeplink redirection
  */
 kony.sdk.isValidDeeplinkCallback = function(params) {
     if (params && params.launchmode == kony.sdk.constants.LAUNCHMODE_DEEPLINK && params.launchparams.code) return true;
     else return false;
 };
 kony.sdk.getReportingParamsForOfflineObjects = function() {
     var reportingData = kony.sdk.getPayload(konyRef);
     reportingData.xmode = "offline";
     reportingData.rsid = kony.sdk.currentInstance.getSessionId();
     return JSON.stringify(reportingData);
 };
 var MFAppVersion;
 kony.sdk.setFabricAppVersion = function(version) {
     MFAppVersion = version;
 };
 /**
  * Returns the SSO token for the provider.
  *
  * @return SSO token
  */
 kony.sdk.util.getSSOTokenForProvider = function(_providerName) {
     kony.sdk.logsdk.trace("### kony.sdk.util.getSSOTokenForProvider:: Entered Method.");
     var tokenString = kony.sdk.util.getSSOToken();
     if (kony.sdk.util.isNullOrEmptyString(tokenString)) {
         kony.sdk.logsdk.warn("### kony.sdk.util.getSSOTokenForProvider:: SSO token is either empty,null or undefined for provider:" + _providerName);
         return null;
     }
     var tokenJSON = JSON.parse(tokenString);
     return tokenJSON[_providerName.toLowerCase()];
 };
 /**
  * Add/Replace and Returns the stringified SSO JSON with
  * the new token and provider or
  * updates the existing one.
  *
  * @return  Stringified SSO token JSON"{*}"
  */
 kony.sdk.util.addOrUpdateSSOTokenWithProvider = function(ssoToken, _providerName) {
     kony.sdk.logsdk.trace("### kony.sdk.util.addOrUpdateSSOTokenWithProvider:: Entered Method.");
     var tokenJSON = {};
     var tokenString = kony.sdk.util.getSSOToken();
     if (!kony.sdk.util.isNullOrEmptyString(tokenString)) {
         tokenJSON = JSON.parse(tokenString);
     }
     tokenJSON[_providerName.toLowerCase()] = ssoToken;
     return JSON.stringify(tokenJSON);
 };
 /**
  * Deletes the SSO Token for the
  * provider passed
  */
 kony.sdk.util.deleteSSOTokenForProvider = function(_providerName) {
     kony.sdk.logsdk.trace("### kony.sdk.util.deleteSSOTokenForProvider:: Entered Method.");
     var tokenString = kony.sdk.util.getSSOToken();
     if (kony.sdk.util.isNullOrEmptyString(tokenString)) {
         kony.sdk.logsdk.warn("### kony.sdk.util.getSSOTokenForProvider:: SSO token is either empty,null or undefined for provider:" + _providerName);
         return null;
     }
     var tokenJSON = JSON.parse(tokenString);
     delete tokenJSON[_providerName.toLowerCase()];
     kony.sdk.util.saveSSOToken(JSON.stringify(tokenJSON));
 };
 /**
  * Returns the default fabric application version. For auto init app version will be available in appConfig,
  * for manual init developer has to send fabric version explicitly.
  *
  * Fabric version in manual init has more priority over one specified in visualizer.
  * @return {*}
  */
 kony.sdk.getFabricAppVersion = function() {
     if (!kony.sdk.isNullOrUndefined(MFAppVersion)) {
         return MFAppVersion;
     } else if (!kony.sdk.isNullOrUndefined(appConfig) && !kony.sdk.isNullOrUndefined(appConfig.runtimeAppVersion)) {
         return appConfig.runtimeAppVersion;
     }
 };
 /**
  * Generates key to encrypt/decrypt any text.
  * @param salt {Array}
  * @returns string
  */
 kony.sdk.generateSecureKeyFromText = function(salt) {
     var secureKey = "";
     if (!kony.sdk.isNullOrUndefined(salt) && kony.sdk.isArray(salt)) {
         secureKey = kony.crypto.newKey("passphrase", 128, {
             passphrasetext: salt,
             subalgo: "aes",
             passphrasehashalgo: "md5"
         });
     } else {
         throw new Exception(kony.sdk.errorConstants.CONFIGURATION_FAILURE, "Invalid param. salt cannot be null, should be of type Array");
     }
     return secureKey;
 };
 /**
  * Encrypts text with the given salt and encryptionAlgo.
  * @param text {string}
  * @param salt {Array}
  * @param encryptionAlgo {text}
  * @returns {string}
  */
 kony.sdk.encryptText = function(text, salt, encryptionAlgo) {
     var encryptionKey = kony.sdk.generateSecureKeyFromText(salt);
     var encryptedText = kony.crypto.encrypt(encryptionAlgo, encryptionKey, text, {});
     return kony.convertToBase64(encryptedText);
 };
 /**
  * Decrypts text with the given salt and encryptionAlgo.
  * @param text {string}
  * @param salt {Array}
  * @param encryptionAlgo {text}
  * @returns {string}
  */
 kony.sdk.decryptText = function(text, salt, decryptionAlgo) {
     var decryptionKey = kony.sdk.generateSecureKeyFromText(salt);
     var rawText = kony.convertToRawBytes(text)
     return kony.crypto.decrypt(decryptionAlgo, decryptionKey, rawText, {});
 };
 /**
  * Returns type of object
  * framework api kony.type is not supported by Phonegap and plain-js platforms
  * @return {*}
  */
 kony.sdk.util.type = function(objectVar) {
     if (kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_NATIVE) {
         return kony.type(objectVar)
     } else {
         return typeof(objectVar)
     }
 };
//FP Appended konylibrary.js-----------------------------------------------------------

	kony.decrement = function(num){
		if(typeof(num) === "number"){
			return num - 1;
		}else{
			return num;
		}
	};
	
	kony.increment = function(num){
		if(typeof(num) === "number"){
			return num + 1;
		}else{
			return num;
		}
	};

	kony.decrementIndices = function(arr){
		var tArr = [];
		for(var i=0; i < arr.length; i++) {
			tArr[i] = arr[i] - 1;		
		}
		return tArr;
	};
	
	kony.incrementIndices = function(arr){
		var tArr = [];
		for(var i=0; i < arr.length; i++) {
			tArr[i] = arr[i] + 1;		
		}
		return tArr;
	};	
/**The Math Library has APIs that you can use to perform mathematical operations.*/
kony.math = {
	/**@Deprecated. This API returns the value of pi. Note: math.pi is not a function, but a property in math namespace.*/
	pi: Math.PI,

	/**@Deprecated. This API generates pseudo-random numbers which are uniformly distributed. This API generates a real number between 0 and 1.*/
	random: function () {
		
		return (Math.random());
		/*var result = Math.random();
	
		if (0 === args.length) {
			return result;
		} else if (1 === args.length) {
			args[0] -= 0;
			if (isNaN(args[0])) {
				throw new Error("Invalid argument to math.random");
			}
	
			result = Math.floor(result * args[0]) + 1;
		} else if (2 === args.length) {
			args[0] -= 0; args[1] -= 0;
			if (isNaN(args[0]) || isNaN(args[1])) {
				throw new Error("Invalid argument(s) to math.random");
			}
	
			result = Math.floor(result * (args[1] - args[0] + 1)) + args[0];
		} else {
			throw new Error("Invalid number of arguments to math.random");
		}
	
		return result;*/
	},
	
	/*
	randomseed: function (args) {
		return null;
	},
	*/
/**@Deprecated. This API sets the input parameter as the "seed" for the pseudo-random generator.
Note: Equal seeds produce equal sequences of numbers.*/
	randomSeed: function (num) {
		pseudoRandomArray = [];
	
		if (isNaN(num))
			throw new Error("Invalid argument to math.randomseed");
		
		if(!pseudoRandomArray[num])
		{
			pseudoRandomArray[num] = Math.random();
		}
		return pseudoRandomArray[num];
	},
/**@Deprecated. This API converts the float value to an integer. The converted integer value is always the integer part of the specified float number (number before the decimal).*/
	toInteger: function (num) {
		num -= 0;
		if (isNaN(num)) {
			throw new Error("Invalid argument to math.tointeger");
		}
	
		return Math.floor(num);
	},
	
	/**@Deprecated. This API raises the first parameter to the power of the second parameter and returns the result.*/
	pow: function (num1, num2) {
		
		num1 -= 0;
		num2 -= 0;
		
		if (isNaN(num1) || isNaN(num2)) {
			throw new Error("Invalid argument(s) to math.pow");
		}
	
		return Math.pow(num1, num2);
	},

		findExtreme: function(extreme, args) {
		if (args.length < 2) {
			throw new Error((extreme ? "math.max" : "math.min") + " needs atleast two arguments");
		}
	
		var result = args[0] - 0;
		if (isNaN(result)) {
			throw new Error("Invalid argument to " + (extreme ? "math.max" : "math.min"));
		}
	
		for (var i = 1; i < args.length; i++) {
			args[i] -= 0;
			if (isNaN(args[i])) {
				throw new Error("Invalid argument to " + (extreme ? "math.max" : "math.min"));
			}
	
			if (extreme) {
				if (result < args[i]) {
					result = args[i];
				}
			} else {
				if (result > args[i]) {
					result = args[i];
				}
			}
		}
	
		return result;
	},

	/**@Deprecated. This API returns the minimum value among the arguments.*/
	min: function () {
		return kony.math.findExtreme(false, arguments);
	},

	/**@Deprecated. This API returns the maximum value among the arguments.*/
	max: function () {
		return kony.math.findExtreme(true, arguments);
	},

	/**@Deprecated. This API returns the square root of the given number.*/
	sqrt: function (num) {
		
		num -= 0;
		if (isNaN(num)) {
			throw new Error("Invalid argument to math.sqrt");
		}
		var result = Math.sqrt(num);
		return isNaN(result) ? "nan" : result;
	}
}

/**The string Library has APIs that you can use to manipulate strings. The kony.string name space provides static string APIs. These static APIs augment the APIs in the Global string object which is available by default. For more information refer, https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/string.*/
kony.string = {

/**@Deprecated This API finds the first occurrence of the search string in the source string. */
    find : function () {
		if (arguments.length < 2) {
			throw new Error("string.find needs atleast two arguments");
		}
	
		for (var i = 0; i < 2; i++) {
			if (typeof(arguments[i]) === "number") {
				arguments[i] = arguments[i].toString();
			} else if (typeof(arguments[i]) !== "string") {
				throw new Error("Invalid argument(s) to string.find");
			}
		}
	
		var beginIndex = 0;
		if (arguments.length > 2) {
			beginIndex = arguments[2] - 0;
			if (!isNaN(beginIndex)) {
				if (beginIndex < 0) {
					beginIndex += arguments[0].length;
					if (beginIndex < 0) beginIndex = 0;
				}
			} else {
				beginIndex = 0;
			}
		}
	
		var result = arguments[0].indexOf(arguments[1], beginIndex - 1);
		if (-1 === result) {
			return null;
		} else {
			////result++;
			//return result, result + arguments[1].length - 1;
			return result;
		}
	},
	
	/**@Deprecated This API returns the length of the source string. */
	len: function (s) {
		if (0 === arguments.length) {
			throw new Error("string.len needs atleast one argument");
		}
		
		if (typeof(s) === "number") {
			s = s.toString();
		} else if (typeof(s) !== "string") {
			throw new Error("Invalid argument to string.len");
		}

		return arguments[0].length;
    },

	/**@Deprecated This API compares the contents of two strings numerically. For example, "Adam" is smaller than "adam" as per the ASCII table because A(65) is smaller than a(97). */
    compare: function (s1, s2) {
		if (arguments.length < 2) {
			throw new Error("string.compare needs atleast two arguemnts");
		}
			
		if (typeof(s1) == "string" && typeof(s2) == "string") {
			if (s1 < s2) {
				return -1;
			} else if (s1 == s2) {
				return 0;
			} else {
				return 1;
			}
		} else {
			throw new Error("Invalid argument(s) to string.compare");
		}
    },

    /**@Deprecated This API returns a string which contains a single character from the source string at the specified index. */
	charat: function (s1, index) {
		if (arguments.length < 2) {
			throw new Error("string.charat needs atleast two arguments");
		}
	
		if (typeof(s1) === "number") {
			s1 = s1.toString();
		} else if (typeof(s1) !== "string") {
			throw new Error("Invalid argument to string.charat");
		}
	
		index -= 0;
		if (isNaN(index)) {
			throw new Error("Invalid argument to string.charat");
		}
	
		////index--;
		if (index < 0 || index >= s1.length) {
			return null;
		}
	
		return s1.charAt(index);
    },

    flipCase: function(args, flag) {
	    if (0 === args.length) {
	            throw new Error(flag ? "string.upper" : "string.lower" + " needs atleast one argument");
	    }
	
	    if (typeof(args[0]) !== "string") {
	            throw new Error("Invalid argment to " + flag ? "string.upper" : "string.lower");
	    }
	
	    if (flag) {
	            return args[0].toUpperCase();
	    } else {
	            return args[0].toLowerCase();
	    }
    },
	/**@Deprecated This API changes the upper case characters of the source string to lower case characters. */
	lower: function () {
		return kony.string.flipCase(arguments, false);
	},
/**@Deprecated This API changes the lower case characters of the source string to upper case characters.*/
	upper: function () {
		return kony.string.flipCase(arguments, true);
	},

	/**This API generates a string which is equivalent to "n copies of the source string concatenated together".*/
	rep: function (s,n) {
		if (arguments.length < 2) {
			throw new Error("Insufficient arguments to string.rep");
		}
	
		if (typeof(s) === "number") {
			s = s.toString();
		} else if (typeof(s) !== "string") {
			throw new Error("Invalid argument to string.rep");
		}
	
		n -= 0;
		if (isNaN(n)) {
			throw new Error("Invalid argument to string.rep");
		}
	
		var resultStr = "";
		for (var i = 0; i < n; i++) {
			resultStr += s;
		}
	
		return resultStr;
	},
	
	/**This API reverses the characters in the source string.*/
	reverse: function (s) {
		if (0 === arguments.length) {
			throw new Error("string.reverse needs atleast one argument");
		}
	
		if (typeof(s) === "number") {
			s = s.toString();
		} else if (typeof(s) !== "string") {
			throw new Error("Invalid argument to string.reverse");
		}
	
		var resultStr = "";
		for (var i = s.length - 1; i >= 0; i--) {
			resultStr += s.charAt(i);
		}
	
		return resultStr;
	},
	/**This API removes the leading and ending spaces from the source string.*/
	trim: function (s) {
        if (0 === arguments.length) {
              throw new Error("string.trim needs atleast one argument");
        }

        if(s === undefined) {
              return s;
        }    
        else if (typeof(s) !== "string") {
              return s.toString();
              //throw new Error("Invalid argument to string.trim");
        }
 
        return s.replace(/^\s*/, "").replace(/\s*$/, "");
  },
	/**Determines whether two strings contain the same data, ignoring the case of the letters in the String. */
	equalsIgnoreCase: function (s1, s2) {
		if (arguments.length < 2) {
			throw new Error("string.equalsIgnoreCase needs atleast two arguments");
		}
	
		if (typeof(s1) !== "string" || typeof(s2) !== "string") {
			throw new Error("Invalid argument(s) to string.equalsIgnoreCase");
		}
	
	    return (s1.toLowerCase() === s2.toLowerCase());
	},
	
	equals: function (s1, s2) {
		if (arguments.length < 2) {
			throw new Error("string.equals needs atleast two arguments");
		}
	
		if (typeof(s1) !== "string" || typeof(s2) !== "string") {
			throw new Error("Invalid argument(s) to string.equals");
		}
	
		return (s1 === s2);
	},
	
	matchEnds: function (args, end) {
		if (args.length < 2) {
			throw new Error(end ? "string.endsWith" : "string.startsWith" +
									" needs atleast two arguments");
		}
	
		if (typeof(args[0]) !== "string" || typeof(args[1]) !== "string") {
			throw new Error("Invalid argument(s) to " + end ? "string.endsWith" : "string.startsWith");
		}
	
		if (!(args.length > 2 && (args[2] === false || args[2] === null))) {
			args[0] = args[0].toLowerCase();
			args[1] = args[1].toLowerCase();
		}
	
	    if (end) {
	    	var ll = args[0].lastIndexOf(args[1]);
	    	if(ll < 0){
	    		return false;
	    	}else{
	        	return (args[0].lastIndexOf(args[1]) === args[0].length - args[1].length);
	        }
	    }
	    else {
	        return (args[0].indexOf(args[1]) === 0);
	    }
	},
	/**This API returns a boolean value indicating if the source string begins with the specified string. */
	startsWith: function (sourcestring, comparestring, ignorecase) {
		return kony.string.matchEnds(arguments, false);
	},
	/**This API returns a boolean value indicating if the source string ends with the specified string. */
	endsWith: function (sourcestring, comparestring, ignorecase) {
		return kony.string.matchEnds(arguments, true);
	},
	/**@Deprecated This API splits the source string based on the separator (default is comma) and returns a table containing the string. */
	split: function (s, sep) {
		if (0 === arguments.length) {
			throw new Error("string.split needs atleast one argument");
		}
	
		if (typeof(s) !== "string") {
			throw new Error("Invalid argument to string.split");
		}
	
		var delim;
		if (arguments.length > 1) {
			if (typeof(sep) !== "string") {
				throw new Error("The optional delimitor for string.split must be a string");
			}
	
			delim = sep;
		} else {
			delim = ",";
		}
		
		var splitstr = new Array();
		
		if(delim == "") {
			splitstr[1] = s;
		} else {
			splitstr = s.split(delim);
			splitstr.unshift(null); //To match lua Array indexing.
		}
		return splitstr;
	},
	/**@Deprecated This API returns the substring of the source string. */
	sub: function () {
		function getIndex(i, len) {
			if (typeof(i) === "string") {
				i -= 0;
			} else if (typeof(i) !== "number") {
				throw new Error("Invalid argument to string.sub");
			}
	
			if (i < 0) {
				////return (i + len + 1);
				return( i + len - 1);
			} else if (i > len) {
				return len;
			}
	
			return i;
		}
	
		function adjustIndex(i) {
			if (i > 0) {
				return i - 1;
			} else {
				return 0;
			}
		}
	
		if (arguments.length < 2) {
			throw new Error("string.sub needs atleast two arguments");
		}
		
		var args = [];
		for(var i=0; i < arguments.length; i++) {
			args[i] = arguments[i];		
		}
	
		if (typeof(args[0]) === "number") {
			args[0] = args[0].toString();
		} else if (typeof(args[0]) !== "string") {
			throw new Error("Invalid argument to string.sub");
		}
	
		var startIndex = getIndex(args[1], args[0].length);
		var endIndex = args[0].length;
		if (args.length > 2) {
			endIndex = getIndex(args[2], args[0].length);
		}
	
		if (endIndex < startIndex || (0 === startIndex && endIndex === startIndex)) {
			return "";
		} else {
			////startIndex = adjustIndex(startIndex); endIndex = adjustIndex(endIndex);
			return args[0].slice(startIndex, endIndex + 1);
		}
	},
	/**@Deprecated This API finds and replaces the occurrences of a string in the source string with a string you specify. */
	replace: function (s, f, rep) {
		if (arguments.length < 3) {
			throw new Error("string.replace needs atleast three arguments");
		}
	
		if (typeof(s) !== "string" || typeof(f) !== "string" ||
			typeof(rep) !== "string") {
			throw new Error("Invalid argument(s) to string.replace");
		}
	
		//return [s.replace(f, rep)];
	
		// Replace all occurrences
	    //var exp1 = new RegExp(f, "g");
		var exp1 = new RegExp(kony.string.escapeRegExp(f), "g");
	    return (s != "" && f == "") ? s : s.replace(exp1, rep);
	},
	/*
	format: function (args) {
		if (0 === args.length) {
			throw new Error("string.format needs atleast one argument");
		}
	
		if (typeof(args[0]) === "number") {
			return args[0].toString();
		} else if (typeof(args[0]) === "string") {
			var toks = args[0].split(/(%[f,s,b])/);
	
			var flag = false;
			var result = "";
			for (var i = 0, j = 1; i < toks.length; i++) {
				if ("%f" === toks[i] || "%s" === toks[i] || "%b" === toks[i]) {
					if (j === args.length) {
						throw new Error("Insufficient number of arguments to string.format");
					}
	
					if ("%f" === toks[i]) {
						var num = args[j] - 0;
	
						if (isNaN(num)) {
							throw new Error("Invalid argument to string.format");
						}
	
						result += num;
					} else if ("%s" === toks[i]) {
						result += args[j].toString();
					} else if ("%b" === toks[i]) {
						if (args[j] === false || args[j] === null) {
							result += "false";
						} else {
							result += "true";
						}
					}
	
					j++;
				} else {
					result += toks[i];
				}
			}
	
			return result;
		} else {
			throw new Error("Invalid first argument to string.format");
		}
	}, */
	/** This API verifies if the input string contains only ASCII alphabet characters and returns a boolean value. */
	isAsciiAlpha: function (s) {
	
		if (arguments.length === 0) {
			throw new Error("string.isAsciiAlpha needs atleast 1 argument");
		}
	
		if (typeof(s) !== "string") {
			throw new Error("Invalid argument(s) to string.isAsciiAlpha");
		}
	
		var regexp = new RegExp("[^a-zA-Z]","g");
	    return (s == "") ? false : !(regexp.test(s));	
	},
	/** This API verifies if the input string contains only ASCII alphabet characters and numbers, and returns a boolean value.*/
	isAsciiAlphaNumeric: function (str) {
	
		if (arguments.length === 0) {
			throw new Error("string.isAsciiAlphaNumeric needs atleast 1 argument");
		}
		var p1 = /[^a-zA-Z0-9]/i;	// Elimimate non alpha numeric chars //Added cap letters also 
		var p2 = /^[a-zA-Z0-9]*$/i; /* Wrong regex   /([a-z]+[0-9])|([0-9]+[a-z])/i; */
		var r1 = str.match(p1);
		var r2 = str.match(p2);	
		return (!r1 && r2 && str) ? true : false;	
	},
	
	/** This API verifies if the input string contains only numeric characters, and returns a boolean value.*/
	isNumeric: function (s) {
		if (arguments.length === 0) {
			throw new Error("string.isNumeric needs atleast 1 argument");
		}
	
		/*if (typeof(args[0]) !== "string") {
			throw new Error("Invalid argument(s) to string.isNumeric");
		}*/
	
	    return (s == "" || (typeof(s) == "string" && s.replace(/\s/g,'').length == 0)) ? false : !(isNaN(s));
	},
	/** This API verifies if any one of the specified set of characters is available in the given string and returns a boolean value.*/
	containsChars: function (s, a) {
		if (arguments.length === 0) {
			throw new Error("string.containsChars needs 2 arguments");
		}
	
		if (typeof(s) !== "string") {
			throw new Error("Invalid argument(s) to string.containsChars");
		}
	
		if (a instanceof Array === false) {
			throw new Error("Invalid argument to table.containsChars");
		}
	
		var charset = [];
		var charstr = "";
		var chararray = a;
		var len = chararray.length;
		var result = false;
	
		for(var i=0; i<len; i++) {
			charset[i] = chararray[i];
			if(s == "" || charset[i] == "") return true;
		}
	
		charstr = charset.join("");
		charstr = "[" + kony.string.escapeRegExp(charstr) + "]";
	
		var regexp = new RegExp(charstr,"g");
		result = regexp.test(s);
	
		return result;
	},
	/** This API verifies if only (and only) the specified set of characters is available in the given string and returns a boolean value.*/
	containsOnlyGivenChars: function (s, a) {
		if (arguments.length === 0) {
			throw new Error("string.containsOnlyGivenChars needs atleast 1 argument");
		}
	
		if (typeof(s) !== "string") {
			throw new Error("Invalid argument(s) to string.containsOnlyGivenChars");
		}
	
		var charset = [];
		var charstr = "";
		var chararray = a;
		var len = chararray.length;
		var result = false;
	
		for(var i=0; i<len; i++) {
			charset[i] = chararray[i];
		}
	
		charstr = charset.join("");
		//charstr = charstr.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
		charstr = "[^" + kony.string.escapeRegExp(charstr) + "]";
	
		var regexp = new RegExp(charstr,"g");
		result = regexp.test(s);
	
		if(result === false) {
			return true;
		} else {
			return false;
		}	
	},
	/** This API verifies that the input string does not contain any of the specified characters and returns a boolean value.*/
	containsNoGivenChars: function (s, a) {
		if (arguments.length === 0) {
			throw new Error("string.containsNoGivenChars needs 2 arguments");
		}
	
		if (typeof(s) !== "string") {
			throw new Error("Invalid argument(s) to string.containsNoGivenChars");
		}
	
		if (a instanceof Array === false) {
			throw new Error("Invalid argument to table.containsNoGivenChars");
		}
	
		var charset = [];
		var charstr = "";
		var chararray = a;
		var len = chararray.length;
		var result = false;
	
		for(var i=0; i<len; i++) {
			charset[i] = chararray[i];
			if(charset[i] == "") return false;
		}
	
		charstr = charset.join("");
		charstr = "[" + kony.string.escapeRegExp(charstr) + "]";
	
		var regexp = new RegExp(charstr,"g");
		result = regexp.test(s);
	
		if(result === false) {
			return true;
		} else {
			return false;
		}	
	},
	/** This API verifies if the input string is a valid email address and returns a boolean value.*/
	isValidEmail: function (s) {
		if (arguments.length === 0)
			throw new Error("string.isValidEmail needs atleast 1 argument");
	
		var value = s;
		if (typeof(value) !== "string")
			return false;
		//(99.9% syntactic accuracy)
		var emailPattern = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
		if((value.length - value.lastIndexOf('.')) < 3){
			return false;
		}

		return emailPattern.test(value);
	},
	
	escapeRegExp: function (text)
	{
	    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	}
}

/**@Deprecated This library provides generic functions for table manipulation. It provides all its functions inside the table.

Most functions in the Table library assume that the table represents an array or a list. For these functions, when we talk about the "length" of a table we mean the result of the length operator.

Note: This library is also available in JavaScript under the namespace kony.table. This is only for maintaining the backward compatibility for the application converted from Lua to JavaScript.*/
kony.table = {
/**@Deprecated This API extracts all the elements of a table and concatenates the elements to form a string. A separator can be specified which can be placed between concatenated elements.*/
	concat: function(inputtable, separator, startposition, endposition) {
	
	    var isArgsError = false;
	    var isInternalError = false;
	    var result = null;
	    
	    if (!arguments[0] instanceof Object) 
	        isArgsError = true;
	    if (!isArgsError) {
	        var len = arguments[0].length;
	        var begin = 0, end = len, sep = "";//4901
	        var numArgs = arguments.length > 4 ? 4 : (arguments.length - 1);
	        switch (arguments.length) {
	            case 4:
	                arguments[3] -= 0;
	                if (isNaN(arguments[3])) {
	                    isArgsError = true;
	                }
	                end = arguments[3];
	            case 3:
	                arguments[2] -= 0;
	                if (isNaN(arguments[2]) || arguments[2] < 0) {
	                    isArgsError = true;
	                }
	                begin = arguments[2];
	            case 2:
	                sep = arguments[1];
	            default:
	                break;
	        }
	        
	        if (len == 0) 
	            return kony.table.returnResult("", isArgsError, isInternalError);
	        
	        if (isArgsError) 
	            return kony.table.returnResult(result, isArgsError, isInternalError);
	        
	        if (begin > end) {
	            //isArgsError = true; // return empty string -- lua std
				return kony.table.returnResult("", isArgsError, isInternalError);
	        }
	        else 
	            if (end > len) {
	                isArgsError = true;
	            }
	            else 
	                if (!isArgsError) {
	                    result = "";
	                    try {
	                        for (var i = begin; i < end; i++) {
								if(arguments[0][i] == null || arguments[0][i] instanceof Object) 
									return kony.table.returnResult(null, true, isInternalError);   
	                            result += arguments[0][i].toString() + sep;
	                        }
	                        result += arguments[0][i].toString();
     
	                    } 
	                    catch (e) {
	                        isInternalError = true;
	                    }
	                }
	    }
	    return kony.table.returnResult(result, isArgsError, isInternalError);
	},
	
	/*maxn: function(args) {
	    if (0 === arguments.length) {
	        throw new Error("table.maxn needs atleast one argument");
	    }
	    
	    if (args[0] instanceof LuaTable === false) {
	        throw new Error("Invalid argument to table.maxn");
	    }
	    
	    var maxIndex = args[0].arrayContainer.length - 1;
	    for (var obj in args[0].hashContainer) {
	        var key = args[0].hashContainer[obj].key;
	        if (args[0].hashContainer[obj].value !== null &&
	        typeof(key) === "number" &&
	        maxIndex < key) {
	            maxIndex = key;
	        }
	    }	    
	    return maxIndex;
	},*/
	/**@Deprecated This API inserts a specified value into the given table in the list part. If a position is specified, the value is inserted before the element currently at that position. If no position is specified, the value is appended to the end of the table. If the specified position is not within the range of the list part of the table, the new element is added to the hash part of the table.*/
	insert: function(inputtable, position, value) {
	
	    var isArgsError = false;
	    var isInternalError = false;
	    var result = null;	
	    
	    if (arguments.length < 2 || !(arguments[0] instanceof Object)) {
	        isArgsError = true;
	    }
	    
	    if (!isArgsError) {
	    
	        var pos, newItem;
	       // var arr = arguments[0];	
	        if (arguments.length > 2) {  
			    pos = arguments[1];      
	            if (typeof pos == "string" || isNaN(pos)) {                
	                return kony.table.returnResult(true, isInternalError);            
				}            
	            newItem = arguments[2];
	        }
	        else {
	            pos = arguments[0].length;
	            newItem = arguments[1];
				/*if(args[1] == null) // don't insert nil at the end of table -- lua std 
					return kony.table.returnResult(args[0], isArgsError, isInternalError);*/
	        }
	        
	        try {      
					if (typeof pos == "string" || pos >= arguments[0].length || pos <= 0) {
						if (pos == 0) {	
							//DEF 3809
							arguments[0].splice(pos,0,newItem);						
							//arguments[0][pos] = newItem;
						}
						else {
							arguments[0][pos] = newItem;
						}
	                }
	                else{
	                 /*   var pre = arguments[0].slice(0, pos);
	                    var post = arguments[0].slice(pos);
	                    pre.push(newItem);
	                    arguments[0] = pre.concat(post);*/
						arguments[0].splice(pos,0,newItem);
	                }		
					//arguments[0] = arr;		
	        } 
	        catch (e) {
	            isInternalError = true;
	        }
	    }
	    return kony.table.returnResult(isArgsError, isInternalError);
	},
		/**@Deprecated This API removes an element from the list part of the table. If a position is specified, the element at the position is removed. If no position is specified, the last element in the table is removed. The removed element is returned. This API operates only on the list part of the table.*/
	remove: function(inputtable, position) {
	
	    var isArgsError = false;
	    var result = null;
	    
	    if (0 === arguments.length || !(arguments[0] instanceof Array)) {
	        isArgsError = true;
	    }
	    
		if (!isArgsError) {
			var pos = arguments[0].length - 1 ;
			if (pos >= 0) {
				if (arguments.length > 1 && arguments[1] != null) {
					arguments[1] -= 0;
					if (isNaN(arguments[1]) || arguments[1] > pos || arguments[1] < 0) {
						isArgsError = true;
						return kony.table.returnResult(result, isArgsError, false);
					}
	
					if (arguments[1] < pos && arguments[1] >= 0) {
						pos = arguments[1]   //-1;//5.0 Decremented
					}
				}
				result = arguments[0].splice(pos, 1);
				result = result[0] ;
				/*for(var i=pos;i > 0;i--){
					result = args[0].arrayContainer.splice(i, 1);
					if(result[0] == null && i == args[0].length()+1)
						continue;
					else
						break;				
				}*/
			}
			else
	    		  return kony.table.returnResult(null, isArgsError, false);
		}
	    return kony.table.returnResult(result, isArgsError, false);
	},
	
/**@Deprecated This API sorts the elements of the input table and returns the modified table. This API sorts only the list part of the table and the hash part of the table is ignored.*/
	sort: function(inputtable, sortkey, comparisonfunction) {
	
	    var isArgsError = false;
	    var isInternalError = false;
	    var result = null;
	    var comparator = null;
		
	    
	   if (0 === arguments.length || !(arguments[0] instanceof Array)) {
	        isArgsError = true;
	    }
	    
	    if (typeof(arguments[1]) == "function") {
			comparator = arguments[1];
		}
		else 
			if (typeof(arguments[2]) == "function") {
				comparator = arguments[2];
			}
	    
	    if (!isArgsError) {
	    	var len = arguments[0].length;
			var pre = arguments[0];

			if(arguments[0].length < 2){
				//Can't do aything. Need more than one element to sort
				return kony.table.returnResult(inputtable,false,false);
			}
			
	        try {        
	            for (var i = 0; i < len; i++) { //5.0 Decremented i
	                var elemType = typeof(arguments[0][1]);
	                if (arguments[0][i] == null || typeof(arguments[0][i]) != elemType) {
	                	
	                    return kony.table.returnResult(true, isInternalError);
	                }                
	            }
	            
	           // pre = arguments[0].slice(1);
	            //var zeroth = arguments[0].shift();
				
				//This is to splice the array to the length to which it has to be sorted
				if(arguments[1] !== null && !isNaN(arguments[1]))						
					pre.splice(arguments[1],pre.slice(arguments[1],pre.length).length);
					
	            if (comparator) {
	                pre.sort(function(a, b){
	                    var retVals = comparator(a, b);
	                    
	                    return (retVals ? -1 : 1);
	                });
	            }
	            else 
	                if (typeof arguments[1] == "string") {
	                    comparator = arguments[1];
	                    pre.sort(function(a, b){
	                        if (a[comparator] != null && typeof a[comparator] == typeof b[comparator] && typeof a[comparator] == "string") {
	                                var nameA = a[comparator].toLowerCase(), nameB = b[comparator].toLowerCase()
	                                if (nameA < nameB) //sort string ascending
	                                    return -1
	                                if (nameA > nameB) 
	                                    return 1
	                                return 0 //default return value (no sorting)				
	                            }
	                            else {
	                                return a[comparator] - b[comparator];
	                            }
	                    });
	                }
	                else {	
	                    pre.sort(function(a, b){
	                        if (typeof a == "string") {
	                            var A = a.toLowerCase();
	                            var B = b.toLowerCase();
	                            if (A < B) {
	                                return -1;
	                            }
	                            else 
	                                if (A > B) {
	                                    return 1;
	                                }
	                                else {
	                                    return 0;
	                                }
	                        }
	                        else 
	                            return a - b;
	                        
	                    });
	                    
	                }
	           // pre.unshift(zeroth);
	           // pre = pre.concat(arguments[0]);
	        } 
	        catch (e) {
	            isInternalError = true;
				pre = null;
	        }
	    }
	    if (!isArgsError && !isInternalError)        
	   		 return kony.table.returnResult(pre, isArgsError, isInternalError);
		else 
			return kony.table.returnResult(true, isInternalError);
	},
/**@Deprecated This API filters the given table based on the provided criteria and returns a set of values that match the given criteria.*/
	filter: function(srctable, mapfunc) {
	
	
	    var isArgsError = false;
	    var isInternalError = false;
	    var tgttable;
	    
	    if (arguments.length < 2 || !(srctable instanceof Object)  || !(typeof(mapfunc)  == "function")) {
	        isArgsError = true;
	    }
		
	    if (!isArgsError) {
	        
	        var key, value, retVals;
	        
	        if ((srctable instanceof Array)  && mapfunc) {
				try {
					tgttable = [];
					for (var i = 0; i < srctable.length; i++) {//5.0 Decremented i
						value = srctable[i];
						if (value instanceof Object) {
							/*var innerLen = value.length();
							 var innerValue;
							 var count = 0;
							 for (var k = 0; k < innerLen; k++) {
							 innerValue = value.arrayContainer[k + 1];
							 retVals = executeClosure(mapfunc, [k + 1, innerValue]);
							 if (retVals[0] == true)
							 count++;
							 }
							 if (count == innerLen)
							 tgttable.arrayContainer.push(value);*/
							return kony.table.returnResult(null, true, isInternalError);
						}
						else {
						
							if (value != null) 
								retVals = mapfunc(i, value);
							if (retVals === true) 
								tgttable.push(value);
							retVals = false;
						}
						
					}
				} 
				catch (e) {
					isArgsError = true;
				}
			}
			else 
				if (srctable && mapfunc) {
					tgttable = new Object();
					
					try {
						for (var j in srctable) {
							key = j
							value = srctable[j];
							if (value != null) 
								retVals = mapfunc(j, value);
							if (retVals === true) {
								tgttable[key] = value;
							}
							retVals = false;
						}
					} 
					catch (e) {
						isArgsError = true;
					}
				}
	    }
	    
	    if (isArgsError || isInternalError) 
	        tgttable = null;
	    
	    return kony.table.returnResult(tgttable, isArgsError, isInternalError);
	},
	/**@Deprecated This API performs the given action on the input table and returns the modified table.*/
	map : function(srctable, mapfunc) {
	
	    var isArgsError = false;
	    var isInternalError = false;
		
	    if (arguments.length < 2 || (srctable instanceof Object === false) || !(typeof(mapfunc) == "function")) {
	        isArgsError = true;
	    }
	    
	    if (!isArgsError) {
	    	
			try {
					
				var key, value, retVals;
					
				if (srctable instanceof Array && mapfunc) {
					var len = srctable.length;
					
					for (var i = 0; i < len; i++) {//5.0 Decremented i
						if (srctable[i] instanceof Array || srctable[i] == null) {
							return kony.table.returnResult(true, isInternalError);
						}
					}
					
					try {
						for (var i = 0; i < len; i++) {//5.0 Decremented i
							value = srctable[i];
							retVals = mapfunc(i, value);
							if (retVals !== false) {
								key = retVals[0];
								value = retVals[1];
								srctable[key] = value;
								retVals = false;
							}
							else 
								return kony.table.returnResult(true, isInternalError);
						}
					} 
					catch (e) {
						isArgsError = true;
					}
				} else	
					if (srctable && mapfunc) {
						
						try {
							for (var j in srctable) {
								key = j;
								value = srctable[key];
								retVals = mapfunc(key, value);
								
								if (retVals !== false) {
									key = retVals[0];
									value = retVals[1];
									srctable[key] =  value;
									retVals = false;
								}
								else 
									return kony.table.returnResult(true, isInternalError);
							}
						} 
						catch (e) {
							isArgsError = true;
						}
					}
			}
			catch(e){
				isInternalError = true;
			}
	    }
	    //srctable added for JSPFQA5653
	    return kony.table.returnResult(srctable, isArgsError, isInternalError);
	    
	},
	/**@Deprecated This API performs the given action on the input table and returns a new table.*/	
	mapNew: function(srctable, mapfunc){
	
	    var isArgsError = false;
	    var isInternalError = false;
	    
	    if (arguments.length < 2 || (srctable instanceof Object === false) || !(typeof(mapfunc) == "function")) {
	        isArgsError = true;
	    }
		
		if(srctable == null)
			return kony.table.returnResult(null, isArgsError, isInternalError);
	    
		try {
			
			var tgttable = null;   
			var key, value, retVals;
			
			if (!isArgsError) {
						
				if (srctable instanceof Array && mapfunc) {
					var len = srctable.length;
				
					for (var i = 0; i < len; i++) {//5.0 Decremented i
						if (srctable[i] instanceof Object || srctable[i] == null) {
							return kony.table.returnResult(null, true, isInternalError);
						}
					}
					
					try {
						
						tgttable = []; 
						for (var i = 0; i < len; i++) {//5.0 Decremented i
							value = srctable[i];
							retVals = mapfunc(i, value);
							key = retVals[0];
							value = retVals[1];
							tgttable[key] = value;
						}
					} 
					catch (e) {
						isArgsError = true;
					}
					
				} else
					if (srctable && mapfunc) {
				
						try {
							tgttable = new Object();
							for (var j in srctable) {
								key = j;
								value = srctable[key];
								retVals = mapfunc(key, value);
								
								if (retVals !== false) {
									key = retVals[0];
									value = retVals[1];
									tgttable[key] =  value;
									retVals = false;
								}
								else 
									return kony.table.returnResult(true, isInternalError);
							}
						} 
						catch (e) {
							isArgsError = true;
						}
					}
				}	
		}
	    catch (e) {
			isInternalError = true;
		}
					
	    if (isArgsError || isInternalError) 
	        tgttable = null;
	    return kony.table.returnResult(tgttable, isArgsError, isInternalError);
	    
	},
/**@Deprecated This API searches the given input table and returns the value at the specified key; if the key is a number, this API returns the value at the index.*/	
	get: function(srctable, key) {
	
	    var isArgsError = false;
	    var isInternalError = false;
		var invalidKey = false;
	    var result = null;
	    
		//TODO:Error Check
	    if (arguments.length < 2 || srctable instanceof Object === false || key == null) {
	        isArgsError = true;
	        return kony.table.returnResult(result, isArgsError, isInternalError);
	    }
	
	    try {
	        if (key in srctable) {
	            result = srctable[key];				
	        } else 
			  invalidKey = true;
	    } 
	    catch (e) {
	        isInternalError = true;
	    }
		
	    return kony.table.returnResult(result, isArgsError, isInternalError, invalidKey);
	},
/**@Deprecated Tests if the specified key is part of the table.*/	
	contains: function(srctable, key) {
	
	    var isArgsError = false;
	    var isInternalError = false;
	    var result = false;
	    
	    if (arguments.length < 2 || srctable instanceof Object === false || key == null) {        
	        return kony.table.returnResult(result, true, isInternalError);
	    }
	    
	    try {
			 if (key in srctable) 
            	result = true;				        
	    } 
	    catch (e) {
	        isInternalError = true;
	    }
	    return kony.table.returnResult(result, isArgsError, isInternalError);
	},
/**@Deprecated This API appends the content of the source table to the target table and returns the modified target table.*/	
	append: function(tgttable, srctable) {
	
	    var isArgsError = false;
	    var isInternalError = false;
	    
	    if (arguments.length != 2 || !(tgttable instanceof Object) || !(srctable instanceof Object)) {
	        isArgsError = true;
	        return kony.table.returnResult(null, isArgsError, isInternalError);
	    }
	      
	    try {
	        if (tgttable.length && srctable.length) {
	          ////  var srcarray = srctable.slice(1);   //4906
				for (var i = 0; i < srctable.length; i++) {
					tgttable.push(srctable[i]);
				}
	        } else {
	                    
	            for (var j in srctable) {
	                tgttable[j] = srctable[j];
	            }
	        }
	    } 
	    catch (e) {
	        isInternalError = true;
	    }
	
	    return kony.table.returnResult(tgttable, isArgsError, isInternalError);
	},
	/**@Deprecated This API removes data from the table represented by the table id.*/	
	removeAll: function(srctable) {
	
	    if (arguments.length < 1) {
	        throw new Error("table.removeAll needs atleast 1 argument");
	    }
	    
		//TODO:Proper error function to distinguish between table (object) & other types
	    if (typeof(srctable) != "object") {
	        throw new Error("Invalid  arguments to table.removeAll");
	    }
	    
		if(srctable.length)
	    	srctable.length = 0;
		else {
			for (var key in srctable) {
				delete srctable[key];
			}
		}
	    
	    return;
	},
	
	/**@Deprecated unpack

This API returns the elements from the given table. This function is equivalent to

return list[i], list[i+1], .... list[j].*/	
	unpack: function (t1) {
       
	    if (0 === arguments.length) {
                throw new Error("unpack needs atleast one argument");
        }

        if (t1 instanceof Object === false) {
                throw new Error("Invalid first argument to unpack");
        }

        var numArgs = arguments.length > 3 ? 3 : arguments.length;
        var maxIndex = arguments[0].length;
        var beginIndex = 0 /*5.0 Decremented beginIndex*/, endIndex = maxIndex;
        switch (numArgs) {
                case 3:
                        arguments[2] -= 0;
                        if (isNaN(arguments[2])) {
                                throw new Error("Invalid argument to unpack");
                        }
                        endIndex = arguments[2];
                case 2:
                        arguments[1] -= 0;
                        if (isNaN(arguments[1])) {
                                throw new Error("Invalid argument to unpack");
                        }
                        beginIndex = arguments[1];
                default:
                        break;
        }

        if (beginIndex > endIndex) {
                return [""];
        } else {
                var retVals = "";//[];		//4907		
                for (var i = beginIndex; i < endIndex; i++) {
                        //retVals.push(arguments[0][i]);
                        if(i == 0){
                        	retVals = arguments[0][i];
                        }else{
                        	retVals = retVals + " " + arguments[0][i];
                        }
                }
                return  retVals;
        }
	},

	// local myjson = '{ "name": "Shasank", "id": "417" }'
	// table.parsejson(myjson)
	/*parsejson: function(args){
	
	    if (arguments.length < 1) {
	        throw new Error("table.parsejson needs atleast 1 argument");
	    }
	    
	    var jsObj = args[0].evalJSON();
	    
	    try {
	        var tgttable = kony.utils.json2LuaTable(jsObj);
	    } 
	    catch (e) {
	        throw new Error("table.parsejson - SyntaxError: Badly formed JSON string");
	    }
	    
	    return tgttable;
	},*/

	/*keys: function(args){
	
	    if (arguments.length < 1) {
	        throw new Error("table.keys needs atleast 1 argument");
	    }
	    
	    if (args[0] instanceof LuaTable === false) {
	        throw new Error("Invalid  arguments to table.keys");
	    }
	    
	    var srctable = args[0];
	    
	    if (srctable.hashKeys.length) {
	    
	        var innerlen = srctable.hashKeys.length;
	        var key;
	        var keysarray = [];
	        for (var j = 0; j < innerlen; j++) {
	            key = srctable.hashKeys[j];
	            keysarray.push(key);
	        }
	        
	        return keysarray;
	    }
	},*/

	returnResult: function() {
	
	    var errorNo = null;
	    var errorMsg = null;
		var isArgsError = false;
		var isInternalError = false;
		
		if (arguments.length >= 3) {
			
			var retArray = arguments[0];
			isArgsError = arguments[1];
			isInternalError = arguments[2];
			var invalidKey = arguments[3];		
		}
		else{
			isArgsError = arguments[0];
			isInternalError = arguments[1];
		}
	    if(isArgsError) {
	        errorNo = 100;
	        errorMsg = "INVALID ARGUMENTS";
	    }
	    else if(isInternalError){
	            errorNo = 101;
	            errorMsg = "INTERNAL ERROR";
	    }
	    else if(invalidKey){
	                errorNo = 0;
	                errorMsg = "INVALID KEY";
		}	
		if (arguments.length >= 3) 			
	    	//return ([retArray, errorNo, errorMsg]);
			return retArray;
		else if(arguments.length == 2 && (isArgsError || isInternalError))
			return ([errorNo, errorMsg]);
		else	
			return;	
	}
}

/**@Deprecated This API returns the current time as a string in hh:mm:ss format. The time is represented in 12 hour format.*/
	kony.os.time = function () {
		var timeStr = (new Date()).toTimeString();
	
		return timeStr.slice(0, timeStr.indexOf(" "));
	};
	/**@Deprecated This API returns the number of seconds between the first input parameter (t1) to the second input parameter (t2).*/
	kony.os.diffDateTime = function (time1, time2) {
		
		if (typeof(time1) !== "string" || typeof(time2) !== "string") {
			throw new Error("Invalid argument(s) to os.diffDateTime");
		}
	
		var t1 = time1.split(":");t1[2] = t1[2] - 0;
		var t2 = time2.split(":");t2[2] = t2[2] - 0;
		var one_day = 86400;  
		var t1sec = t1[0] * 3600 + t1[1] * 60 + t1[2];
		var t2sec = t2[0] * 3600 + t2[1] * 60 + t2[2];	
	
		return (t1sec > one_day || t2sec > one_day ) ? null : t1sec - t2sec;
	};
	/**@Deprecated This API formats the current date to the given format.*/
	kony.os.date = function () {
			
		var result;
		var currentDate = new Date();
		    
	    if (0 === arguments.length) {
	        var timeStr = currentDate.toTimeString();
	        result = kony.os.padZero(currentDate.getMonth() + 1) + "/" + kony.os.padZero(currentDate.getDate()) + "/" + kony.os.padZero(currentDate.getFullYear() % 100) + " " + timeStr.slice(0, timeStr.indexOf(" "));
	        return result;
	    }
	    else if (typeof(arguments[0]) == "string") {        
	        
	        if (arguments[0].toLowerCase().indexOf("dd") != -1) {        
			
	            return kony.os.formatdate(arguments[0], currentDate);            
	        }
	         else {
	                var utc = arguments[0].charAt(0) === '!';
	                var index = utc ? 1 : 0;
	                if ('*' === arguments[0].charAt(index) && 't' === arguments[0].charAt(index + 1)) {
	                    var day = utc ? currentDate.getUTCDate() : currentDate.getDate();
	                    var mon = (utc ? currentDate.getUTCMonth() : currentDate.getMonth()) + 1;
	                    var year = utc ? currentDate.getUTCFullYear() : currentDate.getFullYear();
	                    
	                    result = new Object();
	                    result["year"] =  year;
	                    result["month"] = mon;
	                    result["day"] = day;
	                    result["hour"]  = utc ? currentDate.getUTCHours() : currentDate.getHours();
	                    result["min"] = utc ? currentDate.getUTCMinutes() : currentDate.getMinutes();
	                    result["sec"] = utc ? currentDate.getUTCSeconds() : currentDate.getSeconds();
	                    result["wday"] = utc ? currentDate.getUTCDay() : currentDate.getDay() + 1;
	                    result["yday"] = kony.os.getDayOfYear(day, mon, year);
	                    result["isdst"] = utc ? false : kony.os.checkForDst();
	                    return result;
	           	}
	           else 
	                    return null;
	            }
	      } else 
	          return null;
	};
/**This API allows you to convert the given number to represent currency. At present, only USA currency is supported.*/
	kony.os.toCurrency = function (arg) {
		
		arg -= 0;
		if (isNaN(arg)) {
			throw new Error("Invalid argument to os.toCurrency");
		}
	
		if (arg < 0) arg *= -1;
		var str = arg.toFixed(3);
		str = str.substr(0,str.length-1); 
		var outStr = "";
		for (var i = 0; i < str.length - 4; i++) {
			outStr += str.charAt(i);
			if ((str.length - i - 1) % 3 === 0) outStr += ",";
		}
	
		for (; i < str.length; i++) {
			outStr += str.charAt(i);
		}
	
		return "$" + outStr;
	};
	/**This API converts the argument to a number. If the argument is already a number or a string convertible to a number, then the API returns this number; otherwise, it returns null for JavaScript and nil for Lua.*/
	kony.os.toNumber = function (arg) {
		
		if (arguments.length != 1) {
			throw new Error("Invalid argument to os.toNumber");
		}
		
		if (typeof(arg) === "number") {
			return arg;
		} else if (typeof(arg) === "string") {	
			
			var str = arg.replace(/^\s*/, '').replace(/\s*$/, '');
			if (str === '') {
				return null;
			} else {
				var num = str - 0;
				return (isNaN(num) ? null : num);
			}
		
		} else {
			return null;
		}
	};
	/**@Deprecated This API returns the difference in dates or compares two dates for equality.*/
	//os.compareDates(date1,date2,"format") - dd,mm,yyyy,yy 
	kony.os.compareDates = function (d1, d2, frmt){
		
		if(d1 == null || d2 == null || frmt == null || !kony.os.isvaliddate(d1,frmt) || !kony.os.isvaliddate(d2,frmt))
			return null 
			
		var date1 = kony.os.getDate(d1, frmt);
		var date2 = kony.os.getDate(d2, frmt);
		var oneday = 24*60*60*1000;
		
		return parseInt((date1.getTime() - date2.getTime())/oneday);	
	};
/**@Deprecated This API adds or subtracts units (days, hours, minutes, month, or years) to the given date.*/
	//os.addToDate(date1,format,units,count) - units : days,hours,minutes,month,years
	// Format"dd/mm/yyyy" or "mm/dd/yyyy" or mm/dd/yy
	kony.os.addToDate = function (d1, frmt, unt, cnt){
		
		if (d1 == null || frmt == null || unt == null || cnt == null) {
			return null;
		}
		var inputDate = d1;
		var fmt = frmt;
		var unit = unt;
		var count = cnt;   
		var dateParts = inputDate.split("/");
		
		if(!kony.os.isvaliddate(inputDate,fmt))
			return null;
		
		var dateObj = kony.os.getDate(inputDate, fmt);
			
		if (dateObj) {
	        switch (unit) {
	            case "years":
	                dateObj.setFullYear(dateObj.getFullYear() + count);
	                break;
	            case "months":
	                dateObj.setMonth(dateObj.getMonth() + count);
	                break;
	            case "days":
	                dateObj.setDate(dateObj.getDate() + count);
	                break;
	            case "hours":
	                dateObj.setHours(dateObj.getHours() + count);
	                break;
	            case "minutes":
	                dateObj.setMinutes(dateObj.getMinutes() + count);
	                break;
	            default:
	                break;
	        }
			if(kony.os.isLeapYear([d1,fmt]) && dateObj.getMonth() >= 1 && (unit == "years" || (unit == "months" && (count == -12 || count == 12))) )
					dateObj.setDate(dateObj.getDategetDate() - 1);
			
			return kony.os.formatdate(fmt,dateObj);
			
		}		
		return null;
	};
	/**@Deprecated This API checks if the input year is a leap year.*/
	//os.isLeapYear(yyyy) 
	kony.os.isLeapYear = function (d1, frmt) {
		var year;
		var date = new Date();  //Take the current year;
		year = date.getFullYear();
		    
	    if (typeof(d1) == "string" && typeof(frmt) == "string") {
			
			if(!kony.os.isvaliddate(d1, frmt))
				return false;
				        
	        var yearPart = d1.split("/")[2];
	        year = (yearPart.length == 2) ? parseInt(date.getFullYear().toString().substr(0, 2) + yearPart) : parseInt(yearPart);
	    }
		
		if ((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0))) {
	 		return true;  		
	 	} 
		else {
	  		return false;
	 	} 		 
	};
/**@Deprecated This API converts a given date string to the target format and returns the formatted date. Format will use the tokens dd,mm,yyyy to indicate day, month, and year respectively. The delimiter used between the tokens can be any character. For example, dd/mm/yyyy and (dd)(mm)(yyyy) are valid inputs.*/
	//os.formatdate(inputdate[string],sourceformat[string],targetformat[string])
	kony.os.formatDate = function (d1, sfrmt, tgtfrmt) {
		
		var year;
		if(d1 == null || sfrmt == null || tgtfrmt == null) {
			return null;
		}
		else if(typeof(d1) === "string" && typeof(sfrmt) === "string" && typeof(tgtfrmt) === "string") {
			
	        var inputDate = d1
	        var srcfmt = sfrmt;
	        var targetfmt = tgtfrmt;
	        
	        var datePos = srcfmt.indexOf("dd");
	        var monthPos = srcfmt.indexOf("mm");
	        var yearPos = (srcfmt.indexOf("yyyy") != -1) ? srcfmt.indexOf("yyyy") : srcfmt.indexOf("yy");
	        
	        if ((srcfmt == "dd/mm/yyyy" && !kony.os.isvaliddate(inputDate, srcfmt)) || datePos == -1 || monthPos == -1 || yearPos == -1 || srcfmt.indexOf("ddd") != -1 || srcfmt.indexOf("mmm") != -1) {
	            return null;
	        }
	        
	        var dateStrSep = srcfmt.charAt(datePos - 1);
	        var dateEndSep = srcfmt.charAt(datePos + 2);
	        dateEndSep = (dateEndSep == "(") ? "" : dateEndSep;
	        
	        var monthStrSep = srcfmt.charAt(monthPos - 1);
	        var monthEndSep = srcfmt.charAt(monthPos + 2);
	        
	        var yearStrSep = srcfmt.charAt(yearPos - 1);
	        var yearEndSep = srcfmt.charAt(yearPos + 4);
	        
	        var startDateIndex = (dateStrSep == "") ? inputDate.indexOf(dateStrSep, datePos - 1) : inputDate.indexOf(dateStrSep, datePos - 2) + 1;
	        var startMonthIndex = (monthStrSep == "") ? inputDate.indexOf(monthStrSep, monthPos - 1) : inputDate.indexOf(monthStrSep, monthPos - 2) + 1;
	        var startYearIndex = (yearStrSep == "") ? inputDate.indexOf(yearStrSep, yearPos - 1) : ((inputDate.indexOf(yearStrSep, yearPos - 2) != -1) ? inputDate.indexOf(yearStrSep, yearPos - 2) + 1 : inputDate.indexOf(yearStrSep, yearPos - 4) + 1);
	        
	        var endDateIndex = (dateEndSep != "") ? inputDate.indexOf(dateEndSep, datePos) : inputDate.indexOf(dateEndSep, datePos + 2);
	        var endMonthIndex = (monthEndSep != "") ? inputDate.indexOf(monthEndSep, monthPos) : inputDate.indexOf(monthEndSep, monthPos + 2);
	        var endYearIndex = (yearEndSep != "") ? inputDate.indexOf(yearEndSep, yearPos) : inputDate.indexOf(yearEndSep, yearPos + 4);
	        
	        var dateVal = inputDate.substring(startDateIndex, endDateIndex);
	        var monthVal = inputDate.substring(startMonthIndex, endMonthIndex);
	        var yearVal = inputDate.substring(startYearIndex, endYearIndex);
	        
	        if ((yearVal.length == 2 && targetfmt.indexOf("yyyy") != -1)) 
	            var fullyr = new Date().getFullYear().toString().substr(0, 2) + yearVal;
	        
	        targetfmt = targetfmt.replace(/dd/, kony.os.padZero(parseInt(dateVal,10)));
	        targetfmt = targetfmt.replace(/mm/, kony.os.padZero(parseInt(monthVal,10)));
	        targetfmt = targetfmt.replace(/(yyyy|yy)/, fullyr ? fullyr : ((targetfmt.indexOf("yyyy") == -1 && yearVal.length == 4) ? yearVal.substr(2, 2) : yearVal));
	        
	        return targetfmt;	
		}	
		return null;
	};
/**@Deprecated This API returns the various date components of a specified date (in a specified format) or the current system date.*/
	//os.isvaliddate(date,format) 
	kony.os.isValidDate = function (date, frmt) {		
		return (arguments.length != 2 || date == null || frmt == null) ? false :kony.os.isvaliddate(date, frmt);		
	};
/**@Deprecated This API returns the various date components of a specified date (in a specified format) or the current system date.*/
	//os.dateComponents(date, format);
	//Formats supported:  (dd/mm/yyyy , mm/dd/yyyy, dd/mm/yy , mm/dd/yy) 
	kony.os.dateComponents = function (date,frmt){
		
	    var result;
		var dateObject;
		if (arguments.length == 0) {
			dateObject = new Date();
		}
		else if (date != null && frmt != null) {
				if(!kony.os.isvaliddate(date,frmt))
					return null;			 
				dateObject = kony.os.getDate(date, frmt);
				var yearfmt = frmt.split("/")[2];
			}
		if (dateObject) {	
			
			var day = dateObject.getDate();
			var mon = dateObject.getMonth() + 1;
			var year = (yearfmt && yearfmt.length == 2) ? parseInt(dateObject.getFullYear().toString().substr(2,2)) : dateObject.getFullYear();		
			
			result = new Object();		
			result["year"] = year;
			result["month"] = mon;
			result["day"] = day;
			result["hour"] = dateObject.getHours();
			result["min"] = dateObject.getMinutes();
			result["sec"] = dateObject.getSeconds();
			result["wday"] = dateObject.getDay() + 1;
			result["yday"] = kony.os.getDayOfYear(day, mon, year);
			result["isdst"] = kony.os.checkForDst();
			return result;
		} 
		else
			return null;
		
	};
	
	kony.os.padZero = function (num) {
	    return num < 10 ? ("0"+num) : num;
	};
/**@Deprecated This API converts a given date string to the target format and returns the formatted date. Format will use the tokens dd,mm,yyyy to indicate day, month, and year respectively. The delimiter used between the tokens can be any character. For example, dd/mm/yyyy and (dd)(mm)(yyyy) are valid inputs.*/	
	kony.os.formatdate = function (fmt, dateObj) {
		fmt = fmt.toLowerCase();
	    fmt = fmt.replace(/dd/, kony.os.padZero(dateObj.getDate()));
	    fmt = fmt.replace(/mm/, kony.os.padZero(dateObj.getMonth() + 1));
	    return fmt.replace(/(yyyy|yy)/, fmt.indexOf("yyyy") == -1 ? dateObj.getFullYear().toString().substr(2, 2) : dateObj.getFullYear());
	};
/**@Deprecated This API returns the various date components of a specified date (in a specified format) or the current system date.*/
	 //Valid formats mm/dd/yy and mm/dd/yyyy and dd/mm/yyyy		
    kony.os.isvaliddate = function(dtStr, format){
        var minYear = 1900;
        var maxYear = 2100;
        var dtCh = "/";
        var daysInMonth = kony.os.daysArray(12);

        var pos1 = dtStr.indexOf(dtCh)
        var pos2 = dtStr.indexOf(dtCh, pos1 + 1)
        var dateFormat = format || "dd/mm/yyyy";
        
        if (dateFormat == "dd/mm/yyyy" || dateFormat == "dd/mm/yy") {
            var strDay = dtStr.substring(0, pos1)
            var strMonth = dtStr.substring(pos1 + 1, pos2)
        }
        else 
            if (dateFormat == "mm/dd/yy" || dateFormat == "mm/dd/yyyy") {
                var strDay = dtStr.substring(pos1 + 1, pos2);
                var strMonth = dtStr.substring(0, pos1);
            }
            else 
                return false;
        
        var strYear = dtStr.substring(pos2 + 1);
        /*if(strYear.length == 2 && dateFormat.indexOf("yyyy") != -1)				
         return false;*/
        var today = new Date();
        
        strYr = strYear
        if (strDay.charAt(0) == "0" && strDay.length > 1) 
            strDay = strDay.substring(1)
        if (strMonth.charAt(0) == "0" && strMonth.length > 1) 
            strMonth = strMonth.substring(1)
        if (strYr.length == 2) {
            strYr = (today.getFullYear() + "").substr(0, 2) + strYr;
        }
        for (var i = 1; i <= 3; i++) {
            if (strYr.charAt(0) == "0" && strYr.length > 1) 
                strYr = strYr.substring(1)
        }
        month = parseInt(strMonth)
        day = parseInt(strDay)
        year = parseInt(strYr)
        
        if (!kony.os.isInteger(strMonth) || !kony.os.isInteger(strDay) || !kony.os.isInteger(strYear) || strMonth.length < 1 || month < 1 || month > 12 || strDay.length < 1 || day < 1 || day > 31 || (month == 2 && day > kony.os.daysInFebruary(year)) || day > daysInMonth[month] || strYr.length != 4 || year == 0 || year < minYear || year > maxYear) {
            //alert("invalid date");
            return false
        }
        return true
    };
	
    kony.os.daysArray = function(n){
        for (var i = 1; i <= n; i++) {
            this[i] = 31
            if (i == 4 || i == 6 || i == 9 || i == 11) {
                this[i] = 30
            }
            if (i == 2) {
                this[i] = 29
            }
        }
        return this
    };
	
    kony.os.daysInFebruary = function(year){
        // February has 29 days in any year evenly divisible by four,
        // EXCEPT for centurial years which are not also divisible by 400.
        return (((year % 4 == 0) && ((!(year % 100 == 0)) || (year % 400 == 0))) ? 29 : 28);
    };
	
    kony.os.isInteger = function(s){
        var i;
        for (i = 0; i < s.length; i++) {
            // Check that current character is number.
            var c = s.charAt(i);
            if (((c < "0") || (c > "9"))) 
                return false;
        }
        // All characters are numbers.
        return true;
    };
    
    kony.os.getDate = function(date, format){
        var dateObj;
        if (typeof date === "string" && typeof format === "string") {
            var dateParts = date.split("/");
            var yr = new Date().getFullYear().toString().substr(0, 2);
            if (format.indexOf("yyyy") == -1 || dateParts[2].length == 2) 
                dateParts[2] = yr + dateParts[2];
            
            if (format == "mm/dd/yyyy" || format == "mm/dd/yy") 
                dateObj = new Date(dateParts[0] + "/" + dateParts[1] + "/" + dateParts[2]);
            else 
                dateObj = new Date(dateParts[1] + "/" + dateParts[0] + "/" + dateParts[2]);
            
            return dateObj;
        }
    };
    
    kony.os.getDayOfYear = function(day, month, year){
        var i, j;
        var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        
        if (0 === year % 4) {
            days[1]++;
        }
        
        for (i = 1, j = 0; i < month; j += days[i - 1], i++) 
            ;
        
        return j + day;
    };

    kony.os.checkForDst = function(){

        var rightNow = new Date();
        var jan1 = new Date(rightNow.getFullYear(), 0, 1, 0, 0, 0, 0);
        var temp = jan1.toGMTString();
        var jan2 = new Date(temp.substring(0, temp.lastIndexOf(" ") - 1));
        var std_time_offset = (jan1 - jan2) / (1000 * 60 * 60);

        var june1 = new Date(rightNow.getFullYear(), 6, 1, 0, 0, 0, 0);
        temp = june1.toGMTString();
        var june2 = new Date(temp.substring(0, temp.lastIndexOf(" ") - 1));
        var daylight_time_offset = (june1 - june2) / (1000 * 60 * 60);
        var dst;
        if (std_time_offset == daylight_time_offset) {
            //dst = "0"; // daylight savings time is NOT observed
            return false;
        }
        else {
            //dst = "1"; // daylight savings time is observed
            return true;
        }
    };
	

	
	

//FP Appended konymvcextns.js-----------------------------------------------------------
//release/tool
//ver 1.6.2
;
(function() {
    var BusinessController_Command, BusinessController_CommandResponse, BusinessController_CommandHandler, commonUtils_ExtensibilityApi, BusinessController_CommandExecutionEngine, BusinessController_BusinessController, BusinessController_BusinessDelegator, DataModel_QueryBuilder, DataModel_constants, DataModel_Error, DataModel_DBAssembler, DataModel_DataSource, DataModel_BaseRepository, DataModel_RepositoryManager, PresentationController_MDABasePresenter, BaseNavigator_MDABaseNavigator, ModuleManager_MDAModule, ModuleManager_MDAModuleManager, UIBinder_UIBinder, UIBinder_PropertyDataMapper_GenericProperties, UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom, UIBinder_PropertyDataMapper_ImageProperties, UIBinder_WidgetDataMapper_ImageWidgetDataMapper, UIBinder_PropertyDataMapper_TextboxProperties, UIBinder_WidgetDataMapper_TextboxWidgetDataMapper, UIBinder_PropertyDataMapper_LabelProperties, UIBinder_WidgetDataMapper_LabelWidgetDataMapper, UIBinder_PropertyDataMapper_TextAreaProperties, UIBinder_WidgetDataMapper_TextAreaWidgetDataMapper, UIBinder_PropertyDataMapper_SwitchProperties, UIBinder_WidgetDataMapper_SwitchWidgetDataMapper, UIBinder_PropertyDataMapper_SliderProperties, UIBinder_WidgetDataMapper_SliderWidgetDataMapper, UIBinder_PropertyDataMapper_RichTextProperties, UIBinder_WidgetDataMapper_RichTextWidgetDataMapper, UIBinder_PropertyDataMapper_ButtonProperties, UIBinder_WidgetDataMapper_ButtonWidgetDataMapper, UIBinder_WidgetDataMapper_SegmentWidgetDataMapper, UIBinder_PropertyDataMapper_ListboxProperties, UIBinder_WidgetDataMapper_ListboxWidgetDataMapper, UIBinder_WidgetDataMapper_FlexContainerWidgetDataMapper, UIBinder_PropertyDataMapper_CalendarProperties, UIBinder_WidgetDataMapper_CalendarWidgetDataMapper, UIBinder_UIBinderBuilder, commonUtils_MDAApplication, commonUtils_Logger, commonUtils_InitializeForms, commonUtils_ProcessorUtils, ParallelCommandExecuter_ParallelCommandExecuter, DataModel_ModelRelation, DataModel_BaseModel, DataModel_ORMSession, DataModel_Expression, FormController_MDAFormController, commonUtils_ControllerGetterAPI, main, konymvcMDAFormController, kony_mvc_MDAFormController, MDAFormController;
    BusinessController_Command = function() {
        function Command(id, context, completionCallback, alias) {
            //kony.print("In Command: " + id + "  callback is: " + completionCallback);
            this.id = id;
            this.headers = context.headers;
            delete context.headers;
            this.context = context;
            this.completionCallback = completionCallback;
            this.alias = alias ? alias : id;
        }
        Command.prototype.execute = function() {};
        Command.prototype.getCompletionCallback = function() {
            return this.completionCallback;
        };
        Command.prototype.setCompletionCallback = function(completionCallback) {
            this.completionCallback = completionCallback;
        };
        Command.prototype.getContext = function() {
            return this.context;
        };
        Command.prototype.setContext = function(context) {
            this.context = context;
        };
        Command.prototype.getId = function() {
            return this.id;
        };
        Command.prototype.setId = function(id) {
            this.id = id;
        };
        Command.prototype.getAlias = function() {
            return this.alias;
        };
        Command.prototype.setAlias = function(alias) {
            this.alias = alias;
        };
        return Command;
    }();
    BusinessController_CommandResponse = function() {
        function CommandResponse(commandId, status, data, alias) {
            this.commandId = commandId;
            this.status = status;
            this.data = data;
            this.alias = alias ? alias : commandId;
        }
        return CommandResponse;
    }();
    BusinessController_CommandHandler = function(Command, CommandResponse) {
        function CommandHandler(commandId) {
            this.commandId = commandId;
            this.commandHandlerExtension = null;
            this.businessController = null;
        }
        CommandHandler.prototype.execute = function(command) {};
        CommandHandler.prototype.validate = function() {};
        CommandHandler.prototype.sendResponse = function(command, responseCode, responseData) {
            var response = new CommandResponse(command.id, responseCode, responseData, command.alias);
            command.completionCallback.call(this, response);
        };
        return CommandHandler;
    }(BusinessController_Command, BusinessController_CommandResponse);
    commonUtils_ExtensibilityApi = function() {
        function ClassExtensionUtility() {
            //This json Object is used for deregister purpose by holding the key as function name and value as JSONObject
            jsonForFunction = {};
            /**
             * This Api is the skeleton for addAfter logic
             *
             * @param {function} invoke  - The existing original function.
             * @param {function} newMeth - The new function which has to be executed later in the sequence.
             * @return           retX    - The result after execution of the latest method.
             */
            addAfterWrapper = function(invoke, newMeth) {
                    return {
                        diy: function() {
                            return function() {
                                var retX = invoke.apply(this, arguments);
                                retX = newMeth.apply(this, arguments);
                                return retX;
                            };
                        }
                    };
                },
                /**
                 * This Api is the skeleton for addBefore logic
                 *
                 * @param {function} invoke  - The existing original function.
                 * @param {function} newMeth - The new function which has to be executed prior to the sequence.
                 * @return           retX    - The result after execution of the latest method.
                 */
                addBeforeWrapper = function(invoke, newMeth) {
                    return {
                        diy: function() {
                            return function() {
                                var retX = newMeth.apply(this, arguments);
                                if (retX !== false) {
                                    retX = invoke.apply(this, arguments);
                                }
                                return retX;
                            };
                        }
                    };
                },
                /**
                 * This Api calls the function  which constructs the body for anonymous functions either addAfter or addBefore
                 *
                 * @param {String} key                 - The name of the anonymous function
                 * @param {boolean}flag                - Used to decide addAfter or addBefore
                 */
                makeAnonymousFuncBody = function(key, flag) {
                    if (flag === 1) {
                        makeAnonyAddAfterBody(key);
                    } else {
                        makeAnonyAddBeforeBody(key);
                    }
                },
                /**
                 * This function constructs the body for anonymous function in the scenario  of addAfter
                 *
                 * @param {string} key                 - The existing original function.
                 */
                makeAnonyAddAfterBody = function(key) {
                    var obj = jsonForFunction[key];
                    if (obj[key]['after']) {
                        var afterArray = obj[key]['after'];
                        for (var index = 0; index < afterArray.length; index++) {
                            var invoker = eval(key);
                            meth = eval(afterArray[index]);
                            methObj = addAfterWrapper(invoker, meth);
                        }
                        eval(key + '=methObj.diy();');
                    }
                },
                /**
                 * This function constructs the body for anonymous function in the scenario  of addBefore
                 *
                 * @param {string} key                 - The existing original function.
                 */
                makeAnonyAddBeforeBody = function(key) {
                    var obj = jsonForFunction[key];
                    var beforeArray = obj[key]['before'];
                    for (var index = 0; index < beforeArray.length; index++) {
                        var invoker = eval(key);
                        meth = eval(beforeArray[index]);
                        methObj = addBeforeWrapper(invoker, meth);
                    }
                    eval(key + '=methObj.diy();');
                },
                /**
                 * This Api calls the method which constructs the body for anonymous function in the scenario  of deRegistering a method
                 *
                 * @param {string} key                 - The existing original function.
                 */
                makeAnonymousFuncDeRegisterBody = function(key) {
                    makeAnonyAddAfterDeRegister(key);
                    makeAnonyAddBeforeDeRegister(key);
                },
                /**
                 * This function reconstructs the body after deregistering a particular method
                 *
                 * @param {string} key                 - The existing original function.
                 */
                makeAnonyAddBeforeDeRegister = function(key) {
                    var obj = jsonForFunction[key];
                    var beforeArray = obj[key]['before'];
                    for (var index = 0; index < beforeArray.length; index++) {
                        var invoker = eval(key);
                        meth = eval(beforeArray[index]);
                        var methObj = addBeforeWrapper(invoker, meth);
                        eval(key + '=methObj.diy();');
                    }
                },
                /**
                 * This function reconstructs the body after deRegistering a particular method
                 *
                 * @param {string} key                 - The existing original function.
                 */
                makeAnonyAddAfterDeRegister = function(key) {
                    var obj = jsonForFunction[key];
                    var afterArray = obj[key]['after'];
                    for (var index = 0; index < afterArray.length; index++) {
                        var invoker = eval(key);
                        meth = eval(afterArray[index]);
                        var methObj = addAfterWrapper(invoker, meth);
                        eval(key + '=methObj.diy();');
                    }
                },
                /**
                 * This Api calls the method which constructs the body for class in the scenario  of addAfter or addBefore of a member		
                 *
                 * @param {class} refClass             - The copy of the original class
                 * @param {string} key                 - The existing original function.
                 * @param {boolean} flag               - factor to call addAfter or addBefore.
                 */
                makeClassFunctionBody = function(refClass, key, flag) {
                    if (flag === 1) {
                        makeClassAddAfterFunctionBody(refClass, key);
                    } else {
                        makeClassAddBeforeFunctionBody(refClass, key);
                    }
                },
                /**
                 * This function constructs the body for Class in the scenario  of addAfter
                 *
                 * @param {class} refClass             - The copy of the original class
                 * @param {string} key                 - The existing original function.
                 */
                makeClassAddAfterFunctionBody = function(refClass, key) {
                    var obj = refClass[key + '_orig' + 1];
                    var afterArray = obj[key]['after'];
                    for (var index = 0; index < afterArray.length; index++) {
                        for (var keyValue in afterArray[index]) {
                            var invoker = refClass[key];
                            meth = afterArray[index][keyValue];
                            var methObj = addAfterWrapper(invoker, meth);
                        }
                    }
                    refClass[key] = methObj.diy();
                },
                /**
                 * This function constructs the body for Class in the scenario  of addBefore
                 *
                 * @param {class} refClass             - The copy of the original class
                 * @param {string} key                 - The existing original function.
                 */
                makeClassAddBeforeFunctionBody = function(refClass, key) {
                    var obj = refClass[key + '_orig' + 1];
                    var beforeArray = obj[key]['before'];
                    for (var index = 0; index < beforeArray.length; index++) {
                        for (var keyValue in beforeArray[index]) {
                            var invoker = refClass[key];
                            meth = beforeArray[index][keyValue];
                            var methObj = addBeforeWrapper(invoker, meth);
                        }
                    }
                    refClass[key] = methObj.diy();
                },
                /**
                 * This Api calls the method which constructs the body for class in the scenario  of deRegistering a method	
                 *
                 * @param {class} refClass             - The copy of the original class
                 * @param {string} key                 - The existing original function.
                 */
                makeClassDeRegisterFunctionBody = function(refClass, key) {
                    makeClassAddAfterBody(refClass, key);
                    makeClassAddBeforeBody(refClass, key);
                },
                /**
                 * This function reconstructs the body after deRegistering a particular method
                 *
                 * @param {class} refClass             - The copy of the original class
                 * @param {string} key                 - The existing original function.
                 */
                makeClassAddAfterBody = function(refClass, key) {
                    var obj = refClass[key + '_orig' + 1];
                    var afterArray = obj[key]['after'];
                    for (var index = 0; index < afterArray.length; index++) {
                        for (var keyValue in afterArray[index]) {
                            var invoker = refClass[key];
                            meth = afterArray[index][keyValue];
                            var methObj = addAfterWrapper(invoker, meth);
                        }
                        refClass[key] = methObj.diy();
                    }
                },
                /**
                 * This function reconstructs the body after deRegistering a particular method
                 *
                 * @param {class} refClass             - The copy of the original class
                 * @param {string} key                 - The existing original function.
                 */
                makeClassAddBeforeBody = function(refClass, key) {
                    var obj = refClass[key + '_orig' + 1];
                    var beforeArray = obj[key]['before'];
                    for (var index = 0; index < beforeArray.length; index++) {
                        for (var keyValue in beforeArray[index]) {
                            var invoker = refClass[key];
                            meth = beforeArray[index][keyValue];
                            var methObj = addBeforeWrapper(invoker, meth);
                        }
                        refClass[key] = methObj.diy();
                    }
                },
                /**
                 * This method is used to set the required assets for calling addAfter method to construct the body for anonymous function
                 *
                 * @param {class}    refClass - The prototype of the original class
                 * @param {JSON}     method   - The existing original function and new function as value.
                 * @param {boolean}  flag     - deciding factor to construct JSON Object for before or after methods
                 */
                anonymousFuncAdd = function(claz, method, flag) {
                    var method = claz;
                    for (var key in method) {
                        if (!jsonForFunction[key]) {
                            jsonForFunction[key] = {};
                        }
                        var dummyObject = jsonForFunction[key];
                        var meth = method[key];
                        if (dummyObject[key] === undefined) {
                            makeJsonObject(flag, meth, key);
                        } else {
                            makeJsonObjectComplete(flag, meth, key);
                        }
                        if (flag == 1) {
                            makeAnonymousFuncBody(key, 1);
                        } else {
                            makeAnonymousFuncBody(key, 0);
                        }
                    }
                },
                /**
                 * This Api is used to construct the json for addAfter and addBefore scenarios
                 *
                 * @param {boolean} flag     - deciding factor to construct JSON Object for before or after methods
                 * @param {function} meth    - new method
                 * @param {string} key       - original function
                 */
                makeJsonObject = function(flag, meth, key) {
                    var innerLevelObject = {};
                    innerLevelObject['after'] = [];
                    innerLevelObject['before'] = [];
                    if (flag === 1) {
                        innerLevelObject['after'].push(meth.name);
                    } else {
                        innerLevelObject['before'].push(meth.name);
                    }
                    var dummyObject = jsonForFunction[key];
                    dummyObject[key] = innerLevelObject;
                    jsonForFunction[key + 1] = eval(key);
                    jsonForFunction[key] = dummyObject;
                },
                /**
                 * This Api is used to construct the json for addAfter and addBefore scenarios
                 *
                 * @param {boolean} flag     - deciding factor to construct JSON Object for before or after methods
                 * @param {function} meth    - new method
                 * @param {string} key       - original function
                 */
                makeJsonObjectComplete = function(flag, meth, key) {
                    var dummyObject = jsonForFunction[key];
                    if (dummyObject[key]['after'] == undefined || dummyObject[key]['before'] == undefined) {
                        var innerLevelObject = {};
                        innerLevelObject['after'] = [];
                        innerLevelObject['before'] = [];
                        if (flag === 1) {
                            innerLevelObject['after'].push(meth.name);
                        } else {
                            innerLevelObject['before'].push(meth.name);
                        }
                        dummyObject[key] = innerLevelObject;
                        jsonForFunction[key + 1] = eval(key);
                    } else {
                        if (flag === 1) {
                            dummyObject[key]['after'].push(meth.name);
                        } else {
                            dummyObject[key]['before'].push(meth.name);
                        }
                    }
                    jsonForFunction[key] = dummyObject;
                },
                /**
                 * This method is used to set the required assets for calling addAfter method to construct the body for class
                 *
                 * @param {class}      claz - The prototype of the original class
                 * @param {function} meth    - new method
                 * @param {boolean}  flag     - deciding factor to construct JSON Object for before or after methods
                 */
                classMemberAdd = function(claz, method, flag) {
                    var innerLevelObject = {};
                    var refClass = claz;
                    var methodsList = [];
                    for (var key in method) {
                        if (!refClass[key + '_orig' + 1]) {
                            refClass[key + '_orig' + 1] = {};
                        }
                        var dummyObject = refClass[key + '_orig' + 1];
                        var meth = method[key];
                        if (refClass[key]) {
                            if (dummyObject[key] == undefined) {
                                makeClassJson(key, flag, method, refClass);
                            } else {
                                makeClassJsonComplete(key, flag, method, refClass);
                            }
                            if (flag == 1) {
                                makeClassFunctionBody(refClass, key, 1);
                            } else {
                                makeClassFunctionBody(refClass, key, 0);
                            }
                        }
                    }
                },
                /**
                 * This Api is used to construct the json for addAfter and addBefore scenarios
                 *
                 * @param {string} key       - original function
                 * @param {boolean} flag     - deciding factor to construct JSON Object for before or after methods
                 * @param {function} meth    - new method
                 * @param {class}   refClass- The class which contains prototype of the original class.
                 */
                makeClassJson = function(key, flag, method, refClass) {
                    var dummyObject = refClass[key + '_orig' + 1];
                    var innerLevelObject = {};
                    innerLevelObject['after'] = [];
                    innerLevelObject['before'] = [];
                    innerinnerObject = {};
                    innerinnerObject[method[key].name] = method[key];
                    if (flag == 1) {
                        innerLevelObject['after'].push(innerinnerObject);
                    } else {
                        innerLevelObject['before'].push(innerinnerObject);
                    }
                    dummyObject[key] = innerLevelObject;
                    refClass[key + '_orig'] = refClass[key];
                    refClass[key + '_orig' + 1] = dummyObject;
                },
                /**
                 * This Api is used to construct the json for addAfter and addBefore scenarios
                 *
                 * @param {string} key       - original function
                 * @param {boolean} flag     - deciding factor to construct JSON Object for before or after methods
                 * @param {function} meth    - new method
                 * @param {class}   refClass- The class which contains prototype of the original class.
                 */
                makeClassJsonComplete = function(key, flag, method, refClass) {
                    var dummyObject = refClass[key + '_orig' + 1];
                    if (dummyObject[key]['after'] == undefined || dummyObject[key]['before'] == undefined) {
                        innerLevelObject = {};
                        innerLevelObject['after'] = [];
                        innerLevelObject['before'] = [];
                        innerinnerObject = {};
                        innerinnerObject[method[key].name] = method[key];
                        if (flag == 1) {
                            innerLevelObject['after'].push(innerinnerObject);
                        } else {
                            innerLevelObject['before'].push(innerinnerObject);
                        }
                        dummyObject[key] = innerLevelObject;
                        refClass[key + '_orig'] = refClass[key];
                    } else {
                        innerinnerObject = {};
                        innerinnerObject[method[key].name] = method[key];
                        if (flag == 1) {
                            dummyObject[key]['after'].push(innerinnerObject);
                        } else {
                            dummyObject[key]['before'].push(innerinnerObject);
                        }
                    }
                    refClass[key + '_orig' + 1] = dummyObject;
                },
                /**
                 * This Api is used to call the methods for deRegistering purpose
                 *
                 * @param {class}    claz    - The class which contains various methods
                 * @param {function} meth    - new method
                 */
                deRegisterAnonyFunc = function(claz, method) {
                    method = claz;
                    for (var key in method) {
                        var meth = method[key];
                        var dummyObject = jsonForFunction[key];
                        afterArrayProcessing(key, meth);
                        beforeArrayProcessing(key, meth);
                        eval(key + '=jsonForFunction[key+1]');
                        makeAnonymousFuncDeRegisterBody(key);
                    }
                },
                /**
                 * This Api is used to process the addAfter methods and deregister them accordingly
                 *
                 * @param {string}  key         - The original initial method
                 * @param {function} meth       - new method
                 */
                afterArrayProcessing = function(key, meth) {
                    var dummyObject = jsonForFunction[key];
                    var afterArray = dummyObject[key]['after'];
                    for (var j = 0; j < afterArray.length; j++) {
                        if (afterArray[j] == meth.name) {
                            afterArray.splice(j, 1);
                            dummyObject[key]['after'] = afterArray;
                            jsonForFunction[key] = dummyObject;
                        }
                    }
                },
                /**
                 * This Api is used to process the addBefore methods and deregister them accordingly
                 *
                 * @param {string}  key         - The original initial method
                 * @param {function} meth       - new method
                 */
                beforeArrayProcessing = function(key, meth) {
                    var dummyObject = jsonForFunction[key];
                    var beforeArray = dummyObject[key]['before'];
                    for (var k = 0; k < beforeArray.length; k++) {
                        if (beforeArray[k] == meth.name) {
                            beforeArray.splice(k, 1);
                            dummyObject[key]['before'] = beforeArray;
                            jsonForFunction[key] = dummyObject;
                        }
                    }
                },
                /**
                 * This Api is used to call the methods for deRegistering purpose
                 *
                 * @param {class}    claz    - The class which contains various methods
                 * @param {function} method    - new method
                 */
                deRegisterClassMember = function(claz, method) {
                    var refClass = claz;
                    for (var key in method) {
                        var meth = method[key];
                        var dummyObject = refClass[key + '_orig' + 1];
                        classAfterArrayProcessing(refClass, key, meth);
                        classBeforeArrayProcessing(refClass, key, meth);
                        refClass[key] = refClass[key + '_orig'];
                        makeClassDeRegisterFunctionBody(claz, key);
                    }
                },
                /**
                 * This Api is used to process the addAfter methods and deregister them accordingly
                 *
                 * @param {class}   refClass- The class which contains prototype of the original class.
                 * @param {string}  key         - The original initial method
                 * @param {function} meth       - new method
                 */
                classAfterArrayProcessing = function(refClass, key, meth) {
                    var dummyObject = refClass[key + '_orig' + 1];
                    var afterArray = dummyObject[key]['after'];
                    for (var j = 0; j < afterArray.length; j++) {
                        for (var keyValue in afterArray[j]) {
                            if (keyValue == meth.name) {
                                afterArray.splice(j, 1);
                                dummyObject[key]['after'] = afterArray;
                                refClass[key + '_orig' + 1] = dummyObject;
                            }
                        }
                    }
                },
                /**
                 * This Api is used to process the addBefore methods and deregister them accordingly
                 *
                 * @param {class}   refClass- The class which contains prototype of the original class.
                 * @param {string}  key         - The original initial method
                 * @param {function} meth       - new method
                 */
                classBeforeArrayProcessing = function(refClass, key, meth) {
                    var dummyObject = refClass[key + '_orig' + 1];
                    var beforeArray = dummyObject[key]['before'];
                    for (var k = 0; k < beforeArray.length; k++) {
                        for (var keyValue in beforeArray[k]) {
                            if (keyValue == meth.name) {
                                beforeArray.splice(k, 1);
                                dummyObject[key]['before'] = beforeArray;
                                refClass[key + '_orig' + 1] = dummyObject;
                            }
                        }
                    }
                };
            /**
             * This Api is used to construct the json for addAfter and addBefore scenarios
             *
             * @param {string} key       - original function
             * @param {boolean} flag     - deciding factor to construct JSON Object for before or after methods
             * @param {function} meth    - new method
             * @param {class}   refClass- The class which contains prototype of the original class.
             */
            makeClassJson = function(key, flag, method, refClass) {
                    var dummyObject = refClass[key + '_orig' + 1];
                    var innerLevelObject = {};
                    innerLevelObject['after'] = [];
                    innerLevelObject['before'] = [];
                    innerinnerObject = {};
                    innerinnerObject[method[key].name] = method[key];
                    if (flag == 1) {
                        innerLevelObject['after'].push(innerinnerObject);
                    } else {
                        innerLevelObject['before'].push(innerinnerObject);
                    }
                    dummyObject[key] = innerLevelObject;
                    refClass[key + '_orig'] = refClass[key];
                    refClass[key + '_orig' + 1] = dummyObject;
                }, this.constructor = function(arg) {},
                /**
                 * This function adds a new member function to an existing class definition
                 *
                 * @param {class} claz   - The class for which a new member has to be added.
                 * @param {JSON}  method - The member which has to be added to the class.
                 */
                this.addMethod = function(claz, method) {
                    if (claz) {
                        var refClass = claz;
                    }
                    for (var key in method) {
                        if (!refClass[key]) {
                            refClass[key] = method[key];
                        }
                    }
                },
                /**
                 * This function adds a new sequence to an existing member function of a class definition. 
                 * The new sequence of code is executed after executing the default behaviour
                 *
                 * @param {class} claz   - The class for which addAfter functionality has to be extended.
                 * @param {JSON}  method - The member which has to be extended after to existing member of the class.
                 */
                this.addAfter = function(claz, method) {
                    if (method === undefined) {
                        anonymousFuncAdd(claz, method, 1);
                    } else {
                        classMemberAdd(claz, method, 1);
                    }
                },
                /**
                 * This function adds a new sequence to an existing member function of a class definition. 
                 * The new sequence of code is executed before executing the default behaviour
                 *
                 * @param {class} claz   - The class for which addBefore functionality has to be extended.
                 * @param {JSON}  method - The member which has to be extended before to existing member of the class.
                 */
                this.addBefore = function(claz, method) {
                    if (method === undefined) {
                        anonymousFuncAdd(claz, method, 0);
                    } else {
                        classMemberAdd(claz, method, 0);
                    }
                },
                /**
                 * This function removes an existing member function
                 *
                 * @param {class} claz       - The class for which a member has to be removed.
                 * @param {JSON}  method - The member which has to be removed from the class.
                 */
                this.removeMethod = function(claz, method) {
                    if (claz) {
                        var refClass = claz;
                    }
                    for (var key in methodName) {
                        delete refClass[key];
                    }
                },
                /**
                 * This function overrides an existing member behaviour with a new behaviour.
                 *
                 * @param {class} claz   - The class for which a member has to be updated.
                 * @param {JSON}  method - The member which has to be updated in the class.
                 */
                this.updateMethod = function(claz, method) {
                    if (method === undefined) {
                        method = claz;
                        for (var key in method) {
                            if (method[key] !== undefined) {
                                eval(key + '=method[key];');
                            }
                        }
                    } else {
                        for (var key in method) {
                            if (claz) {
                                var refClass = claz;
                            }
                            if (refClass[key]) {
                                refClass[key] = method[key];
                            }
                        }
                    }
                },
                /**
                 * This function deregisters an existing member function of a class definition. 
                 *
                 * @param {class} claz   - The class for which a member has to be deregistered.
                 * @param {JSON}  method - The member which has to be deRegistered from the sequence of member in the class.
                 */
                this.deRegister = function(claz, method) {
                    if (method === undefined) {
                        deRegisterAnonyFunc(claz, method);
                    } else {
                        deRegisterClassMember(claz, method);
                    }
                };
        }
        return ClassExtensionUtility;
    }();
    BusinessController_CommandExecutionEngine = function(Command, CommandHandler, ClassExtensionUtility) {
        function CommandExecutionEngine() {
            this.commandHandlers = [];
        }
        CommandExecutionEngine.prototype.registerCommandHandler = function(commandHandler) {
            var commandHandlerArray = [
                commandHandler.commandId,
                commandHandler,
                commandHandler.commandHandlerExtension
            ];
            if (commandHandlerArray[2]) {
                if (commandHandlerArray[2].execute) {
                    var extensionInstance = new ClassExtensionUtility();
                    extensionInstance.addBefore(commandHandlerArray[2], {
                        execute: commandHandlerArray[2].addBefore
                    });
                    extensionInstance.addBefore(commandHandlerArray[2], {
                        sendResponse: commandHandlerArray[2].addAfter
                    });
                } else {
                    var extensionInstance = new ClassExtensionUtility();
                    extensionInstance.addBefore(commandHandlerArray[1], {
                        execute: commandHandlerArray[2].addBefore
                    });
                    extensionInstance.addBefore(commandHandlerArray[1], {
                        sendResponse: commandHandlerArray[2].addAfter
                    });
                }
            }
            this.commandHandlers.push(commandHandlerArray); //kony.print("MDA2*** commandHandlers is :" + this.commandHandlers);
        };
        CommandExecutionEngine.prototype.unRegisterHandler = function(commandId) {
            for (var i = 0; i < this.commandHandlers.length; i++) {
                var commandHandlerArray = this.commandHandlers[i];
                if (commandHandlerArray[0] === commandId) {
                    this.commandHandlers.splice(i, 1);
                    break;
                }
            }
        };
        CommandExecutionEngine.prototype._executeCommand = function(command, params) {
            kony.print('MDA2*** CommandExecutionEngine execute : ' + command);
            if (this.isCommandRegistered(command.id) === true) {
                for (var i = 0; i < this.commandHandlers.length; i++) {
                    var commandHandlerArray = this.commandHandlers[i];
                    if (commandHandlerArray[0] === command.id) {
                        commandHandler = commandHandlerArray[1];
                        commandHandler.validate(params);
                        commandHandler.execute(command);
                        break;
                    }
                }
            } else {
                kony.print('Not registered ');
                throw new Exception('ERROR_CODE_300', 'Error at Command Execution Engine, Missing or Wrong CommandID');
            }
        };
        CommandExecutionEngine.prototype.execute = function(command) {
            kony.print('MDA2*** CommandExecutionEngine execute : ' + command);
            if (this.isCommandRegistered(command.id) === true) {
                for (var i = 0; i < this.commandHandlers.length; i++) {
                    var commandHandlerArray = this.commandHandlers[i];
                    if (commandHandlerArray[0] === command.id) {
                        commandHandler = commandHandlerArray[1];
                        commandHandlerExtension = commandHandlerArray[2];
                        if (commandHandlerExtension != null && commandHandlerExtension.execute) {
                            commandHandlerExtension.super = commandHandler.execute;
                            var returnVal = commandHandlerExtension.execute(command);
                            if (returnVal === false) {
                                commandHandler.sendResponse(command, kony.mvc.constants.STATUS_ABORT, null);
                            }
                        } else {
                            commandHandler.execute(command);
                        }
                        break;
                    }
                }
            } else {
                kony.print('Not registered ');
                throw new Exception('ERROR_CODE_300', 'Error at Command Execution Engine, Missing or Wrong CommandID ');
            }
        };
        CommandExecutionEngine.prototype.isCommandRegistered = function(commandId) {
            for (var i = 0; i < this.commandHandlers.length; i++) {
                var commandHandlerArray = this.commandHandlers[i];
                if (commandHandlerArray[0] === commandId) {
                    return true;
                }
            }
            return false;
        };
        return CommandExecutionEngine;
    }(BusinessController_Command, BusinessController_CommandHandler, commonUtils_ExtensibilityApi);
    BusinessController_BusinessController = function(CommandExecutionEngine, CommandHandler, Command) {
        function BusinessController() {
            //this.context = context;
            this.cmdEngine = new CommandExecutionEngine();
            this.initializeBusinessController();
        }
        BusinessController.prototype.initializeBusinessController = function() {};
        BusinessController.prototype.executeCommand = function(command, params) {
            this.cmdEngine._executeCommand(command, params);
        };
        BusinessController.prototype.execute = function(command) {
            //kony.print ("In BC executing :" + command.id);
            this.cmdEngine.execute(command);
        };
        BusinessController.prototype.registerCommandHandlers = function(commandHandlers, callback) {
            if (callback == '' || callback == undefined) {
                for (var i = 0; i < commandHandlers.length; i++) {
                    var commandId = commandHandlers[i].CommandId;
                    var commandHandler = require(commandHandlers[i].CommandHandler);
                    if (commandHandlers[i].CommandHandlerExtension && commandHandlers[i].CommandHandlerExtension != null) {
                        var commandHandlerExtn = commandHandlers[i].CommandHandlerExtension;
                        try {
                            var commandExtension = require(commandHandlerExtn);
                        } catch (err) {
                            throw new Exception('ERROR_CODE_300', 'Missing Command Handler Extension : ' + err);
                        }
                    } else {
                        var commandExtension = null;
                    }
                    var handler = new commandHandler(commandId);
                    handler.commandHandlerExtension = commandExtension;
                    if (commandExtension && commandExtension.execute) commandExtension.sendResponse = handler.sendResponse;
                    handler.businessController = this;
                    this.cmdEngine.registerCommandHandler(handler);
                } //var handler = eval('new '+commandHandler+'("'+commandId+'");');
            } else {
                var self = this;
                var handlersarray = [],
                    commandId = [],
                    commandHandlerExtn = [];
                for (var i = 0; i < commandHandlers.length; i++) {
                    commandId[i] = commandHandlers[i].CommandId;
                    commandHandlerExtn[i] = commandHandlers[i].CommandHandlerExtension;
                    handlersarray[i] = commandHandlers[i].CommandHandler;
                }
                var handlerinstances;
                var commandHandler = require(handlersarray, function() {
                    for (var i = 0; i < arguments.length; i++) {
                        try {
                            handlerinstances = arguments;
                            var HandlerExtn = commandHandlerExtn[i];
                            var instanceCommandHandler = handlerinstances[i];
                            var handler = new instanceCommandHandler(commandId[i]);
                            if (commandHandlerExtn[i] != null || commandHandlerExtn[i] != undefined) {
                                var commandExtension = require([HandlerExtn], function(instanceCommandHandlerExtn) {
                                    handler.commandHandlerExtension = instanceCommandHandlerExtn;
                                    if (instanceCommandHandlerExtn && instanceCommandHandlerExtn.execute) instanceCommandHandlerExtn.sendResponse = handler.sendResponse;
                                });
                            } else {
                                var commandExtension = null;
                            }
                            handler.businessController = self;
                            self.cmdEngine.registerCommandHandler(handler); //callback();
                        } catch (err) {
                            throw new Exception('ERROR_CODE_300', 'Missing Command Handler Extension : ' + err);
                        }
                    }
                });
            }
        };
        return BusinessController;
    }(BusinessController_CommandExecutionEngine, BusinessController_CommandHandler, BusinessController_Command);
    BusinessController_BusinessDelegator = function() {
        function BusinessDelegator() {
            this.superParams = {
                counter: 0,
                level: null,
                refStack: []
            };
        }
        BusinessDelegator.prototype.super = function(methodName, argList) {
            var scope = this;
            var returnValue = null;
            if (this.superParams.level === null) {
                this.superParams.level = 0;
                while (scope['extensionLevel' + this.superParams.level.toString()]) {
                    this.superParams.level++;
                }
            }
            if (this.superParams.counter === 0) {
                for (var i = 0; i < this.superParams.level; i++) {
                    if (scope['extensionLevel' + i.toString()][methodName]) {
                        this.superParams.refStack.push(i);
                    }
                }
            }
            this.superParams.refStack.pop();
            if (this.superParams.refStack.length !== 0) {
                var callLvl = this.superParams.refStack[this.superParams.refStack.length - 1];
                this.superParams.counter++;
                returnValue = scope['extensionLevel' + callLvl.toString()][methodName].apply(this, argList);
                this.superParams.counter--;
            } else {
                kony.print('#MDA2 : Can\'t find any super for the ' + methodName + ' Method.');
            }
            if (this.superParams.counter === 0) {
                this.superParams.refStack = [];
                this.superParams.level = null;
            }
            return returnValue;
        };
        return BusinessDelegator;
    }();
    DataModel_QueryBuilder = function() {
        function QueryBuilder() {}
        /**
         * @function buildSelectList creates a list of fields for given model
         * @param  {BaseModel} baseModel model defination
         * @param  {Json} config    config for corresponding model
         * @return {String} select list
         */
        QueryBuilder.prototype.buildSelectList = function(baseModel, config) {
            var selectList = '';
            for (var key in baseModel.relations) {
                var relationship = baseModel.relations[key];
                var modelstr = relationship.targetObject;
                var modeldefination = kony.mvc.MDAApplication.getSharedInstance().modelStore.getModelDefinition(modelstr);
                var configdefination = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(modelstr);
                selectList = selectList + QueryBuilder.prototype.buildSelectList(modeldefination, configdefination);
            }
            for (var column in config.mappings) {
                selectList = selectList + '`' + config.tableName + '`.`' + config.mappings[column] + '` as ' + config.tableName + '_' + config.mappings[column] + ',';
            }
            return selectList;
        };
        /**
         * @function buildTableName creates list of table names for given model including inner join with related models if any
         * @param  {BaseModel} baseModel model defination
         * @param  {Json} config    config for corresponding model
         * @param  {String} parent   parent table name
         * @param  {Json} parentRelation json describing model relation with parent
         * @return {String} list of table names including inner join with related models if any
         */
        QueryBuilder.prototype.buildTableName = function(baseModel, config, parent, parentRelation) {
            var fromList = '`' + config.tableName + '`';
            if (parentRelation !== undefined) {
                var relations = parentRelation.relationFields;
                var relation = relations[0];
                fromList = fromList + ' ON `' + parent + '`.`' + relation.sourceField + '`=`' + parentRelation.targetObject + '`.`' + relation.targetField + '`';
                for (var i = 1; i < relations.length; i++) {
                    relation = relations[i];
                    fromList = fromList + ' AND `' + parent + '`.`' + relation.sourceField + '`=`' + parentRelation.targetObject + '`.`' + relation.targetField + '`';
                }
            }
            for (var key in baseModel.relations) {
                var relationship = baseModel.relations[key];
                var modelstr = relationship.targetObject;
                var modeldefination = kony.mvc.MDAApplication.getSharedInstance().modelStore.getModelDefinition(modelstr);
                var configdefination = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(modelstr);
                fromList = fromList + ' LEFT OUTER JOIN ' + QueryBuilder.prototype.buildTableName(modeldefination, configdefination, config.tableName, relationship);
            }
            return fromList;
        };
        /**
         * @function buildConditions create a where condition based on criteria
         * @param  {Json} criteria Json object describing criteria
         * @param  {Json} config   config object
         * @return {String} where condition
         */
        QueryBuilder.prototype.buildConditions = function(criteria, config) {
            var finalCriteria = '';
            var leftcondition = '';
            var rightcondition = '';
            if (criteria !== undefined) {
                if (criteria.hasOwnProperty('expr')) {
                    if (!(criteria['lhs'].constructor == {}.constructor) && !(criteria['rhs'].constructor == {}.constructor)) {
                        finalCriteria = criteria['lhs'] + '' + criteria['expr'] + '' + criteria['rhs'];
                    } else {
                        if (criteria.hasOwnProperty('lhs') && criteria['lhs'].constructor == {}.constructor) {
                            leftcondition = leftcondition + QueryBuilder.prototype.buildConditions(criteria['lhs'], config);
                        } else {
                            leftcondition = criteria['lhs'];
                        }
                        if (criteria.hasOwnProperty('rhs') && criteria['rhs'].constructor == {}.constructor) {
                            rightcondition = rightcondition + QueryBuilder.prototype.buildConditions(criteria['rhs'], config);
                        } else {
                            rightcondition = criteria['rhs'];
                        }
                        finalCriteria = leftcondition + ' ' + criteria['expr'] + ' ' + rightcondition;
                    }
                }
            }
            return finalCriteria;
        };
        QueryBuilder.prototype.constructPrimaryKeyODataQuery = function(primaryKeyObj) {
            var filterQuery = '$filter=';
            var primaryKeys = Object.keys(primaryKeyObj);
            var length = primaryKeys.length;
            var query = '';
            for (var index in primaryKeys) {
                query = query + primaryKeys[index] + ' eq ' + primaryKeyObj[primaryKeys[index]];
                if (index < length - 1) query = query + ' and ';
            }
            if (query == '') {
                return null;
            } else {
                return filterQuery + query;
            }
            return query;
        };
        return QueryBuilder;
    }();
    DataModel_constants = {
        SESSIONTOKEN: 'session_token',
        DATA_OBJECT: 'dataObject',
        HEADERS_STRING: 'headers',
        QUERY_PARAMS: 'queryParams',
        LHS_STRING: 'lhs',
        RHS_STRING: 'rhs',
        ACCESS: 'access',
        ONLINE: 'online',
        OFFLINE: 'offline',
        SELECT_STRING: 'select ',
        FROM_STRING: ' from ',
        WHERE_STRING: ' where ',
        EXPR: 'expr',
        MESSAGE_FOR_RECORDCREATED: 'record created',
        MESSAGE_FOR_RECORDPARIALUPDATE: 'record partial update',
        MESSAGE_FOR_RECORDUPDATED: 'record updated',
        MESSAGE_FOR_RECORDDELETED: 'Record deleted',
        ERROR_IN_RECORD_DELETION: 'Error in record deletion',
        MODEL_STRING: 'Model',
        SYMBOL_UNDERSCORE: '_',
        MF_CONFIG_STRING: '_MF_Config',
        FORM_CONTROLLER_TYPE: 'kony.mvc.MDAFormController',
        HTTP_REQUEST_OPTIONS: 'httpRequestOptions',
        XML_REQUEST_OPTIONS: 'xmlHttpRequestOptions'
    };
    DataModel_Error = function() {
        //error object
        var Error = function() {
            this.errcode = null;
            this.errmsg = null;
            this.opstatus = null;
        };
        return Error;
    }();
    DataModel_DBAssembler = function(Error) {
        var assembler = {};
        /**
         * @function {function toDBJson}
         * @param  {BaseModel} BaseModelInstance {instance obj of BaseModel subType}
         * @param  {json object} config {config Json Mapping property names in BaseModel to db column names}
         * @return {json object} {Json object with instance values mapped to db column names}
         */
        assembler.toDBJson = function(BaseModelInstance, config) {
            /*if BaseModelInstance is an instance of model then object to json conversion is performed using toJsonInternal utility to ensure
             **getters are not invoked for this operation.
             **else if BaseModelInstance is an instance of BaseRepository not model instance, standard js methods could be used for conversion.
             */
            if (BaseModelInstance.toJsonInternal) {
                return BaseModelInstance.toJsonInternal();
            } else {
                var dbJson = {};
                Object.keys(config.mappings).forEach(function(key) {
                    dbJson[config.mappings[key]] = BaseModelInstance[key];
                });
                return dbJson;
            }
        };
        //create Error Object
        assembler.createError = function(BaseModelInstance, config, error) {
            var err = new Error();
            if (error.opstatus == 0) {
                if (config.mappings.text == undefined) {
                    err.errcode = 300;
                    err.errmsg = 'Invalid Params';
                    err.opstatus = error.opstatus;
                } else {
                    for (key in error) {
                        err[key] = error[key];
                    }
                }
            } else {
                for (key in error) {
                    err[key] = error[key];
                }
            }
            return err;
        };
        /**
         * @function {function fromDBJson}
         * @param  {BaseModelClass} BaseModelClass {Class of BaseModel subType for object creation}
         * @param  {json object} config         {config Json Mapping property names in BaseModel to db column names}
         * @param  {json object} dbJson         {Json object with instance values mapped to db column names}
         * @return {BaseModel} {BaseModel subType instance object}
         */
        assembler.fromDBJson = function(BaseModelClass, config, dbJson) {
            var modelJson = {};
            Object.keys(config.mappings).forEach(function(key) {
                modelJson[key] = dbJson[config.mappings[key]];
            });
            /*According to the new requirement internal layers shouldn't invoke getters and setters for object instantiation, below statements could be used
             **to instantiate object without invoking getters and setters.
             */
            var retModel = new BaseModelClass();
            if (retModel.fromJsonInternal) retModel.fromJsonInternal(modelJson);
            else retModel = new BaseModelClass(modelJson);
            var baseMap = BaseModelClass.prototype.attributeMap;
            var attributeMap = JSON.parse(JSON.stringify(baseMap));
            for (var attribute in attributeMap) {
                var model = attributeMap[attribute].model;
                var attributeDBValue = dbJson[attribute];
                if (model) {
                    var modelDefinition = kony.mvc.MDAApplication.getSharedInstance().modelStore.getModelDefinition(model);
                    var modelConfig = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(model);
                    if (Array.isArray(attributeDBValue)) {
                        var modelArray = [];
                        for (var record in attributeDBValue) {
                            var modelAttributeJson = {};
                            Object.keys(modelConfig.mappings).forEach(function(key) {
                                modelAttributeJson[key] = attributeDBValue[record][modelConfig.mappings[key]];
                            });
                            var attributeModel = new modelDefinition();
                            if (attributeModel.fromJsonInternal) attributeModel.fromJsonInternal(modelAttributeJson);
                            else attributeModel = new modelDefinition(modelAttributeJson);
                            modelArray.push(attributeModel);
                        }
                        retModel[attribute] = modelArray;
                    } else {
                        var modelAttributeJson = {};
                        Object.keys(modelConfig.mappings).forEach(function(key) {
                            modelAttributeJson[key] = attributeDBValue[modelConfig.mappings[key]];
                        });
                        var attributeModel = new modelDefinition();
                        if (attributeModel.fromJsonInternal) attributeModel.fromJsonInternal(modelAttributeJson);
                        else attributeModel = new modelDefinition(modelAttributeJson);
                        retModel[attribute] = attributeModel;
                    }
                } else {
                    retModel[attribute] = attributeDBValue;
                }
            }
            return retModel;
        };
        return assembler;
    }(DataModel_Error);
    DataModel_DataSource = function(QueryBuilder, constants, DBAssembler) {
        DataSource = function() {};
        /**
         * @function getByPrimaryKey  fetches data for the specified model based on the primary keys
         * @param  {BaseModel} BaseModel model defination
         * @param  {Json} config      config of corresponding model
         * @param  {String/JSON} primaryKey   primitive in case of one primary key and json in case of composite primary key
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        DataSource.prototype.getByPrimaryKey = function(BaseModel, config, primaryKey, onCompletion, accessMode, headerParams, dtoOptions) {
            var modelobject;
            var primaykeyobj = {};
            var primarykey;
            if (primaryKey == null || primaryKey == '' || primaryKey == undefined) {
                throw new Exception('ERROR_CODE_500', 'Invalid Primary Key');
            }
            for (var key in config.primaryKeys) {
                if (!(config.primaryKeys[key] in primaryKey)) {
                    var errPk = new Error();
                    errPk.opstatus = 0;
                    var errorobject = DBAssembler.createError(null, config, errPk);
                    errorobject.errmsg = 'Primary Key ' + config.primaryKeys[key] + ' is missing in the the input record.';
                    //User defines attributes with model object in attributeMap. Each API takes care of deleting the attributes defined
                    //for its usage. With each new invocation of the API, old attributes might be retained if not deleted which might
                    //cause inconsistency, if used.
                    for (var attribute in BaseModel.prototype.attributeMap) {
                        delete BaseModel.prototype.attributeMap[attribute];
                    }
                    onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorobject);
                    return;
                }
            }
            if (primaryKey.constructor == {}.constructor) {
                primaykeyobj = primaryKey;
            } else {
                for (var key in config.primaryKeys) {
                    primarykey = config.primaryKeys[key];
                    primaykeyobj[primarykey] = primaryKey;
                }
            }
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            var odataQueryFlag = kony.mvc.MDAApplication.getSharedInstance().getODataStatus();
            var options = {};
            if (odataQueryFlag) {
                var queryBuilder = new QueryBuilder();
                var odataQuery = queryBuilder.constructPrimaryKeyODataQuery(primaykeyobj);
                if (odataQuery) dataObject.setOdataUrl(odataQuery);
            } else {
                options[constants.QUERY_PARAMS] = primaykeyobj;
            }
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.fetch(options, function(response) {
                if (response && response.records && response.records.length == 1) {
                    modelobject = DBAssembler.fromDBJson(BaseModel, config, response.records[0]);
                }
                for (var attribute in BaseModel.prototype.attributeMap) {
                    delete BaseModel.prototype.attributeMap[attribute];
                }
                //callback sends status, data, error
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, modelobject, null);
            }, function(err) {
                //callback sends status, data, error
                errorobject = DBAssembler.createError(BaseModel, config, err);
                for (var attribute in BaseModel.prototype.attributeMap) {
                    delete BaseModel.prototype.attributeMap[attribute];
                }
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorobject);
            });
        };
        /**
         * @function checkObj   forms the valid JSON to be passed as criteria to fetch data for ONLINE calls
         * @param  {JSON} criteria      JSON including "EXPR","lhs" and "rhs" as criteria object for ONLINE calls
         * @param  {JSON} finalCriteria  JSON including pairs as value["lhs"] : value["rhs"] 
         * @return {JSON} finalCriteria
         */
        DataSource.prototype.checkObj = function(criteria, finalCriteria) {
            if (criteria.hasOwnProperty(constants.LHS_STRING) && criteria[constants.LHS_STRING].constructor == kony.mvc.Expression) {
                DataSource.prototype.checkObj(criteria[constants.LHS_STRING], finalCriteria);
            } else {
                finalCriteria[criteria[constants.LHS_STRING]] = criteria[constants.RHS_STRING];
            }
            if (criteria.hasOwnProperty(constants.RHS_STRING) && criteria[constants.RHS_STRING].constructor == kony.mvc.Expression) {
                DataSource.prototype.checkObj(criteria[constants.RHS_STRING], finalCriteria);
            } else {
                finalCriteria[criteria[constants.LHS_STRING]] = criteria[constants.RHS_STRING];
            }
            return finalCriteria;
        };
        /**
         * @function customVerb fetches data for the specified model using specified customVerb
         * @param  {BaseModel} BaseModel    model defination
         * @param  {Json}      config      config of corresponding model
         * @param  {String} customVerb   name of the custom verb to be executed
         * @param  {Json} params       parameters in the form of key value pairs
         * @param  {function} onCompletion success callback
         * @return 
         */
        DataSource.prototype.customVerb = function(BaseModel, config, customVerb, params, onCompletion, headerParams, dtoOptions) {
            var modelobject;
            var basemodel = new BaseModel();
            var models = [];
            var access = {};
            access[constants.ACCESS] = constants.ONLINE;
            var objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, access);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            for (var key in params) {
                dataObject.addField(key, params[key]);
            }
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.customVerb(customVerb, options, function(response) {
                if (response[config.tableName]) {
                    for (var key in response[config.tableName]) {
                        modelobject = DBAssembler.fromDBJson(BaseModel, config, response[config.tableName][key]);
                        models.push(modelobject);
                    }
                    for (var attribute in BaseModel.prototype.attributeMap) {
                        delete BaseModel.prototype.attributeMap[attribute];
                    }
                    onCompletion(kony.mvc.constants.STATUS_SUCCESS, models, null);
                } else {
                    for (var attribute in BaseModel.prototype.attributeMap) {
                        delete BaseModel.prototype.attributeMap[attribute];
                    }
                    if (response.text === null) {
                        errorObject = DBAssembler.createError(BaseModel, config, response);
                        if (errorObject.code == 300) {
                            onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject);
                        } else {
                            onCompletion(kony.mvc.constants.STATUS_SUCCESS, errorObject, null);
                        }
                    }
                    onCompletion(kony.mvc.constants.STATUS_SUCCESS, response, null);
                }
            }, function(err) {
                //callback sends status, data, error
                errorObject = DBAssembler.createError(BaseModel, config, err);
                for (var attribute in BaseModel.prototype.attributeMap) {
                    delete BaseModel.prototype.attributeMap[attribute];
                }
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject);
            });
        };
        /**
         * @function createModelResponse  converts the backend response into required models
         * @param  {Json} response  response from backend
         * @param  {BaseModel} baseModel model defination
         * @param  {Json} config    config of corresponding model
         * @return {Json} backend responde in the form of models
         */
        DataSource.prototype.createModelResponse = function(response, baseModel, config) {
            var modelresponse = {};
            for (var key in baseModel.relations) {
                var relationship = baseModel.relations[key];
                var modelstr = relationship.targetObject;
                var modeldefination = kony.mvc.MDAApplication.getSharedInstance().modelStore.getModelDefinition(modelstr);
                var configdefination = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(modelstr);
                for (var relations in relationship.relationFields) {
                    var relation = relationship.relationFields[relations];
                    var res = DataSource.prototype.createModelResponse(response, modeldefination, configdefination);
                    response[config.tableName + constants.SYMBOL_UNDERSCORE + relation.sourceField] = res;
                }
            }
            for (var column in config.mappings) {
                try {
                    modelresponse[config.mappings[column]] = response[config.tableName + constants.SYMBOL_UNDERSCORE + config.mappings[column]];
                } catch (err) {}
            }
            var modelObject = DBAssembler.fromDBJson(baseModel, config, modelresponse);
            return modelObject;
        };
        /**
         * @function getByCriteria  fetches data for the specified model based on the criteria passed
         * @param  {BaseModel} modelDefination   model defination
         * @param  {Json} config          config of corresponding model
         * @param  {Json} criteria        criteria object based on which query is build in case of ONLINE and OFFLINE
         * @param  {function} onCompletion    success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        DataSource.prototype.getByCriteria = function(modelDefination, config, criteria, onCompletion, accessMode, headerParams, dtoOptions) {
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            var modelobject;
            var models = [];
            var objSvc;
            var finalCriteria = {};
            var access = {};
            if (accessMode[constants.ACCESS] == constants.OFFLINE) {
                var queryString;
                var query = new QueryBuilder();
                var selectList = query.buildSelectList(modelDefination, config);
                var fromList = query.buildTableName(modelDefination, config);
                selectList = selectList.slice(0, -1);
                queryString = constants.SELECT_STRING + selectList + constants.FROM_STRING + fromList + constants.WHERE_STRING + query.buildConditions(criteria, config);
                var tables = [config.tableName];
                for (var key in modelDefination.relations) {
                    var relationship = modelDefination.relations[key];
                    tables.push(relationship.targetObject);
                }
                access[constants.ACCESS] = constants.OFFLINE;
                objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, access);
                objSvc.executeSelectQuery(queryString, function(response) {
                    kony.print(JSON.stringify(response));
                    var modelresponse = [];
                    for (var key in response) {
                        modelobject = DataSource.prototype.createModelResponse(response[key], modelDefination, config);
                        modelresponse.push(modelobject);
                    }
                    onCompletion(modelresponse);
                }, function(err) {
                    errorObject = DBAssembler.createError(modelDefination, config, err);
                    onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject);
                });
            } else {
                if (criteria !== undefined) {
                    if (criteria.hasOwnProperty(constants.EXPR)) {
                        if (criteria.hasOwnProperty(constants.LHS_STRING) && criteria[constants.LHS_STRING].constructor == kony.mvc.Expression) {
                            finalCriteria = DataSource.prototype.checkObj(criteria[constants.LHS_STRING], finalCriteria);
                        }
                        if (criteria.hasOwnProperty(constants.RHS_STRING) && criteria[constants.RHS_STRING].constructor == kony.mvc.Expression) {
                            finalCriteria = DataSource.prototype.checkObj(criteria[constants.RHS_STRING], finalCriteria);
                        }
                        if (!(criteria[constants.LHS_STRING].constructor == kony.mvc.Expression && criteria[constants.RHS_STRING].constructor == kony.mvc.Expression)) {
                            finalCriteria[criteria[constants.LHS_STRING]] = criteria[constants.RHS_STRING];
                        }
                    }
                }
                access[constants.ACCESS] = constants.ONLINE;
                objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, access);
                var headers = {};
                headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
                for (var headKey in headerParams) {
                    headers[headKey] = headerParams[headKey];
                }
                var dataObject = new kony.sdk.dto.DataObject(config.tableName);
                DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
                var options = {};
                options[constants.DATA_OBJECT] = dataObject;
                options[constants.HEADERS_STRING] = headers;
                options[constants.QUERY_PARAMS] = finalCriteria;
                var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
                var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
                if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
                if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
                objSvc.fetch(options, function(response) {
                    for (var key in response.records) {
                        modelobject = DBAssembler.fromDBJson(modelDefination, config, response.records[key]);
                        models.push(modelobject);
                    }
                    for (var attribute in modelDefination.prototype.attributeMap) {
                        delete modelDefination.prototype.attributeMap[attribute];
                    }
                    //callback sends status, data, error
                    onCompletion(kony.mvc.constants.STATUS_SUCCESS, models, null);
                }, function(err) {
                    //callback sends status, data, error
                    errorObject = DBAssembler.createError(modelDefination, config, err);
                    for (var attribute in modelDefination.prototype.attributeMap) {
                        delete modelDefination.prototype.attributeMap[attribute];
                    }
                    onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject);
                });
            }
        };
        /**
         * @function save saves the given model data in the backend
         * @param  {BaseModel} BaseModel    model defination
         * @param  {JSON} config       config of corresponding model
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        DataSource.prototype.save = function(BaseModel, config, onCompletion, accessMode, headerParams, dtoOptions) {
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            var dbobject = DBAssembler.toDBJson(BaseModel, config);
            for (var key in dbobject) {
                if (dbobject[key] !== null) {
                    dataObject.addField(key, dbobject[key]);
                }
            }
            var baseMap = BaseModel.attributeMap;
            if (baseMap) {
                /*Removing JSON.parse(JSON.stringify(baseMap) since it calls getters which in turn calls post processor.Internal layer should not call getters and setters.
                 **Instead of cloning, pushing all the keys in baseMap to attributeMap and then iterating over attributeMap fixes our requirement.
                 */
                var attributeMap = [];
                for (var i in baseMap) {
                    attributeMap.push(i);
                }
                for (var attribute in attributeMap) {
                    var model = baseMap[attributeMap[attribute]].model;
                    var attributeValue = baseMap[attributeMap[attribute]].value;
                    if (model) {
                        var modelArray = [];
                        var modelConfig = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(model);
                        if (Array.isArray(attributeValue)) {
                            for (var eachRecord in attributeValue) {
                                var dbobject = DBAssembler.toDBJson(attributeValue[eachRecord], modelConfig);
                                modelArray.push(dbobject);
                            }
                        } else {
                            var dbobject = DBAssembler.toDBJson(attributeValue, modelConfig);
                            modelArray.push(dbobject);
                        }
                        dataObject.addField(attributeMap[attribute], modelArray);
                    } else {
                        dataObject.addField(attributeMap[attribute], attributeValue);
                    }
                    delete BaseModel.attributeMap[attributeMap[attribute]];
                }
            }
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.create(options, function(res) {
                kony.print(constants.MESSAGE_FOR_RECORDCREATED + JSON.stringify(res));
                kony.print(constants.MESSAGE_FOR_RECORDCREATED);
                //callback sends status, data, error
                if (res.text === null) {
                    errorObject = DBAssembler.createError(BaseModel, config, response);
                    onCompletion(kony.mvc.constants.STATUS_SUCCESS, errorObject, null);
                }
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, res, null);
            }, function(err) {
                kony.print(JSON.stringify(err));
                errorObject = DBAssembler.createError(BaseModel, config, err);
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject); //callback sends status, data, error
                //onCompletion(kony.mvc.constants.STATUS_FAILURE,undefined,err);
            });
        };
        /**
         * @function partialUpdate partially update the model data to the backend
         * @param  {BaseModel} BaseModel    model defination
         * @param  {JSON} config       config of corresponding model
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        DataSource.prototype.partialUpdate = function(BaseModel, config, onCompletion, accessMode, headerParams, dtoOptions) {
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            var dbobject = DBAssembler.toDBJson(BaseModel, config);
            for (var key in dbobject) {
                if (dbobject[key] !== null) {
                    dataObject.addField(key, dbobject[key]);
                }
            }
            var baseMap = BaseModel.attributeMap;
            if (baseMap) {
                /*Removing JSON.parse(JSON.stringify(baseMap) since it calls getters which in turn calls post processor.Internal layer should not call getters and setters.
                 **Instead of cloning, pushing all the keys in baseMap to attributeMap and then iterating over attributeMap fixes our requirement.
                 */
                var attributeMap = [];
                for (var i in baseMap) {
                    attributeMap.push(i);
                }
                for (var attribute in attributeMap) {
                    var model = baseMap[attributeMap[attribute]].model;
                    var attributeValue = baseMap[attributeMap[attribute]].value;
                    if (model) {
                        var modelArray = [];
                        var modelConfig = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(model);
                        if (Array.isArray(attributeValue)) {
                            for (var eachRecord in attributeValue) {
                                var dbobject = DBAssembler.toDBJson(attributeValue[eachRecord], modelConfig);
                                modelArray.push(dbobject);
                            }
                        } else {
                            var dbobject = DBAssembler.toDBJson(attributeValue, modelConfig);
                            modelArray.push(dbobject);
                        }
                        dataObject.addField(attributeMap[attribute], modelArray);
                    } else {
                        dataObject.addField(attributeMap[attribute], attributeValue);
                    }
                    delete BaseModel.attributeMap[attributeMap[attribute]];
                }
            }
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.partialUpdate(options, function(res) {
                kony.print(constants.MESSAGE_FOR_RECORDPARIALUPDATE + JSON.stringify(res));
                kony.print(constants.MESSAGE_FOR_RECORDPARIALUPDATE);
                //callback sends status, data, error
                if (res.text === null) {
                    errorObject = DBAssembler.createError(BaseModel, config, response);
                    onCompletion(kony.mvc.constants.STATUS_SUCCESS, errorObject, null);
                }
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, res, null);
            }, function(err) {
                kony.print(JSON.stringify(err));
                errorObject = DBAssembler.createError(BaseModel, config, err);
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject); //callback sends status, data, error
            });
        };
        /**
         * @function getAll fetches  all the records for the specified model
         * @param  {BaseModel} BaseModel    model defination
         * @param  {JSON} config       config of corresponding model
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        DataSource.prototype.getAll = function(BaseModel, config, onCompletion, accessMode, headerParams, dtoOptions) {
            var modelobject;
            var models = [];
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.fetch(options, function(response) {
                for (var key in response.records) {
                    modelobject = DBAssembler.fromDBJson(BaseModel, config, response.records[key]);
                    models.push(modelobject);
                }
                for (var attribute in BaseModel.prototype.attributeMap) {
                    delete BaseModel.prototype.attributeMap[attribute];
                }
                //callback sends status, data, error
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, models, null);
            }, function(err) {
                //callback sends status, data, error
                errorObject = DBAssembler.createError(BaseModel, config, err);
                for (var attribute in BaseModel.prototype.attributeMap) {
                    delete BaseModel.prototype.attributeMap[attribute];
                }
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject); // onCompletion(kony.mvc.constants.STATUS_FAILURE,undefined,err);
            });
        };
        /**
         * @function update updates the specified model into the backend
         * @param  {BaseModel} BaseModel    model defination
         * @param  {JSON} config       config of corresponding model
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        DataSource.prototype.update = function(BaseModel, config, onCompletion, accessMode, headerParams, dtoOptions) {
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            var dbobject = DBAssembler.toDBJson(BaseModel, config);
            for (var key in dbobject) {
                if (dbobject[key] !== null) {
                    dataObject.addField(key, dbobject[key]);
                }
            }
            var baseMap = BaseModel.attributeMap;
            if (baseMap) {
                /*Removing JSON.parse(JSON.stringify(baseMap) since it calls getters which in turn calls post processor.Internal layer should not call getters and setters.
                 **Instead of cloning, pushing all the keys in baseMap to attributeMap and then iterating over attributeMap fixes our requirement.
                 */
                var attributeMap = [];
                for (var i in baseMap) {
                    attributeMap.push(i);
                }
                for (var attribute in attributeMap) {
                    var model = baseMap[attributeMap[attribute]].model;
                    var attributeValue = baseMap[attributeMap[attribute]].value;
                    if (model) {
                        var modelArray = [];
                        var modelConfig = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(model);
                        if (Array.isArray(attributeValue)) {
                            for (var eachRecord in attributeValue) {
                                var dbobject = DBAssembler.toDBJson(attributeValue[eachRecord], modelConfig);
                                modelArray.push(dbobject);
                            }
                        } else {
                            var dbobject = DBAssembler.toDBJson(attributeValue, modelConfig);
                            modelArray.push(dbobject);
                        }
                        dataObject.addField(attributeMap[attribute], modelArray);
                    } else {
                        dataObject.addField(attributeMap[attribute], attributeValue);
                    }
                    delete BaseModel.attributeMap[attributeMap[attribute]];
                }
            }
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.update(options, function(res) {
                kony.print(constants.MESSAGE_FOR_RECORDUPDATED + JSON.stringify(res));
                kony.print(constants.MESSAGE_FOR_RECORDUPDATED);
                //callback sends status, data, error
                if (res.text === null) {
                    errorObject = DBAssembler.createError(BaseModel, config, response);
                    onCompletion(kony.mvc.constants.STATUS_SUCCESS, errorObject, null);
                }
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, res, null);
            }, function(err) {
                kony.print(JSON.stringify(err));
                //callback sends status, data, error
                errorObject = DBAssembler.createError(BaseModel, config, err);
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject); //onCompletion(kony.mvc.constants.STATUS_FAILURE,undefined,err);
            });
        };
        /**
         * @function remove deletes the specified model from the backend
         * @param  {BaseModel} BaseModel    model defination
         * @param  {Json} config      config of corresponding model
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        DataSource.prototype.remove = function(BaseModel, config, onCompletion, accessMode, headerParams, dtoOptions) {
            var dbobject = DBAssembler.toDBJson(BaseModel, config);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            for (var key in dbobject) {
                if (dbobject[key] !== null) {
                    dataObject.addField(key, dbobject[key]);
                }
            }
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.deleteRecord(options, function(res) {
                kony.print(constants.MESSAGE_FOR_RECORDDELETED);
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, res, null);
            }, function(err) {
                kony.print(constants.ERROR_IN_RECORD_DELETION + JSON.stringify(err));
                errorObject = DBAssembler.createError(BaseModel, config, err);
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject); //onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, err);
            });
        };
        /**
         * @function removeById deletes the specified model from the backend
         * @param  {BaseModel} BaseModel    model defination
         * @param  {Json} config      config of corresponding model
         * @param  {function} onCompletion success callback
         * @param {JSON/STRING} primaryKey primary key value or json representing the key and value
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        DataSource.prototype.removeById = function(BaseModel, config, primaryKey, onCompletion, accessMode, headerParams, dtoOptions) {
            var modelobject;
            var primaykeyobj = {};
            var primarykey;
            if (primaryKey == null || primaryKey == '' || primaryKey == undefined) {
                throw new Exception('ERROR_CODE_500', 'Invalid  Primary Key');
            }
            if (primaryKey.constructor == {}.constructor) {
                primaykeyobj = primaryKey;
            } else {
                for (var key in config.primaryKeys) {
                    primarykey = config.primaryKeys[key];
                    primaykeyobj[primarykey] = primaryKey;
                }
            }
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            var keys = Object.keys(primaykeyobj);
            for (var records in keys) {
                dataObject.addField(keys[records], primaykeyobj[keys[records]]);
            }
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            //options[constants.QUERY_PARAMS]= primaykeyobj;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.deleteRecord(options, function(res) {
                kony.print(constants.MESSAGE_FOR_RECORDDELETED);
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, res, null);
            }, function(err) {
                kony.print(constants.ERROR_IN_RECORD_DELETION + JSON.stringify(err));
                errorObject = DBAssembler.createError(BaseModel, config, err);
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject); // onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, err);
            });
        };
        DataSource.prototype.addOptionsToDTO = function(dataObject, dtoOptions) {
            for (var key in dtoOptions) {
                dataObject[key] = dtoOptions[key];
            }
        };
        return DataSource;
    }(DataModel_QueryBuilder, DataModel_constants, DataModel_DBAssembler);
    DataModel_BaseRepository = function(DataSource) {
        function BaseRepository(modelDefinition, config, injectedDataSource) {
            this.modelDefinition = modelDefinition;
            this.config = config;
            this.datasource = injectedDataSource || new DataSource();
            this.headerParams = null;
        }
        /**
         * @function initialize initalize the base repository
         * @param  {JSON} context 
         * @return 
         */
        BaseRepository.prototype.initialize = function(context) {};
        /**
         * @function save saves the given model data in the backend
         * @param  {BaseModel} modelInstance model object
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseRepository.prototype.save = function(modelInstance, onCompletion, accessMode, options) {
            this.datasource.save(modelInstance, this.config, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function update updates the specified model into the backend
         * @param  {BaseModel} modelInstance model object
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseRepository.prototype.update = function(modelInstance, onCompletion, accessMode, options) {
            this.datasource.update(modelInstance, this.config, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function partialUpdate partially update the model data to the backend
         * @param  {BaseModel} modelInstance model object
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        BaseRepository.prototype.partialUpdate = function(modelInstance, onCompletion, accessMode, options) {
            this.datasource.partialUpdate(modelInstance, this.config, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function remove deletes the specified model from the backend
         * @param  {BaseModel} modelInstance model object
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseRepository.prototype.remove = function(modelInstance, onCompletion, accessMode, options) {
            this.datasource.remove(modelInstance, this.config, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function removeById deletes the specified model from the backend
         * @param  {BaseModel} modelInstance model object
         * @param {JSON/STRING} primaryKey primary key value or json representing the key and value
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseRepository.prototype.removeById = function(modelInstance, primaryKey, onCompletion, accessMode, options) {
            this.datasource.removeById(modelInstance, this.config, primaryKey, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function getByPrimaryKey  fetches data for the specified model based on the primary keys
         * @param  {String/JSON} primaryKey   primitive in case of one primary key and json in case of composite primary key
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        BaseRepository.prototype.getByPrimaryKey = function(PrimaryKey, onCompletion, accessMode, options) {
            this.datasource.getByPrimaryKey(this.modelDefinition, this.config, PrimaryKey, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function getAll fetches  all the records for the specified model
         * @param  {type} onCompletion success callback
         * @param  {type} accessMode   json specifing access mode
         * @return 
         */
        BaseRepository.prototype.getAll = function(onCompletion, accessMode, options) {
            this.datasource.getAll(this.modelDefinition, this.config, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function customVerb fetches data for the specified model using specified customVerb
         * @param  {String} customVerb   name of the custom verb to be executed
         * @param  {JSON} params       parameters in the form of key value pairs
         * @param  {function} onCompletion success callback
         * @return 
         */
        BaseRepository.prototype.customVerb = function(customVerb, params, onCompletion, options) {
            this.datasource.customVerb(this.modelDefinition, this.config, customVerb, params, onCompletion, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function getByCriteria  fetches data for the specified model based on the criteria passed
         * @param  {Json} criteria        criteria object based on which query is build in case of online and offline
         * @param  {function} onCompletion    success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseRepository.prototype.getByCriteria = function(criteria, onCompletion, accessMode, options) {
            this.datasource.getByCriteria(this.modelDefinition, this.config, criteria, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        BaseRepository.prototype.setHeaderParams = function(headers) {
            this.headerParams = headers;
        };
        BaseRepository.prototype.clearHeaderParams = function() {
            this.headerParams = null;
        };
        return BaseRepository;
    }(DataModel_DataSource);
    DataModel_RepositoryManager = function(BaseRepository) {
        RepositoryManager = function() {
            this.repoMap = {};
            this.repo = undefined;
            this.repoConfig = undefined;
            this.initializeRepoConfig('RepoManagerConfig');
        };
        RepositoryManager.prototype.initialize = function(context) {};
        /**
         * @function initializeRepoConfig intializes repoManagerConfig which is generated 
         * @param  {String} repoconfig repoManagerConfig file name
         * @return 
         */
        RepositoryManager.prototype.initializeRepoConfig = function(repoconfig) {
            this.repoConfig = require(repoconfig);
        };
        /**
         * @function getRepository
         * @param  {String} model model name as per repoManagerConfig file
         * @return {BaseRepository} repository for given model
         */
        RepositoryManager.prototype.getRepository = function(model) {
            var repo = this.repoMap[model];
            if (repo === undefined) {
                var modelConfig = this.repoConfig[model];
                var modelPath = modelConfig['model'];
                var configPath = modelConfig['config'];
                var repoPath = modelConfig['repository'];
                var repository;
                if (repoPath == '') {
                    repository = BaseRepository;
                } else {
                    repository = require(repoPath);
                }
                this.setRepository(model, modelPath, configPath, repository);
            }
            return this.repoMap[model];
        };
        /**
         * @function getAllRepository gives all the repositories which are set in repository manager
         * @return {Array} list of repositories
         */
        RepositoryManager.prototype.getAllRepository = function() {
            var repositories = [];
            for (var model in this.repoMap) {
                repositories.push(this.repoMap[model]);
            }
            return repositories;
        };
        /**
         * @function setRepository sets repository in repository manager
         * @param  {String} modelName       name of model as per repoManagerConfig file
         * @param  {String} modelPath       Path of model which used to require the corresponding model 
         * @param  {String} configPath      Path of config which used to require the corresponding config
         * @param  {function} ModelRepository repository defination
         * @return 
         */
        RepositoryManager.prototype.setRepository = function(modelName, modelPath, configPath, ModelRepository) {
            var model = require(modelPath);
            var config = require(configPath);
            var repository = new ModelRepository(model, config);
            this.repoMap[modelName] = repository;
        };
        return RepositoryManager; //}();
    }(DataModel_BaseRepository);
    PresentationController_MDABasePresenter = function() {
        function MDABasePresenter() {
            this.navigator = null;
            this.businessController = null;
            this.superParams = {
                counter: 0,
                level: null,
                refStack: []
            };
            this.initialize();
        }
        MDABasePresenter.prototype.initialize = function() {};
        MDABasePresenter.prototype.asyncUpdateUI = function(uiTag, context) {
            var formInStack = false;
            for (var i = 0; i < this._presentationStack.length; i++) {
                if (this._presentationStack[i].formName == uiTag) {
                    formInStack = true;
                    break;
                }
            }
            if (formInStack) {
                var controller = _kony.mvc.GetController(uiTag, true);
                controller.updateUI(context);
            } else {
                kony.print('## MDA: Trying to asyncUpdateUI. Can\'t find the FORM: ' + uiTag + ' as Loaded.');
            }
        };
        MDABasePresenter.prototype.presentUserInterface = function(uiTag, context, isBack) {
            isBack = isBack ? isBack : false;
            if (!isBack) {
                this._pushToPresentationStack(this, uiTag, context);
            }
            //TO DO: Will move to individial Derived class
            this.navigator.presentUserInterface(uiTag, context);
        };
        MDABasePresenter.prototype._onEventRaised = function(sender, eventId, eventContext) {
            if ('on' + eventId in this) {
                this['on' + eventId].call(this, sender, eventContext);
            } else {
                this.onEventRaised(sender, eventId, eventContext);
            }
        };
        MDABasePresenter.prototype.onEventRaised = function(sender, eventId, eventContext) {};
        MDABasePresenter.prototype._presentationStack = [];
        MDABasePresenter.prototype._createPresentationStackObject = function(presenter, formName, context) {
            var stackObj = {};
            stackObj.presenter = presenter;
            stackObj.formName = formName;
            stackObj.context = context;
            return stackObj;
        };
        MDABasePresenter.prototype._pushToPresentationStack = function(presenter, formName, context) {
            if (this._presentationStack.length != 0) {
                var top = this._presentationStack.length - 1;
                var topStackObj = this._presentationStack[top];
                if (topStackObj.formName == formName) {
                    topStackObj.context = context;
                } else {
                    this._presentationStack.push(this._createPresentationStackObject(presenter, formName, context));
                }
            } else {
                this._presentationStack.push(this._createPresentationStackObject(presenter, formName, context));
            }
        };
        MDABasePresenter.prototype._popFromPresentationStack = function() {
            var poppedStackObject = this._presentationStack.pop();
            var stackLength = this._presentationStack.length;
            if (stackLength != 0) return this._presentationStack[stackLength - 1];
            else return null;
        };
        MDABasePresenter.prototype.clearPresentationStackUntil = function(formName) {
            if (formName) {
                var top = this._presentationStack.length - 1;
                while (this._presentationStack[top].formName != formName) {
                    this._presentationStack.pop();
                    top -= 1;
                }
            } else {
                kony.print('mention form name parameter to clear until that object in stack');
            }
        };
        MDABasePresenter.prototype.presentPreviousScreen = function(context) {
            var previousStackContext = this._popFromPresentationStack();
            if (previousStackContext) {
                var presenter = previousStackContext.presenter;
                var formName = previousStackContext.formName;
                var context = context ? context : previousStackContext.context;
                presenter.presentUserInterface(formName, context, true);
            } else {
                kony.print('No previous forms available');
            }
        };
        MDABasePresenter.prototype.attachBackPresentationFlow = function(formName, context) {
            this._pushToPresentationStack(this, formName, context);
        };
        MDABasePresenter.prototype.detachFromPresentationFlow = function(formName) {
            var poppedArray = [];
            var top = this._presentationStack.length - 1;
            while (this._presentationStack[top].formName != formName) {
                var poppedObject = this._presentationStack.pop();
                poppedArray.push(poppedObject);
                top -= 1;
            }
            //Removing the from
            this._presentationStack.pop();
            Array.prototype.push.apply(this._presentationStack, poppedArray);
        };
        MDABasePresenter.prototype.getCurrentForm = function() {
            var top = this._presentationStack.length - 1;
            var topStackObj = this._presentationStack[top];
            return topStackObj.formName;
        };
        MDABasePresenter.prototype.super = function(methodName, argList) {
            var scope = this;
            var returnValue = null;
            if (this.superParams.level === null) {
                this.superParams.level = 0;
                while (scope['extensionLevel' + this.superParams.level.toString()]) {
                    this.superParams.level++;
                }
            }
            if (this.superParams.counter === 0) {
                for (var i = 0; i < this.superParams.level; i++) {
                    if (scope['extensionLevel' + i.toString()][methodName]) {
                        this.superParams.refStack.push(i);
                    }
                }
            }
            this.superParams.refStack.pop();
            if (this.superParams.refStack.length !== 0) {
                var callLvl = this.superParams.refStack[this.superParams.refStack.length - 1];
                this.superParams.counter++;
                returnValue = scope['extensionLevel' + callLvl.toString()][methodName].apply(this, argList);
                this.superParams.counter--;
            } else {
                kony.print('#MDA2 : Can\'t find any super for the ' + methodName + ' Method.');
            }
            if (this.superParams.counter === 0) {
                this.superParams.refStack = [];
                this.superParams.level = null;
            }
            return returnValue;
        };
        return MDABasePresenter;
    }();
    BaseNavigator_MDABaseNavigator = function() {
        function MDABaseNavigator() {
            this.presentationController = null;
            this.config = null;
            this.initialize();
        }
        MDABaseNavigator.prototype.initialize = function() {};
        MDABaseNavigator.prototype.presentUserInterface = function(uiTag, context) {
            var formToPresent = uiTag;
            this.presentForm(formToPresent, uiTag, context);
        };
        MDABaseNavigator.prototype.presentForm = function(form, uiTag, viewModel) {
            var context = {};
            context['viewModel'] = viewModel;
            context._presenter = this.presentationController;
            var config = this.getConfig(form);
            context._formConfig = config;
            var _currentForm = kony.application.getCurrentForm();
            if (_currentForm && form == _currentForm.id) {
                var controller = _kony.mvc.GetController(form, true);
                controller.updateUI(context['viewModel']);
            } else {
                try {
                    var frmNavObject = new kony.mvc.Navigation(form);
                    frmNavObject.navigate(context);
                } catch (err) {
                    throw new Exception('ERROR_CODE_300', 'Error at Navigator, Missing or Wrong UITag : ' + err);
                }
            }
        };
        MDABaseNavigator.prototype.getConfig = function(form) {
            var name;
            try {
                this.name = eval(form + 'Config');
            } catch (err) {
                return null;
            }
            return this.name;
        };
        return MDABaseNavigator;
    }();
    ModuleManager_MDAModule = function(MDABasePresenter, MDABaseNavigator, BusinessController, constants, BusinessDelegator) {
        function MDAModule(moduleName, moduleMode, channel, callback, isStartup) {
            this.businessController = null;
            this.presentationController = null;
            this.navigator = null;
            this.moduleName = moduleName;
            this.channel = channel;
            try {
                this.moduleConfig = eval(this.moduleName + 'Config');
                if (this.moduleConfig[moduleMode]) {
                    this.moduleConfig = this.moduleConfig[moduleMode];
                    this.moduleMode = moduleMode;
                } else {
                    this.moduleMode = 'Default';
                    kony.print('MDA2***..module: ' + moduleName + '- Default Mode');
                }
            } catch (e) {
                throw new Exception('ERROR_CODE_600', 'Module Config expected ' + e);
            }
            if (isStartup == 1) {
                this.setStartupModule(callback);
            } else {
                this.setupModule(callback);
            }
        }
        MDAModule.prototype.setStartupModule = function(callback) {
            kony.print('MDA2*** Setup Startup module');
            if (callback !== undefined) {
                this.setUpBusinessPresentationController(callback);
                this.setUpNavigator();
            } else {
                this.setUpBusinessController();
                this.setUpPresentationController();
                this.setUpNavigator();
                this.presentationController.navigator = this.navigator;
                this.presentationController.businessController = this.businessController;
                this.navigator.presentationController = this.presentationController;
            }
        };
        MDAModule.prototype.setupModule = function(callback) {
            kony.print('MDA2*** Setup module');
            if (callback !== undefined) {
                this.setUpForms();
                this.setUpBusinessPresentationController(callback);
                this.setUpNavigator();
            } else {
                this.setUpForms();
                this.setUpBusinessController();
                this.setUpPresentationController();
                this.setUpNavigator();
                this.presentationController.navigator = this.navigator;
                this.presentationController.businessController = this.businessController;
                this.navigator.presentationController = this.presentationController;
            }
        };
        MDAModule.prototype.setUpBusinessPresentationController = function(callback) {
            if (this.moduleConfig === undefined) {
                this.businessController = this.createBusinessController();
                this.presentationController = this.createPresentationController();
                if (this.businessController === null && this.presentationController === null) {
                    kony.print('MDA2*** Derived module does not provide a Business controller');
                    this.businessController = this.createDefaultBusinessController();
                }
            } else {
                var businessControllerClass, presentationControllerClass, businessExtensions, presentationExtensions;
                if (this.moduleConfig.BusinessControllerConfig) {
                    businessControllerClass = this.moduleConfig.BusinessControllerConfig.BusinessControllerClass;
                    if (this.moduleConfig.BusinessControllerConfig.CommandHandler) {
                        var commandHandlers = this.moduleConfig.BusinessControllerConfig.CommandHandler;
                        var handlersarray = [],
                            commandId = [],
                            commandHandlerExtn = [];
                        for (var i = 0; i < commandHandlers.length; i++) {
                            commandId[i] = commandHandlers[i].CommandId;
                            commandHandlerExtn[i] = commandHandlers[i].CommandHandlerExtension;
                            handlersarray[i] = commandHandlers[i].CommandHandler;
                        }
                    }
                }
                if (this.moduleConfig.BusinessControllerConfig.BusinessExtensions) businessExtensions = this.moduleConfig.BusinessControllerConfig.BusinessExtensions;
                //If buisnessController class is not supplied in config file, 
                //create from derived module else default Buisness controller
                var currentChannel = kony.sdk.getChannelType();
                //TO DO: Platform team to generate channel correctly
                currentChannel = currentChannel.charAt(0).toUpperCase() + currentChannel.slice(1);
                if (this.channel === undefined) {
                    if (this.moduleConfig.PresentationControllerConfig) {
                        var defaultPresentation = this.moduleConfig.PresentationControllerConfig['Default'];
                        var channelPresentation = this.moduleConfig.PresentationControllerConfig[currentChannel];
                        this.channel = channelPresentation ? currentChannel : 'Default';
                        presentationControllerClass = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationControllerClass;
                        presentationExtensions = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationExtensions;
                    } else presentationControllerClass = undefined;
                } else {
                    if (this.moduleConfig.PresentationControllerConfig && this.moduleConfig.PresentationControllerConfig[this.channel]) {
                        presentationControllerClass = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationControllerClass;
                        presentationExtensions = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationExtensions;
                    } else presentationControllerClass = undefined;
                }
                if (businessControllerClass === undefined || businessControllerClass === '' || presentationControllerClass === undefined || presentationControllerClass === '') {
                    kony.print(' MDA2*** Config does not provide a Business controller');
                    kony.print('MDA2*** Config does not provide a Presentation controller');
                    this.businessController = this.createBusinessController();
                    this.presentationController = this.createPresentationController();
                    if (this.businessController === null && this.presentationController === null) {
                        kony.print('MDA2*** Derived module does not provide a Business controller');
                        this.businessController = this.createDefaultBusinessController();
                        kony.print('MDA2*** Derived module does not provide a Presentation controller');
                        this.presentationController = this.createDefaultPresentationController();
                    }
                } else {
                    kony.print('MDA2*** Config  provides a Presentation controller');
                    try {
                        var pController, bController;
                        var self = this;
                        var params = [
                            presentationControllerClass,
                            businessControllerClass
                        ];
                        params = params.concat(businessExtensions);
                        params = params.concat(presentationExtensions);
                        if (handlersarray) params = params.concat(handlersarray);
                        if (commandHandlerExtn) params = params.concat(commandHandlerExtn);
                        var DerivedController = require(params, function() {
                            presentationControllerClass = arguments[0];
                            businessControllerClass = arguments[1];
                            pController = new presentationControllerClass();
                            bController = new businessControllerClass();
                            self.presentationController = pController;
                            self.businessController = bController;
                            self.navigator.presentationController = self.presentationController;
                            self.presentationController.businessController = self.businessController;
                            self.presentationController.navigator = self.navigator;

                            function Callback() {
                                callback(self);
                            }
                            self.createPresentationExtensionsAsync(function() {
                                if (BusinessController.prototype.isPrototypeOf(bController)) {
                                    self.createCommandHandlers(Callback);
                                } else {
                                    self.createBusinessExtensionsAsync(businessExtensions, Callback);
                                } //callback(self);
                            });
                            kony.print('MDA2*** Config  provides a Business controller');
                        });
                    } catch (err) {
                        throw new Exception('ERROR_CODE_300', ' Invalid Presentation Controller Class ' + err);
                    }
                }
            }
        };
        MDAModule.prototype.createBusinessExtensionsAsync = function(businessExtensions, callback) {
            var self = this;
            if (businessExtensions !== undefined) {
                var extNModule;
                try {
                    (function() {
                        return this;
                    }()['require'](businessExtensions, function() {
                        extNModule = [self.businessController].concat(Array.prototype.slice.call(arguments));
                        kony.print('MDA2**** extNModule : ' + extNModule);
                        _kony.mvc.assignFunctions2Controller(self.businessController, extNModule);
                        callback(self);
                    }));
                } catch (err) {
                    throw new Exception('ERROR_CODE_300', 'Business Controller Extension invalid ' + err);
                }
                kony.print('MDA2**** extNModule : ' + extNModule);
            } else {
                callback(self);
                kony.print('MDA2**** invalid businessExtensions: ' + businessExtensions);
            }
        };
        MDAModule.prototype.createPresentationExtensionsAsync = function(callback) {
            var self = this;
            if (this.moduleConfig !== undefined) {
                var presentationExtensions;
                if (this.channel === undefined) {
                    extChannel = 'Default';
                }
                if (this.moduleConfig.PresentationControllerConfig && this.moduleConfig.PresentationControllerConfig[this.channel]) presentationExtensions = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationExtensions;
                if (presentationExtensions !== undefined) {
                    var extNModule;
                    try {
                        (function() {
                            return this;
                        }()['require'](presentationExtensions, function() {
                            extNModule = [self.presentationController].concat(Array.prototype.slice.call(arguments));
                            kony.print('MDA2**** extNModule : ' + extNModule);
                            _kony.mvc.assignFunctions2Controller(self.presentationController, extNModule);
                            callback();
                        }));
                    } catch (err) {
                        throw new Exception('ERROR_CODE_300', 'Presentation Controller Extension invalid ' + err);
                    }
                }
            }
        };
        MDAModule.prototype.setUpBusinessController = function() {
            if (this.moduleConfig === undefined) {
                this.businessController = this.createBusinessController();
                if (this.businessController === null) {
                    kony.print('MDA2*** Derived module does not provide a Business controller');
                    this.businessController = this.createDefaultBusinessController();
                }
            } else {
                var businessControllerClass;
                if (this.moduleConfig.BusinessControllerConfig) businessControllerClass = this.moduleConfig.BusinessControllerConfig.BusinessControllerClass;
                //If buisnessController class is not supplied in config file, 
                //create from derived module else default Buisness controller
                if (businessControllerClass === undefined || businessControllerClass === '') {
                    kony.print(' MDA2*** Config does not provide a Business controller');
                    this.businessController = this.createBusinessController();
                    if (this.businessController === null) {
                        kony.print('MDA2*** Derived module does not provide a Business controller');
                        this.businessController = this.createDefaultBusinessController();
                    }
                } else {
                    kony.print('MDA2*** Config  provides a Business controller');
                    try {
                        var DerivedBusinessController = require(businessControllerClass);
                        this.businessController = new DerivedBusinessController();
                    } catch (err) {
                        throw new Exception('ERROR_CODE_300', 'Invalid Business Controller Class ' + err);
                    }
                }
            }
            if (BusinessController.prototype.isPrototypeOf(this.businessController)) {
                this.createCommandHandlers();
            } else {
                this.createBusinessExtensions();
            }
        };
        MDAModule.prototype.setUpPresentationController = function() {
            if (this.moduleConfig === undefined) {
                this.presentationController = this.createPresentationController();
                if (this.presentationController === null) {
                    kony.print('MDA2*** Derived module does not provide a Presentation controller');
                    this.presentationController = this.createDefaultPresentationController();
                }
            } else {
                var presentationControllerClass;
                var currentChannel = kony.sdk.getChannelType();
                //TO DO: Platform team to generate channel correctly
                currentChannel = currentChannel.charAt(0).toUpperCase() + currentChannel.slice(1);
                if (this.channel === undefined) {
                    if (this.moduleConfig.PresentationControllerConfig) {
                        var defaultPresentation = this.moduleConfig.PresentationControllerConfig['Default'];
                        var channelPresentation = this.moduleConfig.PresentationControllerConfig[currentChannel];
                        this.channel = channelPresentation ? currentChannel : 'Default';
                        presentationControllerClass = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationControllerClass;
                    } else presentationControllerClass = undefined;
                } else {
                    if (this.moduleConfig.PresentationControllerConfig && this.moduleConfig.PresentationControllerConfig[this.channel]) presentationControllerClass = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationControllerClass;
                    else presentationControllerClass = undefined;
                }
                if (presentationControllerClass === undefined || presentationControllerClass === '') {
                    kony.print('MDA2*** Config does not provide a Presentation controller');
                    this.presentationController = this.createPresentationController();
                    if (this.presentationController === null) {
                        kony.print('MDA2*** Derived module does not provide a Presentation controller');
                        this.presentationController = this.createDefaultPresentationController();
                    }
                } else {
                    kony.print('MDA2*** Config  provides a Presentation controller');
                    try {
                        var DerivedPresentationController = require(presentationControllerClass);
                        this.presentationController = new DerivedPresentationController();
                    } catch (err) {
                        throw new Exception('ERROR_CODE_300', ' Invalid Presentation Controller Class ' + err);
                    }
                }
            }
            this.createPresentationExtensions();
        };
        MDAModule.prototype.setUpNavigator = function() {
            this.navigator = this.createNavigator();
            if (this.navigator === null) {
                this.navigator = this.createDefaultNavigator();
            }
        };
        MDAModule.prototype.setUpForms = function() {
            if (this.moduleConfig !== undefined) {
                var forms = this.moduleConfig.Forms;
                var channel = kony.sdk.getChannelType();
                //Call some API here
                if (forms && channel && forms[channel]) {
                    var formsList = Object.keys(forms[channel]);
                    for (var eachForm in formsList) {
                        if (kony.mvc.registry.getControllerType(eachForm) != constants.FORM_CONTROLLER_TYPE) {
                            var formNameKey = formsList[eachForm];
                            var formPath = forms[channel][formNameKey].FormName;
                            var friendlyName = forms[channel][formNameKey].friendlyName || formPath;
                            var controller = forms[channel][formNameKey].Controller;
                            var formController = forms[channel][formNameKey].FormController;
                            var controllerExtensions = forms[channel][formNameKey].ControllerExtensions;
                            var controllerExtName = [];
                            Array.prototype.push.apply(controllerExtName, controllerExtensions);
                            kony.mvc.registry.remove(friendlyName);
                            kony.mvc.registry.add(friendlyName, formPath, {
                                'controllerName': controller,
                                'controllerType': formController,
                                'controllerExtName': controllerExtName
                            });
                        }
                    }
                }
            }
        };
        MDAModule.prototype.createBusinessController = function() {
            return null;
        };
        MDAModule.prototype.createPresentationController = function() {
            return null;
        };
        MDAModule.prototype.createNavigator = function() {
            return null;
        };
        MDAModule.prototype.createDefaultNavigator = function() {
            return new MDABaseNavigator();
        };
        MDAModule.prototype.createDefaultBusinessController = function() {
            var businessController = new BusinessController();
            return businessController;
        };
        MDAModule.prototype.createDefaultPresentationController = function() {
            var presentationController = new MDABasePresenter();
            return presentationController;
        };
        MDAModule.prototype.createCommandHandlers = function(callback) {
            if (this.moduleConfig !== undefined && this.moduleConfig.BusinessControllerConfig) {
                var commandHandlers = this.moduleConfig.BusinessControllerConfig.CommandHandler;
                kony.print(commandHandlers);
                this.businessController.registerCommandHandlers(commandHandlers, callback);
                if (callback) {
                    callback();
                }
            }
        };
        MDAModule.prototype.createPresentationExtensions = function() {
            if (this.moduleConfig !== undefined) {
                var presentationExtensions;
                if (this.channel === undefined) {
                    extChannel = 'Default';
                }
                if (this.moduleConfig.PresentationControllerConfig && this.moduleConfig.PresentationControllerConfig[this.channel]) presentationExtensions = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationExtensions;
                if (presentationExtensions !== undefined) {
                    var extNModule = [];
                    extNModule.push(this.presentationController);
                    for (var i = 0; i < presentationExtensions.length; i++) {
                        try {
                            extNModule.push(require(presentationExtensions[i]));
                        } catch (err) {
                            throw new Exception('ERROR_CODE_300', 'Presentation Controller Extension invalid ' + err);
                        }
                        kony.print('MDA2**** extNModule : ' + extNModule);
                    }
                    _kony.mvc.assignFunctions2Controller(this.presentationController, extNModule);
                } else {
                    kony.print('MDA2**** invalid presentationExtensions: ' + presentationExtensions);
                }
            }
        };
        MDAModule.prototype.createBusinessExtensions = function() {
            if (this.moduleConfig !== undefined) {
                var businessExtensions;
                if (this.moduleConfig.BusinessControllerConfig.BusinessExtensions) businessExtensions = this.moduleConfig.BusinessControllerConfig.BusinessExtensions;
                if (businessExtensions !== undefined) {
                    var extNModule = [];
                    extNModule.push(this.businessController);
                    for (var i = 0; i < businessExtensions.length; i++) {
                        try {
                            extNModule.push(require(businessExtensions[i]));
                        } catch (err) {
                            throw new Exception('ERROR_CODE_300', 'Business Controller Extension invalid ' + err);
                        }
                        kony.print('MDA2**** extNModule : ' + extNModule);
                    }
                    _kony.mvc.assignFunctions2Controller(this.businessController, extNModule);
                } else {
                    kony.print('MDA2**** invalid businessExtensions: ' + businessExtensions);
                }
            }
        };
        return MDAModule;
    }(PresentationController_MDABasePresenter, BaseNavigator_MDABaseNavigator, BusinessController_BusinessController, DataModel_constants, BusinessController_BusinessDelegator);
    ModuleManager_MDAModuleManager = function(MDAModule) {
        function MDAModuleManager() {
            this.moduleMap = {};
            this.initialize();
        }
        MDAModuleManager.prototype.initialize = function() {};
        MDAModuleManager.prototype.loadModule = function(moduleName, moduleMode, channel, callback) {
            if (moduleMode == null) moduleMode = 'Default';
            kony.print('MDA2***..loadModule: ' + moduleName + '-' + moduleMode + 'Mode');
            var self = this;
            if (!this.moduleMap[moduleName]) {
                var module = null;
                var moduleConfig;
                try {
                    moduleConfig = eval(this.moduleName + 'Config');
                } catch (e) {}
                if (moduleConfig !== undefined) {
                    var moduleClass = moduleConfig.ModuleClass;
                    if (moduleClass !== undefined || moduleClass !== '') {
                        var Module = require(moduleClass);
                        module = new Module(moduleName, moduleMode, channel, callback);
                        this.moduleMap[moduleName] = module;
                    } else {
                        if (callback !== undefined) {
                            new MDAModule(moduleName, moduleMode, channel, function(module) {
                                self.moduleMap[moduleName] = module;
                                callback(module);
                            });
                        } else {
                            module = new MDAModule(moduleName, moduleMode, channel, callback);
                            this.moduleMap[moduleName] = module;
                        }
                    }
                } else {
                    var self = this;
                    if (callback !== undefined) {
                        new MDAModule(moduleName, moduleMode, channel, function(module) {
                            self.moduleMap[moduleName] = module;
                            callback(module);
                        });
                    } else {
                        module = new MDAModule(moduleName, moduleMode, channel, callback);
                        this.moduleMap[moduleName] = module;
                    }
                }
            }
        };
        MDAModuleManager.prototype.getModule = function(moduleName, moduleMode, channel, callback) {
            // kony.print('Returned MDA2*** Module: ' + moduleName + '-' + this.moduleMap[moduleName].moduleMode + ' Mode Instance');
            if (!this.moduleMap[moduleName]) {
                this.loadModule(moduleName, moduleMode, channel, callback);
                return this.moduleMap[moduleName];
            } else {
                if (callback === undefined) {
                    return this.moduleMap[moduleName];
                } else {
                    callback(this.moduleMap[moduleName]);
                }
            }
        };
        MDAModuleManager.prototype.loadStartupModule = function(moduleName, moduleMode, channel, callback) {
            if (moduleMode == null) moduleMode = 'Default';
            kony.print('MDA2***..loadStartupModule: ' + moduleName + '-' + moduleMode + 'Mode');
            var self = this;
            var isStartup = 1;
            if (!this.moduleMap[moduleName]) {
                var module = null;
                var moduleConfig;
                try {
                    moduleConfig = eval(this.moduleName + 'Config');
                } catch (e) {}
                if (moduleConfig !== undefined) {
                    var moduleClass = moduleConfig.ModuleClass;
                    if (moduleClass !== undefined || moduleClass !== '') {
                        var Module = require(moduleClass);
                        module = new Module(moduleName, moduleMode, channel, callback, isStartup);
                        this.moduleMap[moduleName] = module;
                    } else {
                        if (callback !== undefined) {
                            new MDAModule(moduleName, moduleMode, channel, function(module) {
                                self.moduleMap[moduleName] = module;
                                callback(module);
                            }, isStartup);
                        } else {
                            module = new MDAModule(moduleName, moduleMode, channel, callback, isStartup);
                            this.moduleMap[moduleName] = module;
                        }
                    }
                } else {
                    var self = this;
                    if (callback !== undefined) {
                        new MDAModule(moduleName, moduleMode, channel, function(module) {
                            self.moduleMap[moduleName] = module;
                            callback(module);
                        }, isStartup);
                    } else {
                        module = new MDAModule(moduleName, moduleMode, channel, callback, isStartup);
                        this.moduleMap[moduleName] = module;
                    }
                }
            }
        };
        MDAModuleManager.prototype.getStartupModule = function(moduleName, moduleMode, channel, callback) {
            if (!this.moduleMap[moduleName]) {
                this.loadModule(moduleName, moduleMode, channel, callback);
                return this.moduleMap[moduleName];
            } else {
                if (callback === undefined) {
                    return this.moduleMap[moduleName];
                } else {
                    callback(this.moduleMap[moduleName]);
                }
            }
        };
        return MDAModuleManager;
    }(ModuleManager_MDAModule);
    UIBinder_UIBinder = function() {
        var includesInArray = function(array, obj) {
            if (Array.isArray(array)) {
                for (var ele in array) {
                    if (obj == array[ele]) {
                        return true;
                    }
                }
            }
            return false;
        };

        function UIBinder() {
            this.map = {};
        }
        UIBinder.prototype.registerWidgetMapper = function(widgetType, widgetDataMapper) {
            //Mapping widget with its mapper
            this.map[widgetType.toLowerCase()] = widgetDataMapper;
        };
        UIBinder.prototype.mapWidgetData = function(config, data, form, widgetId) {
            var dataModelKeys = Object.keys(data);
            var widgetDataModel = config[widgetId].entityId;
            for (var eachDataModel in dataModelKeys) {
                if (widgetDataModel == dataModelKeys[eachDataModel]) {
                    screenRefreshFlag = true;
                    var componentTag = config[widgetId].componentId;
                    var widget;
                    if (componentTag) widget = form[componentTag][widgetId];
                    else widget = form[widgetId];
                    var widgetConfig = config[widgetId];
                    widgetConfig['widgetId'] = widgetId;
                    var widgetType = widgetConfig.widgetType.toLowerCase();
                    if (widgetType in this.map) {
                        var mapper = this.map[widgetType];
                        try {
                            mapper.mapData(widgetConfig, data, widget);
                        } catch (err) {
                            kony.print('Widget Data Mapper error while mapping: ' + err);
                        }
                    } else {
                        kony.print('Widget doesn\'t exist with UIBinder ' + widgetType);
                    }
                } else {
                    kony.print('View Model ' + dataModelKeys[eachDataModel] + ' is not for widget:' + widgetId + ' with View Model:' + widgetDataModel);
                }
            }
        };
        UIBinder.prototype.mapData = function(config, data, form, groupSelect) {
            if (config && data) {
                if (config.groups) {
                    for (var groupId in config.groups) {
                        if (groupSelect) {
                            if (includesInArray(groupSelect, groupId) || groupId === groupSelect) {
                                for (var widgetid in config.groups[groupId]) {
                                    this.mapWidgetData(config.groups[groupId], data, form, widgetid);
                                }
                            }
                        } else {
                            for (var widgetid in config.groups[groupId]) {
                                this.mapWidgetData(config.groups[groupId], data, form, widgetid);
                            }
                        }
                    }
                    if (config.widgets === null || config.widgets === undefined) {
                        config.widgets = {};
                    }
                }
                if (config.widgets) {
                    for (var widgetId in config.widgets) {
                        this.mapWidgetData(config.widgets, data, form, widgetId);
                    }
                } else {
                    //Config Format Old
                    var newConfig = {};
                    //Setting the formid to formId
                    newConfig['formId'] = config['formid'];
                    delete config.formid;
                    //Getting Object Service name, online/offline, entity details
                    newConfig['objectServiceName'] = config[newConfig.formId]['objectServiceName'];
                    newConfig['objectServiceOptions'] = config[newConfig.formId]['objectServiceOptions'];
                    newConfig['entityId'] = config[newConfig.formId]['entity'];
                    delete config[newConfig.formId];
                    //Add widgets object
                    newConfig['widgets'] = {};
                    //Adding widgets to config
                    for (var widget in config) {
                        newConfig.widgets[widget] = {};
                        newConfig.widgets[widget]['widgetType'] = config[widget].fieldprops.widgettype.toLowerCase();
                        newConfig.widgets[widget]['entityId'] = config[widget].fieldprops.entity;
                        if (config[widget].fieldprops.widgettype.toLowerCase() == 'segment') {
                            newConfig.widgets[widget]['objectServiceName'] = newConfig.objectServiceName;
                            newConfig.widgets[widget]['fields'] = {};
                            for (var eachField in config[widget].fieldprops.field) {
                                newConfig.widgets[widget].fields[eachField] = {};
                                newConfig.widgets[widget].fields[eachField]['widgetType'] = config[widget].fieldprops.field[eachField].widgettype.toLowerCase();
                                newConfig.widgets[widget].fields[eachField]['fieldId'] = config[widget].fieldprops.field[eachField].field;
                            }
                        } else {
                            newConfig.widgets[widget]['fieldId'] = config[widget].fieldprops.field;
                        }
                    }
                    //Recursively calling map data
                    this.mapData(newConfig, data, form);
                }
                form.forceLayout();
            }
        };
        UIBinder.prototype.getWidgetData = function(config, formId, widgetId, dataMap) {
            var widget = formId[widgetId];
            var widgetConfig = config[widgetId];
            if (dataMap[widgetConfig.entityId] == null) dataMap[widgetConfig.entityId] = {};
            var widgetType = widgetConfig.widgetType.toLowerCase();
            if (widgetType in this.map) {
                if (widgetType !== 'segment') {
                    var mapper = this.map[widgetType];
                    dataMap[widgetConfig.entityId][widgetConfig.fieldId] = mapper.getPropertyData(widget);
                } else {
                    var mapper = this.map[widgetType];
                    dataMap[widgetConfig.entityId] = mapper.getPropertyData(widget);
                }
            }
        };
        //Get Data
        UIBinder.prototype.getData = function(config, formId, groupSelect) {
            if (config) {
                var dataMap = {};
                if (config.groups) {
                    for (var groupId in config.groups) {
                        if (groupSelect) {
                            if (includesInArray(groupSelect, groupId) || groupId === groupSelect) {
                                for (var widgetid in config.groups[groupId]) {
                                    this.getWidgetData(config.groups[groupId], formId, widgetid, dataMap);
                                }
                            }
                        } else {
                            for (var widgetid in config.groups[groupId]) {
                                this.getWidgetData(config.groups[groupId], formId, widgetid, dataMap);
                            }
                        }
                    }
                }
                if (config.widgets) {
                    for (var widgetId in config.widgets) {
                        this.getWidgetData(config.widgets, formId, widgetId, dataMap);
                    }
                }
                return dataMap;
            }
        };
        return UIBinder;
    }();

    function GenericPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    GenericPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    //Bottom Property
    function BottomPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    BottomPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    BottomPropertyMapper.prototype.propertyHandler = function() {};
    //CenterX Property
    function CenterXPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    CenterXPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    CenterXPropertyMapper.prototype.propertyHandler = function() {};
    //CenterY Property
    function CenterYPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    CenterYPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    CenterYPropertyMapper.prototype.propertyHandler = function() {};
    //Height Property
    function HeightPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    HeightPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    HeightPropertyMapper.prototype.propertyHandler = function() {};
    //Is Visible Property
    function IsVisiblePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    IsVisiblePropertyMapper.prototype.mapProperty = function(data, widget) {
        if (data == 'true') data = true;
        else if (data == 'false') data = false;
        var property = this.map.propName;
        widget[property] = data;
    };
    IsVisiblePropertyMapper.prototype.propertyHandler = function() {};
    //Skin Property
    function SkinPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    SkinPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    SkinPropertyMapper.prototype.propertyHandler = function() {};
    //Top Property
    function TopPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TopPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    TopPropertyMapper.prototype.propertyHandler = function() {};
    //Width Property
    function WidthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    WidthPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    WidthPropertyMapper.prototype.propertyHandler = function() {};
    //Left Property
    function LeftPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    LeftPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    LeftPropertyMapper.prototype.propertyHandler = function() {};
    //Background Color
    function BackgroundColorPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    BackgroundColorPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    BackgroundColorPropertyMapper.prototype.propertyHandler = function() {};
    //Right Property
    function RightPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    RightPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    RightPropertyMapper.prototype.propertyHandler = function() {};
    //MaxWidth Property
    function MaxWidthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MaxWidthPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    MaxWidthPropertyMapper.prototype.propertyHandler = function() {};
    //MinWidth Property
    function MinWidthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MinWidthPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    MinWidthPropertyMapper.prototype.propertyHandler = function() {};
    //MaxHeight Property
    function MaxHeightPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MaxHeightPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    MaxHeightPropertyMapper.prototype.propertyHandler = function() {};
    //MinHeight Property
    function MinHeightPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MinHeightPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    MinHeightPropertyMapper.prototype.propertyHandler = function() {};
    //ZIndex Property
    function ZIndexPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ZIndexPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    ZIndexPropertyMapper.prototype.propertyHandler = function() {};
    UIBinder_PropertyDataMapper_GenericProperties = undefined;
    UIBinder_WidgetDataMapper_WidgetDataMapper = function() {
        function WidgetDataMapper(widgetType) {
            this.propertyMap = {
                'width': new WidthPropertyMapper('width'),
                'height': new HeightPropertyMapper('height'),
                'isvisible': new IsVisiblePropertyMapper('isVisible'),
                'top': new TopPropertyMapper('top'),
                'bottom': new BottomPropertyMapper('bottom'),
                'centerx': new CenterXPropertyMapper('centerX'),
                'centery': new CenterYPropertyMapper('centerY'),
                'skin': new SkinPropertyMapper('skin'),
                'left': new LeftPropertyMapper('left'),
                'backgroundcolor': new BackgroundColorPropertyMapper('backgroundColor'),
                'right': new RightPropertyMapper('right'),
                'maxwidth': new MaxWidthPropertyMapper('maxWidth'),
                'minwidth': new MinWidthPropertyMapper('minWidth'),
                'maxheight': new MaxHeightPropertyMapper('maxHeiht'),
                'minheight': new MinHeightPropertyMapper('minHeight'),
                'zindex': new ZIndexPropertyMapper('zIndex')
            };
            this.widgetType = widgetType;
        }
        //Register property mapper or base property mapper
        WidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            this.propertyMap[propertyType.toLowerCase()] = propertyMapper;
        };
        WidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            if (widgetConfig.propertyMapper) {
                kony.print('Mapping properties with widgets');
                var properties = Object.keys(widgetConfig.propertyMapper);
                for (var property in properties) {
                    //alert(properties[property].toLowerCase());
                    var mapper = this.propertyMap[properties[property].toLowerCase()];
                    try {
                        if (widgetConfig.scope.toLowerCase() == 'context') {} else {
                            var dataKey = data[widgetConfig.entityId][widgetConfig.fieldId];
                            var keyVal = widgetConfig.propertyMapper[properties[property]].split('.');
                            var key = keyVal[keyVal.length - 1];
                            var dataVal = dataKey[key];
                            try {
                                mapper.mapProperty(dataVal, widget);
                            } catch (err) {
                                kony.print('MapData function error while mapping property ' + err);
                            }
                        }
                    } catch (err) {
                        kony.print('Error in data format : MapData WidgetDataMapper ' + err);
                    }
                }
            } else {
                //If no property map exists
                //Backward compatibility
                kony.print('Mapping default properties with widgets');
                var defaultMapper = this.propertyMap['default'];
                if (typeof data[widgetConfig.entityId][widgetConfig.fieldId] == 'object') {
                    type = defaultMapper.map.propName;
                    try {
                        defaultMapper.mapProperty(data[widgetConfig.entityId][widgetConfig.fieldId][type], widget);
                    } catch (err) {
                        kony.print('Error while Mapping default property with widget ' + err);
                    }
                } else {
                    try {
                        defaultMapper.mapProperty(data[widgetConfig.entityId][widgetConfig.fieldId], widget);
                    } catch (err) {
                        kony.print('Error while Mapping default property with widget ' + err);
                    }
                }
            }
        };
        WidgetDataMapper.prototype.getPropertyData = function(widget) {
            var txtMapper = this.propertyMap['text'];
            var data = txtMapper.getPropertyValue(widget);
            return data;
        };
        return WidgetDataMapper;
    }();
    commonUtils_inheritsFrom = function() {
        var inheritsFrom = function(child, parent) {
            child.prototype = Object.create(parent.prototype);
            child.prototype.constructor = child;
        };
        return inheritsFrom;
    }();

    function SourcePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    SourcePropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    SourcePropertyMapper.prototype.propertyHandler = function() {};
    SourcePropertyMapper.prototype.getPropertyValue = function(widget) {
        var srcVal = widget[this.map['propName']];
        return srcVal;
    };
    //BASE64 PROPERTY
    function Base64PropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    Base64PropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    Base64PropertyMapper.prototype.propertyHandler = function() {};
    //IMAGE WHEN FAIL PROPERTY
    function ImageWhenFailedPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ImageWhenFailedPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    ImageWhenFailedPropertyMapper.prototype.propertyHandler = function() {};
    //IMAGE WHILE DOWNLOAD PROPERTY
    function ImageWhileDownloadPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ImageWhileDownloadPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    ImageWhileDownloadPropertyMapper.prototype.propertyHandler = function() {};
    UIBinder_PropertyDataMapper_ImageProperties = undefined;
    UIBinder_WidgetDataMapper_ImageWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Image
        function ImageWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType);
            this.registerPropertyMapper('default', new SourcePropertyMapper('src'));
        }
        inheritsFrom(ImageWidgetDataMapper, WidgetDataMapper);
        ImageWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        ImageWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        ImageWidgetDataMapper.prototype.getPropertyData = function(widget) {
            var srcMapper = this.propertyMap['source'];
            var data = srcMapper.getPropertyValue(widget);
            return data;
        };
        return ImageWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);

    function PlaceholderPropertyMappper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    PlaceholderPropertyMappper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    PlaceholderPropertyMappper.prototype.propertyHandler = function() {};

    function PlaceholderSkinPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    PlaceholderSkinPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    PlaceholderSkinPropertyMapper.prototype.propertyHandler = function() {};

    function TextPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    TextPropertyMapper.prototype.propertyHandler = function() {};
    TextPropertyMapper.prototype.getPropertyValue = function(widget) {
        var textValue = widget[this.map['propName']];
        return textValue;
    };

    function MaxTextLengthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MaxTextLengthPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };
    MaxTextLengthPropertyMapper.prototype.propertyHandler = function() {};
    UIBinder_PropertyDataMapper_TextboxProperties = undefined;
    UIBinder_WidgetDataMapper_TextboxWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //TextBox
        function TextboxWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(TextboxWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', new TextPropertyMapper('text'));
        }
        TextboxWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        TextboxWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        TextboxWidgetDataMapper.prototype.getPropertyData = function(widget) {
            WidgetDataMapper.prototype.getPropertyData.call(this, widget);
        };
        return TextboxWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);

    function TextPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    TextPropertyMapper.prototype.propertyHandler = function() {};
    TextPropertyMapper.prototype.getPropertyValue = function(widget) {
        var textValue = widget[this.map['propName']];
        return textValue;
    };

    function TextStylePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextStylePropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    TextStylePropertyMapper.prototype.propertyHandler = function() {};

    function TextCopyablePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextCopyablePropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        if (data == 'true') widget[property] = true;
        else if (data == 'false') widget[property] = false;
    };
    TextCopyablePropertyMapper.prototype.propertyHandler = function() {};

    function WrappingPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    WrappingPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    WrappingPropertyMapper.prototype.propertyHandler = function() {};
    UIBinder_PropertyDataMapper_LabelProperties = undefined;
    UIBinder_WidgetDataMapper_LabelWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Label
        function LabelWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType);
            inheritsFrom(LabelWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', new TextPropertyMapper('text'));
        }
        LabelWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        LabelWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        LabelWidgetDataMapper.prototype.getPropertyData = function(widget) {
            WidgetDataMapper.prototype.getPropertyData.call(this, widget);
        };
        return LabelWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);
    //shadowtype, showclosebutton, showprogressindicator, textInputMode, toolTip, wrapText
    function ShadowTypePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ShadowTypePropertyMapper.prototype.propertyHandler = function() {};
    ShadowTypePropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };

    function ShowCloseButtonPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ShowCloseButtonPropertyMapper.prototype.propertyHandler = function() {};
    ShowCloseButtonPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function ShowProgressIndicatorPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ShowProgressIndicatorPropertyMapper.prototype.propertyHandler = function() {};
    ShowProgressIndicatorPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function TextInputModePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextInputModePropertyMapper.prototype.propertyHandler = function() {};
    TextInputModePropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };

    function ToolTipPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ToolTipPropertyMapper.prototype.propertyHandler = function() {};
    ToolTipPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function WrapTextPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    WrapTextPropertyMapper.prototype.propertyHandler = function() {};
    WrapTextPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function PlaceholderPropertyMappper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    PlaceholderPropertyMappper.prototype.propertyHandler = function() {};
    PlaceholderPropertyMappper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function TextPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextPropertyMapper.prototype.propertyHandler = function() {};
    TextPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };
    TextPropertyMapper.prototype.getPropertyValue = function(widget) {
        var textValue = widget[this.map['propName']];
        return textValue;
    };
    UIBinder_PropertyDataMapper_TextAreaProperties = undefined;
    UIBinder_WidgetDataMapper_TextAreaWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Textarea
        function TextAreaWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(TextAreaWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', new TextPropertyMapper('text'));
        }
        TextAreaWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        TextAreaWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        TextAreaWidgetDataMapper.prototype.getPropertyData = function(widget) {
            WidgetDataMapper.prototype.getPropertyData.call(this, widget);
        };
        return TextAreaWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);

    function SelectedIndexPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    SelectedIndexPropertyMapper.prototype.mapProperty = function(data, widget) {
        data = parseInt(data);
        var property = this.map.propName;
        widget[property] = data;
    };
    SelectedIndexPropertyMapper.prototype.propertyHandler = function() {};
    SelectedIndexPropertyMapper.prototype.getPropertyValue = function(widget) {
        var textValue = widget[this.map['propName']];
        return textValue.toString();
    };

    function OpacityPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    OpacityPropertyMapper.prototype.propertyHandler = function() {};
    OpacityPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };
    UIBinder_PropertyDataMapper_SwitchProperties = undefined;
    UIBinder_WidgetDataMapper_SwitchWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Switch
        function SwitchWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(SwitchWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', SelectedIndexPropertyMapper('selectedIndex'));
        }
        SwitchWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        SwitchWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        SwitchWidgetDataMapper.prototype.getPropertyData = function(widget) {
            var switchMapper = this.propertyMap['selectedindex'];
            var data = switchMapper.getPropertyValue(widget);
            return data;
        };
        return SwitchWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);

    function SelectedValuePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    SelectedValuePropertyMapper.prototype.mapProperty = function(data, widget) {
        data = parseInt(data);
        var property = this.map.propName;
        widget[property] = data;
    };
    SelectedValuePropertyMapper.prototype.propertyHandler = function() {};
    SelectedValuePropertyMapper.prototype.getPropertyValue = function(widget) {
        var value = widget[this.map['propName']];
        return value.toString();
    };

    function ThicknessPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ThicknessPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    ThicknessPropertyMapper.prototype.propertyHandler = function() {};

    function MinWidthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MinWidthPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };
    MinWidthPropertyMapper.prototype.propertyHandler = function() {};

    function MaxWidthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MaxWidthPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };
    MaxWidthPropertyMapper.prototype.propertyHandler = function() {};
    UIBinder_PropertyDataMapper_SliderProperties = undefined;
    UIBinder_WidgetDataMapper_SliderWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Slider
        function SliderWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(SliderWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', SelectedValuePropertyMapper('selectedValue'));
        }
        SliderWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        SliderWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        SliderWidgetDataMapper.prototype.getPropertyData = function(widget) {
            var sliderMapper = this.propertyMap['selectedvalue'];
            var data = sliderMapper.getPropertyValue(widget);
            return data;
        };
        return SliderWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);

    function TextPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextPropertyMapper.prototype.propertyHandler = function() {};
    TextPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };
    TextPropertyMapper.prototype.getPropertyValue = function(widget) {
        var textValue = widget[this.map['propName']];
        return textValue;
    };

    function OpacityPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    OpacityPropertyMapper.prototype.propertyHandler = function() {};
    OpacityPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };
    UIBinder_PropertyDataMapper_RichTextProperties = undefined;
    UIBinder_WidgetDataMapper_RichTextWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //RichText
        function RichTextWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(RichTextWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', new TextPropertyMapper('text'));
        }
        RichTextWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        RichTextWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        RichTextWidgetDataMapper.prototype.getPropertyData = function(widget) {
            WidgetDataMapper.prototype.getPropertyData.call(this, widget);
        };
        return RichTextWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);
    //TEXT PROPERTY MAPPER
    function TextPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    TextPropertyMapper.prototype.propertyHandler = function() {};
    TextPropertyMapper.prototype.getPropertyValue = function(widget) {
        var textValue = widget[this.map['propName']];
        return textValue;
    };
    UIBinder_PropertyDataMapper_ButtonProperties = undefined;
    UIBinder_WidgetDataMapper_ButtonWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Button
        function ButtonWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(ButtonWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', new TextPropertyMapper('text'));
        }
        ButtonWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        ButtonWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        ButtonWidgetDataMapper.prototype.getPropertyData = function(widget) {
            WidgetDataMapper.prototype.getPropertyData.call(this, widget);
        };
        return ButtonWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);
    UIBinder_WidgetDataMapper_SegmentWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //SEGMENT
        function SegmentWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType);
            inheritsFrom(SegmentWidgetDataMapper, WidgetDataMapper);
        }
        SegmentWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        SegmentWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            //CONSTRUCT SEGMENT WIDGET DATA MAP
            var widgetDataMap = {};
            var segmentFields = [];
            var entity = widgetConfig.entityId;
            var field = widgetConfig.fieldId;
            for (var fieldWidget in widgetConfig.fields) {
                var widgetField = widgetConfig.fields[fieldWidget].fieldId;
                widgetDataMap[fieldWidget] = widgetField;
                segmentFields.push(widgetField);
            }
            widget.widgetDataMap = widgetDataMap;
            //construct array of json to pass to segment.addAll();
            // var dataArr=[];
            // for(var eachRecord in data[entity][field] ){
            //     var recordMap={};
            //     for(var eachField in segmentFields){
            //         if(data[entity][field][eachRecord][segmentFields[eachField]] !== null){
            //             if(typeof data[entity][field][eachRecord][segmentFields[eachField]]==="object"){
            //                 //data in field->JSON format
            //                 recordMap[segmentFields[eachField]]=data[entity][field][eachRecord][segmentFields[eachField]].text;
            //             }
            //             else{
            //                 //normal data format
            //                 recordMap[segmentFields[eachField]]=data[entity][field][eachRecord][segmentFields[eachField]];
            //             }
            //         }
            //         //SET other properties for the widget fields
            //     }
            //     dataArr.push(recordMap);
            // }
            widget.removeAll();
            widget.addAll(data[entity][field]);
        };
        SegmentWidgetDataMapper.prototype.getPropertyData = function(widget) {
            return widget.data;
        };
        return SegmentWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);

    function ShadowTypePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ShadowTypePropertyMapper.prototype.propertyHandler = function() {};
    ShadowTypePropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };

    function ShadowDepthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ShadowDepthPropertyMapper.prototype.propertyHandler = function() {};
    ShadowDepthPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };

    function TickedImagePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TickedImagePropertyMapper.prototype.propertyHandler = function() {};
    TickedImagePropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function HoverSkinPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    HoverSkinPropertyMapper.prototype.propertyHandler = function() {};
    HoverSkinPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function MasterDataPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MasterDataPropertyMapper.prototype.propertyHandler = function() {};
    MasterDataPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };
    MasterDataPropertyMapper.prototype.getPropertyValue = function(widget) {
        var data = [];
        for (var item in widget[this.map['propName']]) {
            data.push(item);
        }
        return data;
    };

    function SelectedKeyPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    SelectedKeyPropertyMapper.prototype.propertyHandler = function() {};
    SelectedKeyPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };
    SelectedKeyPropertyMapper.prototype.getPropertyValue = function(widget) {
        return widget[this.map['propName']];
    };

    function SelectedKeysPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    SelectedKeysPropertyMapper.prototype.propertyHandler = function() {};
    SelectedKeysPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };
    SelectedKeysPropertyMapper.prototype.getPropertyValue = function(widget) {
        return widget[this.map['propName']];
    };
    UIBinder_PropertyDataMapper_ListboxProperties = undefined;
    UIBinder_WidgetDataMapper_ListboxWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Listbox
        function ListboxWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(ListboxWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', SelectedKeyPropertyMapper('selectedKey'));
        }
        ListboxWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        ListboxWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        ListboxWidgetDataMapper.prototype.getPropertyData = function(widget) {
            var listboxMapper = this.propertyMap['selectedkey'];
            var data = listboxMapper.getPropertyValue(widget);
            return data;
        };
        return ListboxWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);
    UIBinder_WidgetDataMapper_FlexContainerWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Button
        function FlexContainerWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(FlexContainerWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', null);
        }
        FlexContainerWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        FlexContainerWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        FlexContainerWidgetDataMapper.prototype.getPropertyData = function(widget) {
            WidgetDataMapper.prototype.getPropertyData.call(this, widget);
        };
        return FlexContainerWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);
    //DATE COMPONENT PROPERTY
    function DateComponentsPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    DateComponentsPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    DateComponentsPropertyMapper.prototype.propertyHandler = function() {};
    DateComponentsPropertyMapper.prototype.getPropertyValue = function(widget) {
        var datecompValue = widget[this.map['propName']];
        return datecompValue;
    };
    UIBinder_PropertyDataMapper_CalendarProperties = undefined;
    UIBinder_WidgetDataMapper_CalendarWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //CALENDAR
        function CalendarWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(CalendarWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', new DateComponentsPropertyMapper('dateComponents'));
        }
        CalendarWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        CalendarWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        CalendarWidgetDataMapper.prototype.getPropertyData = function(widget) {
            var datecompMapper = this.propertyMap['dateComponents'];
            var data = datecompMapper.getPropertyValue(widget);
            return data;
        };
        return CalendarWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);
    UIBinder_UIBinderBuilder = function(UIBinder, WidgetDataMapper, ImageWidgetDataMapper, TextboxWidgetDataMapper, LabelWidgetDataMapper, TextAreaWidgetDataMapper, SwitchWidgetDataMapper, SliderWidgetDataMapper, RichTextWidgetDataMapper, ButtonWidgetDataMapper, SegmentWidgetDataMapper, ListboxWidgetDataMapper, FlexContainerWidgetDataMapper, CalendarWidgetDataMapper) {
        var binderInstance = null;
        UIBinderBuilder = function() {
            this.initialize();
        };
        UIBinderBuilder.prototype.initialize = function() {
            if (binderInstance === null) {
                binderInstance = new UIBinder();
            }
            this.register();
        };
        UIBinderBuilder.prototype.register = function() {
            var imageMapper = new ImageWidgetDataMapper('image');
            var textBoxMapper = new TextboxWidgetDataMapper('textbox');
            var labelMapper = new LabelWidgetDataMapper('label');
            var textAreaMapper = new TextAreaWidgetDataMapper('textarea');
            var switchMapper = new SwitchWidgetDataMapper('switch');
            var sliderMapper = new SliderWidgetDataMapper('slider');
            var richTextMapper = new RichTextWidgetDataMapper('richtext');
            var buttonMapper = new ButtonWidgetDataMapper('button');
            var segmentMapper = new SegmentWidgetDataMapper('segment');
            var listBoxMapper = new ListboxWidgetDataMapper('listbox');
            var flexContainerMapper = new FlexContainerWidgetDataMapper('flexcontainer');
            var calendarMapper = new CalendarWidgetDataMapper('calendar');
            //Registering properties
            imageMapper.registerPropertyMapper('src', new SourcePropertyMapper('src'));
            imageMapper.registerPropertyMapper('base64', new Base64PropertyMapper('base64'));
            textBoxMapper.registerPropertyMapper('placeholder', new PlaceholderPropertyMappper('placeholder'));
            textBoxMapper.registerPropertyMapper('text', new TextPropertyMapper('text'));
            textBoxMapper.registerPropertyMapper('maxtextlength', new MaxTextLengthPropertyMapper('maxTextLength'));
            labelMapper.registerPropertyMapper('text', new TextPropertyMapper('text'));
            labelMapper.registerPropertyMapper('textstyle', new TextStylePropertyMapper('textStyle'));
            labelMapper.registerPropertyMapper('textcopyable', new TextCopyablePropertyMapper('textCopyable'));
            textAreaMapper.registerPropertyMapper('text', new TextPropertyMapper('text'));
            textAreaMapper.registerPropertyMapper('shadowtype', new ShadowTypePropertyMapper('shadowType'));
            textAreaMapper.registerPropertyMapper('textinputmode', new TextInputModePropertyMapper('textInputMode'));
            textAreaMapper.registerPropertyMapper('tooltip', new ToolTipPropertyMapper('toolTip'));
            textAreaMapper.registerPropertyMapper('placeholder', new PlaceholderPropertyMappper('placeholder'));
            switchMapper.registerPropertyMapper('selectedindex', new SelectedIndexPropertyMapper('selectedIndex'));
            sliderMapper.registerPropertyMapper('selectedvalue', new SelectedValuePropertyMapper('selectedValue'));
            sliderMapper.registerPropertyMapper('minwidth', new MinWidthPropertyMapper('minWidth'));
            sliderMapper.registerPropertyMapper('maxWidth', new MaxWidthPropertyMapper('maxWidth'));
            richTextMapper.registerPropertyMapper('text', new TextPropertyMapper('text'));
            richTextMapper.registerPropertyMapper('opacity', new OpacityPropertyMapper('opacity'));
            buttonMapper.registerPropertyMapper('text', new TextPropertyMapper('text'));
            listBoxMapper.registerPropertyMapper('shadowtype', new ShadowTypePropertyMapper('shadowType'));
            listBoxMapper.registerPropertyMapper('shadowdepth', new ShadowDepthPropertyMapper('shadowDepth'));
            listBoxMapper.registerPropertyMapper('hoverskin', new HoverSkinPropertyMapper('hoverSkin'));
            listBoxMapper.registerPropertyMapper('masterdata', new MasterDataPropertyMapper('masterData'));
            listBoxMapper.registerPropertyMapper('selectedkey', new SelectedKeyPropertyMapper('selectedKey'));
            listBoxMapper.registerPropertyMapper('selectedkeys', new SelectedKeysPropertyMapper('selectedKeys'));
            calendarMapper.registerPropertyMapper('datecomponents', new DateComponentsPropertyMapper('dateComponents'));
            //Registering Widgets
            binderInstance.registerWidgetMapper('image', imageMapper);
            binderInstance.registerWidgetMapper('textbox', textBoxMapper);
            binderInstance.registerWidgetMapper('label', labelMapper);
            binderInstance.registerWidgetMapper('textarea', textAreaMapper);
            binderInstance.registerWidgetMapper('switch', switchMapper);
            binderInstance.registerWidgetMapper('slider', sliderMapper);
            binderInstance.registerWidgetMapper('richtext', richTextMapper);
            binderInstance.registerWidgetMapper('button', buttonMapper);
            binderInstance.registerWidgetMapper('segment', segmentMapper);
            binderInstance.registerWidgetMapper('listbox', listBoxMapper);
            binderInstance.registerWidgetMapper('flexcontainer', flexContainerMapper);
            binderInstance.registerWidgetMapper('calendar', calendarMapper);
        };
        UIBinderBuilder.prototype.getBinder = function() {
            return binderInstance;
        };
        return UIBinderBuilder;
    }(UIBinder_UIBinder, UIBinder_WidgetDataMapper_WidgetDataMapper, UIBinder_WidgetDataMapper_ImageWidgetDataMapper, UIBinder_WidgetDataMapper_TextboxWidgetDataMapper, UIBinder_WidgetDataMapper_LabelWidgetDataMapper, UIBinder_WidgetDataMapper_TextAreaWidgetDataMapper, UIBinder_WidgetDataMapper_SwitchWidgetDataMapper, UIBinder_WidgetDataMapper_SliderWidgetDataMapper, UIBinder_WidgetDataMapper_RichTextWidgetDataMapper, UIBinder_WidgetDataMapper_ButtonWidgetDataMapper, UIBinder_WidgetDataMapper_SegmentWidgetDataMapper, UIBinder_WidgetDataMapper_ListboxWidgetDataMapper, UIBinder_WidgetDataMapper_FlexContainerWidgetDataMapper, UIBinder_WidgetDataMapper_CalendarWidgetDataMapper);
    commonUtils_MDAApplication = function(RepositoryManager, MDAModuleManager, UIBinderBuilder) {
        var appInstance = null;

        function MDAApplication() {
            if (appInstance !== null) {
                throw new Error(' Cannot instantiate more than one MDAApplication, use MDAApplication.getSharedInstance()');
            }
            this.initialize();
        }
        MDAApplication.prototype = {
            initialize: function() {
                this.repositoryManager = new RepositoryManager();
                this.moduleManager = new MDAModuleManager();
                this.UIBinder = new UIBinderBuilder().getBinder();
                this.appContext = {};
                this.accessMode = {
                    'access': 'online'
                };
                this.oDataQueryFlag = false;
                var scope = this;
                this.modelStore = {
                    getModelDefinition: function(modelName) {
                        var modelConfig = scope.repositoryManager.repoConfig[modelName];
                        var modelPath = modelConfig['model'];
                        var model = require(modelPath);
                        return model;
                    },
                    getConfig: function(modelName) {
                        var modelConfig = scope.repositoryManager.repoConfig[modelName];
                        var configPath = modelConfig['config'];
                        var config = require(configPath);
                        return config;
                    }
                };
            }
        };
        MDAApplication.getSharedInstance = function() {
            if (appInstance === null) {
                appInstance = new MDAApplication();
            }
            return appInstance;
        };
        MDAApplication.prototype.getRepoManager = function() {
            return this.repositoryManager;
        };
        MDAApplication.prototype.setRepoManager = function(repoManagerInstance) {
            this.repositoryManager = repoManagerInstance;
        };
        MDAApplication.prototype.getModuleManager = function() {
            return this.moduleManager;
        };
        MDAApplication.prototype.setModuleManager = function(moduleManagerInstance) {
            this.moduleManager = moduleManagerInstance;
        };
        MDAApplication.prototype.getUIBinder = function() {
            return this.UIBinder;
        };
        MDAApplication.prototype.setUIBinder = function(uiBinderInstance) {
            this.UIBinder = uiBinderInstance;
        };
        MDAApplication.prototype.setAppMode = function(appMode) {
            this.accessMode['access'] = appMode;
        };
        MDAApplication.prototype.getAppMode = function() {
            return this.accessMode;
        };
        MDAApplication.prototype.getODataStatus = function() {
            return this.oDataQueryFlag;
        };
        MDAApplication.prototype.setOdataStatus = function(flag) {
            this.oDataQueryFlag = flag;
        };
        return MDAApplication;
    }(DataModel_RepositoryManager, ModuleManager_MDAModuleManager, UIBinder_UIBinderBuilder);
    commonUtils_Logger = function() {
        function Logger() {}
        Logger.logExecutionTimes = function(targetObject, targetMethod, args) {
            function callbackTimeStamping(callback) {
                return function() {
                    var startTime = Date.now();
                    kony.print('MDA PERF :: Start Time executing callback ' + callback.name + '() : ' + startTime);
                    callback.apply(null, arguments);
                    var endTime = Date.now();
                    kony.print('MDA PERF :: End Time executing callback ' + callback.name + '() : ' + endTime);
                    kony.print('MDA PERF :: Total time executing callback ' + callback.name + '() : ' + (endTime - startTime) + 'ms');
                };
            }
            var argArr = [];
            for (var i = 0; i < args.length; i++) {
                if (typeof args[i] === 'function') {
                    argArr.push(callbackTimeStamping(args[i]));
                } else if (args[i] instanceof kony.mvc.Business.Command) {
                    var target = {};
                    for (var key in args[i]) {
                        if (args[i].hasOwnProperty(key)) {
                            target[key] = args[i][key];
                        }
                    }
                    target.completionCallback = callbackTimeStamping(args[i].completionCallback);
                    argArr.push(target);
                } else {
                    argArr.push(args[i]);
                }
            }
            var targetFunction = null;
            var _targetObject = targetObject == null ? this : targetObject;
            var targetFunctionName = '';
            if (typeof targetMethod === 'function') {
                targetFunction = targetMethod;
                targetFunctionName = targetFunction.name;
            } else if (typeof targetMethod === 'string') {
                targetFunction = _targetObject[targetMethod];
                targetFunctionName = targetMethod;
            }
            if (targetFunctionName == null || targetFunctionName.trim() === '') {
                targetFunctionName = '<anonymous>';
            }
            var startTimeLogPrefix = 'MDA PERF :: Start Time executing ' + _targetObject.constructor.name + '.' + targetFunctionName + '() : ';
            var endTimeLogPrefix = 'MDA PERF :: End Time executing ' + _targetObject.constructor.name + '.' + targetFunctionName + '() : ';
            var totalTimeLogPrefix = 'MDA PERF :: Total Time executing ' + _targetObject.constructor.name + '.' + targetFunctionName + '() : ';
            var startTime = Date.now();
            kony.print(startTimeLogPrefix + startTime);
            var returnVal = targetFunction.apply(_targetObject, argArr);
            var endTime = Date.now();
            kony.print(endTimeLogPrefix + endTime);
            kony.print(totalTimeLogPrefix + (endTime - startTime) + 'ms');
            return returnVal;
        };
        return Logger;
    }();
    commonUtils_InitializeForms = function(constants) {
        function InitializeForms(moduleName) {
            this.moduleConfig = eval(moduleName + 'Config');
            if (this.moduleConfig !== undefined) {
                var forms = this.moduleConfig.Forms;
                var channel = kony.sdk.getChannelType();
                //Call some API here
                if (forms && channel && forms[channel]) {
                    var formsList = Object.keys(forms[channel]);
                    for (var eachForm in formsList) {
                        if (kony.mvc.registry.getControllerType(eachForm) != constants.FORM_CONTROLLER_TYPE) {
                            var formNameKey = formsList[eachForm];
                            var formPath = forms[channel][formNameKey].FormName;
                            var friendlyName = forms[channel][formNameKey].friendlyName || formPath;
                            var controller = forms[channel][formNameKey].Controller;
                            var formController = forms[channel][formNameKey].FormController;
                            var controllerExtensions = forms[channel][formNameKey].ControllerExtensions;
                            var controllerExtName = [];
                            Array.prototype.push.apply(controllerExtName, controllerExtensions);
                            kony.mvc.registry.remove(friendlyName);
                            kony.mvc.registry.add(friendlyName, formPath, {
                                'controllerName': controller,
                                'controllerType': formController,
                                'controllerExtName': controllerExtName
                            });
                        }
                    }
                }
            }
        }
        return InitializeForms;
    }(DataModel_constants);
    commonUtils_ProcessorUtils = function() {
        function ProcessorUtils() {}
        ProcessorUtils.applyFunction = function(fnToApply, val, context) {
            //Context fetch from sdk metadata
            if (fnToApply && context['metadata']) {
                var config = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(context['object']);
                context['datatype'] = config.typings[context['field']];
                val = fnToApply(val, context);
            }
            return val;
        };
        ProcessorUtils.getMetadataForObject = function(serviceName, objectName, options, successCallback, failureCallback) {
            kony.sdk.getCurrentInstance().getObjectService(serviceName, {
                'access': 'online'
            }).getMetadataOfObject(objectName, options, successCallback, failureCallback);
        };
        ProcessorUtils.convertObjectMetadataToFieldMetadataMap = function(objectMetadata) {
            var metadataMap = {};
            if (objectMetadata) {
                var columns = objectMetadata.columns;
                for (var colIndex in columns) {
                    if (columns[colIndex].metadata) {
                        metadataMap[columns[colIndex].displayName] = columns[colIndex].metadata;
                    }
                }
            }
            return metadataMap;
        };
        return ProcessorUtils;
    }();
    ParallelCommandExecuter_ParallelCommandExecuter = function() {
        function ParallelCommandExecuter() {}
        ParallelCommandExecuter.executeCommands = function(businessController, commands, callback) {
            var responseList = [];

            function successCallback(response) {
                if (response !== undefined) {
                    responseList.push(response);
                }
                if (responseList.length === commands.length) {
                    var responseListInOrder = [];
                    for (var i = 0; i < commands.length; i++) {
                        var alias = commands[i].getAlias();
                        for (var j = 0; j < responseList.length; j++) {
                            if (alias === responseList[j].alias) {
                                responseListInOrder.push(responseList[j]);
                            }
                        }
                    }
                    callback(responseListInOrder);
                }
            }
            for (var i = 0; i < commands.length; i++) {
                commands[i].setCompletionCallback(successCallback);
                businessController.execute(commands[i]);
            }
        };
        return ParallelCommandExecuter;
    }();
    DataModel_ModelRelation = function() {
        var Relation = function(name, targetObject) {
            this.name = name;
            this.targetObject = targetObject;
            this.relationFields = [];
            this.addRelationField = function(source, target) {
                this.relationFields.push({
                    sourceField: source,
                    targetField: target
                });
            };
            this.isValid = function() {
                if (this.relationFields.length === 0) {
                    throw Error('atleast one relationfield should be added use addRelationField(sourceProperty,targetProperty)');
                } else {
                    return true;
                }
            };
            this.type = 'OneToMany';
            this.cascade = 'false';
        };
        return Relation;
    }();
    DataModel_BaseModel = function(ModelRelation) {
        var BaseModel = function() {};
        //BaseModel.prototype.attributeMap={};
        BaseModel.prototype.getId = function() {
            if (this.config.primaryKeys.length === 1) {
                return this[this.config.primaryKeys[0]];
            } else {
                throw Error('getId() for Composite keys is not implemented yet.');
            }
        };
        BaseModel.isParentOf = function(child) {
            var _this = this;
            child.prototype = Object.create(this.prototype);
            child.prototype.constructor = child;
            child.prototype.attributeMap = {};
            Object.keys(this).forEach(function(key) {
                child[key] = _this[key];
            });
        };
        BaseModel.prototype.toDBJson = function(config) {
            var _this2 = this;
            var dbMapObj = {};
            Object.keys(config.mappings).forEach(function(e) {
                dbMapObj[config.mappings[e]] = _this2[e];
            });
            return dbMapObj;
        };
        /**
         * @function addRelation adds new relation to existing model
         * @param  {relation} relation object
         * @return
         */
        BaseModel.addRelation = function(relationObject) {
            var existingrelation;
            var relationexists = false;
            var modelrelations = this.relations;
            for (var i = 0; i < modelrelations.length; i++) {
                existingrelation = modelrelations[i];
                if (relationObject['targetObject'] == existingrelation['targetObject']) {
                    relationexists = true;
                }
            }
            if (!relationexists) {
                if (relationObject instanceof ModelRelation && relationObject.isValid()) {
                    this.relations.push(relationObject);
                }
            }
        };
        //Making attribute map part of Child model so depricating this
        //BaseModel.prototype.attributeMap={};
        /**
         * @function prototype function add Attribute adds new attribute and value to existing model instance
         * @param  {attributeKey} attribute key
         * @param  {modelDef} model defination
         * @return
         */
        BaseModel.prototype.addAttribute = function(attributeKey, attributeValue, modelName) {
            this.attributeMap[attributeKey] = {
                'model': modelName,
                'value': attributeValue
            };
        };
        /**
         * @function function add Attribute adds new attribute and value to existing model
         * @param  {attributeKey} attribute key
         * @param  {modelDef} model defination
         * @return
         */
        BaseModel.addAttribute = function(attributeKey, attributeValue, modelName) {
            this.prototype.attributeMap[attributeKey] = {
                'model': modelName,
                'value': null
            };
        };
        /**
         * @function save saves the given model data in the backend
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseModel.prototype.save = function(onCompletion, accessMode, options) {
            var model = this.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).save(this, onCompletion, accessMode, options);
        };
        /**
         * @function getByPrimaryKey  fetches data for the specified model based on the primary keys
         * @param  {String/JSON} primaryKey   primitive in case of one primary key and json in case of composite primary key
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        BaseModel.getByPrimaryKey = function(PrimaryKey, onCompletion, accessMode, options) {
            var model = this.prototype.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).getByPrimaryKey(PrimaryKey, onCompletion, accessMode, options);
        };
        /**
         * @function update  updates the record into the backend
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseModel.prototype.update = function(onCompletion, accessMode, options) {
            var model = this.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).update(this, onCompletion, accessMode, options);
        };
        /**
         * @function partialUpdate partially update the model data to the backend
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        BaseModel.prototype.partialUpdate = function(onCompletion, accessMode, options) {
            var model = this.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).partialUpdate(this, onCompletion, accessMode, options);
        };
        /**
         * @function remove deletes the specified model from the backend
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseModel.prototype.remove = function(onCompletion, accessMode, options) {
            var model = this.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).remove(this, onCompletion, accessMode, options);
        };
        /**
         * @function removeById deletes the specified model from the backend with a specific id
         * @param {JSON/STRING} primaryKey primary key value or json representing the key and value
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseModel.removeById = function(primaryKey, onCompletion, accessMode, options) {
            var model = this.prototype.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).removeById(this, primaryKey, onCompletion, accessMode, options);
        };
        /**
         * @function getAll  fetches  all the data for the specified model
         * @param  {type} onCompletion success callback
         * @param  {type} accessMode   json specifing access mode
         * @return 
         */
        BaseModel.getAll = function(onCompletion, accessMode, options) {
            var model = this.prototype.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).getAll(onCompletion, accessMode, options);
        };
        /**
         * @function customVerb fetches data for the specified model using specified customVerb
         * @param  {String} customVerb   name of the custom verb to be executed
         * @param  {JSON} params       parameters in the form of key value pairs
         * @param  {function} onCompletion success callback
         * @return 
         */
        BaseModel.customVerb = function(customVerb, params, onCompletion, options) {
            var model = this.prototype.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).customVerb(customVerb, params, onCompletion, options);
        };
        /**
         * @function getByCriteria  fetches data for the specified model based on the criteria passed
         * @param  {Json} criteria        criteria object based on which query is build in case of online and offline
         * @param  {function} onCompletion    success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseModel.getByCriteria = function(criteria, onCompletion, accessMode, options) {
            var model = this.prototype.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).getByCriteria(criteria, onCompletion, accessMode, options);
        };
        /**
         * @function {function name}
         * @param  {type} injectedNamedValMap    {description}
         * @param  {type} injectedPropertyValMap {description}
         * @return {type} {description}
         */
        BaseModel.Validator = function(injectedNamedValMap, injectedPropertyValMap) {
            var NamedValidatorMap = injectedNamedValMap ? injectedNamedValMap : {};
            var PropertyToValidatorMap = injectedPropertyValMap ? injectedPropertyValMap : {};
            var getValidations = function(propName) {
                if (PropertyToValidatorMap[propName]) {
                    return PropertyToValidatorMap[propName];
                } else {
                    return [];
                }
            };
            this.isValid = function(obj, propName, value) {
                if (propName) {
                    return getValidations(propName).every(function(fn) {
                        return fn(value, propName, obj);
                    });
                } else {
                    return Object.keys(PropertyToValidatorMap).filter(function(prop) {
                        return PropertyToValidatorMap[prop];
                    }).every(function(prop) {
                        return PropertyToValidatorMap[prop].every(function(fn) {
                            return fn(obj[prop], prop, obj);
                        });
                    });
                }
            };
            this.registerValidator = function(propName, validationFn, validationName) {
                var errMsg = 'Unable to register Validator ';
                if (!propName) {
                    throw Error(errMsg + '-> Property Name should be specified');
                }
                if (!validationFn) {
                    throw Error(errMsg + '-> Validation Function should be specified');
                }
                var validationFnToStore = validationFn;
                if (validationName) {
                    if (NamedValidatorMap[validationName] && NamedValidatorMap[validationName] != null) {
                        throw Error(errMsg + '-> Validation Function named "' + validationName + '" already exists.');
                    } else {
                        validationFnToStore = function validationFnToStore() {
                            if (validationFn.apply(undefined, arguments)) {
                                return true;
                            } else {
                                throw Error('Validation "' + validationName + '" failed for property : ' + propName);
                            }
                        };
                        validationFnToStore.name = validationName;
                        validationFnToStore.onProperty = propName;
                        NamedValidatorMap[validationName] = validationFnToStore;
                    }
                }
                if (!PropertyToValidatorMap[propName]) {
                    PropertyToValidatorMap[propName] = [];
                }
                PropertyToValidatorMap[propName].push(validationFnToStore);
            };
            this.deRegisterValidator = function(validationName) {
                if (NamedValidatorMap[validationName]) {
                    var fnToRemove = NamedValidatorMap[validationName];
                    PropertyToValidatorMap[fnToRemove.onProperty] = PropertyToValidatorMap[fnToRemove.onProperty].filter(function(e) {
                        return e != fnToRemove;
                    });
                    NamedValidatorMap[validationName] = null;
                } //else{throw 'No such validator was registered';}
            };
            this.clearAllValidators = function(forPropName) {
                if (forPropName) {
                    if (PropertyToValidatorMap[forPropName]) {
                        //clear named validations for the property
                        Object.keys(NamedValidatorMap).filter(function(key) {
                            return NamedValidatorMap[key] != null;
                        }).filter(function(key) {
                            return NamedValidatorMap[key].onProperty === forPropName;
                        }).forEach(function(key) {
                            NamedValidatorMap[key] = null;
                        });
                        //reset all the validataions for property
                        PropertyToValidatorMap[forPropName] = [];
                    }
                } else {
                    //clear all named validations
                    Object.keys(NamedValidatorMap).forEach(function(key) {
                        NamedValidatorMap[key] = null;
                    });
                    //reset all validations for all properties
                    Object.keys(PropertyToValidatorMap).forEach(function(key) {
                        PropertyToValidatorMap[key] = [];
                    });
                }
            };
            this.getNamedValidations = function() {
                return Object.keys(NamedValidatorMap).filter(function(key) {
                    return NamedValidatorMap[key];
                });
            };
        };
        return BaseModel;
    }(DataModel_ModelRelation);
    DataModel_ORMSession = function() {
        ORMSession = function(appContext) {
            this.appContext = appContext;
        };
        ORMSession.prototype.intialize = function() {};
        ORMSession.prototype.save = function(QueryBuilder) {};
        ORMSession.prototype.remove = function(QueryBuilder) {};
        ORMSession.prototype.get = function(QueryBuilder) {
            //Put Validation Logic
            //Put Execution Logic  
            //get query from QueryBuilder 
            //execute and return result
            console.log('in ormsession get method');
            var query = QueryBuilder.getQuery();
            console.log('execute ' + query);
        };
        return ORMSession;
    }();
    DataModel_Expression = function() {
        Expression = function() {
            this.expr = null;
            this.lhs = null;
            this.rhs = null;
        };
        Expression.and = function() {
            var rootExpression = Expression.eq(null, null);
            for (var expression in arguments) {
                if (rootExpression.lhs == null) {
                    rootExpression.lhs = arguments[expression];
                    continue;
                } else if (rootExpression.rhs == null) {
                    rootExpression.rhs = arguments[expression];
                    continue;
                } else {
                    var temp = rootExpression;
                    rootExpression = Expression.eq(null, null);
                    rootExpression.lhs = temp;
                    rootExpression.rhs = arguments[expression];
                }
            }
            return rootExpression;
        };
        Expression.eq = function(lexpr, rexpr) {
            var expr = new Expression();
            expr.expr = 'eq';
            expr.lhs = lexpr;
            expr.rhs = rexpr;
            return expr;
        };
        return Expression;
    }();
    FormController_MDAFormController = function(inheritsFrom) {
        function MDAFormController(viewId1) {
            this.eventDelegate = null;
            this.presenter = null;
            this.config = null;
            this.superParams = {
                counter: 0,
                level: null,
                refStack: []
            };
            kony.mvc.FormController.call(this, viewId1);
        }
        inheritsFrom(MDAFormController, kony.mvc.FormController);
        MDAFormController.prototype.show = function(context, isBackNavigation) {
            kony.mvc.FormController.prototype.show.call(this, context, isBackNavigation);
        };
        MDAFormController.prototype.raiseEvent = function(eventId, eventContext) {
            if (this.eventDelegate !== null) {
                this.eventDelegate._onEventRaised(this, eventId, eventContext);
            }
        };
        MDAFormController.prototype.setStartupContext = function() {};
        MDAFormController.prototype.onNavigate = function(context, isBackNavigation) {
            this.setStartupContext();
            if (context) {
                this.eventDelegate = context._presenter;
                this.presenter = context._presenter;
                this.config = context._formConfig;
                if ('viewModel' in context) {
                    this.updateUI(context.viewModel);
                }
            }
        };
        MDAFormController.prototype.updateUI = function(viewModel) {
            var uiInstance = kony.mvc.MDAApplication.getSharedInstance().getUIBinder();
            if (this.shouldUpdateUI(viewModel)) {
                this.willUpdateUI(viewModel);
                uiInstance.mapData(this.config, viewModel, this.view);
                this.didUpdateUI(viewModel);
            }
        };
        MDAFormController.prototype.shouldUpdateUI = function(context) {
            //code
            return true;
        };
        MDAFormController.prototype.willUpdateUI = function(context) {};
        MDAFormController.prototype.didUpdateUI = function(context) {};
        MDAFormController.prototype.attachToModule = function(module) {
            this.presenter = module.presentationController;
            this.presenter._pushToPresentationStack(this.presenter, this.view.id, null);
        };
        MDAFormController.prototype.super = function(methodName, argList) {
            var scope = this;
            var returnValue = null;
            if (this.superParams.level === null) {
                this.superParams.level = 0;
                while (scope['extensionLevel' + this.superParams.level.toString()]) {
                    this.superParams.level++;
                }
            }
            if (this.superParams.counter === 0) {
                for (var i = 0; i < this.superParams.level; i++) {
                    if (scope['extensionLevel' + i.toString()][methodName]) {
                        this.superParams.refStack.push(i);
                    }
                }
            }
            this.superParams.refStack.pop();
            if (this.superParams.refStack.length !== 0) {
                var callLvl = this.superParams.refStack[this.superParams.refStack.length - 1];
                this.superParams.counter++;
                returnValue = scope['extensionLevel' + callLvl.toString()][methodName].apply(this, argList);
                this.superParams.counter--;
            } else {
                kony.print('#MDA2 : Can\'t find any super for the ' + methodName + ' Method.');
            }
            if (this.superParams.counter === 0) {
                this.superParams.refStack = [];
                this.superParams.level = null;
            }
            return returnValue;
        };
        return MDAFormController;
    }(commonUtils_inheritsFrom);
    commonUtils_ControllerGetterAPI = function() {
        function getController(formId) {
            var tempController = kony.mvc.registry.get(formId);
            var controllerType = 'kony.mvc.MDAFormController';
            var isForm = true;
            if (tempController != null) {
                var tempControllerType = kony.mvc.registry.getControllerType(formId);
                if (tempControllerType == controllerType) {
                    return _kony.mvc.GetController(formId, isForm);
                } else {
                    var friendlyName = kony.mvc.registry.getFriendlyName(formId);
                    var controllerName = kony.mvc.registry.getControllerName(formId);
                    var controllerExtName = kony.mvc.registry.getControllerExtName(formId);
                    kony.mvc.registry.remove(formId);
                    kony.mvc.registry.add(formId, formId, {
                        'controllerName': controllerType,
                        'controllerType': controllerType,
                        'controllerExtName': controllerExtName
                    });
                    return _kony.mvc.GetController(formId, isForm);
                }
            } else {
                return null;
            }
        }
        return getController;
    }();
    main = function(require) {
        if (typeof kony === 'undefined') {
            kony = {};
        }
        kony.mvc = kony.mvc ? kony.mvc : {};
        const mda = kony.mvc;
        mda.Business = {};
        mda.Business.Controller = BusinessController_BusinessController;
        mda.Business.Command = BusinessController_Command;
        mda.Business.CommandExecutionEngine = BusinessController_CommandExecutionEngine;
        mda.Business.CommandHandler = BusinessController_CommandHandler;
        mda.Business.CommandResponse = BusinessController_CommandResponse;
        mda.Business.Delegator = BusinessController_BusinessDelegator;
        mda.util = mda.util ? mda.util : {};
        mda.MDAApplication = commonUtils_MDAApplication;
        mda.util.ClassExtensionUtility = commonUtils_ExtensibilityApi;
        mda.util.Logger = commonUtils_Logger;
        mda.util.InitializeForms = commonUtils_InitializeForms;
        mda.util.ProcessorUtils = commonUtils_ProcessorUtils;
        //mda.util.sync = mda.util.sync ? mda.util.sync : {};
        //mda.util.sync.Sync_Initialize_CommandHandler = require('commonUtils/syncController/Sync_Initialize_CommandHandler');
        //mda.util.sync.Sync_PresentationController = require('commonUtils/syncController/Sync_PresentationController');
        //mda.util.sync.SyncModuleConfig = require('commonUtils/syncController/SyncModuleConfig');
        mda.util.ParallelCommandExecuter = ParallelCommandExecuter_ParallelCommandExecuter;
        mda.Data = mda.Data ? mda.Data : {};
        mda.Data.BaseModel = DataModel_BaseModel;
        mda.Data.BaseRepository = DataModel_BaseRepository;
        mda.Data.DataSource = DataModel_DataSource;
        mda.Data.ORMSession = DataModel_ORMSession;
        mda.Data.QueryBuilder = DataModel_QueryBuilder;
        mda.Data.RepositoryManager = DataModel_RepositoryManager;
        mda.Data.ModelRelation = DataModel_ModelRelation;
        mda.Expression = DataModel_Expression;
        mda.MDAFormController = FormController_MDAFormController;
        mda.MDAModule = ModuleManager_MDAModule;
        mda.MDAModuleManager = ModuleManager_MDAModuleManager;
        mda.Presentation = mda.Presentation ? mda.Presentation : {};
        mda.Presentation.BasePresenter = PresentationController_MDABasePresenter;
        mda.Presentation.BaseNavigator = BaseNavigator_MDABaseNavigator;
        mda.UIBinder = mda.UIBinder ? mda.UIBinder : {};
        mda.UIBinder.UIBinder = UIBinder_UIBinder;
        mda.UIBinder.UIBinderBuilder = UIBinder_UIBinderBuilder;
        mda.UIBinder.WidgetDataMapper = UIBinder_WidgetDataMapper_WidgetDataMapper;
        mda.UIBinder.PropertyDataMapper = mda.UIBinder.PropertyDataMapper ? mda.UIBinder.PropertyDataMapper : {};
        mda.UIBinder.PropertyDataMapper.ButtonProperties = UIBinder_PropertyDataMapper_ButtonProperties;
        mda.UIBinder.PropertyDataMapper.CalendarProperties = UIBinder_PropertyDataMapper_CalendarProperties;
        mda.UIBinder.PropertyDataMapper.GenericProperties = UIBinder_PropertyDataMapper_GenericProperties;
        mda.UIBinder.PropertyDataMapper.ImageProperties = UIBinder_PropertyDataMapper_ImageProperties;
        mda.UIBinder.PropertyDataMapper.LabelProperties = UIBinder_PropertyDataMapper_LabelProperties;
        mda.UIBinder.PropertyDataMapper.ListboxProperties = UIBinder_PropertyDataMapper_ListboxProperties;
        mda.UIBinder.PropertyDataMapper.RichTextProperties = UIBinder_PropertyDataMapper_RichTextProperties;
        mda.UIBinder.PropertyDataMapper.SliderProperties = UIBinder_PropertyDataMapper_SliderProperties;
        mda.UIBinder.PropertyDataMapper.SwitchProperties = UIBinder_PropertyDataMapper_SwitchProperties;
        mda.UIBinder.PropertyDataMapper.TextAreaProperties = UIBinder_PropertyDataMapper_TextAreaProperties;
        mda.UIBinder.PropertyDataMapper.TextboxProperties = UIBinder_PropertyDataMapper_TextboxProperties;
        mda.UIBinder.WidgetDataMapper = mda.UIBinder.WidgetDataMapper ? mda.UIBinder.WidgetDataMapper : {};
        mda.UIBinder.WidgetDataMapper.ButtonWidgetDataMapper = UIBinder_WidgetDataMapper_ButtonWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.CalendarWidgetDataMapper = UIBinder_WidgetDataMapper_CalendarWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.ImageWidgetDataMapper = UIBinder_WidgetDataMapper_ImageWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.LabelWidgetDataMapper = UIBinder_WidgetDataMapper_LabelWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.ListboxWidgetDataMapper = UIBinder_WidgetDataMapper_ListboxWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.RichTextWidgetDataMapper = UIBinder_WidgetDataMapper_RichTextWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.SegmentWidgetDataMapper = UIBinder_WidgetDataMapper_SegmentWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.SliderWidgetDataMapper = UIBinder_WidgetDataMapper_SliderWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.SwitchWidgetDataMapper = UIBinder_WidgetDataMapper_SwitchWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.TextAreaWidgetDataMapper = UIBinder_WidgetDataMapper_TextAreaWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.TextboxWidgetDataMapper = UIBinder_WidgetDataMapper_TextboxWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.FlexContainerWidgetDataMapper = UIBinder_WidgetDataMapper_FlexContainerWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.WidgetDataMapper = UIBinder_WidgetDataMapper_WidgetDataMapper;
        mda.getController = commonUtils_ControllerGetterAPI;
        //constants
        mda.constants = mda.constants ? mda.constants : {};
        mda.constants.STATUS_SUCCESS = 100;
        mda.constants.STATUS_FAILURE = 200;
        mda.constants.STATUS_ABORT = 99;
        define('kony.mvc.MDAFormController', kony.mvc.MDAFormController);
        define('kony/mvc/MDAFormController', kony.mvc.MDAFormController);
        define('MDAFormController', kony.mvc.MDAFormController);
        return mda;
    }({});
}());
//FP Appended kronin.js-----------------------------------------------------------
(function() {
    function r(e, n, t) {
        function o(i, f) {
            if (!n[i]) {
                if (!e[i]) {
                    var c = "function" == typeof require && require;
                    if (!f && c) return c(i, !0);
                    if (u) return u(i, !0);
                    var a = new Error("Cannot find module '" + i + "'");
                    throw a.code = "MODULE_NOT_FOUND", a
                }
                var p = n[i] = {
                    exports: {}
                };
                e[i][0].call(p.exports, function(r) {
                    var n = e[i][1][r];
                    return o(n || r)
                }, p, p.exports, r, e, n, t)
            }
            return n[i].exports
        }
        for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
        return o
    }
    return r
})()({
    1: [function(require, module, exports) {
        (function(global, undefined) {
            var slice = [].slice,
                subscriptions = {};
            var duplicatesAllowed = false;

            function equalsFunction(f1, f2) {
                //If both are anonymous functions.
                if (f1.name === "" && f2.name === "") {
                    //Stringify the bodies and compare.
                } else {
                    return f1 === f2;
                }
            }

            function getFunctionBody(func) {
                var funcString = func.toString();
                var funcBody = funcString.substring(funcString.indexOf("{"));
                //funcBody = funcBody.replace(/\n/g, '').replace(/\s{2}/g, ' ');
                return funcBody;
            }
            /*exported amplify*/
            var amplify = global.amplify = {
                allowDuplicates: function(allow) {
                    duplicatesAllowed = allow;
                },
                getSubscriptions: function(topic) {
                    //Generate a read-only copy of the subscriptions.
                    return JSON.parse(JSON.stringify(subscriptions[topic]));
                },
                isSubscribed: function(topic, callback) {
                    var found = false;
                    for (var i = subscriptions[topic].length - 1; i >= 0; i--) {
                        var existingSubscriptor = subscriptions[topic][i].callback;
                        //For named functions, compare them directly.
                        if (typeof callback.name === "string" && callback.name.length > 0) {
                            if (existingSubscriptor === callback) {
                                found = true;
                                break;
                            }
                        }
                        //For unnamed functions stringify, remove anything before the curlys and compare.
                        else {
                            if (getFunctionBody(existingSubscriptor) === getFunctionBody(callback)) {
                                found = true;
                                break;
                            }
                        }
                    }
                    return found;
                },
                publish: function(topic) {
                    if (typeof topic !== "string") {
                        throw new Error("You must provide a valid topic to publish.");
                    }
                    var args = slice.call(arguments, 1),
                        topicSubscriptions,
                        subscription,
                        length,
                        i = 0,
                        ret;
                    if (!subscriptions[topic]) {
                        return true;
                    }
                    topicSubscriptions = subscriptions[topic].slice();
                    for (length = topicSubscriptions.length; i < length; i++) {
                        subscription = topicSubscriptions[i];
                        ret = subscription.callback.apply(subscription.context, args);
                        if (ret === false) {
                            break;
                        }
                    }
                    return ret !== false;
                },
                subscribe: function(topic, context, callback, priority) {
                    if (typeof topic !== "string") {
                        throw new Error("You must provide a valid topic to create a subscription.");
                    }
                    if (arguments.length === 3 && typeof callback === "number") {
                        priority = callback;
                        callback = context;
                        context = null;
                    }
                    if (arguments.length === 2) {
                        callback = context;
                        context = null;
                    }
                    priority = priority || 10;
                    var topicIndex = 0,
                        topics = topic.split(/\s/),
                        topicLength = topics.length,
                        added;
                    for (; topicIndex < topicLength; topicIndex++) {
                        topic = topics[topicIndex];
                        added = false;
                        if (!subscriptions[topic]) {
                            subscriptions[topic] = [];
                        }
                        if (duplicatesAllowed || !this.isSubscribed(topic, callback)) {
                            var i = subscriptions[topic].length - 1,
                                subscriptionInfo = {
                                    callback: callback,
                                    context: context,
                                    priority: priority
                                };
                            for (; i >= 0; i--) {
                                if (subscriptions[topic][i].priority <= priority) {
                                    subscriptions[topic].splice(i + 1, 0, subscriptionInfo);
                                    added = true;
                                    break;
                                }
                            }
                            if (!added) {
                                subscriptions[topic].unshift(subscriptionInfo);
                            }
                        }
                    }
                    return callback;
                },
                unsubscribe: function(topic, context, callback) {
                    if (typeof topic !== "string") {
                        throw new Error("You must provide a valid topic to remove a subscription.");
                    }
                    if (arguments.length === 2) {
                        callback = context;
                        context = null;
                    }
                    if (!subscriptions[topic]) {
                        return;
                    }
                    var length = subscriptions[topic].length,
                        i = 0;
                    for (; i < length; i++) {
                        if (subscriptions[topic][i].callback === callback) {
                            if (!context || subscriptions[topic][i].context === context) {
                                subscriptions[topic].splice(i, 1);
                                // Adjust counter and length for removed item
                                i--;
                                length--;
                            }
                        }
                    }
                }
            };
        }(kony));
    }, {}],
    2: [function(require, module, exports) {
        /**
         * setAppBarColor - Sets the background color of the Android status bar.
         *
         * @param  {String} color An RGA hex-based color code e.g. #cc0000 for a dark red.
         * @author Miguelngel Fernndez
         */
        (() => {
            function setAppBarColor(color) {
                kony.application.setApplicationProperties({
                    statusBarColor: color
                });
            }
            kony.application.setAppBarColor = setAppBarColor;
        })();
    }, {}],
    3: [function(require, module, exports) {
        /**
         * getLocalizedString2 - Get the localised string for an i18n key or return the key itself
         * if no localised string is found for the current locale. This is useful because if there
         * are gaps in a language bundle, seeing the actual key on screen is useful to quickly determine
         * what translations are missing  as opposed to just seeing a blank label and wondering what
         * that is for.
         * This function also supports substitution variables specified with curly brackets  e.g.:
         * If the localised string of an i18n key <em>"LABELS.GREETING"</em> is <em>"Hello {name}"</em>, then the example
         * below will render <em>"Hello Miguel"</em>.
         * @example kony.i18n.getLocalizedString2("LABELS.GREETING", {"name": "Miguel"});
         *
         * @name getLocalizedString2
         * @namespace kony.i18n
         *
         * @author Miguelngel Fernndez
         *
         */
        ((definition) => {
            kony.i18n.getLocalizedString2 = definition;
        })(
            /** @lends getLocalizedString2
             * @param  {String} key   The i18n key to be localised.
             * @param  {Object} scope Any substitution variables required for the placeholders in the localised string.
             * @return {String}       The localised string.
             **/
            function getLocalizedString2(key, scope) {
                var s = kony.i18n.getLocalizedString(key);
                if (!s) return key;
                for (var property in scope) {
                    if (scope.hasOwnProperty(property)) {
                        s = s.replace(new RegExp("\\{" + property + "\\}", "g"), scope[property]);
                    }
                }
                return s;
            });
    }, {}],
    4: [function(require, module, exports) {
        require("./amplify.js");
        require("./application.setAppBarColor.js");
        require("./i18n.getLocalizedString2.js");
        require("./main.js");
        require("./mvc.genAccessors.js");
        require("./mvc.patch.js");
        require("./mvc.router.js");
        require("./os.js");
        require("./ui.getDescendants.js");
    }, {
        "./amplify.js": 1,
        "./application.setAppBarColor.js": 2,
        "./i18n.getLocalizedString2.js": 3,
        "./main.js": 4,
        "./mvc.genAccessors.js": 5,
        "./mvc.patch.js": 6,
        "./mvc.router.js": 7,
        "./os.js": 8,
        "./ui.getDescendants.js": 9
    }],
    5: [function(require, module, exports) {
        /*
         * Define a component's setters and getters in one line by just listing the fields -e.g.:
         * initGettersSetters: function() {kony.mvc.genAccessors(this, ["foo","bar"]);}
         */
        ((definition) => {
            kony.mvc.genAccessors = definition;
        })((compCtrl, fields) => {
            fields.forEach((fieldName) => {
                //The internal field name is prefixed with underscore -e.g.: "_foo" for field "foo"
                var internalFieldName = "_" + fieldName;
                defineGetter(compCtrl, fieldName, function() {
                    return compCtrl[internalFieldName];
                });
                defineSetter(compCtrl, fieldName, function(message) {
                    compCtrl[internalFieldName] = message;
                });
            });
        });
    }, {}],
    6: [function(require, module, exports) {
        ((definition) => {
            kony.mvc.patch = definition;
        })((controller, bindComponents) => {
            if (!controller.constructor || controller.constructor.name !== "BaseController") {
                throw new Error("Cannot use extension kony.mvc.patch on anything other than a form controller");
            }
            const events = [ //Form events.
                "init",
                //"onDestroy" //Controllers already have their own onDestroy event.
                "preShow", "postShow", "onHide", "onBreakpointChange", "onOrientationChange"
            ];
            var view = controller.view;
            events.forEach((eventName) => {
                if (typeof controller[eventName] === "function") {
                    view[eventName] = function() {
                        try {
                            //kony.print(`*******Event fired: ${view.id}.${eventName}`);
                            controller[eventName]();
                        } catch (e) {
                            alert(e);
                        }
                    };
                }
            });
            /*global amplify*/
            if (bindComponents) {
                if (typeof amplify !== "undefined" && typeof kony.ui.getDescendants !== "undefined") {
                    var components = kony.ui.getDescendants(controller.view, false, (child) => {
                        return child.name === "kony.ui.KComponent";
                    });
                    //kony.print(`Found ${components.length} components in form ${view.id}*******`);
                    components.forEach((component) => {
                        events.forEach((event) => {
                            if (typeof component[event] === "function") {
                                amplify.subscribe(`${view.id}.${event}`, component[event]);
                            } else {
                                kony.print(`${view.id}.${component.id}.${event} is either ` + "not defined or not exposed. Expose it as a custom method.");
                            }
                        });
                    });
                } else {
                    kony.print("Cannot bind component events to form events " + "without amplify and extension kony.ui.getDescendants");
                }
            }
            //TODO: Make this a require module so it can be applied to the component like: return kony.mvc.patch({controller here})
            /*var ctrlEvents = ["onNavigate", "onDestroy"];
            ctrlEvents.forEach((eventName) => {
            	if(typeof controller[eventName] === "function"){
            		controller[eventName] = function(){
            			try{
            				kony.print(`*******Controller event fired: ${controller.view.id}.${eventName}`);
            				controller[eventName]();
            			}
            			catch(e){
            				alert(e);
            			}
            		};
            	}
            });

            return controller;*/
        });
    }, {}],
    7: [function(require, module, exports) {
        ((definition) => {
            if (typeof kony.router !== "object") {
                kony.router = definition();
            }
        })(function() {
            var history = [];
            var maxH = 5;

            function _initHistory() {
                if (typeof history === "undefined") {
                    history = [];
                } else if (history.length >= 1) {
                    history = [history[0]];
                }
            }

            function _init(maxHistory) {
                _initHistory();
                if (typeof maxHistory !== "undefined" && !isNaN(maxHistory)) {
                    maxH = maxHistory;
                }
            }

            function _addToHistory(priorForm) {
                if (typeof priorForm === "undefined") {
                    return;
                }
                var priorId = priorForm.id;
                //If the latest is not already the prior one, then add it.
                if (history.length === 0 || history[history.length - 1] !== priorId) {
                    //If there's no more roon in the history, remove the oldest after home.
                    if (history.length >= maxH) {
                        history = history.slice(0, 1).concat(history.slice(2));
                    }
                    history.push(priorId);
                    //kony.print(`********Added ${priorId} to history. length ${history.length}`);
                }
            }

            function _getCurrent() {
                return history[history.length - 1];
            }

            function _goBack(context) {
                if (history.length === 0) {
                    return;
                } else if (history.length === 1) {
                    _goTo(history[0], context, true);
                } else {
                    _goTo(history.pop(), context, true);
                }
            }

            function _goHome(context) {
                _goTo(history[0], context, true);
                _initHistory();
            }

            function _getHistory() {
                return JSON.parse(JSON.stringify(history));
            }

            function _goTo(friendlyName, context, isGoingBack) {
                try {
                    (new kony.mvc.Navigation(friendlyName)).navigate(context);
                    var priorForm = kony.application.getPreviousForm();
                    if (!isGoingBack) _addToHistory(priorForm);
                } catch (e) {
                    let message = "Can't navigate to form ";
                    message += `by friendly name '${friendlyName}'\nError: ${e}`;
                    //alert(message);
                    if (typeof kony.ui.Toast === "undefined") {
                        alert(message);
                    } else {
                        var toast = new kony.ui.Toast({
                            text: message,
                            duration: constants.TOAST_LENGTH_LONG
                        });
                        toast.show();
                    }
                }
            }
            return {
                init: _init,
                goto: _goTo,
                goTo: _goTo,
                getCurrent: _getCurrent,
                goBack: _goBack,
                goHome: _goHome,
                getHistory: _getHistory
            };
        });
    }, {}],
    8: [function(require, module, exports) {
        (() => {
            const OS_ANDROID = "android";
            const OS_IOS = "ios";
            const MOBILE_WEB = "mobile_web";
            var os;
            var deviceInfo = kony.os.deviceInfo();
            //TODO: Break this module into one per function.
            function getOs() {
                if (typeof os === "undefined") {
                    // Mobile web -> kony.os.deviceInfo().name === thinclient.
                    var message1 = `kony.os.deviceInfo().name: ${deviceInfo.name}\n` + `kony.os.deviceInfo().osname: ${deviceInfo.osname}`;
                    kony.print(message1);
                    //alert(message1);
                    os = deviceInfo.name /*android*/ || deviceInfo.osname /*iPhone*/ ;
                    if (os === "i-phone" || os === "i-pad") {
                        os = OS_IOS;
                    } else if (os === "thinclient") {
                        os = MOBILE_WEB;
                    }
                }
                var message2 = `os: ${os}`;
                kony.print(message2);
                //alert(message2);
                return os;
            }

            function isIos() {
                return getOs() === OS_IOS;
            }

            function isAndroid() {
                return getOs() === OS_ANDROID;
            }

            function isWeb() {
                //TODO: Determine which other values other than thinclient mean it's a web app -e.g. responsive, PWA, desktop web, etc.
                return getOs() === MOBILE_WEB;
            }
            kony.os.isIos = isIos;
            kony.os.isAndroid = isAndroid;
            kony.os.isWeb = isWeb;
        })();
    }, {}],
    9: [function(require, module, exports) {
        /**
         * getDescendants - Returns an array containing all the widgets nested within a form or container widget.
         * The container widget may be a Form, a Flex Container, Scroll Flex Container or any other widget capable
         * of containing other widgets.
         *
         * @param  {FlexForm|FlexContainer|FlexFormContainer|Segment} containerWidget The parent form or container widget
         * for which you wish to get all descendants.
         * @param  {Boolean} includeParent   Whether to include the parent container widget in the
         * resulting array.
         * @param  {Function} test   A function used to determine which children must be included in the result.
         * @return {Array} An array containing all widgets within a form or container widget.
         *
         * @author Miguelngel Fernndez
         */
        ((definition) => {
            kony.ui.getDescendants = definition;
        })(function getDescendants(containerWidget, includeParent, test) {
            //A function that given a widget, returns its children matching a test
            function getChildren(parent, t) {
                var filtered = typeof t === "function";
                var descendants = [];
                if (typeof parent.widgets === "function") {
                    let children = parent.widgets();
                    if (filtered) children = children.filter(t);
                    descendants = descendants.concat(children);
                }
                return descendants;
            }
            //If a widget is considered a descendant of itself, then start by putting it in the array.
            var descendants = includeParent ? [containerWidget] : [];
            if (typeof test === "function") descendants = descendants.filter(test);
            //Then add the children of the parent.
            descendants = getChildren(containerWidget, test);
            //Then add the children of each child already known.
            for (var k = 0; k < descendants.length; k++) {
                descendants = getChildren(descendants[k], test);
            }
            return descendants;
        });
    }, {}]
}, {}, [4]);
//FP Appended oauth.js-----------------------------------------------------------
/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here's some JavaScript software for implementing OAuth.

   This isn't as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: "GET", action: "http://server.com/path", parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [["a", 1], ["b", 2], ["a", 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: "GET", action: "http://server/path", parameters: {p: "x y"}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn't a valid OAuth request, since it lacks a signature etc.)
   Note that the object "x y" is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn't percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   <script src="oauth.js?oauth_timestamp=<?=time()?>" ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null && from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return "";
        }
        if (s instanceof Array) {
            var e = "";
            for (var i = 0; i < s.length; ++s) {
                if (e != "") e += '&';
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn't do
        // encodeURIComponent ignores: - _ . ! ~ * ' ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, "%21");
        s = s.replace(/\*/g, "%2A");
        s = s.replace(/\'/g, "%27");
        s = s.replace(/\(/g, "%28");
        s = s.replace(/\)/g, "%29");
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, " ");
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != "object") {
            return OAuth.decodeForm(parameters + "");
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != "object") {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + ""));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p < parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p < parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = "";
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p < list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = "";
            if (form != "") form += '&';
            form += OAuth.percentEncode(list[p][0])
              +'='+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split('&');
        for (var n = 0; n < nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == "") {
                continue;
            }
            var equals = nvp.indexOf('=');
            var name;
            var value;
            if (equals < 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p < parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i < list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn't fill in every parameter.
        The accessor object should be like:
        {consumerKey:'foo', consumerSecret:'bar', accessorSecret:'nurn', token:'krelm', tokenSecret:'blah'}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = "GET";
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, "oauth_consumer_key", accessor.consumerKey || "");
        }
        if (map.oauth_token == null && accessor.token != null) {
            OAuth.setParameter(message, "oauth_token", accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, "oauth_version", "1.0");
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, "oauth_timestamp", OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, "oauth_nonce", OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, "oauth_timestamp", OAuth.timestamp());
        OAuth.setParameter(message, "oauth_nonce", OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length > 0) {
                var q = url.indexOf('?');
                if (q < 0) newURL += '?';
                else       newURL += '&';
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = 'OAuth realm="' + OAuth.percentEncode(realm) + '"';
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p < list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf("oauth_") == 0) {
                header += ',' + OAuth.percentEncode(name) + '="' + OAuth.percentEncode(parameter[1]) + '"';
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || "oauth_timestamp";
        var scripts = document.getElementsByTagName('script');
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf("?");
        if (q < 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = "";
        for (var i = 0; i < length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null && previous != null) {
        for (var key in previous) {
            if (key != "prototype") {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, "SignatureMethod", function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, "oauth_signature", signature);
        return signature; // just in case someone's interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            && name.length > 9
            && name.substring(name.length-9) == "-Accessor")
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +"&"+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: "lakjsdflkj...", consumerSecret: "QOUEWRI..", accessorSecret: "xcmvzc..."}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == "") {
            name = "HMAC-SHA1";
            OAuth.setParameter(message, "oauth_signature_method", name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error("signature_method_rejected");
        var acceptable = "";
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != "") acceptable += '&';
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n < names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren't any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf('?');
        var parameters;
        if (q < 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a < toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +'&'+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +'&'+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == "http" && uri.port == 80)
                    || (scheme == "https" && uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(":");
            if (index >= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = "/"; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + "://" + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: ["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || "";
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return "";
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p < list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != "oauth_signature") {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + " " // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] < b[0]) return  -1;
                          if (a[0] > b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s < sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass(["PLAINTEXT", "PLAINTEXT-Accessor"],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass(["HMAC-SHA1", "HMAC-SHA1-Accessor"],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = '=';
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}

//FP Appended sha1.js-----------------------------------------------------------
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}

//Appending startup.js 
kony.globals["appid"] = "KroninTest1";
kony.globals["build"] = "debug";
kony.globals["locales"] = [];
kony.globals["i18nArray"] = [];
//startup.js
var appConfig = {
    appId: "KroninTest1",
    appName: "KroninTest1",
    appVersion: "1.0.0",
    isDebug: true,
    isMFApp: false,
    eventTypes: [],
};
sessionID = "";

function setAppBehaviors() {
    kony.application.setApplicationBehaviors({
        applyMarginPaddingInBCGMode: false,
        adherePercentageStrictly: true,
        retainSpaceOnHide: true,
        isMVC: true,
        responsive: true,
        APILevel: 8400
    })
};

function themeCallBack() {
    initializeGlobalVariables();
    requirejs.config({
        baseUrl: kony.appinit.getStaticContentPath() + 'spaandroid/appjs'
    });
    require(['kvmodules'], function() {
        applicationController = require("applicationController");
        callAppMenu();
        kony.application.setApplicationInitializationEvents({
            init: applicationController.appInit,
            postappinit: applicationController.postAppInitCallBack,
            showstartupform: function() {
                new kony.mvc.Navigation("Form1").navigate();
            }
        });
    });
};

function loadResources() {
    kony.theme.packagedthemes(["default"]);
    globalhttpheaders = {};
    sdkInitConfig = {
        "appConfig": appConfig,
        "isMFApp": appConfig.isMFApp,
        "eventTypes": appConfig.eventTypes,
    }
    kony.theme.setCurrentTheme("default", themeCallBack, themeCallBack);
};

function initializeApp() {
    kony.application.setApplicationMode(constants.APPLICATION_MODE_NATIVE);
    //This is the entry point for the application.When Locale comes,Local API call will be the entry point.
    loadResources();
};
debugger;